{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":false,"distro_crate":true,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"/home/xanewok/repos/rust","program":"/home/xanewok/repos/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc","arguments":["--edition=2018","--crate-name","core","src/libcore/lib.rs","--color","always","--crate-type","lib","--emit=dep-info,link","-C","opt-level=2","-C","metadata=a5db6a3445116c08-rustc","-C","extra-filename=-a5db6a3445116c08","--out-dir","/home/xanewok/repos/rust/build/x86_64-unknown-linux-gnu/stage1-std/x86_64-unknown-linux-gnu/release/deps","--target","x86_64-unknown-linux-gnu","-L","dependency=/home/xanewok/repos/rust/build/x86_64-unknown-linux-gnu/stage1-std/x86_64-unknown-linux-gnu/release/deps","-L","dependency=/home/xanewok/repos/rust/build/x86_64-unknown-linux-gnu/stage1-std/release/deps","--cfg","stage1","--sysroot","/home/xanewok/repos/rust/build/x86_64-unknown-linux-gnu/stage1","-Zexternal-macro-backtrace","-Cprefer-dynamic","-C","debug-assertions=n","-Zsave-analysis","-C","link-args=-Wl,-rpath,$ORIGIN/../lib","-Zunstable-options","-Z","force-unstable-if-unmarked","-Dwarnings","-Dbare_trait_objects"],"output":"/home/xanewok/repos/rust/build/x86_64-unknown-linux-gnu/stage1-std/x86_64-unknown-linux-gnu/release/deps/libcore-a5db6a3445116c08.rlib"},"prelude":{"crate_id":{"name":"core","disambiguator":[824896561043773286,9999613319747983107]},"crate_root":"src/libcore","external_crates":[],"span":{"file_name":"src/libcore/lib.rs","byte_start":0,"byte_end":7375,"line_start":1,"line_end":239,"column_start":1,"column_end":25}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":390},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238357,"byte_end":238363,"line_start":124,"line_end":124,"column_start":25,"column_end":31},"alias_span":null,"name":"decode","value":"","parent":{"krate":0,"index":348}},{"kind":"Use","ref_id":{"krate":0,"index":378},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238365,"byte_end":238379,"line_start":124,"line_end":124,"column_start":33,"column_end":47},"alias_span":null,"name":"DecodableFloat","value":"","parent":{"krate":0,"index":348}},{"kind":"Use","ref_id":{"krate":0,"index":13618},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238381,"byte_end":238392,"line_start":124,"line_end":124,"column_start":49,"column_end":60},"alias_span":null,"name":"FullDecoded","value":"","parent":{"krate":0,"index":348}},{"kind":"Use","ref_id":{"krate":0,"index":13596},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238394,"byte_end":238401,"line_start":124,"line_end":124,"column_start":62,"column_end":69},"alias_span":null,"name":"Decoded","value":"","parent":{"krate":0,"index":348}},{"kind":"Use","ref_id":{"krate":0,"index":13858},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":364561,"byte_end":364569,"line_start":7,"line_end":7,"column_start":29,"column_end":37},"alias_span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":364573,"byte_end":364576,"line_start":7,"line_end":7,"column_start":41,"column_end":44},"name":"Big","value":"","parent":{"krate":0,"index":620}},{"kind":"Use","ref_id":{"krate":0,"index":946},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434720,"byte_end":434725,"line_start":914,"line_end":914,"column_start":29,"column_end":34},"alias_span":null,"name":"isize","value":"","parent":{"krate":0,"index":940}},{"kind":"Use","ref_id":{"krate":0,"index":944},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434906,"byte_end":434911,"line_start":921,"line_end":921,"column_start":29,"column_end":34},"alias_span":null,"name":"usize","value":"","parent":{"krate":0,"index":940}},{"kind":"Use","ref_id":{"krate":0,"index":13790},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":225856,"byte_end":225871,"line_start":4829,"line_end":4829,"column_start":30,"column_end":45},"alias_span":null,"name":"ParseFloatError","value":"","parent":{"krate":0,"index":298}},{"kind":"Use","ref_id":{"krate":0,"index":1716},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435424,"byte_end":435428,"line_start":12,"line_end":12,"column_start":25,"column_end":29},"alias_span":null,"name":"Copy","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1706},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435430,"byte_end":435434,"line_start":12,"line_end":12,"column_start":31,"column_end":35},"alias_span":null,"name":"Send","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1712},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435436,"byte_end":435441,"line_start":12,"line_end":12,"column_start":37,"column_end":42},"alias_span":null,"name":"Sized","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1718},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435443,"byte_end":435447,"line_start":12,"line_end":12,"column_start":44,"column_end":48},"alias_span":null,"name":"Sync","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1748},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435449,"byte_end":435454,"line_start":12,"line_end":12,"column_start":50,"column_end":55},"alias_span":null,"name":"Unpin","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1984},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435549,"byte_end":435553,"line_start":15,"line_end":15,"column_start":22,"column_end":26},"alias_span":null,"name":"Drop","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1990},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435555,"byte_end":435557,"line_start":15,"line_end":15,"column_start":28,"column_end":30},"alias_span":null,"name":"Fn","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1994},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435559,"byte_end":435564,"line_start":15,"line_end":15,"column_start":32,"column_end":37},"alias_span":null,"name":"FnMut","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1998},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435566,"byte_end":435572,"line_start":15,"line_end":15,"column_start":39,"column_end":45},"alias_span":null,"name":"FnOnce","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1256},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435692,"byte_end":435696,"line_start":20,"line_end":20,"column_start":21,"column_end":25},"alias_span":null,"name":"drop","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2606},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435824,"byte_end":435829,"line_start":25,"line_end":25,"column_start":23,"column_end":28},"alias_span":null,"name":"Clone","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2416},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435923,"byte_end":435932,"line_start":28,"line_end":28,"column_start":22,"column_end":31},"alias_span":null,"name":"PartialEq","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2472},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435934,"byte_end":435944,"line_start":28,"line_end":28,"column_start":33,"column_end":43},"alias_span":null,"name":"PartialOrd","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2422},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435946,"byte_end":435948,"line_start":28,"line_end":28,"column_start":45,"column_end":47},"alias_span":null,"name":"Eq","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2452},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435950,"byte_end":435953,"line_start":28,"line_end":28,"column_start":49,"column_end":52},"alias_span":null,"name":"Ord","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2652},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436052,"byte_end":436057,"line_start":31,"line_end":31,"column_start":26,"column_end":31},"alias_span":null,"name":"AsRef","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2656},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436059,"byte_end":436064,"line_start":31,"line_end":31,"column_start":33,"column_end":38},"alias_span":null,"name":"AsMut","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2660},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436066,"byte_end":436070,"line_start":31,"line_end":31,"column_start":40,"column_end":44},"alias_span":null,"name":"Into","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2664},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436072,"byte_end":436076,"line_start":31,"line_end":31,"column_start":46,"column_end":50},"alias_span":null,"name":"From","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":2640},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436174,"byte_end":436181,"line_start":34,"line_end":34,"column_start":25,"column_end":32},"alias_span":null,"name":"Default","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":4334},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436276,"byte_end":436284,"line_start":37,"line_end":37,"column_start":23,"column_end":31},"alias_span":null,"name":"Iterator","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":4528},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436286,"byte_end":436292,"line_start":37,"line_end":37,"column_start":33,"column_end":39},"alias_span":null,"name":"Extend","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":4512},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436294,"byte_end":436306,"line_start":37,"line_end":37,"column_start":41,"column_end":53},"alias_span":null,"name":"IntoIterator","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":4474},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436402,"byte_end":436421,"line_start":40,"line_end":40,"column_start":23,"column_end":42},"alias_span":null,"name":"DoubleEndedIterator","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":4494},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436423,"byte_end":436440,"line_start":40,"line_end":40,"column_start":44,"column_end":61},"alias_span":null,"name":"ExactSizeIterator","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":42488},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436546,"byte_end":436550,"line_start":43,"line_end":43,"column_start":33,"column_end":37},"alias_span":null,"name":"self","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":22883},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436552,"byte_end":436556,"line_start":43,"line_end":43,"column_start":39,"column_end":43},"alias_span":null,"name":"Some","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":22879},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436558,"byte_end":436562,"line_start":43,"line_end":43,"column_start":45,"column_end":49},"alias_span":null,"name":"None","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":42602},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436668,"byte_end":436672,"line_start":46,"line_end":46,"column_start":33,"column_end":37},"alias_span":null,"name":"self","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":22955},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436674,"byte_end":436676,"line_start":46,"line_end":46,"column_start":39,"column_end":41},"alias_span":null,"name":"Ok","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":22961},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":436678,"byte_end":436681,"line_start":46,"line_end":46,"column_start":43,"column_end":46},"alias_span":null,"name":"Err","value":"","parent":{"krate":0,"index":1106}},{"kind":"Use","ref_id":{"krate":0,"index":1380},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":438396,"byte_end":438409,"line_start":42,"line_end":42,"column_start":21,"column_end":34},"alias_span":null,"name":"drop_in_place","value":"","parent":{"krate":0,"index":1186}},{"kind":"Use","ref_id":{"krate":0,"index":565},"span":{"file_name":"src/libcore/mem.rs","byte_start":510673,"byte_end":510682,"line_start":19,"line_end":19,"column_start":28,"column_end":37},"alias_span":null,"name":"transmute","value":"","parent":{"krate":0,"index":1204}},{"kind":"Use","ref_id":{"krate":0,"index":1198},"span":{"file_name":"src/libcore/ptr.rs","byte_start":562322,"byte_end":562341,"line_start":77,"line_end":77,"column_start":28,"column_end":47},"alias_span":null,"name":"copy_nonoverlapping","value":"","parent":{"krate":0,"index":1336}},{"kind":"Use","ref_id":{"krate":0,"index":1200},"span":{"file_name":"src/libcore/ptr.rs","byte_start":562417,"byte_end":562421,"line_start":80,"line_end":80,"column_start":28,"column_end":32},"alias_span":null,"name":"copy","value":"","parent":{"krate":0,"index":1336}},{"kind":"Use","ref_id":{"krate":0,"index":1202},"span":{"file_name":"src/libcore/ptr.rs","byte_start":562497,"byte_end":562508,"line_start":83,"line_end":83,"column_start":28,"column_end":39},"alias_span":null,"name":"write_bytes","value":"","parent":{"krate":0,"index":1336}},{"kind":"Use","ref_id":{"krate":0,"index":1774},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703358,"byte_end":703361,"line_start":159,"line_end":159,"column_start":23,"column_end":26},"alias_span":null,"name":"Add","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1782},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703363,"byte_end":703366,"line_start":159,"line_end":159,"column_start":28,"column_end":31},"alias_span":null,"name":"Sub","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1790},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703368,"byte_end":703371,"line_start":159,"line_end":159,"column_start":33,"column_end":36},"alias_span":null,"name":"Mul","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1798},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703373,"byte_end":703376,"line_start":159,"line_end":159,"column_start":38,"column_end":41},"alias_span":null,"name":"Div","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1808},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703378,"byte_end":703381,"line_start":159,"line_end":159,"column_start":43,"column_end":46},"alias_span":null,"name":"Rem","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1818},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703383,"byte_end":703386,"line_start":159,"line_end":159,"column_start":48,"column_end":51},"alias_span":null,"name":"Neg","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1830},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703468,"byte_end":703477,"line_start":161,"line_end":161,"column_start":23,"column_end":32},"alias_span":null,"name":"AddAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1836},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703479,"byte_end":703488,"line_start":161,"line_end":161,"column_start":34,"column_end":43},"alias_span":null,"name":"SubAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1842},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703490,"byte_end":703499,"line_start":161,"line_end":161,"column_start":45,"column_end":54},"alias_span":null,"name":"MulAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1848},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703501,"byte_end":703510,"line_start":161,"line_end":161,"column_start":56,"column_end":65},"alias_span":null,"name":"DivAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1854},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703512,"byte_end":703521,"line_start":161,"line_end":161,"column_start":67,"column_end":76},"alias_span":null,"name":"RemAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1862},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703591,"byte_end":703594,"line_start":164,"line_end":164,"column_start":21,"column_end":24},"alias_span":null,"name":"Not","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1870},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703596,"byte_end":703602,"line_start":164,"line_end":164,"column_start":26,"column_end":32},"alias_span":null,"name":"BitAnd","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1878},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703604,"byte_end":703609,"line_start":164,"line_end":164,"column_start":34,"column_end":39},"alias_span":null,"name":"BitOr","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1886},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703611,"byte_end":703617,"line_start":164,"line_end":164,"column_start":41,"column_end":47},"alias_span":null,"name":"BitXor","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1894},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703619,"byte_end":703622,"line_start":164,"line_end":164,"column_start":49,"column_end":52},"alias_span":null,"name":"Shl","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1904},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703624,"byte_end":703627,"line_start":164,"line_end":164,"column_start":54,"column_end":57},"alias_span":null,"name":"Shr","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1914},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703707,"byte_end":703719,"line_start":166,"line_end":166,"column_start":21,"column_end":33},"alias_span":null,"name":"BitAndAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1920},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703721,"byte_end":703732,"line_start":166,"line_end":166,"column_start":35,"column_end":46},"alias_span":null,"name":"BitOrAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1926},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703734,"byte_end":703746,"line_start":166,"line_end":166,"column_start":48,"column_end":60},"alias_span":null,"name":"BitXorAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1932},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703748,"byte_end":703757,"line_start":166,"line_end":166,"column_start":62,"column_end":71},"alias_span":null,"name":"ShlAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1940},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703759,"byte_end":703768,"line_start":166,"line_end":166,"column_start":73,"column_end":82},"alias_span":null,"name":"ShrAssign","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1950},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703840,"byte_end":703845,"line_start":169,"line_end":169,"column_start":23,"column_end":28},"alias_span":null,"name":"Deref","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1968},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703847,"byte_end":703855,"line_start":169,"line_end":169,"column_start":30,"column_end":38},"alias_span":null,"name":"DerefMut","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1976},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703933,"byte_end":703941,"line_start":172,"line_end":172,"column_start":22,"column_end":30},"alias_span":null,"name":"Receiver","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1984},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704010,"byte_end":704014,"line_start":175,"line_end":175,"column_start":21,"column_end":25},"alias_span":null,"name":"Drop","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1990},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704088,"byte_end":704090,"line_start":178,"line_end":178,"column_start":26,"column_end":28},"alias_span":null,"name":"Fn","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1994},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704092,"byte_end":704097,"line_start":178,"line_end":178,"column_start":30,"column_end":35},"alias_span":null,"name":"FnMut","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":1998},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704099,"byte_end":704105,"line_start":178,"line_end":178,"column_start":37,"column_end":43},"alias_span":null,"name":"FnOnce","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":2062},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704177,"byte_end":704182,"line_start":181,"line_end":181,"column_start":23,"column_end":28},"alias_span":null,"name":"Index","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":2068},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704184,"byte_end":704192,"line_start":181,"line_end":181,"column_start":30,"column_end":38},"alias_span":null,"name":"IndexMut","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":36058},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704264,"byte_end":704269,"line_start":184,"line_end":184,"column_start":23,"column_end":28},"alias_span":null,"name":"Range","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":36078},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704271,"byte_end":704280,"line_start":184,"line_end":184,"column_start":30,"column_end":39},"alias_span":null,"name":"RangeFrom","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":36038},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704282,"byte_end":704291,"line_start":184,"line_end":184,"column_start":41,"column_end":50},"alias_span":null,"name":"RangeFull","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":36098},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704293,"byte_end":704300,"line_start":184,"line_end":184,"column_start":52,"column_end":59},"alias_span":null,"name":"RangeTo","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":36120},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704383,"byte_end":704397,"line_start":187,"line_end":187,"column_start":23,"column_end":37},"alias_span":null,"name":"RangeInclusive","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":36126},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704399,"byte_end":704415,"line_start":187,"line_end":187,"column_start":39,"column_end":55},"alias_span":null,"name":"RangeToInclusive","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":2162},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704417,"byte_end":704428,"line_start":187,"line_end":187,"column_start":57,"column_end":68},"alias_span":null,"name":"RangeBounds","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":36148},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704430,"byte_end":704435,"line_start":187,"line_end":187,"column_start":70,"column_end":75},"alias_span":null,"name":"Bound","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":2258},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704512,"byte_end":704515,"line_start":190,"line_end":190,"column_start":22,"column_end":25},"alias_span":null,"name":"Try","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":2036},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704602,"byte_end":704611,"line_start":193,"line_end":193,"column_start":27,"column_end":36},"alias_span":null,"name":"Generator","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":35996},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704613,"byte_end":704627,"line_start":193,"line_end":193,"column_start":38,"column_end":52},"alias_span":null,"name":"GeneratorState","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":2274},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704710,"byte_end":704723,"line_start":196,"line_end":196,"column_start":23,"column_end":36},"alias_span":null,"name":"CoerceUnsized","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":2294},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":704804,"byte_end":704819,"line_start":199,"line_end":199,"column_start":23,"column_end":38},"alias_span":null,"name":"DispatchFromDyn","value":"","parent":{"krate":0,"index":1770}},{"kind":"Use","ref_id":{"krate":0,"index":3384},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1070768,"byte_end":1070776,"line_start":28,"line_end":28,"column_start":25,"column_end":33},"alias_span":null,"name":"from_u32","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":3420},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1070778,"byte_end":1070788,"line_start":28,"line_end":28,"column_start":35,"column_end":45},"alias_span":null,"name":"from_digit","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":3386},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1070874,"byte_end":1070892,"line_start":30,"line_end":30,"column_start":24,"column_end":42},"alias_span":null,"name":"from_u32_unchecked","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":41382},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1070972,"byte_end":1070986,"line_start":32,"line_end":32,"column_start":24,"column_end":38},"alias_span":null,"name":"ParseCharError","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":41422},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1071061,"byte_end":1071077,"line_start":34,"line_end":34,"column_start":24,"column_end":40},"alias_span":null,"name":"CharTryFromError","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":3428},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1071155,"byte_end":1071167,"line_start":36,"line_end":36,"column_start":24,"column_end":36},"alias_span":null,"name":"decode_utf16","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":41444},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1071169,"byte_end":1071180,"line_start":36,"line_end":36,"column_start":38,"column_end":49},"alias_span":null,"name":"DecodeUtf16","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":41454},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1071182,"byte_end":1071198,"line_start":36,"line_end":36,"column_start":51,"column_end":67},"alias_span":null,"name":"DecodeUtf16Error","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":8896},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1071315,"byte_end":1071330,"line_start":40,"line_end":40,"column_start":33,"column_end":48},"alias_span":null,"name":"UNICODE_VERSION","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":44778},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1071423,"byte_end":1071437,"line_start":42,"line_end":42,"column_start":34,"column_end":48},"alias_span":null,"name":"UnicodeVersion","value":"","parent":{"krate":0,"index":3370}},{"kind":"Use","ref_id":{"krate":0,"index":4334},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193523,"byte_end":1193531,"line_start":312,"line_end":312,"column_start":23,"column_end":31},"alias_span":null,"name":"Iterator","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4020},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193688,"byte_end":1193692,"line_start":317,"line_end":317,"column_start":22,"column_end":26},"alias_span":null,"name":"Step","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":41826},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193765,"byte_end":1193771,"line_start":320,"line_end":320,"column_start":25,"column_end":31},"alias_span":null,"name":"Repeat","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4142},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193773,"byte_end":1193779,"line_start":320,"line_end":320,"column_start":33,"column_end":39},"alias_span":null,"name":"repeat","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":41836},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193868,"byte_end":1193878,"line_start":322,"line_end":322,"column_start":25,"column_end":35},"alias_span":null,"name":"RepeatWith","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4156},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193880,"byte_end":1193891,"line_start":322,"line_end":322,"column_start":37,"column_end":48},"alias_span":null,"name":"repeat_with","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4158},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193969,"byte_end":1193974,"line_start":324,"line_end":324,"column_start":25,"column_end":30},"alias_span":null,"name":"Empty","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4192},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193976,"byte_end":1193981,"line_start":324,"line_end":324,"column_start":32,"column_end":37},"alias_span":null,"name":"empty","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":41848},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194058,"byte_end":1194062,"line_start":326,"line_end":326,"column_start":25,"column_end":29},"alias_span":null,"name":"Once","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4214},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194064,"byte_end":1194068,"line_start":326,"line_end":326,"column_start":31,"column_end":35},"alias_span":null,"name":"once","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":41858},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194152,"byte_end":1194160,"line_start":328,"line_end":328,"column_start":25,"column_end":33},"alias_span":null,"name":"OnceWith","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4236},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194162,"byte_end":1194171,"line_start":328,"line_end":328,"column_start":35,"column_end":44},"alias_span":null,"name":"once_with","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":41870},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194252,"byte_end":1194258,"line_start":330,"line_end":330,"column_start":25,"column_end":31},"alias_span":null,"name":"FromFn","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4238},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194260,"byte_end":1194267,"line_start":330,"line_end":330,"column_start":33,"column_end":40},"alias_span":null,"name":"from_fn","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":41876},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194351,"byte_end":1194361,"line_start":332,"line_end":332,"column_start":25,"column_end":35},"alias_span":null,"name":"Successors","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4250},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194363,"byte_end":1194373,"line_start":332,"line_end":332,"column_start":37,"column_end":47},"alias_span":null,"name":"successors","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4508},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194446,"byte_end":1194458,"line_start":335,"line_end":335,"column_start":24,"column_end":36},"alias_span":null,"name":"FromIterator","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4512},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194460,"byte_end":1194472,"line_start":335,"line_end":335,"column_start":38,"column_end":50},"alias_span":null,"name":"IntoIterator","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4474},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194474,"byte_end":1194493,"line_start":335,"line_end":335,"column_start":52,"column_end":71},"alias_span":null,"name":"DoubleEndedIterator","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4528},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194495,"byte_end":1194501,"line_start":335,"line_end":335,"column_start":73,"column_end":79},"alias_span":null,"name":"Extend","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4494},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194573,"byte_end":1194590,"line_start":337,"line_end":337,"column_start":24,"column_end":41},"alias_span":null,"name":"ExactSizeIterator","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4546},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194592,"byte_end":1194595,"line_start":337,"line_end":337,"column_start":43,"column_end":46},"alias_span":null,"name":"Sum","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4550},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194597,"byte_end":1194604,"line_start":337,"line_end":337,"column_start":48,"column_end":55},"alias_span":null,"name":"Product","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4586},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194676,"byte_end":1194689,"line_start":339,"line_end":339,"column_start":23,"column_end":36},"alias_span":null,"name":"FusedIterator","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4590},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194767,"byte_end":1194777,"line_start":341,"line_end":341,"column_start":23,"column_end":33},"alias_span":null,"name":"TrustedLen","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42338},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194851,"byte_end":1194854,"line_start":344,"line_end":344,"column_start":26,"column_end":29},"alias_span":null,"name":"Rev","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42368},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194856,"byte_end":1194861,"line_start":344,"line_end":344,"column_start":31,"column_end":36},"alias_span":null,"name":"Cycle","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42298},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194863,"byte_end":1194868,"line_start":344,"line_end":344,"column_start":38,"column_end":43},"alias_span":null,"name":"Chain","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42328},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194870,"byte_end":1194873,"line_start":344,"line_end":344,"column_start":45,"column_end":48},"alias_span":null,"name":"Zip","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42388},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194875,"byte_end":1194878,"line_start":344,"line_end":344,"column_start":50,"column_end":53},"alias_span":null,"name":"Map","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42394},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194880,"byte_end":1194886,"line_start":344,"line_end":344,"column_start":55,"column_end":61},"alias_span":null,"name":"Filter","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42400},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194888,"byte_end":1194897,"line_start":344,"line_end":344,"column_start":63,"column_end":72},"alias_span":null,"name":"FilterMap","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42406},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194899,"byte_end":1194908,"line_start":344,"line_end":344,"column_start":74,"column_end":83},"alias_span":null,"name":"Enumerate","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42416},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194982,"byte_end":1194990,"line_start":346,"line_end":346,"column_start":26,"column_end":34},"alias_span":null,"name":"Peekable","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42426},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1194992,"byte_end":1195001,"line_start":346,"line_end":346,"column_start":36,"column_end":45},"alias_span":null,"name":"SkipWhile","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42432},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195003,"byte_end":1195012,"line_start":346,"line_end":346,"column_start":47,"column_end":56},"alias_span":null,"name":"TakeWhile","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42438},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195014,"byte_end":1195018,"line_start":346,"line_end":346,"column_start":58,"column_end":62},"alias_span":null,"name":"Skip","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42448},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195020,"byte_end":1195024,"line_start":346,"line_end":346,"column_start":64,"column_end":68},"alias_span":null,"name":"Take","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42458},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195026,"byte_end":1195030,"line_start":346,"line_end":346,"column_start":70,"column_end":74},"alias_span":null,"name":"Scan","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4714},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195032,"byte_end":1195039,"line_start":346,"line_end":346,"column_start":76,"column_end":83},"alias_span":null,"name":"FlatMap","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42464},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195113,"byte_end":1195117,"line_start":348,"line_end":348,"column_start":26,"column_end":30},"alias_span":null,"name":"Fuse","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42474},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195119,"byte_end":1195126,"line_start":348,"line_end":348,"column_start":32,"column_end":39},"alias_span":null,"name":"Inspect","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42358},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195205,"byte_end":1195211,"line_start":350,"line_end":350,"column_start":25,"column_end":31},"alias_span":null,"name":"Cloned","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42378},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195295,"byte_end":1195301,"line_start":352,"line_end":352,"column_start":25,"column_end":31},"alias_span":null,"name":"StepBy","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4750},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195385,"byte_end":1195392,"line_start":354,"line_end":354,"column_start":25,"column_end":32},"alias_span":null,"name":"Flatten","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":42348},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195472,"byte_end":1195478,"line_start":356,"line_end":356,"column_start":25,"column_end":31},"alias_span":null,"name":"Copied","value":"","parent":{"krate":0,"index":3874}},{"kind":"Use","ref_id":{"krate":0,"index":4334},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227682,"byte_end":1227690,"line_start":9,"line_end":9,"column_start":25,"column_end":33},"alias_span":null,"name":"Iterator","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4474},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227720,"byte_end":1227739,"line_start":10,"line_end":10,"column_start":29,"column_end":48},"alias_span":null,"name":"DoubleEndedIterator","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4494},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227767,"byte_end":1227784,"line_start":11,"line_end":11,"column_start":27,"column_end":44},"alias_span":null,"name":"ExactSizeIterator","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4508},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227810,"byte_end":1227822,"line_start":12,"line_end":12,"column_start":25,"column_end":37},"alias_span":null,"name":"FromIterator","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4512},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227824,"byte_end":1227836,"line_start":12,"line_end":12,"column_start":39,"column_end":51},"alias_span":null,"name":"IntoIterator","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4528},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227838,"byte_end":1227844,"line_start":12,"line_end":12,"column_start":53,"column_end":59},"alias_span":null,"name":"Extend","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4546},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227869,"byte_end":1227872,"line_start":13,"line_end":13,"column_start":23,"column_end":26},"alias_span":null,"name":"Sum","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4550},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227874,"byte_end":1227881,"line_start":13,"line_end":13,"column_start":28,"column_end":35},"alias_span":null,"name":"Product","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4586},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227953,"byte_end":1227966,"line_start":15,"line_end":15,"column_start":24,"column_end":37},"alias_span":null,"name":"FusedIterator","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":4590},"span":{"file_name":"src/libcore/iter/traits/mod.rs","byte_start":1227968,"byte_end":1227978,"line_start":15,"line_end":15,"column_start":39,"column_end":49},"alias_span":null,"name":"TrustedLen","value":"","parent":{"krate":0,"index":4266}},{"kind":"Use","ref_id":{"krate":0,"index":42298},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348287,"byte_end":1348292,"line_start":14,"line_end":14,"column_start":22,"column_end":27},"alias_span":null,"name":"Chain","value":"","parent":{"krate":0,"index":4620}},{"kind":"Use","ref_id":{"krate":0,"index":4714},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348364,"byte_end":1348371,"line_start":16,"line_end":16,"column_start":25,"column_end":32},"alias_span":null,"name":"FlatMap","value":"","parent":{"krate":0,"index":4620}},{"kind":"Use","ref_id":{"krate":0,"index":4750},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348373,"byte_end":1348380,"line_start":16,"line_end":16,"column_start":34,"column_end":41},"alias_span":null,"name":"Flatten","value":"","parent":{"krate":0,"index":4620}},{"kind":"Use","ref_id":{"krate":0,"index":42328},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348402,"byte_end":1348405,"line_start":17,"line_end":17,"column_start":20,"column_end":23},"alias_span":null,"name":"Zip","value":"","parent":{"krate":0,"index":4620}},{"kind":"Use","ref_id":{"krate":0,"index":43738},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1938462,"byte_end":1938471,"line_start":89,"line_end":89,"column_start":20,"column_end":29},"alias_span":null,"name":"SipHasher","value":"","parent":{"krate":0,"index":7956}},{"kind":"Use","ref_id":{"krate":0,"index":43710},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1938585,"byte_end":1938596,"line_start":94,"line_end":94,"column_start":20,"column_end":31},"alias_span":null,"name":"SipHasher13","value":"","parent":{"krate":0,"index":7956}},{"kind":"Use","ref_id":{"krate":0,"index":8338},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969397,"byte_end":1969408,"line_start":34,"line_end":34,"column_start":26,"column_end":37},"alias_span":null,"name":"DebugStruct","value":"","parent":{"krate":0,"index":8198}},{"kind":"Use","ref_id":{"krate":0,"index":8350},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969410,"byte_end":1969420,"line_start":34,"line_end":34,"column_start":39,"column_end":49},"alias_span":null,"name":"DebugTuple","value":"","parent":{"krate":0,"index":8198}},{"kind":"Use","ref_id":{"krate":0,"index":8370},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969422,"byte_end":1969430,"line_start":34,"line_end":34,"column_start":51,"column_end":59},"alias_span":null,"name":"DebugSet","value":"","parent":{"krate":0,"index":8198}},{"kind":"Use","ref_id":{"krate":0,"index":8382},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969432,"byte_end":1969441,"line_start":34,"line_end":34,"column_start":61,"column_end":70},"alias_span":null,"name":"DebugList","value":"","parent":{"krate":0,"index":8198}},{"kind":"Use","ref_id":{"krate":0,"index":8394},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969443,"byte_end":1969451,"line_start":34,"line_end":34,"column_start":72,"column_end":80},"alias_span":null,"name":"DebugMap","value":"","parent":{"krate":0,"index":8198}},{"kind":"Use","ref_id":{"krate":0,"index":8916},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2109163,"byte_end":2109177,"line_start":11,"line_end":11,"column_start":56,"column_end":70},"alias_span":null,"name":"Case_Ignorable","value":"","parent":{"krate":0,"index":8966}},{"kind":"Use","ref_id":{"krate":0,"index":8920},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2109179,"byte_end":2109184,"line_start":11,"line_end":11,"column_start":72,"column_end":77},"alias_span":null,"name":"Cased","value":"","parent":{"krate":0,"index":8966}},{"kind":"Use","ref_id":{"krate":0,"index":8954},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2109261,"byte_end":2109269,"line_start":14,"line_end":14,"column_start":51,"column_end":59},"alias_span":null,"name":"to_lower","value":"","parent":{"krate":0,"index":8974}},{"kind":"Use","ref_id":{"krate":0,"index":8956},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2109271,"byte_end":2109279,"line_start":14,"line_end":14,"column_start":61,"column_end":69},"alias_span":null,"name":"to_upper","value":"","parent":{"krate":0,"index":8974}},{"kind":"Use","ref_id":{"krate":0,"index":8946},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2109374,"byte_end":2109393,"line_start":19,"line_end":19,"column_start":47,"column_end":66},"alias_span":null,"name":"Pattern_White_Space","value":"","parent":{"krate":0,"index":8982}},{"kind":"Use","ref_id":{"krate":0,"index":9002},"span":{"file_name":"src/libcore/future/mod.rs","byte_start":2352809,"byte_end":2352815,"line_start":8,"line_end":8,"column_start":23,"column_end":29},"alias_span":null,"name":"Future","value":"","parent":{"krate":0,"index":8986}},{"kind":"Use","ref_id":{"krate":0,"index":44816},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2357992,"byte_end":2357996,"line_start":8,"line_end":8,"column_start":21,"column_end":25},"alias_span":null,"name":"Poll","value":"","parent":{"krate":0,"index":9022}},{"kind":"Use","ref_id":{"krate":0,"index":9088},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2358030,"byte_end":2358037,"line_start":11,"line_end":11,"column_start":22,"column_end":29},"alias_span":null,"name":"Context","value":"","parent":{"krate":0,"index":9022}},{"kind":"Use","ref_id":{"krate":0,"index":9100},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2358039,"byte_end":2358044,"line_start":11,"line_end":11,"column_start":31,"column_end":36},"alias_span":null,"name":"Waker","value":"","parent":{"krate":0,"index":9022}},{"kind":"Use","ref_id":{"krate":0,"index":44858},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2358046,"byte_end":2358054,"line_start":11,"line_end":11,"column_start":38,"column_end":46},"alias_span":null,"name":"RawWaker","value":"","parent":{"krate":0,"index":9022}},{"kind":"Use","ref_id":{"krate":0,"index":44870},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":2358056,"byte_end":2358070,"line_start":11,"line_end":11,"column_start":48,"column_end":62},"alias_span":null,"name":"RawWakerVTable","value":"","parent":{"krate":0,"index":9022}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2430064,"byte_end":2430065,"line_start":37,"line_end":37,"column_start":40,"column_end":41},"alias_span":null,"name":"*","value":"_mm_pause","parent":{"krate":0,"index":9280}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2430167,"byte_end":2430168,"line_start":39,"line_end":39,"column_start":43,"column_end":44},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9280}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468785,"byte_end":2468786,"line_start":479,"line_end":479,"column_start":23,"column_end":24},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468819,"byte_end":2468820,"line_start":482,"line_end":482,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468855,"byte_end":2468856,"line_start":485,"line_end":485,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468891,"byte_end":2468892,"line_start":488,"line_end":488,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468927,"byte_end":2468928,"line_start":491,"line_end":491,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468962,"byte_end":2468963,"line_start":493,"line_end":493,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468994,"byte_end":2468995,"line_start":496,"line_end":496,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"_mm_undefined_ps, _mm_loadu_ps, _mm_storeu_ps, _mm_setzero_ps, _mm_set1_ps","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469027,"byte_end":2469028,"line_start":498,"line_end":498,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"_mm_setzero_pd, _mm_load1_pd, _mm_set_epi64x, _mm_storeu_pd, _mm_set1_epi32, _mm_set1_epi64x, _mm_setzero_si128, _mm_cmpeq_epi32, _mm_storeu_si128, _mm_undefined_pd, _mm_loadu_si128, _mm_set1_pd, _mm_set1_epi8, _mm_loadu_pd, _mm_pause","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469060,"byte_end":2469061,"line_start":500,"line_end":500,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469095,"byte_end":2469096,"line_start":502,"line_end":502,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469130,"byte_end":2469131,"line_start":504,"line_end":504,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469165,"byte_end":2469166,"line_start":506,"line_end":506,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469196,"byte_end":2469197,"line_start":508,"line_end":508,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"_mm256_set1_epi64x, _mm256_set1_ps, _mm256_setzero_ps, _mm256_setzero_pd, _mm256_undefined_si256, _mm256_castsi128_si256, _mm256_set1_epi32, _mm256_set1_epi8, _mm256_set1_pd, _mm256_undefined_pd, _mm256_setzero_si256","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469229,"byte_end":2469230,"line_start":510,"line_end":510,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469260,"byte_end":2469261,"line_start":512,"line_end":512,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469292,"byte_end":2469293,"line_start":515,"line_end":515,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469325,"byte_end":2469326,"line_start":517,"line_end":517,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469359,"byte_end":2469360,"line_start":520,"line_end":520,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469457,"byte_end":2469458,"line_start":525,"line_end":525,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469551,"byte_end":2469552,"line_start":530,"line_end":530,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469583,"byte_end":2469584,"line_start":533,"line_end":533,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"_mm_cmpgt_pi8, _mm_packs_pi32, _mm_cmpgt_pi16, _mm_setzero_si64, _mm_unpacklo_pi16, _mm_unpacklo_pi8, _mm_packs_pi16, _mm_unpackhi_pi16","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469627,"byte_end":2469628,"line_start":536,"line_end":536,"column_start":26,"column_end":27},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469659,"byte_end":2469660,"line_start":539,"line_end":539,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469697,"byte_end":2469698,"line_start":542,"line_end":542,"column_start":23,"column_end":24},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469729,"byte_end":2469730,"line_start":545,"line_end":545,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469761,"byte_end":2469762,"line_start":548,"line_end":548,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469989,"byte_end":2469990,"line_start":561,"line_end":561,"column_start":24,"column_end":25},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2470035,"byte_end":2470036,"line_start":564,"line_end":564,"column_start":27,"column_end":28},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2470065,"byte_end":2470066,"line_start":567,"line_end":567,"column_start":19,"column_end":20},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":9290}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504655,"byte_end":3504656,"line_start":4,"line_end":4,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504687,"byte_end":3504688,"line_start":7,"line_end":7,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504721,"byte_end":3504722,"line_start":10,"line_end":10,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504757,"byte_end":3504758,"line_start":13,"line_end":13,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504793,"byte_end":3504794,"line_start":16,"line_end":16,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504829,"byte_end":3504830,"line_start":19,"line_end":19,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504861,"byte_end":3504862,"line_start":22,"line_end":22,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504893,"byte_end":3504894,"line_start":25,"line_end":25,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504925,"byte_end":3504926,"line_start":28,"line_end":28,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504959,"byte_end":3504960,"line_start":31,"line_end":31,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3504993,"byte_end":3504994,"line_start":34,"line_end":34,"column_start":21,"column_end":22},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3505029,"byte_end":3505030,"line_start":37,"line_end":37,"column_start":22,"column_end":23},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3505067,"byte_end":3505068,"line_start":40,"line_end":40,"column_start":23,"column_end":24},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3505113,"byte_end":3505114,"line_start":43,"line_end":43,"column_start":27,"column_end":28},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3505145,"byte_end":3505146,"line_start":46,"line_end":46,"column_start":20,"column_end":21},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"GlobUse","ref_id":null,"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/mod.rs","byte_start":3505175,"byte_end":3505176,"line_start":49,"line_end":49,"column_start":19,"column_end":20},"alias_span":null,"name":"*","value":"","parent":{"krate":0,"index":12310}},{"kind":"Use","ref_id":{"krate":0,"index":9278},"span":{"file_name":"src/libcore/lib.rs","byte_start":7370,"byte_end":7374,"line_start":239,"line_end":239,"column_start":20,"column_end":24},"alias_span":null,"name":"arch","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"src/libcore/lib.rs","byte_start":0,"byte_end":7375,"line_start":1,"line_end":239,"column_start":1,"column_end":25},"name":"","qualname":"::","value":"src/libcore/lib.rs","parent":null,"children":[{"krate":0,"index":2},{"krate":0,"index":4},{"krate":0,"index":32},{"krate":0,"index":44},{"krate":0,"index":48},{"krate":0,"index":52},{"krate":0,"index":54},{"krate":0,"index":56},{"krate":0,"index":58},{"krate":0,"index":60},{"krate":0,"index":62},{"krate":0,"index":64},{"krate":0,"index":66},{"krate":0,"index":68},{"krate":0,"index":70},{"krate":0,"index":72},{"krate":0,"index":74},{"krate":0,"index":76},{"krate":0,"index":186},{"krate":0,"index":298},{"krate":0,"index":1104},{"krate":0,"index":1186},{"krate":0,"index":1204},{"krate":0,"index":1336},{"krate":0,"index":1686},{"krate":0,"index":1696},{"krate":0,"index":1770},{"krate":0,"index":2412},{"krate":0,"index":2604},{"krate":0,"index":2638},{"krate":0,"index":2646},{"krate":0,"index":2754},{"krate":0,"index":2784},{"krate":0,"index":2838},{"krate":0,"index":2894},{"krate":0,"index":2928},{"krate":0,"index":3072},{"krate":0,"index":3370},{"krate":0,"index":3704},{"krate":0,"index":3748},{"krate":0,"index":3766},{"krate":0,"index":3874},{"krate":0,"index":5506},{"krate":0,"index":5758},{"krate":0,"index":5760},{"krate":0,"index":5956},{"krate":0,"index":5984},{"krate":0,"index":7096},{"krate":0,"index":7956},{"krate":0,"index":8198},{"krate":0,"index":8692},{"krate":0,"index":8850},{"krate":0,"index":8986},{"krate":0,"index":9022},{"krate":0,"index":9140},{"krate":0,"index":9246},{"krate":0,"index":9262},{"krate":0,"index":9270},{"krate":0,"index":12544}],"decl_id":null,"docs":" # The Rust Core Library","sig":null,"attributes":[{"value":"cfg(not(test))","span":{"file_name":"src/libcore/lib.rs","byte_start":2621,"byte_end":2639,"line_start":51,"line_end":51,"column_start":1,"column_end":19}},{"value":"stable(feature = \"core\", since = \"1.6.0\")","span":{"file_name":"src/libcore/lib.rs","byte_start":2641,"byte_end":2686,"line_start":53,"line_end":53,"column_start":1,"column_end":46}},{"value":"no_core","span":{"file_name":"src/libcore/lib.rs","byte_start":3017,"byte_end":3028,"line_start":59,"line_end":59,"column_start":1,"column_end":12}},{"value":"warn(deprecated_in_future)","span":{"file_name":"src/libcore/lib.rs","byte_start":3030,"byte_end":3060,"line_start":61,"line_end":61,"column_start":1,"column_end":31}},{"value":"warn(missing_docs)","span":{"file_name":"src/libcore/lib.rs","byte_start":3061,"byte_end":3083,"line_start":62,"line_end":62,"column_start":1,"column_end":23}},{"value":"warn(missing_debug_implementations)","span":{"file_name":"src/libcore/lib.rs","byte_start":3084,"byte_end":3123,"line_start":63,"line_end":63,"column_start":1,"column_end":40}},{"value":"deny(intra_doc_link_resolution_failure)","span":{"file_name":"src/libcore/lib.rs","byte_start":3124,"byte_end":3167,"line_start":64,"line_end":64,"column_start":1,"column_end":44}},{"value":"deny(rust_2018_idioms)","span":{"file_name":"src/libcore/lib.rs","byte_start":3207,"byte_end":3233,"line_start":66,"line_end":66,"column_start":1,"column_end":27}},{"value":"allow(explicit_outlives_requirements)","span":{"file_name":"src/libcore/lib.rs","byte_start":3234,"byte_end":3275,"line_start":67,"line_end":67,"column_start":1,"column_end":42}},{"value":"feature(allow_internal_unstable)","span":{"file_name":"src/libcore/lib.rs","byte_start":3277,"byte_end":3313,"line_start":69,"line_end":69,"column_start":1,"column_end":37}},{"value":"feature(arbitrary_self_types)","span":{"file_name":"src/libcore/lib.rs","byte_start":3314,"byte_end":3347,"line_start":70,"line_end":70,"column_start":1,"column_end":34}},{"value":"feature(asm)","span":{"file_name":"src/libcore/lib.rs","byte_start":3348,"byte_end":3364,"line_start":71,"line_end":71,"column_start":1,"column_end":17}},{"value":"feature(associated_type_defaults)","span":{"file_name":"src/libcore/lib.rs","byte_start":3365,"byte_end":3402,"line_start":72,"line_end":72,"column_start":1,"column_end":38}},{"value":"feature(cfg_target_has_atomic)","span":{"file_name":"src/libcore/lib.rs","byte_start":3403,"byte_end":3437,"line_start":73,"line_end":73,"column_start":1,"column_end":35}},{"value":"feature(concat_idents)","span":{"file_name":"src/libcore/lib.rs","byte_start":3438,"byte_end":3464,"line_start":74,"line_end":74,"column_start":1,"column_end":27}},{"value":"feature(const_fn)","span":{"file_name":"src/libcore/lib.rs","byte_start":3465,"byte_end":3486,"line_start":75,"line_end":75,"column_start":1,"column_end":22}},{"value":"feature(const_fn_union)","span":{"file_name":"src/libcore/lib.rs","byte_start":3487,"byte_end":3514,"line_start":76,"line_end":76,"column_start":1,"column_end":28}},{"value":"feature(custom_attribute)","span":{"file_name":"src/libcore/lib.rs","byte_start":3515,"byte_end":3544,"line_start":77,"line_end":77,"column_start":1,"column_end":30}},{"value":"feature(doc_cfg)","span":{"file_name":"src/libcore/lib.rs","byte_start":3545,"byte_end":3565,"line_start":78,"line_end":78,"column_start":1,"column_end":21}},{"value":"feature(doc_spotlight)","span":{"file_name":"src/libcore/lib.rs","byte_start":3566,"byte_end":3592,"line_start":79,"line_end":79,"column_start":1,"column_end":27}},{"value":"feature(extern_types)","span":{"file_name":"src/libcore/lib.rs","byte_start":3593,"byte_end":3618,"line_start":80,"line_end":80,"column_start":1,"column_end":26}},{"value":"feature(fundamental)","span":{"file_name":"src/libcore/lib.rs","byte_start":3619,"byte_end":3643,"line_start":81,"line_end":81,"column_start":1,"column_end":25}},{"value":"feature(intrinsics)","span":{"file_name":"src/libcore/lib.rs","byte_start":3644,"byte_end":3667,"line_start":82,"line_end":82,"column_start":1,"column_end":24}},{"value":"feature(is_sorted)","span":{"file_name":"src/libcore/lib.rs","byte_start":3668,"byte_end":3690,"line_start":83,"line_end":83,"column_start":1,"column_end":23}},{"value":"feature(iter_once_with)","span":{"file_name":"src/libcore/lib.rs","byte_start":3691,"byte_end":3718,"line_start":84,"line_end":84,"column_start":1,"column_end":28}},{"value":"feature(lang_items)","span":{"file_name":"src/libcore/lib.rs","byte_start":3719,"byte_end":3742,"line_start":85,"line_end":85,"column_start":1,"column_end":24}},{"value":"feature(link_llvm_intrinsics)","span":{"file_name":"src/libcore/lib.rs","byte_start":3743,"byte_end":3776,"line_start":86,"line_end":86,"column_start":1,"column_end":34}},{"value":"feature(never_type)","span":{"file_name":"src/libcore/lib.rs","byte_start":3777,"byte_end":3800,"line_start":87,"line_end":87,"column_start":1,"column_end":24}},{"value":"feature(nll)","span":{"file_name":"src/libcore/lib.rs","byte_start":3801,"byte_end":3817,"line_start":88,"line_end":88,"column_start":1,"column_end":17}},{"value":"feature(bind_by_move_pattern_guards)","span":{"file_name":"src/libcore/lib.rs","byte_start":3818,"byte_end":3858,"line_start":89,"line_end":89,"column_start":1,"column_end":41}},{"value":"feature(exhaustive_patterns)","span":{"file_name":"src/libcore/lib.rs","byte_start":3859,"byte_end":3891,"line_start":90,"line_end":90,"column_start":1,"column_end":33}},{"value":"feature(no_core)","span":{"file_name":"src/libcore/lib.rs","byte_start":3892,"byte_end":3912,"line_start":91,"line_end":91,"column_start":1,"column_end":21}},{"value":"feature(on_unimplemented)","span":{"file_name":"src/libcore/lib.rs","byte_start":3913,"byte_end":3942,"line_start":92,"line_end":92,"column_start":1,"column_end":30}},{"value":"feature(optin_builtin_traits)","span":{"file_name":"src/libcore/lib.rs","byte_start":3943,"byte_end":3976,"line_start":93,"line_end":93,"column_start":1,"column_end":34}},{"value":"feature(prelude_import)","span":{"file_name":"src/libcore/lib.rs","byte_start":3977,"byte_end":4004,"line_start":94,"line_end":94,"column_start":1,"column_end":28}},{"value":"feature(repr_simd, platform_intrinsics)","span":{"file_name":"src/libcore/lib.rs","byte_start":4005,"byte_end":4048,"line_start":95,"line_end":95,"column_start":1,"column_end":44}},{"value":"feature(rustc_attrs)","span":{"file_name":"src/libcore/lib.rs","byte_start":4049,"byte_end":4073,"line_start":96,"line_end":96,"column_start":1,"column_end":25}},{"value":"feature(rustc_const_unstable)","span":{"file_name":"src/libcore/lib.rs","byte_start":4074,"byte_end":4107,"line_start":97,"line_end":97,"column_start":1,"column_end":34}},{"value":"feature(simd_ffi)","span":{"file_name":"src/libcore/lib.rs","byte_start":4108,"byte_end":4129,"line_start":98,"line_end":98,"column_start":1,"column_end":22}},{"value":"feature(specialization)","span":{"file_name":"src/libcore/lib.rs","byte_start":4130,"byte_end":4157,"line_start":99,"line_end":99,"column_start":1,"column_end":28}},{"value":"feature(staged_api)","span":{"file_name":"src/libcore/lib.rs","byte_start":4158,"byte_end":4181,"line_start":100,"line_end":100,"column_start":1,"column_end":24}},{"value":"feature(std_internals)","span":{"file_name":"src/libcore/lib.rs","byte_start":4182,"byte_end":4208,"line_start":101,"line_end":101,"column_start":1,"column_end":27}},{"value":"feature(stmt_expr_attributes)","span":{"file_name":"src/libcore/lib.rs","byte_start":4209,"byte_end":4242,"line_start":102,"line_end":102,"column_start":1,"column_end":34}},{"value":"feature(unboxed_closures)","span":{"file_name":"src/libcore/lib.rs","byte_start":4243,"byte_end":4272,"line_start":103,"line_end":103,"column_start":1,"column_end":30}},{"value":"feature(unsized_locals)","span":{"file_name":"src/libcore/lib.rs","byte_start":4273,"byte_end":4300,"line_start":104,"line_end":104,"column_start":1,"column_end":28}},{"value":"feature(untagged_unions)","span":{"file_name":"src/libcore/lib.rs","byte_start":4301,"byte_end":4329,"line_start":105,"line_end":105,"column_start":1,"column_end":29}},{"value":"feature(unwind_attributes)","span":{"file_name":"src/libcore/lib.rs","byte_start":4330,"byte_end":4360,"line_start":106,"line_end":106,"column_start":1,"column_end":31}},{"value":"feature(doc_alias)","span":{"file_name":"src/libcore/lib.rs","byte_start":4361,"byte_end":4383,"line_start":107,"line_end":107,"column_start":1,"column_end":23}},{"value":"feature(mmx_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4384,"byte_end":4415,"line_start":108,"line_end":108,"column_start":1,"column_end":32}},{"value":"feature(tbm_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4416,"byte_end":4447,"line_start":109,"line_end":109,"column_start":1,"column_end":32}},{"value":"feature(sse4a_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4448,"byte_end":4481,"line_start":110,"line_end":110,"column_start":1,"column_end":34}},{"value":"feature(arm_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4482,"byte_end":4513,"line_start":111,"line_end":111,"column_start":1,"column_end":32}},{"value":"feature(powerpc_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4514,"byte_end":4549,"line_start":112,"line_end":112,"column_start":1,"column_end":36}},{"value":"feature(mips_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4550,"byte_end":4582,"line_start":113,"line_end":113,"column_start":1,"column_end":33}},{"value":"feature(aarch64_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4583,"byte_end":4618,"line_start":114,"line_end":114,"column_start":1,"column_end":36}},{"value":"feature(wasm_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4619,"byte_end":4651,"line_start":115,"line_end":115,"column_start":1,"column_end":33}},{"value":"feature(avx512_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4652,"byte_end":4686,"line_start":116,"line_end":116,"column_start":1,"column_end":35}},{"value":"feature(cmpxchg16b_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4687,"byte_end":4725,"line_start":117,"line_end":117,"column_start":1,"column_end":39}},{"value":"feature(const_slice_len)","span":{"file_name":"src/libcore/lib.rs","byte_start":4726,"byte_end":4754,"line_start":118,"line_end":118,"column_start":1,"column_end":29}},{"value":"feature(const_str_as_bytes)","span":{"file_name":"src/libcore/lib.rs","byte_start":4755,"byte_end":4786,"line_start":119,"line_end":119,"column_start":1,"column_end":32}},{"value":"feature(const_str_len)","span":{"file_name":"src/libcore/lib.rs","byte_start":4787,"byte_end":4813,"line_start":120,"line_end":120,"column_start":1,"column_end":27}},{"value":"feature(const_int_conversion)","span":{"file_name":"src/libcore/lib.rs","byte_start":4814,"byte_end":4847,"line_start":121,"line_end":121,"column_start":1,"column_end":34}},{"value":"feature(const_transmute)","span":{"file_name":"src/libcore/lib.rs","byte_start":4848,"byte_end":4876,"line_start":122,"line_end":122,"column_start":1,"column_end":29}},{"value":"feature(reverse_bits)","span":{"file_name":"src/libcore/lib.rs","byte_start":4877,"byte_end":4902,"line_start":123,"line_end":123,"column_start":1,"column_end":26}},{"value":"feature(non_exhaustive)","span":{"file_name":"src/libcore/lib.rs","byte_start":4903,"byte_end":4930,"line_start":124,"line_end":124,"column_start":1,"column_end":28}},{"value":"feature(structural_match)","span":{"file_name":"src/libcore/lib.rs","byte_start":4931,"byte_end":4960,"line_start":125,"line_end":125,"column_start":1,"column_end":30}},{"value":"feature(abi_unadjusted)","span":{"file_name":"src/libcore/lib.rs","byte_start":4961,"byte_end":4988,"line_start":126,"line_end":126,"column_start":1,"column_end":28}},{"value":"feature(adx_target_feature)","span":{"file_name":"src/libcore/lib.rs","byte_start":4989,"byte_end":5020,"line_start":127,"line_end":127,"column_start":1,"column_end":32}},{"value":"feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)","span":{"file_name":"src/libcore/lib.rs","byte_start":5021,"byte_end":5086,"line_start":128,"line_end":128,"column_start":1,"column_end":66}},{"value":"feature(external_doc)","span":{"file_name":"src/libcore/lib.rs","byte_start":5087,"byte_end":5112,"line_start":129,"line_end":129,"column_start":1,"column_end":26}}]},{"kind":"Mod","id":{"krate":0,"index":52},"span":{"file_name":"src/libcore/num/isize.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"isize","qualname":"::isize","value":"src/libcore/num/isize.rs","parent":null,"children":[{"krate":0,"index":12546},{"krate":0,"index":12548}],"decl_id":null,"docs":" The pointer-sized signed integer type.","sig":null,"attributes":[{"value":"path = \"num/isize.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5353,"byte_end":5377,"line_start":149,"line_end":149,"column_start":1,"column_end":25}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/isize.rs","byte_start":41767,"byte_end":41813,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":54},"span":{"file_name":"src/libcore/num/i8.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i8","qualname":"::i8","value":"src/libcore/num/i8.rs","parent":null,"children":[{"krate":0,"index":12550},{"krate":0,"index":12552}],"decl_id":null,"docs":" The 8-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i8.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5393,"byte_end":5414,"line_start":150,"line_end":150,"column_start":1,"column_end":22}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/i8.rs","byte_start":41949,"byte_end":41995,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":56},"span":{"file_name":"src/libcore/num/i16.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i16","qualname":"::i16","value":"src/libcore/num/i16.rs","parent":null,"children":[{"krate":0,"index":12554},{"krate":0,"index":12556}],"decl_id":null,"docs":" The 16-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i16.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5430,"byte_end":5452,"line_start":151,"line_end":151,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/i16.rs","byte_start":42131,"byte_end":42177,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":58},"span":{"file_name":"src/libcore/num/i32.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i32","qualname":"::i32","value":"src/libcore/num/i32.rs","parent":null,"children":[{"krate":0,"index":12558},{"krate":0,"index":12560}],"decl_id":null,"docs":" The 32-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i32.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5468,"byte_end":5490,"line_start":152,"line_end":152,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/i32.rs","byte_start":42314,"byte_end":42360,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":60},"span":{"file_name":"src/libcore/num/i64.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i64","qualname":"::i64","value":"src/libcore/num/i64.rs","parent":null,"children":[{"krate":0,"index":12562},{"krate":0,"index":12564}],"decl_id":null,"docs":" The 64-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i64.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5506,"byte_end":5528,"line_start":153,"line_end":153,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/i64.rs","byte_start":42497,"byte_end":42543,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":62},"span":{"file_name":"src/libcore/num/i128.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"i128","qualname":"::i128","value":"src/libcore/num/i128.rs","parent":null,"children":[{"krate":0,"index":12566},{"krate":0,"index":12568}],"decl_id":null,"docs":" The 128-bit signed integer type.","sig":null,"attributes":[{"value":"path = \"num/i128.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5544,"byte_end":5567,"line_start":154,"line_end":154,"column_start":1,"column_end":24}},{"value":"stable(feature = \"i128\", since = \"1.26.0\")","span":{"file_name":"src/libcore/num/i128.rs","byte_start":42683,"byte_end":42729,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":64},"span":{"file_name":"src/libcore/num/usize.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"usize","qualname":"::usize","value":"src/libcore/num/usize.rs","parent":null,"children":[{"krate":0,"index":12570},{"krate":0,"index":12572}],"decl_id":null,"docs":" The pointer-sized unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/usize.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5584,"byte_end":5608,"line_start":156,"line_end":156,"column_start":1,"column_end":25}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/usize.rs","byte_start":42925,"byte_end":42971,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":66},"span":{"file_name":"src/libcore/num/u8.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u8","qualname":"::u8","value":"src/libcore/num/u8.rs","parent":null,"children":[{"krate":0,"index":12574},{"krate":0,"index":12576}],"decl_id":null,"docs":" The 8-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u8.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5624,"byte_end":5645,"line_start":157,"line_end":157,"column_start":1,"column_end":22}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/u8.rs","byte_start":43110,"byte_end":43156,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":68},"span":{"file_name":"src/libcore/num/u16.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u16","qualname":"::u16","value":"src/libcore/num/u16.rs","parent":null,"children":[{"krate":0,"index":12578},{"krate":0,"index":12580}],"decl_id":null,"docs":" The 16-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u16.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5661,"byte_end":5683,"line_start":158,"line_end":158,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/u16.rs","byte_start":43295,"byte_end":43341,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":70},"span":{"file_name":"src/libcore/num/u32.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u32","qualname":"::u32","value":"src/libcore/num/u32.rs","parent":null,"children":[{"krate":0,"index":12582},{"krate":0,"index":12584}],"decl_id":null,"docs":" The 32-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u32.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5699,"byte_end":5721,"line_start":159,"line_end":159,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/u32.rs","byte_start":43481,"byte_end":43527,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":72},"span":{"file_name":"src/libcore/num/u64.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u64","qualname":"::u64","value":"src/libcore/num/u64.rs","parent":null,"children":[{"krate":0,"index":12586},{"krate":0,"index":12588}],"decl_id":null,"docs":" The 64-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u64.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5737,"byte_end":5759,"line_start":160,"line_end":160,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/u64.rs","byte_start":43667,"byte_end":43713,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":74},"span":{"file_name":"src/libcore/num/u128.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"u128","qualname":"::u128","value":"src/libcore/num/u128.rs","parent":null,"children":[{"krate":0,"index":12590},{"krate":0,"index":12592}],"decl_id":null,"docs":" The 128-bit unsigned integer type.","sig":null,"attributes":[{"value":"path = \"num/u128.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5775,"byte_end":5798,"line_start":161,"line_end":161,"column_start":1,"column_end":24}},{"value":"stable(feature = \"i128\", since = \"1.26.0\")","span":{"file_name":"src/libcore/num/u128.rs","byte_start":43856,"byte_end":43902,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":76},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"f32","qualname":"::f32","value":"src/libcore/num/f32.rs","parent":null,"children":[{"krate":0,"index":78},{"krate":0,"index":80},{"krate":0,"index":82},{"krate":0,"index":84},{"krate":0,"index":86},{"krate":0,"index":88},{"krate":0,"index":90},{"krate":0,"index":92},{"krate":0,"index":94},{"krate":0,"index":96},{"krate":0,"index":98},{"krate":0,"index":100},{"krate":0,"index":102},{"krate":0,"index":104},{"krate":0,"index":106},{"krate":0,"index":108},{"krate":0,"index":110},{"krate":0,"index":148}],"decl_id":null,"docs":" This module provides constants which are specific to the implementation\n of the `f32` floating point data type.","sig":null,"attributes":[{"value":"path = \"num/f32.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5815,"byte_end":5837,"line_start":163,"line_end":163,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44252,"byte_end":44298,"line_start":8,"line_end":8,"column_start":1,"column_end":47}}]},{"kind":"Const","id":{"krate":0,"index":82},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44464,"byte_end":44469,"line_start":15,"line_end":15,"column_start":11,"column_end":16},"name":"RADIX","qualname":"::f32::RADIX","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" The radix or base of the internal representation of `f32`.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44408,"byte_end":44453,"line_start":14,"line_end":14,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":84},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44581,"byte_end":44596,"line_start":19,"line_end":19,"column_start":11,"column_end":26},"name":"MANTISSA_DIGITS","qualname":"::f32::MANTISSA_DIGITS","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" Number of significant digits in base 2.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44525,"byte_end":44570,"line_start":18,"line_end":18,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":86},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44721,"byte_end":44727,"line_start":22,"line_end":22,"column_start":11,"column_end":17},"name":"DIGITS","qualname":"::f32::DIGITS","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" Approximate number of significant digits in base 10.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44665,"byte_end":44710,"line_start":21,"line_end":21,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":88},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":44995,"byte_end":45002,"line_start":30,"line_end":30,"column_start":11,"column_end":18},"name":"EPSILON","qualname":"::f32::EPSILON","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" [Machine epsilon] value for `f32`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":44939,"byte_end":44984,"line_start":29,"line_end":29,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":90},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45120,"byte_end":45123,"line_start":34,"line_end":34,"column_start":11,"column_end":14},"name":"MIN","qualname":"::f32::MIN","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Smallest finite `f32` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45064,"byte_end":45109,"line_start":33,"line_end":33,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":92},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45250,"byte_end":45262,"line_start":37,"line_end":37,"column_start":11,"column_end":23},"name":"MIN_POSITIVE","qualname":"::f32::MIN_POSITIVE","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Smallest positive normal `f32` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45194,"byte_end":45239,"line_start":36,"line_end":36,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":94},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45378,"byte_end":45381,"line_start":40,"line_end":40,"column_start":11,"column_end":14},"name":"MAX","qualname":"::f32::MAX","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Largest finite `f32` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45322,"byte_end":45367,"line_start":39,"line_end":39,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":96},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45536,"byte_end":45543,"line_start":44,"line_end":44,"column_start":11,"column_end":18},"name":"MIN_EXP","qualname":"::f32::MIN_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" One greater than the minimum possible normal power of 2 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45480,"byte_end":45525,"line_start":43,"line_end":43,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":98},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45655,"byte_end":45662,"line_start":47,"line_end":47,"column_start":11,"column_end":18},"name":"MAX_EXP","qualname":"::f32::MAX_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Maximum possible power of 2 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45599,"byte_end":45644,"line_start":46,"line_end":46,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":100},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45782,"byte_end":45792,"line_start":51,"line_end":51,"column_start":11,"column_end":21},"name":"MIN_10_EXP","qualname":"::f32::MIN_10_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Minimum possible normal power of 10 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45726,"byte_end":45771,"line_start":50,"line_end":50,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":102},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":45904,"byte_end":45914,"line_start":54,"line_end":54,"column_start":11,"column_end":21},"name":"MAX_10_EXP","qualname":"::f32::MAX_10_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Maximum possible power of 10 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45848,"byte_end":45893,"line_start":53,"line_end":53,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":104},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46007,"byte_end":46010,"line_start":58,"line_end":58,"column_start":11,"column_end":14},"name":"NAN","qualname":"::f32::NAN","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Not a Number (NaN).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":45951,"byte_end":45996,"line_start":57,"line_end":57,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":106},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46113,"byte_end":46121,"line_start":61,"line_end":61,"column_start":11,"column_end":19},"name":"INFINITY","qualname":"::f32::INFINITY","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Infinity ().\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46057,"byte_end":46102,"line_start":60,"line_end":60,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":108},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46234,"byte_end":46246,"line_start":64,"line_end":64,"column_start":11,"column_end":23},"name":"NEG_INFINITY","qualname":"::f32::NEG_INFINITY","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Negative infinity (-).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46178,"byte_end":46223,"line_start":63,"line_end":63,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":110},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46363,"byte_end":46369,"line_start":68,"line_end":68,"column_start":9,"column_end":15},"name":"consts","qualname":"::f32::consts","value":"src/libcore/num/f32.rs","parent":null,"children":[{"krate":0,"index":112},{"krate":0,"index":114},{"krate":0,"index":116},{"krate":0,"index":118},{"krate":0,"index":120},{"krate":0,"index":122},{"krate":0,"index":124},{"krate":0,"index":126},{"krate":0,"index":128},{"krate":0,"index":130},{"krate":0,"index":132},{"krate":0,"index":134},{"krate":0,"index":136},{"krate":0,"index":138},{"krate":0,"index":140},{"krate":0,"index":142},{"krate":0,"index":144},{"krate":0,"index":146}],"decl_id":null,"docs":" Basic mathematical constants.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46309,"byte_end":46354,"line_start":67,"line_end":67,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":112},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46533,"byte_end":46535,"line_start":73,"line_end":73,"column_start":15,"column_end":17},"name":"PI","qualname":"::f32::consts::PI","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Archimedes' constant ()\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46473,"byte_end":46518,"line_start":72,"line_end":72,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":114},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46664,"byte_end":46673,"line_start":77,"line_end":77,"column_start":15,"column_end":24},"name":"FRAC_PI_2","qualname":"::f32::consts::FRAC_PI_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" /2\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46604,"byte_end":46649,"line_start":76,"line_end":76,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":116},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46802,"byte_end":46811,"line_start":81,"line_end":81,"column_start":15,"column_end":24},"name":"FRAC_PI_3","qualname":"::f32::consts::FRAC_PI_3","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" /3\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46742,"byte_end":46787,"line_start":80,"line_end":80,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":118},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":46940,"byte_end":46949,"line_start":85,"line_end":85,"column_start":15,"column_end":24},"name":"FRAC_PI_4","qualname":"::f32::consts::FRAC_PI_4","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" /4\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":46880,"byte_end":46925,"line_start":84,"line_end":84,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":120},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":47079,"byte_end":47088,"line_start":89,"line_end":89,"column_start":15,"column_end":24},"name":"FRAC_PI_6","qualname":"::f32::consts::FRAC_PI_6","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" /6\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47019,"byte_end":47064,"line_start":88,"line_end":88,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":122},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":47217,"byte_end":47226,"line_start":93,"line_end":93,"column_start":15,"column_end":24},"name":"FRAC_PI_8","qualname":"::f32::consts::FRAC_PI_8","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" /8\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47157,"byte_end":47202,"line_start":92,"line_end":92,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":124},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":47355,"byte_end":47364,"line_start":97,"line_end":97,"column_start":15,"column_end":24},"name":"FRAC_1_PI","qualname":"::f32::consts::FRAC_1_PI","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" 1/\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47295,"byte_end":47340,"line_start":96,"line_end":96,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":126},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":47494,"byte_end":47503,"line_start":101,"line_end":101,"column_start":15,"column_end":24},"name":"FRAC_2_PI","qualname":"::f32::consts::FRAC_2_PI","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" 2/\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47434,"byte_end":47479,"line_start":100,"line_end":100,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":128},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":47639,"byte_end":47653,"line_start":105,"line_end":105,"column_start":15,"column_end":29},"name":"FRAC_2_SQRT_PI","qualname":"::f32::consts::FRAC_2_SQRT_PI","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" 2/sqrt()\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47579,"byte_end":47624,"line_start":104,"line_end":104,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":130},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":47785,"byte_end":47791,"line_start":109,"line_end":109,"column_start":15,"column_end":21},"name":"SQRT_2","qualname":"::f32::consts::SQRT_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" sqrt(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47725,"byte_end":47770,"line_start":108,"line_end":108,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":132},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":47925,"byte_end":47938,"line_start":113,"line_end":113,"column_start":15,"column_end":28},"name":"FRAC_1_SQRT_2","qualname":"::f32::consts::FRAC_1_SQRT_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" 1/sqrt(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":47865,"byte_end":47910,"line_start":112,"line_end":112,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":134},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":48082,"byte_end":48083,"line_start":117,"line_end":117,"column_start":15,"column_end":16},"name":"E","qualname":"::f32::consts::E","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" Euler's number (e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48022,"byte_end":48067,"line_start":116,"line_end":116,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":136},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":48226,"byte_end":48232,"line_start":121,"line_end":121,"column_start":15,"column_end":21},"name":"LOG2_E","qualname":"::f32::consts::LOG2_E","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" log<sub>2</sub>(e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48166,"byte_end":48211,"line_start":120,"line_end":120,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":138},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":48389,"byte_end":48396,"line_start":125,"line_end":125,"column_start":15,"column_end":22},"name":"LOG2_10","qualname":"::f32::consts::LOG2_10","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" log<sub>2</sub>(10)\n","sig":null,"attributes":[{"value":"unstable(feature = \"extra_log_consts\", issue = \"50540\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48316,"byte_end":48374,"line_start":124,"line_end":124,"column_start":5,"column_end":63}}]},{"kind":"Const","id":{"krate":0,"index":140},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":48540,"byte_end":48547,"line_start":129,"line_end":129,"column_start":15,"column_end":22},"name":"LOG10_E","qualname":"::f32::consts::LOG10_E","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" log<sub>10</sub>(e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48480,"byte_end":48525,"line_start":128,"line_end":128,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":142},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":48705,"byte_end":48712,"line_start":133,"line_end":133,"column_start":15,"column_end":22},"name":"LOG10_2","qualname":"::f32::consts::LOG10_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" log<sub>10</sub>(2)\n","sig":null,"attributes":[{"value":"unstable(feature = \"extra_log_consts\", issue = \"50540\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48632,"byte_end":48690,"line_start":132,"line_end":132,"column_start":5,"column_end":63}}]},{"kind":"Const","id":{"krate":0,"index":144},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":48843,"byte_end":48847,"line_start":137,"line_end":137,"column_start":15,"column_end":19},"name":"LN_2","qualname":"::f32::consts::LN_2","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" ln(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48783,"byte_end":48828,"line_start":136,"line_end":136,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":146},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":48979,"byte_end":48984,"line_start":141,"line_end":141,"column_start":15,"column_end":20},"name":"LN_10","qualname":"::f32::consts::LN_10","value":"f32","parent":null,"children":[],"decl_id":null,"docs":" ln(10)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":48919,"byte_end":48964,"line_start":140,"line_end":140,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":150},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":49389,"byte_end":49395,"line_start":160,"line_end":160,"column_start":12,"column_end":18},"name":"is_nan","qualname":"<f32>::is_nan","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this value is `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":49318,"byte_end":49363,"line_start":158,"line_end":158,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":49368,"byte_end":49377,"line_start":159,"line_end":159,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":154},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":50252,"byte_end":50263,"line_start":191,"line_end":191,"column_start":12,"column_end":23},"name":"is_infinite","qualname":"<f32>::is_infinite","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this value is positive infinity or negative infinity, and\n `false` otherwise.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":50181,"byte_end":50226,"line_start":189,"line_end":189,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":50231,"byte_end":50240,"line_start":190,"line_end":190,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":156},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":50815,"byte_end":50824,"line_start":213,"line_end":213,"column_start":12,"column_end":21},"name":"is_finite","qualname":"<f32>::is_finite","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this number is neither infinite nor `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":50744,"byte_end":50789,"line_start":211,"line_end":211,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":50794,"byte_end":50803,"line_start":212,"line_end":212,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":158},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":51786,"byte_end":51795,"line_start":242,"line_end":242,"column_start":12,"column_end":21},"name":"is_normal","qualname":"<f32>::is_normal","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the number is neither zero, infinite,\n [subnormal][subnormal], or `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":51715,"byte_end":51760,"line_start":240,"line_end":240,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":51765,"byte_end":51774,"line_start":241,"line_end":241,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":160},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":52386,"byte_end":52394,"line_start":261,"line_end":261,"column_start":12,"column_end":20},"name":"classify","qualname":"<f32>::classify","value":"fn (self) -> FpCategory","parent":null,"children":[],"decl_id":null,"docs":" Returns the floating point category of the number. If only one property\n is going to be tested, it is generally faster to use the specific\n predicate instead.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":52329,"byte_end":52374,"line_start":260,"line_end":260,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":166},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":53202,"byte_end":53218,"line_start":287,"line_end":287,"column_start":12,"column_end":28},"name":"is_sign_positive","qualname":"<f32>::is_sign_positive","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n positive sign bit and positive infinity.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":53131,"byte_end":53176,"line_start":285,"line_end":285,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":53181,"byte_end":53190,"line_start":286,"line_end":286,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":168},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":53651,"byte_end":53667,"line_start":303,"line_end":303,"column_start":12,"column_end":28},"name":"is_sign_negative","qualname":"<f32>::is_sign_negative","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n negative sign bit and negative infinity.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":53580,"byte_end":53625,"line_start":301,"line_end":301,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":53630,"byte_end":53639,"line_start":302,"line_end":302,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":170},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":54211,"byte_end":54216,"line_start":321,"line_end":321,"column_start":12,"column_end":17},"name":"recip","qualname":"<f32>::recip","value":"fn (self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Takes the reciprocal (inverse) of a number, `1/x`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":54140,"byte_end":54185,"line_start":319,"line_end":319,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":54190,"byte_end":54199,"line_start":320,"line_end":320,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":172},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":54626,"byte_end":54636,"line_start":338,"line_end":338,"column_start":12,"column_end":22},"name":"to_degrees","qualname":"<f32>::to_degrees","value":"fn (self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Converts radians to degrees.","sig":null,"attributes":[{"value":"stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":54539,"byte_end":54600,"line_start":336,"line_end":336,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":54605,"byte_end":54614,"line_start":337,"line_end":337,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":176},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":55179,"byte_end":55189,"line_start":357,"line_end":357,"column_start":12,"column_end":22},"name":"to_radians","qualname":"<f32>::to_radians","value":"fn (self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Converts degrees to radians.","sig":null,"attributes":[{"value":"stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":55092,"byte_end":55153,"line_start":355,"line_end":355,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":55158,"byte_end":55167,"line_start":356,"line_end":356,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":178},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":55612,"byte_end":55615,"line_start":374,"line_end":374,"column_start":12,"column_end":15},"name":"max","qualname":"<f32>::max","value":"fn (self, other: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the maximum of the two numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":55541,"byte_end":55586,"line_start":372,"line_end":372,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":55591,"byte_end":55600,"line_start":373,"line_end":373,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":180},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":56704,"byte_end":56707,"line_start":398,"line_end":398,"column_start":12,"column_end":15},"name":"min","qualname":"<f32>::min","value":"fn (self, other: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the minimum of the two numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":56633,"byte_end":56678,"line_start":396,"line_end":396,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":56683,"byte_end":56692,"line_start":397,"line_end":397,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":182},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":58166,"byte_end":58173,"line_start":429,"line_end":429,"column_start":12,"column_end":19},"name":"to_bits","qualname":"<f32>::to_bits","value":"fn (self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Raw transmutation to `u32`.","sig":null,"attributes":[{"value":"stable(feature = \"float_bits_conv\", since = \"1.20.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":58084,"byte_end":58140,"line_start":427,"line_end":427,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":58145,"byte_end":58154,"line_start":428,"line_end":428,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":184},"span":{"file_name":"src/libcore/num/f32.rs","byte_start":60097,"byte_end":60106,"line_start":473,"line_end":473,"column_start":12,"column_end":21},"name":"from_bits","qualname":"<f32>::from_bits","value":"fn (v: u32) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Raw transmutation from `u32`.","sig":null,"attributes":[{"value":"stable(feature = \"float_bits_conv\", since = \"1.20.0\")","span":{"file_name":"src/libcore/num/f32.rs","byte_start":60015,"byte_end":60071,"line_start":471,"line_end":471,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/num/f32.rs","byte_start":60076,"byte_end":60085,"line_start":472,"line_end":472,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":186},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"f64","qualname":"::f64","value":"src/libcore/num/f64.rs","parent":null,"children":[{"krate":0,"index":188},{"krate":0,"index":190},{"krate":0,"index":192},{"krate":0,"index":194},{"krate":0,"index":196},{"krate":0,"index":198},{"krate":0,"index":200},{"krate":0,"index":202},{"krate":0,"index":204},{"krate":0,"index":206},{"krate":0,"index":208},{"krate":0,"index":210},{"krate":0,"index":212},{"krate":0,"index":214},{"krate":0,"index":216},{"krate":0,"index":218},{"krate":0,"index":220},{"krate":0,"index":258}],"decl_id":null,"docs":" This module provides constants which are specific to the implementation\n of the `f64` floating point data type.","sig":null,"attributes":[{"value":"path = \"num/f64.rs\"","span":{"file_name":"src/libcore/lib.rs","byte_start":5853,"byte_end":5875,"line_start":164,"line_end":164,"column_start":1,"column_end":23}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60528,"byte_end":60574,"line_start":8,"line_end":8,"column_start":1,"column_end":47}}]},{"kind":"Const","id":{"krate":0,"index":192},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60740,"byte_end":60745,"line_start":15,"line_end":15,"column_start":11,"column_end":16},"name":"RADIX","qualname":"::f64::RADIX","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" The radix or base of the internal representation of `f64`.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60684,"byte_end":60729,"line_start":14,"line_end":14,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":194},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60857,"byte_end":60872,"line_start":19,"line_end":19,"column_start":11,"column_end":26},"name":"MANTISSA_DIGITS","qualname":"::f64::MANTISSA_DIGITS","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" Number of significant digits in base 2.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60801,"byte_end":60846,"line_start":18,"line_end":18,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":196},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":60997,"byte_end":61003,"line_start":22,"line_end":22,"column_start":11,"column_end":17},"name":"DIGITS","qualname":"::f64::DIGITS","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" Approximate number of significant digits in base 10.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":60941,"byte_end":60986,"line_start":21,"line_end":21,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":198},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61272,"byte_end":61279,"line_start":30,"line_end":30,"column_start":11,"column_end":18},"name":"EPSILON","qualname":"::f64::EPSILON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" [Machine epsilon] value for `f64`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61216,"byte_end":61261,"line_start":29,"line_end":29,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":200},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61405,"byte_end":61408,"line_start":34,"line_end":34,"column_start":11,"column_end":14},"name":"MIN","qualname":"::f64::MIN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Smallest finite `f64` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61349,"byte_end":61394,"line_start":33,"line_end":33,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":202},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61544,"byte_end":61556,"line_start":37,"line_end":37,"column_start":11,"column_end":23},"name":"MIN_POSITIVE","qualname":"::f64::MIN_POSITIVE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Smallest positive normal `f64` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61488,"byte_end":61533,"line_start":36,"line_end":36,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":204},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61681,"byte_end":61684,"line_start":40,"line_end":40,"column_start":11,"column_end":14},"name":"MAX","qualname":"::f64::MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Largest finite `f64` value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61625,"byte_end":61670,"line_start":39,"line_end":39,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":206},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61848,"byte_end":61855,"line_start":44,"line_end":44,"column_start":11,"column_end":18},"name":"MIN_EXP","qualname":"::f64::MIN_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" One greater than the minimum possible normal power of 2 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61792,"byte_end":61837,"line_start":43,"line_end":43,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":208},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":61968,"byte_end":61975,"line_start":47,"line_end":47,"column_start":11,"column_end":18},"name":"MAX_EXP","qualname":"::f64::MAX_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Maximum possible power of 2 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":61912,"byte_end":61957,"line_start":46,"line_end":46,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":210},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62096,"byte_end":62106,"line_start":51,"line_end":51,"column_start":11,"column_end":21},"name":"MIN_10_EXP","qualname":"::f64::MIN_10_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Minimum possible normal power of 10 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62040,"byte_end":62085,"line_start":50,"line_end":50,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":212},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62219,"byte_end":62229,"line_start":54,"line_end":54,"column_start":11,"column_end":21},"name":"MAX_10_EXP","qualname":"::f64::MAX_10_EXP","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Maximum possible power of 10 exponent.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62163,"byte_end":62208,"line_start":53,"line_end":53,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":214},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62323,"byte_end":62326,"line_start":58,"line_end":58,"column_start":11,"column_end":14},"name":"NAN","qualname":"::f64::NAN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Not a Number (NaN).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62267,"byte_end":62312,"line_start":57,"line_end":57,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":216},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62429,"byte_end":62437,"line_start":61,"line_end":61,"column_start":11,"column_end":19},"name":"INFINITY","qualname":"::f64::INFINITY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Infinity ().\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62373,"byte_end":62418,"line_start":60,"line_end":60,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":218},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62550,"byte_end":62562,"line_start":64,"line_end":64,"column_start":11,"column_end":23},"name":"NEG_INFINITY","qualname":"::f64::NEG_INFINITY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Negative infinity (-).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62494,"byte_end":62539,"line_start":63,"line_end":63,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":220},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62679,"byte_end":62685,"line_start":68,"line_end":68,"column_start":9,"column_end":15},"name":"consts","qualname":"::f64::consts","value":"src/libcore/num/f64.rs","parent":null,"children":[{"krate":0,"index":222},{"krate":0,"index":224},{"krate":0,"index":226},{"krate":0,"index":228},{"krate":0,"index":230},{"krate":0,"index":232},{"krate":0,"index":234},{"krate":0,"index":236},{"krate":0,"index":238},{"krate":0,"index":240},{"krate":0,"index":242},{"krate":0,"index":244},{"krate":0,"index":246},{"krate":0,"index":248},{"krate":0,"index":250},{"krate":0,"index":252},{"krate":0,"index":254},{"krate":0,"index":256}],"decl_id":null,"docs":" Basic mathematical constants.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62625,"byte_end":62670,"line_start":67,"line_end":67,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":222},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62849,"byte_end":62851,"line_start":73,"line_end":73,"column_start":15,"column_end":17},"name":"PI","qualname":"::f64::consts::PI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Archimedes' constant ()\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62789,"byte_end":62834,"line_start":72,"line_end":72,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":224},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":62980,"byte_end":62989,"line_start":77,"line_end":77,"column_start":15,"column_end":24},"name":"FRAC_PI_2","qualname":"::f64::consts::FRAC_PI_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" /2\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":62920,"byte_end":62965,"line_start":76,"line_end":76,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":226},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":63118,"byte_end":63127,"line_start":81,"line_end":81,"column_start":15,"column_end":24},"name":"FRAC_PI_3","qualname":"::f64::consts::FRAC_PI_3","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" /3\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63058,"byte_end":63103,"line_start":80,"line_end":80,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":228},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":63256,"byte_end":63265,"line_start":85,"line_end":85,"column_start":15,"column_end":24},"name":"FRAC_PI_4","qualname":"::f64::consts::FRAC_PI_4","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" /4\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63196,"byte_end":63241,"line_start":84,"line_end":84,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":230},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":63395,"byte_end":63404,"line_start":89,"line_end":89,"column_start":15,"column_end":24},"name":"FRAC_PI_6","qualname":"::f64::consts::FRAC_PI_6","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" /6\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63335,"byte_end":63380,"line_start":88,"line_end":88,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":232},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":63533,"byte_end":63542,"line_start":93,"line_end":93,"column_start":15,"column_end":24},"name":"FRAC_PI_8","qualname":"::f64::consts::FRAC_PI_8","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" /8\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63473,"byte_end":63518,"line_start":92,"line_end":92,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":234},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":63671,"byte_end":63680,"line_start":97,"line_end":97,"column_start":15,"column_end":24},"name":"FRAC_1_PI","qualname":"::f64::consts::FRAC_1_PI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 1/\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63611,"byte_end":63656,"line_start":96,"line_end":96,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":236},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":63810,"byte_end":63819,"line_start":101,"line_end":101,"column_start":15,"column_end":24},"name":"FRAC_2_PI","qualname":"::f64::consts::FRAC_2_PI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 2/\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63750,"byte_end":63795,"line_start":100,"line_end":100,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":238},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":63955,"byte_end":63969,"line_start":105,"line_end":105,"column_start":15,"column_end":29},"name":"FRAC_2_SQRT_PI","qualname":"::f64::consts::FRAC_2_SQRT_PI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 2/sqrt()\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":63895,"byte_end":63940,"line_start":104,"line_end":104,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":240},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":64101,"byte_end":64107,"line_start":109,"line_end":109,"column_start":15,"column_end":21},"name":"SQRT_2","qualname":"::f64::consts::SQRT_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" sqrt(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64041,"byte_end":64086,"line_start":108,"line_end":108,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":242},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":64241,"byte_end":64254,"line_start":113,"line_end":113,"column_start":15,"column_end":28},"name":"FRAC_1_SQRT_2","qualname":"::f64::consts::FRAC_1_SQRT_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 1/sqrt(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64181,"byte_end":64226,"line_start":112,"line_end":112,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":244},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":64398,"byte_end":64399,"line_start":117,"line_end":117,"column_start":15,"column_end":16},"name":"E","qualname":"::f64::consts::E","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Euler's number (e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64338,"byte_end":64383,"line_start":116,"line_end":116,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":246},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":64556,"byte_end":64563,"line_start":121,"line_end":121,"column_start":15,"column_end":22},"name":"LOG2_10","qualname":"::f64::consts::LOG2_10","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" log<sub>2</sub>(10)\n","sig":null,"attributes":[{"value":"unstable(feature = \"extra_log_consts\", issue = \"50540\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64483,"byte_end":64541,"line_start":120,"line_end":120,"column_start":5,"column_end":63}}]},{"kind":"Const","id":{"krate":0,"index":248},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":64706,"byte_end":64712,"line_start":125,"line_end":125,"column_start":15,"column_end":21},"name":"LOG2_E","qualname":"::f64::consts::LOG2_E","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" log<sub>2</sub>(e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64646,"byte_end":64691,"line_start":124,"line_end":124,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":250},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":64869,"byte_end":64876,"line_start":129,"line_end":129,"column_start":15,"column_end":22},"name":"LOG10_2","qualname":"::f64::consts::LOG10_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" log<sub>10</sub>(2)\n","sig":null,"attributes":[{"value":"unstable(feature = \"extra_log_consts\", issue = \"50540\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64796,"byte_end":64854,"line_start":128,"line_end":128,"column_start":5,"column_end":63}}]},{"kind":"Const","id":{"krate":0,"index":252},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":65021,"byte_end":65028,"line_start":133,"line_end":133,"column_start":15,"column_end":22},"name":"LOG10_E","qualname":"::f64::consts::LOG10_E","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" log<sub>10</sub>(e)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":64961,"byte_end":65006,"line_start":132,"line_end":132,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":254},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":65159,"byte_end":65163,"line_start":137,"line_end":137,"column_start":15,"column_end":19},"name":"LN_2","qualname":"::f64::consts::LN_2","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" ln(2)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65099,"byte_end":65144,"line_start":136,"line_end":136,"column_start":5,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":256},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":65295,"byte_end":65300,"line_start":141,"line_end":141,"column_start":15,"column_end":20},"name":"LN_10","qualname":"::f64::consts::LN_10","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" ln(10)\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65235,"byte_end":65280,"line_start":140,"line_end":140,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":260},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":65705,"byte_end":65711,"line_start":160,"line_end":160,"column_start":12,"column_end":18},"name":"is_nan","qualname":"<f64>::is_nan","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this value is `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65634,"byte_end":65679,"line_start":158,"line_end":158,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":65684,"byte_end":65693,"line_start":159,"line_end":159,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":264},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":66578,"byte_end":66589,"line_start":191,"line_end":191,"column_start":12,"column_end":23},"name":"is_infinite","qualname":"<f64>::is_infinite","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this value is positive infinity or negative infinity, and\n `false` otherwise.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":66507,"byte_end":66552,"line_start":189,"line_end":189,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":66557,"byte_end":66566,"line_start":190,"line_end":190,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":266},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":67156,"byte_end":67165,"line_start":213,"line_end":213,"column_start":12,"column_end":21},"name":"is_finite","qualname":"<f64>::is_finite","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this number is neither infinite nor `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":67085,"byte_end":67130,"line_start":211,"line_end":211,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":67135,"byte_end":67144,"line_start":212,"line_end":212,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":268},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":68136,"byte_end":68145,"line_start":242,"line_end":242,"column_start":12,"column_end":21},"name":"is_normal","qualname":"<f64>::is_normal","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the number is neither zero, infinite,\n [subnormal][subnormal], or `NaN`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68065,"byte_end":68110,"line_start":240,"line_end":240,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68115,"byte_end":68124,"line_start":241,"line_end":241,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":270},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":68736,"byte_end":68744,"line_start":261,"line_end":261,"column_start":12,"column_end":20},"name":"classify","qualname":"<f64>::classify","value":"fn (self) -> FpCategory","parent":null,"children":[],"decl_id":null,"docs":" Returns the floating point category of the number. If only one property\n is going to be tested, it is generally faster to use the specific\n predicate instead.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":68679,"byte_end":68724,"line_start":260,"line_end":260,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":276},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":69568,"byte_end":69584,"line_start":287,"line_end":287,"column_start":12,"column_end":28},"name":"is_sign_positive","qualname":"<f64>::is_sign_positive","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n positive sign bit and positive infinity.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":69497,"byte_end":69542,"line_start":285,"line_end":285,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":69547,"byte_end":69556,"line_start":286,"line_end":286,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":278},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":69816,"byte_end":69827,"line_start":295,"line_end":295,"column_start":12,"column_end":23},"name":"is_positive","qualname":"<f64>::is_positive","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":69645,"byte_end":69690,"line_start":291,"line_end":291,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":69695,"byte_end":69771,"line_start":292,"line_end":292,"column_start":5,"column_end":81}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":69776,"byte_end":69785,"line_start":293,"line_end":293,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":280},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":70261,"byte_end":70277,"line_start":311,"line_end":311,"column_start":12,"column_end":28},"name":"is_sign_negative","qualname":"<f64>::is_sign_negative","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n negative sign bit and negative infinity.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":70190,"byte_end":70235,"line_start":309,"line_end":309,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":70240,"byte_end":70249,"line_start":310,"line_end":310,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":282},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":70528,"byte_end":70539,"line_start":319,"line_end":319,"column_start":12,"column_end":23},"name":"is_negative","qualname":"<f64>::is_negative","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":70357,"byte_end":70402,"line_start":315,"line_end":315,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":70407,"byte_end":70483,"line_start":316,"line_end":316,"column_start":5,"column_end":81}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":70488,"byte_end":70497,"line_start":317,"line_end":317,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":284},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":70893,"byte_end":70898,"line_start":333,"line_end":333,"column_start":12,"column_end":17},"name":"recip","qualname":"<f64>::recip","value":"fn (self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Takes the reciprocal (inverse) of a number, `1/x`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":70822,"byte_end":70867,"line_start":331,"line_end":331,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":70872,"byte_end":70881,"line_start":332,"line_end":332,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":286},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":71276,"byte_end":71286,"line_start":350,"line_end":350,"column_start":12,"column_end":22},"name":"to_degrees","qualname":"<f64>::to_degrees","value":"fn (self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Converts radians to degrees.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":71205,"byte_end":71250,"line_start":348,"line_end":348,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":71255,"byte_end":71264,"line_start":349,"line_end":349,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":288},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":71895,"byte_end":71905,"line_start":370,"line_end":370,"column_start":12,"column_end":22},"name":"to_radians","qualname":"<f64>::to_radians","value":"fn (self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Converts degrees to radians.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":71824,"byte_end":71869,"line_start":368,"line_end":368,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":71874,"byte_end":71883,"line_start":369,"line_end":369,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":290},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":72327,"byte_end":72330,"line_start":387,"line_end":387,"column_start":12,"column_end":15},"name":"max","qualname":"<f64>::max","value":"fn (self, other: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the maximum of the two numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":72256,"byte_end":72301,"line_start":385,"line_end":385,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":72306,"byte_end":72315,"line_start":386,"line_end":386,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":292},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":73421,"byte_end":73424,"line_start":411,"line_end":411,"column_start":12,"column_end":15},"name":"min","qualname":"<f64>::min","value":"fn (self, other: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the minimum of the two numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":73350,"byte_end":73395,"line_start":409,"line_end":409,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":73400,"byte_end":73409,"line_start":410,"line_end":410,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":294},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":74890,"byte_end":74897,"line_start":442,"line_end":442,"column_start":12,"column_end":19},"name":"to_bits","qualname":"<f64>::to_bits","value":"fn (self) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Raw transmutation to `u64`.","sig":null,"attributes":[{"value":"stable(feature = \"float_bits_conv\", since = \"1.20.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":74808,"byte_end":74864,"line_start":440,"line_end":440,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":74869,"byte_end":74878,"line_start":441,"line_end":441,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":296},"span":{"file_name":"src/libcore/num/f64.rs","byte_start":76830,"byte_end":76839,"line_start":486,"line_end":486,"column_start":12,"column_end":21},"name":"from_bits","qualname":"<f64>::from_bits","value":"fn (v: u64) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Raw transmutation from `u64`.","sig":null,"attributes":[{"value":"stable(feature = \"float_bits_conv\", since = \"1.20.0\")","span":{"file_name":"src/libcore/num/f64.rs","byte_start":76748,"byte_end":76804,"line_start":484,"line_end":484,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/num/f64.rs","byte_start":76809,"byte_end":76818,"line_start":485,"line_end":485,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":298},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"num","qualname":"::num","value":"src/libcore/num/mod.rs","parent":null,"children":[{"krate":0,"index":300},{"krate":0,"index":306},{"krate":0,"index":308},{"krate":0,"index":310},{"krate":0,"index":312},{"krate":0,"index":314},{"krate":0,"index":316},{"krate":0,"index":318},{"krate":0,"index":320},{"krate":0,"index":12738},{"krate":0,"index":12774},{"krate":0,"index":12770},{"krate":0,"index":12766},{"krate":0,"index":12760},{"krate":0,"index":12756},{"krate":0,"index":12744},{"krate":0,"index":12740},{"krate":0,"index":12594},{"krate":0,"index":12602},{"krate":0,"index":12776},{"krate":0,"index":12780},{"krate":0,"index":12784},{"krate":0,"index":12788},{"krate":0,"index":12792},{"krate":0,"index":12796},{"krate":0,"index":12800},{"krate":0,"index":12836},{"krate":0,"index":12832},{"krate":0,"index":12828},{"krate":0,"index":12822},{"krate":0,"index":12818},{"krate":0,"index":12806},{"krate":0,"index":12802},{"krate":0,"index":12606},{"krate":0,"index":12614},{"krate":0,"index":12838},{"krate":0,"index":12842},{"krate":0,"index":12846},{"krate":0,"index":12850},{"krate":0,"index":12854},{"krate":0,"index":12858},{"krate":0,"index":12862},{"krate":0,"index":12898},{"krate":0,"index":12894},{"krate":0,"index":12890},{"krate":0,"index":12884},{"krate":0,"index":12880},{"krate":0,"index":12868},{"krate":0,"index":12864},{"krate":0,"index":12618},{"krate":0,"index":12626},{"krate":0,"index":12900},{"krate":0,"index":12904},{"krate":0,"index":12908},{"krate":0,"index":12912},{"krate":0,"index":12916},{"krate":0,"index":12920},{"krate":0,"index":12924},{"krate":0,"index":12960},{"krate":0,"index":12956},{"krate":0,"index":12952},{"krate":0,"index":12946},{"krate":0,"index":12942},{"krate":0,"index":12930},{"krate":0,"index":12926},{"krate":0,"index":12630},{"krate":0,"index":12638},{"krate":0,"index":12962},{"krate":0,"index":12966},{"krate":0,"index":12970},{"krate":0,"index":12974},{"krate":0,"index":12978},{"krate":0,"index":12982},{"krate":0,"index":12986},{"krate":0,"index":13022},{"krate":0,"index":13018},{"krate":0,"index":13014},{"krate":0,"index":13008},{"krate":0,"index":13004},{"krate":0,"index":12992},{"krate":0,"index":12988},{"krate":0,"index":12642},{"krate":0,"index":12650},{"krate":0,"index":13024},{"krate":0,"index":13028},{"krate":0,"index":13032},{"krate":0,"index":13036},{"krate":0,"index":13040},{"krate":0,"index":13044},{"krate":0,"index":13048},{"krate":0,"index":13084},{"krate":0,"index":13080},{"krate":0,"index":13076},{"krate":0,"index":13070},{"krate":0,"index":13066},{"krate":0,"index":13054},{"krate":0,"index":13050},{"krate":0,"index":12654},{"krate":0,"index":12662},{"krate":0,"index":13086},{"krate":0,"index":13090},{"krate":0,"index":13094},{"krate":0,"index":13098},{"krate":0,"index":13102},{"krate":0,"index":13106},{"krate":0,"index":13110},{"krate":0,"index":13146},{"krate":0,"index":13142},{"krate":0,"index":13138},{"krate":0,"index":13132},{"krate":0,"index":13128},{"krate":0,"index":13116},{"krate":0,"index":13112},{"krate":0,"index":12666},{"krate":0,"index":12674},{"krate":0,"index":13148},{"krate":0,"index":13152},{"krate":0,"index":13156},{"krate":0,"index":13160},{"krate":0,"index":13164},{"krate":0,"index":13168},{"krate":0,"index":13172},{"krate":0,"index":13208},{"krate":0,"index":13204},{"krate":0,"index":13200},{"krate":0,"index":13194},{"krate":0,"index":13190},{"krate":0,"index":13178},{"krate":0,"index":13174},{"krate":0,"index":12678},{"krate":0,"index":12686},{"krate":0,"index":13210},{"krate":0,"index":13214},{"krate":0,"index":13218},{"krate":0,"index":13222},{"krate":0,"index":13226},{"krate":0,"index":13230},{"krate":0,"index":13234},{"krate":0,"index":13270},{"krate":0,"index":13266},{"krate":0,"index":13262},{"krate":0,"index":13256},{"krate":0,"index":13252},{"krate":0,"index":13240},{"krate":0,"index":13236},{"krate":0,"index":12690},{"krate":0,"index":12698},{"krate":0,"index":13272},{"krate":0,"index":13276},{"krate":0,"index":13280},{"krate":0,"index":13284},{"krate":0,"index":13288},{"krate":0,"index":13292},{"krate":0,"index":13296},{"krate":0,"index":13332},{"krate":0,"index":13328},{"krate":0,"index":13324},{"krate":0,"index":13318},{"krate":0,"index":13314},{"krate":0,"index":13302},{"krate":0,"index":13298},{"krate":0,"index":12702},{"krate":0,"index":12710},{"krate":0,"index":13334},{"krate":0,"index":13338},{"krate":0,"index":13342},{"krate":0,"index":13346},{"krate":0,"index":13350},{"krate":0,"index":13354},{"krate":0,"index":13358},{"krate":0,"index":13394},{"krate":0,"index":13390},{"krate":0,"index":13386},{"krate":0,"index":13380},{"krate":0,"index":13376},{"krate":0,"index":13364},{"krate":0,"index":13360},{"krate":0,"index":12714},{"krate":0,"index":12722},{"krate":0,"index":13396},{"krate":0,"index":13400},{"krate":0,"index":13404},{"krate":0,"index":13408},{"krate":0,"index":13412},{"krate":0,"index":13416},{"krate":0,"index":13420},{"krate":0,"index":13456},{"krate":0,"index":13452},{"krate":0,"index":13448},{"krate":0,"index":13442},{"krate":0,"index":13438},{"krate":0,"index":13426},{"krate":0,"index":13422},{"krate":0,"index":12726},{"krate":0,"index":12734},{"krate":0,"index":13458},{"krate":0,"index":13462},{"krate":0,"index":13466},{"krate":0,"index":13470},{"krate":0,"index":13474},{"krate":0,"index":13478},{"krate":0,"index":322},{"krate":0,"index":13482},{"krate":0,"index":13488},{"krate":0,"index":13494},{"krate":0,"index":13500},{"krate":0,"index":13506},{"krate":0,"index":13512},{"krate":0,"index":13518},{"krate":0,"index":13524},{"krate":0,"index":13530},{"krate":0,"index":13536},{"krate":0,"index":13542},{"krate":0,"index":13548},{"krate":0,"index":13554},{"krate":0,"index":13590},{"krate":0,"index":13586},{"krate":0,"index":13574},{"krate":0,"index":13570},{"krate":0,"index":13566},{"krate":0,"index":13564},{"krate":0,"index":13560},{"krate":0,"index":13556},{"krate":0,"index":324},{"krate":0,"index":328},{"krate":0,"index":332},{"krate":0,"index":336},{"krate":0,"index":340},{"krate":0,"index":344},{"krate":0,"index":348},{"krate":0,"index":528},{"krate":0,"index":882},{"krate":0,"index":908},{"krate":0,"index":920},{"krate":0,"index":972},{"krate":0,"index":974},{"krate":0,"index":976},{"krate":0,"index":978},{"krate":0,"index":980},{"krate":0,"index":982},{"krate":0,"index":984},{"krate":0,"index":986},{"krate":0,"index":988},{"krate":0,"index":1022},{"krate":0,"index":1024},{"krate":0,"index":1026},{"krate":0,"index":1028},{"krate":0,"index":1030},{"krate":0,"index":19790},{"krate":0,"index":19808},{"krate":0,"index":19804},{"krate":0,"index":19800},{"krate":0,"index":19796},{"krate":0,"index":19792},{"krate":0,"index":1032},{"krate":0,"index":19810},{"krate":0,"index":19816},{"krate":0,"index":19822},{"krate":0,"index":19828},{"krate":0,"index":19834},{"krate":0,"index":19840},{"krate":0,"index":19846},{"krate":0,"index":19852},{"krate":0,"index":19858},{"krate":0,"index":19864},{"krate":0,"index":19870},{"krate":0,"index":19876},{"krate":0,"index":19882},{"krate":0,"index":19900},{"krate":0,"index":19898},{"krate":0,"index":19894},{"krate":0,"index":19888},{"krate":0,"index":19884},{"krate":0,"index":1034},{"krate":0,"index":1038},{"krate":0,"index":1042},{"krate":0,"index":1046},{"krate":0,"index":1050},{"krate":0,"index":1052},{"krate":0,"index":1054},{"krate":0,"index":1056},{"krate":0,"index":1058},{"krate":0,"index":19904},{"krate":0,"index":19910},{"krate":0,"index":19916},{"krate":0,"index":19922},{"krate":0,"index":19928},{"krate":0,"index":19934},{"krate":0,"index":19940},{"krate":0,"index":19946},{"krate":0,"index":19952},{"krate":0,"index":19958},{"krate":0,"index":19964},{"krate":0,"index":19970},{"krate":0,"index":19976},{"krate":0,"index":19982},{"krate":0,"index":19988},{"krate":0,"index":19994},{"krate":0,"index":20000},{"krate":0,"index":20006},{"krate":0,"index":20012},{"krate":0,"index":20018},{"krate":0,"index":20024},{"krate":0,"index":20030},{"krate":0,"index":20036},{"krate":0,"index":20042},{"krate":0,"index":20048},{"krate":0,"index":20054},{"krate":0,"index":20060},{"krate":0,"index":20066},{"krate":0,"index":20072},{"krate":0,"index":20078},{"krate":0,"index":20084},{"krate":0,"index":20090},{"krate":0,"index":20096},{"krate":0,"index":20102},{"krate":0,"index":20108},{"krate":0,"index":20114},{"krate":0,"index":20120},{"krate":0,"index":20126},{"krate":0,"index":20132},{"krate":0,"index":20138},{"krate":0,"index":20144},{"krate":0,"index":20150},{"krate":0,"index":20156},{"krate":0,"index":20162},{"krate":0,"index":20168},{"krate":0,"index":20174},{"krate":0,"index":20180},{"krate":0,"index":20186},{"krate":0,"index":20192},{"krate":0,"index":20198},{"krate":0,"index":20204},{"krate":0,"index":20210},{"krate":0,"index":20216},{"krate":0,"index":20222},{"krate":0,"index":20228},{"krate":0,"index":20234},{"krate":0,"index":20240},{"krate":0,"index":20246},{"krate":0,"index":20252},{"krate":0,"index":20258},{"krate":0,"index":20264},{"krate":0,"index":20270},{"krate":0,"index":1060},{"krate":0,"index":1066},{"krate":0,"index":1080},{"krate":0,"index":20486},{"krate":0,"index":20500},{"krate":0,"index":20514},{"krate":0,"index":20528},{"krate":0,"index":20542},{"krate":0,"index":20556},{"krate":0,"index":20570},{"krate":0,"index":20584},{"krate":0,"index":20598},{"krate":0,"index":20612},{"krate":0,"index":20626},{"krate":0,"index":20640},{"krate":0,"index":1082},{"krate":0,"index":20654},{"krate":0,"index":20670},{"krate":0,"index":20666},{"krate":0,"index":20660},{"krate":0,"index":20656},{"krate":0,"index":20674},{"krate":0,"index":20688},{"krate":0,"index":20684},{"krate":0,"index":20680},{"krate":0,"index":20676},{"krate":0,"index":1088},{"krate":0,"index":1094},{"krate":0,"index":1098},{"krate":0,"index":1100},{"krate":0,"index":1102},{"krate":0,"index":20692},{"krate":0,"index":20696},{"krate":0,"index":20700},{"krate":0,"index":20704},{"krate":0,"index":20708},{"krate":0,"index":20712},{"krate":0,"index":20716},{"krate":0,"index":20720},{"krate":0,"index":20724},{"krate":0,"index":20728},{"krate":0,"index":20732},{"krate":0,"index":20736},{"krate":0,"index":20740},{"krate":0,"index":20744},{"krate":0,"index":20748},{"krate":0,"index":20752},{"krate":0,"index":20756},{"krate":0,"index":20760},{"krate":0,"index":20764},{"krate":0,"index":20768},{"krate":0,"index":20772},{"krate":0,"index":20776},{"krate":0,"index":20780},{"krate":0,"index":20784},{"krate":0,"index":20788},{"krate":0,"index":20792},{"krate":0,"index":20796},{"krate":0,"index":20800},{"krate":0,"index":20804},{"krate":0,"index":20808},{"krate":0,"index":20812},{"krate":0,"index":20816},{"krate":0,"index":20820},{"krate":0,"index":20824},{"krate":0,"index":20828},{"krate":0,"index":20832},{"krate":0,"index":20836},{"krate":0,"index":20840},{"krate":0,"index":20844},{"krate":0,"index":20848},{"krate":0,"index":20852},{"krate":0,"index":20856},{"krate":0,"index":20860},{"krate":0,"index":20864},{"krate":0,"index":20868},{"krate":0,"index":20872},{"krate":0,"index":20876},{"krate":0,"index":20880},{"krate":0,"index":20884},{"krate":0,"index":20888},{"krate":0,"index":20892},{"krate":0,"index":20896},{"krate":0,"index":20900},{"krate":0,"index":20904},{"krate":0,"index":20908},{"krate":0,"index":20912},{"krate":0,"index":20916},{"krate":0,"index":20920}],"decl_id":null,"docs":" Numeric traits and functions for the built-in numeric types.\n","sig":null,"attributes":[{"value":"macro_use","span":{"file_name":"src/libcore/lib.rs","byte_start":5892,"byte_end":5904,"line_start":166,"line_end":166,"column_start":1,"column_end":13}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":77046,"byte_end":77092,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":12738},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":79855,"byte_end":79864,"line_start":101,"line_end":101,"column_start":54,"column_end":63},"name":"NonZeroU8","qualname":"::num::NonZeroU8","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":12800},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":79923,"byte_end":79933,"line_start":102,"line_end":102,"column_start":54,"column_end":64},"name":"NonZeroU16","qualname":"::num::NonZeroU16","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":12862},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":79993,"byte_end":80003,"line_start":103,"line_end":103,"column_start":54,"column_end":64},"name":"NonZeroU32","qualname":"::num::NonZeroU32","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":12924},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80063,"byte_end":80073,"line_start":104,"line_end":104,"column_start":54,"column_end":64},"name":"NonZeroU64","qualname":"::num::NonZeroU64","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":12986},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80133,"byte_end":80144,"line_start":105,"line_end":105,"column_start":54,"column_end":65},"name":"NonZeroU128","qualname":"::num::NonZeroU128","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":13048},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80205,"byte_end":80217,"line_start":106,"line_end":106,"column_start":54,"column_end":66},"name":"NonZeroUsize","qualname":"::num::NonZeroUsize","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"nonzero\", since = \"1.28.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":13110},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80286,"byte_end":80295,"line_start":107,"line_end":107,"column_start":61,"column_end":70},"name":"NonZeroI8","qualname":"::num::NonZeroI8","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":13172},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80361,"byte_end":80371,"line_start":108,"line_end":108,"column_start":61,"column_end":71},"name":"NonZeroI16","qualname":"::num::NonZeroI16","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":13234},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80438,"byte_end":80448,"line_start":109,"line_end":109,"column_start":61,"column_end":71},"name":"NonZeroI32","qualname":"::num::NonZeroI32","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":13296},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80515,"byte_end":80525,"line_start":110,"line_end":110,"column_start":61,"column_end":71},"name":"NonZeroI64","qualname":"::num::NonZeroI64","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":13358},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80592,"byte_end":80603,"line_start":111,"line_end":111,"column_start":61,"column_end":72},"name":"NonZeroI128","qualname":"::num::NonZeroI128","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":13420},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":80671,"byte_end":80683,"line_start":112,"line_end":112,"column_start":61,"column_end":73},"name":"NonZeroIsize","qualname":"::num::NonZeroIsize","value":"","parent":null,"children":[],"decl_id":null,"docs":"An integer that is known not to equal zero.","sig":null,"attributes":[{"value":"stable(feature = \"signed_nonzero\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78207,"byte_end":78220,"line_start":47,"line_end":47,"column_start":17,"column_end":30}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78314,"byte_end":78334,"line_start":49,"line_end":49,"column_start":17,"column_end":37}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78351,"byte_end":78394,"line_start":50,"line_end":50,"column_start":17,"column_end":60}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":78411,"byte_end":78432,"line_start":51,"line_end":51,"column_start":17,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":13554},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":82385,"byte_end":82393,"line_start":162,"line_end":162,"column_start":12,"column_end":20},"name":"Wrapping","qualname":"::num::Wrapping","value":"","parent":null,"children":[],"decl_id":null,"docs":" Provides intentionally-wrapped arithmetic on `T`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":82237,"byte_end":82282,"line_start":159,"line_end":159,"column_start":1,"column_end":46}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/num/mod.rs","byte_start":82353,"byte_end":82373,"line_start":161,"line_end":161,"column_start":1,"column_end":21}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":82374,"byte_end":82473,"line_start":162,"line_end":163,"column_start":1,"column_end":31}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":82374,"byte_end":82473,"line_start":162,"line_end":163,"column_start":1,"column_end":31}}]},{"kind":"Mod","id":{"krate":0,"index":348},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"flt2dec","qualname":"::num::flt2dec","value":"src/libcore/num/flt2dec/mod.rs","parent":null,"children":[{"krate":0,"index":350},{"krate":0,"index":352},{"krate":0,"index":362},{"krate":0,"index":366},{"krate":0,"index":392},{"krate":0,"index":496},{"krate":0,"index":498},{"krate":0,"index":13640},{"krate":0,"index":13660},{"krate":0,"index":13656},{"krate":0,"index":13650},{"krate":0,"index":13646},{"krate":0,"index":13642},{"krate":0,"index":500},{"krate":0,"index":13662},{"krate":0,"index":13664},{"krate":0,"index":506},{"krate":0,"index":512},{"krate":0,"index":514},{"krate":0,"index":13668},{"krate":0,"index":13686},{"krate":0,"index":13682},{"krate":0,"index":13678},{"krate":0,"index":13674},{"krate":0,"index":13670},{"krate":0,"index":516},{"krate":0,"index":518},{"krate":0,"index":520},{"krate":0,"index":522},{"krate":0,"index":524},{"krate":0,"index":526}],"decl_id":null,"docs":"Floating-point number to decimal conversion routines.","sig":null,"attributes":[{"value":"unstable(feature = \"flt2dec\",\n           reason = \"internal routines only exposed for testing\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238190,"byte_end":238315,"line_start":119,"line_end":121,"column_start":1,"column_end":26}}]},{"kind":"Mod","id":{"krate":0,"index":362},"span":{"file_name":"src/libcore/num/flt2dec/estimator.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"estimator","qualname":"::num::flt2dec::estimator","value":"src/libcore/num/flt2dec/estimator.rs","parent":null,"children":[{"krate":0,"index":364}],"decl_id":null,"docs":" The exponent estimator.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":364},"span":{"file_name":"src/libcore/num/flt2dec/estimator.rs","byte_start":261246,"byte_end":261269,"line_start":8,"line_end":8,"column_start":8,"column_end":31},"name":"estimate_scaling_factor","qualname":"::num::flt2dec::estimator::estimate_scaling_factor","value":"fn (mant: u64, exp: i16) -> i16","parent":null,"children":[],"decl_id":null,"docs":" Finds `k_0` such that `10^(k_0-1) < mant * 2^exp <= 10^(k_0+1)`.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":366},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"decoder","qualname":"::num::flt2dec::decoder","value":"src/libcore/num/flt2dec/decoder.rs","parent":null,"children":[{"krate":0,"index":368},{"krate":0,"index":374},{"krate":0,"index":376},{"krate":0,"index":13596},{"krate":0,"index":13616},{"krate":0,"index":13612},{"krate":0,"index":13608},{"krate":0,"index":13602},{"krate":0,"index":13598},{"krate":0,"index":13618},{"krate":0,"index":13638},{"krate":0,"index":13634},{"krate":0,"index":13630},{"krate":0,"index":13624},{"krate":0,"index":13620},{"krate":0,"index":378},{"krate":0,"index":382},{"krate":0,"index":386},{"krate":0,"index":390}],"decl_id":null,"docs":" Decodes a floating-point value into individual parts and error ranges.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":13596},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262086,"byte_end":262093,"line_start":15,"line_end":15,"column_start":12,"column_end":19},"name":"Decoded","qualname":"::num::flt2dec::decoder::Decoded","value":"Decoded { mant, minus, plus, exp, inclusive }","parent":null,"children":[{"krate":0,"index":6501},{"krate":0,"index":6503},{"krate":0,"index":6505},{"krate":0,"index":6507},{"krate":0,"index":6509}],"decl_id":null,"docs":" Decoded unsigned finite value, such that:","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262075,"byte_end":262455,"line_start":15,"line_end":28,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262075,"byte_end":262455,"line_start":15,"line_end":28,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":6501},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262133,"byte_end":262137,"line_start":17,"line_end":17,"column_start":9,"column_end":13},"name":"mant","qualname":"::num::flt2dec::decoder::Decoded::mant","value":"u64","parent":{"krate":0,"index":13596},"children":[],"decl_id":null,"docs":" The scaled mantissa.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6503},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262183,"byte_end":262188,"line_start":19,"line_end":19,"column_start":9,"column_end":14},"name":"minus","qualname":"::num::flt2dec::decoder::Decoded::minus","value":"u64","parent":{"krate":0,"index":13596},"children":[],"decl_id":null,"docs":" The lower error range.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6505},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262234,"byte_end":262238,"line_start":21,"line_end":21,"column_start":9,"column_end":13},"name":"plus","qualname":"::num::flt2dec::decoder::Decoded::plus","value":"u64","parent":{"krate":0,"index":13596},"children":[],"decl_id":null,"docs":" The upper error range.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6507},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262292,"byte_end":262295,"line_start":23,"line_end":23,"column_start":9,"column_end":12},"name":"exp","qualname":"::num::flt2dec::decoder::Decoded::exp","value":"i16","parent":{"krate":0,"index":13596},"children":[],"decl_id":null,"docs":" The shared exponent in base 2.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6509},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262437,"byte_end":262446,"line_start":27,"line_end":27,"column_start":9,"column_end":18},"name":"inclusive","qualname":"::num::flt2dec::decoder::Decoded::inclusive","value":"bool","parent":{"krate":0,"index":13596},"children":[],"decl_id":null,"docs":" True when the error range is inclusive.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6511},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262579,"byte_end":262582,"line_start":34,"line_end":34,"column_start":5,"column_end":8},"name":"Nan","qualname":"::num::flt2dec::decoder::FullDecoded::Nan","value":"FullDecoded::Nan","parent":{"krate":0,"index":13618},"children":[],"decl_id":null,"docs":" Not-a-number.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6515},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262637,"byte_end":262645,"line_start":36,"line_end":36,"column_start":5,"column_end":13},"name":"Infinite","qualname":"::num::flt2dec::decoder::FullDecoded::Infinite","value":"FullDecoded::Infinite","parent":{"krate":0,"index":13618},"children":[],"decl_id":null,"docs":" Infinities, either positive or negative.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6519},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262694,"byte_end":262698,"line_start":38,"line_end":38,"column_start":5,"column_end":9},"name":"Zero","qualname":"::num::flt2dec::decoder::FullDecoded::Zero","value":"FullDecoded::Zero","parent":{"krate":0,"index":13618},"children":[],"decl_id":null,"docs":" Zero, either positive or negative.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6523},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262756,"byte_end":262762,"line_start":40,"line_end":40,"column_start":5,"column_end":11},"name":"Finite","qualname":"::num::flt2dec::decoder::FullDecoded::Finite","value":"FullDecoded::Finite(Decoded)","parent":{"krate":0,"index":13618},"children":[],"decl_id":null,"docs":" Finite numbers with further decoded fields.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":13618},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262539,"byte_end":262550,"line_start":32,"line_end":32,"column_start":10,"column_end":21},"name":"FullDecoded","qualname":"::num::flt2dec::decoder::FullDecoded","value":"FullDecoded::{Nan, Infinite, Zero, Finite}","parent":null,"children":[{"krate":0,"index":6511},{"krate":0,"index":6515},{"krate":0,"index":6519},{"krate":0,"index":6523}],"decl_id":null,"docs":" Decoded unsigned value.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262530,"byte_end":262774,"line_start":32,"line_end":41,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262530,"byte_end":262774,"line_start":32,"line_end":41,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":378},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262836,"byte_end":262850,"line_start":44,"line_end":44,"column_start":11,"column_end":25},"name":"DecodableFloat","qualname":"::num::flt2dec::decoder::DecodableFloat","value":"DecodableFloat: RawFloat + Copy","parent":null,"children":[{"krate":0,"index":380}],"decl_id":null,"docs":" A floating point type which can be `decode`d.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":380},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262924,"byte_end":262942,"line_start":46,"line_end":46,"column_start":8,"column_end":26},"name":"min_pos_norm_value","qualname":"::num::flt2dec::decoder::DecodableFloat::min_pos_norm_value","value":"fn () -> Self","parent":{"krate":0,"index":378},"children":[],"decl_id":null,"docs":" The minimum positive normalized value.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":390},"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":263248,"byte_end":263254,"line_start":59,"line_end":59,"column_start":8,"column_end":14},"name":"decode","qualname":"::num::flt2dec::decoder::decode","value":"fn <T> (v: T) -> (bool, FullDecoded)","parent":null,"children":[],"decl_id":null,"docs":" Returns a sign (true when negative) and `FullDecoded` value\n from given floating point number.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":392},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238483,"byte_end":238491,"line_start":130,"line_end":130,"column_start":9,"column_end":17},"name":"strategy","qualname":"::num::flt2dec::strategy","value":"src/libcore/num/flt2dec/mod.rs","parent":null,"children":[{"krate":0,"index":394},{"krate":0,"index":436}],"decl_id":null,"docs":" Digit-generation algorithms.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":394},"span":{"file_name":"src/libcore/num/flt2dec/strategy/dragon.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"dragon","qualname":"::num::flt2dec::strategy::dragon","value":"src/libcore/num/flt2dec/strategy/dragon.rs","parent":null,"children":[{"krate":0,"index":396},{"krate":0,"index":398},{"krate":0,"index":406},{"krate":0,"index":408},{"krate":0,"index":410},{"krate":0,"index":412},{"krate":0,"index":414},{"krate":0,"index":416},{"krate":0,"index":418},{"krate":0,"index":420},{"krate":0,"index":422},{"krate":0,"index":424},{"krate":0,"index":426},{"krate":0,"index":428},{"krate":0,"index":430},{"krate":0,"index":432},{"krate":0,"index":434}],"decl_id":null,"docs":" Almost direct (but slightly optimized) Rust translation of Figure 3 of \"Printing\n Floating-Point Numbers Quickly and Accurately\"[^1].","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":426},"span":{"file_name":"src/libcore/num/flt2dec/strategy/dragon.rs","byte_start":266317,"byte_end":266326,"line_start":32,"line_end":32,"column_start":8,"column_end":17},"name":"mul_pow10","qualname":"::num::flt2dec::strategy::dragon::mul_pow10","value":"fn (x: &mut Big, n: usize) -> &mut Big","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":432},"span":{"file_name":"src/libcore/num/flt2dec/strategy/dragon.rs","byte_start":267508,"byte_end":267523,"line_start":67,"line_end":67,"column_start":8,"column_end":23},"name":"format_shortest","qualname":"::num::flt2dec::strategy::dragon::format_shortest","value":"fn (d: &Decoded, buf: &mut [u8]) -> (usize, i16)","parent":null,"children":[],"decl_id":null,"docs":" The shortest mode implementation for Dragon.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":434},"span":{"file_name":"src/libcore/num/flt2dec/strategy/dragon.rs","byte_start":274432,"byte_end":274444,"line_start":217,"line_end":217,"column_start":8,"column_end":20},"name":"format_exact","qualname":"::num::flt2dec::strategy::dragon::format_exact","value":"fn (d: &Decoded, buf: &mut [u8], limit: i16) -> (usize, i16)","parent":null,"children":[],"decl_id":null,"docs":" The exact and fixed mode implementation for Dragon.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":436},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"grisu","qualname":"::num::flt2dec::strategy::grisu","value":"src/libcore/num/flt2dec/strategy/grisu.rs","parent":null,"children":[{"krate":0,"index":438},{"krate":0,"index":440},{"krate":0,"index":448},{"krate":0,"index":450},{"krate":0,"index":452},{"krate":0,"index":454},{"krate":0,"index":456},{"krate":0,"index":458},{"krate":0,"index":460},{"krate":0,"index":480},{"krate":0,"index":484},{"krate":0,"index":488},{"krate":0,"index":492}],"decl_id":null,"docs":" Rust adaptation of the Grisu3 algorithm described in \"Printing Floating-Point Numbers Quickly\n and Accurately with Integers\"[^1]. It uses about 1KB of precomputed table, and in turn, it's\n very quick for most inputs.","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":448},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":279213,"byte_end":279218,"line_start":13,"line_end":13,"column_start":26,"column_end":31},"name":"ALPHA","qualname":"::num::flt2dec::strategy::grisu::ALPHA","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":450},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":279256,"byte_end":279261,"line_start":14,"line_end":14,"column_start":26,"column_end":31},"name":"GAMMA","qualname":"::num::flt2dec::strategy::grisu::GAMMA","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":452},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":279595,"byte_end":279607,"line_start":27,"line_end":27,"column_start":12,"column_end":24},"name":"CACHED_POW10","qualname":"::num::flt2dec::strategy::grisu::CACHED_POW10","value":"[(u64, i16, i16); 81]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":454},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":282836,"byte_end":282856,"line_start":111,"line_end":111,"column_start":26,"column_end":46},"name":"CACHED_POW10_FIRST_E","qualname":"::num::flt2dec::strategy::grisu::CACHED_POW10_FIRST_E","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":456},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":282896,"byte_end":282915,"line_start":112,"line_end":112,"column_start":26,"column_end":45},"name":"CACHED_POW10_LAST_E","qualname":"::num::flt2dec::strategy::grisu::CACHED_POW10_LAST_E","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":458},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":282952,"byte_end":282964,"line_start":115,"line_end":115,"column_start":8,"column_end":20},"name":"cached_power","qualname":"::num::flt2dec::strategy::grisu::cached_power","value":"fn (alpha: i16, gamma: i16) -> (i16, Fp)","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":460},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":283439,"byte_end":283461,"line_start":127,"line_end":127,"column_start":8,"column_end":30},"name":"max_pow10_no_more_than","qualname":"::num::flt2dec::strategy::grisu::max_pow10_no_more_than","value":"fn (x: u32) -> (u8, u32)","parent":null,"children":[],"decl_id":null,"docs":" Given `x > 0`, returns `(k, 10^k)` such that `10^k <= x < 10^(k+1)`.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":480},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":284296,"byte_end":284315,"line_start":153,"line_end":153,"column_start":8,"column_end":27},"name":"format_shortest_opt","qualname":"::num::flt2dec::strategy::grisu::format_shortest_opt","value":"fn (d: &Decoded, buf: &mut [u8]) -> Option<(usize, i16)>","parent":null,"children":[],"decl_id":null,"docs":" The shortest mode implementation for Grisu.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":484},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":298511,"byte_end":298526,"line_start":420,"line_end":420,"column_start":8,"column_end":23},"name":"format_shortest","qualname":"::num::flt2dec::strategy::grisu::format_shortest","value":"fn (d: &Decoded, buf: &mut [u8]) -> (usize, i16)","parent":null,"children":[],"decl_id":null,"docs":" The shortest mode implementation for Grisu with Dragon fallback.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":488},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":298925,"byte_end":298941,"line_start":431,"line_end":431,"column_start":8,"column_end":24},"name":"format_exact_opt","qualname":"::num::flt2dec::strategy::grisu::format_exact_opt","value":"fn (d: &Decoded, buf: &mut [u8], limit: i16) -> Option<(usize, i16)>","parent":null,"children":[],"decl_id":null,"docs":" The exact and fixed mode implementation for Grisu.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":492},"span":{"file_name":"src/libcore/num/flt2dec/strategy/grisu.rs","byte_start":310157,"byte_end":310169,"line_start":677,"line_end":677,"column_start":8,"column_end":20},"name":"format_exact","qualname":"::num::flt2dec::strategy::grisu::format_exact","value":"fn (d: &Decoded, buf: &mut [u8], limit: i16) -> (usize, i16)","parent":null,"children":[],"decl_id":null,"docs":" The exact and fixed mode implementation for Grisu with Dragon fallback.","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":496},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238848,"byte_end":238862,"line_start":140,"line_end":140,"column_start":11,"column_end":25},"name":"MAX_SIG_DIGITS","qualname":"::num::flt2dec::MAX_SIG_DIGITS","value":"usize","parent":null,"children":[],"decl_id":null,"docs":" The minimum size of buffer necessary for the shortest mode.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":498},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239046,"byte_end":239054,"line_start":145,"line_end":145,"column_start":8,"column_end":16},"name":"round_up","qualname":"::num::flt2dec::round_up","value":"fn (d: &mut [u8], n: usize) -> Option<u8>","parent":null,"children":[],"decl_id":null,"docs":" When `d[..n]` contains decimal digits, increase the last digit and propagate carry.\n Returns a next digit when it causes the length change.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6531},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239723,"byte_end":239727,"line_start":167,"line_end":167,"column_start":5,"column_end":9},"name":"Zero","qualname":"::num::flt2dec::Part::Zero","value":"Part::Zero(usize)","parent":{"krate":0,"index":13640},"children":[],"decl_id":null,"docs":" Given number of zero digits.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6537},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239781,"byte_end":239784,"line_start":169,"line_end":169,"column_start":5,"column_end":8},"name":"Num","qualname":"::num::flt2dec::Part::Num","value":"Part::Num(u16)","parent":{"krate":0,"index":13640},"children":[],"decl_id":null,"docs":" A literal number up to 5 digits.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6543},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239835,"byte_end":239839,"line_start":171,"line_end":171,"column_start":5,"column_end":9},"name":"Copy","qualname":"::num::flt2dec::Part::Copy","value":"Part::Copy(&'a [u8])","parent":{"krate":0,"index":13640},"children":[],"decl_id":null,"docs":" A verbatim copy of given bytes.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":13640},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239671,"byte_end":239675,"line_start":165,"line_end":165,"column_start":10,"column_end":14},"name":"Part","qualname":"::num::flt2dec::Part","value":"Part::{Zero, Num, Copy}","parent":null,"children":[{"krate":0,"index":6531},{"krate":0,"index":6537},{"krate":0,"index":6543}],"decl_id":null,"docs":" Formatted parts.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239662,"byte_end":239852,"line_start":165,"line_end":172,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239662,"byte_end":239852,"line_start":165,"line_end":172,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":502},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239938,"byte_end":239941,"line_start":176,"line_end":176,"column_start":12,"column_end":15},"name":"len","qualname":"<Part>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the exact byte length of given part.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":504},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":240480,"byte_end":240485,"line_start":188,"line_end":188,"column_start":12,"column_end":17},"name":"write","qualname":"<Part>::write","value":"fn (&self, out: &mut [u8]) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Writes a part into the supplied buffer.\n Returns the number of written bytes, or `None` if the buffer is not enough.\n (It may still leave partially written bytes in the buffer; do not rely on that.)\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":13662},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":241362,"byte_end":241371,"line_start":216,"line_end":216,"column_start":12,"column_end":21},"name":"Formatted","qualname":"::num::flt2dec::Formatted","value":"Formatted { sign, parts }","parent":null,"children":[{"krate":0,"index":6561},{"krate":0,"index":6563}],"decl_id":null,"docs":" Formatted result containing one or more parts.\n This can be written to the byte buffer or converted to the allocated string.\n","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":241294,"byte_end":241333,"line_start":214,"line_end":214,"column_start":1,"column_end":40}}]},{"kind":"Field","id":{"krate":0,"index":6561},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":241457,"byte_end":241461,"line_start":218,"line_end":218,"column_start":9,"column_end":13},"name":"sign","qualname":"::num::flt2dec::Formatted::sign","value":"&'static [u8]","parent":{"krate":0,"index":13662},"children":[],"decl_id":null,"docs":" A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6563},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":241565,"byte_end":241570,"line_start":220,"line_end":220,"column_start":9,"column_end":14},"name":"parts","qualname":"::num::flt2dec::Formatted::parts","value":"&'a [num::flt2dec::Part<'a>]","parent":{"krate":0,"index":13662},"children":[],"decl_id":null,"docs":" Formatted parts to be rendered after a sign and optional zero padding.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":508},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":241695,"byte_end":241698,"line_start":225,"line_end":225,"column_start":12,"column_end":15},"name":"len","qualname":"<Formatted>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the exact byte length of combined formatted result.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":510},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":242094,"byte_end":242099,"line_start":236,"line_end":236,"column_start":12,"column_end":17},"name":"write","qualname":"<Formatted>::write","value":"fn (&self, out: &mut [u8]) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Writes all formatted parts into the supplied buffer.\n Returns the number of written bytes, or `None` if the buffer is not enough.\n (It may still leave partially written bytes in the buffer; do not rely on that.)\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6567},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247120,"byte_end":247125,"line_start":362,"line_end":362,"column_start":5,"column_end":10},"name":"Minus","qualname":"::num::flt2dec::Sign::Minus","value":"Sign::Minus","parent":{"krate":0,"index":13668},"children":[],"decl_id":null,"docs":" Prints `-` only for the negative non-zero values.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6571},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247246,"byte_end":247254,"line_start":364,"line_end":364,"column_start":5,"column_end":13},"name":"MinusRaw","qualname":"::num::flt2dec::Sign::MinusRaw","value":"Sign::MinusRaw","parent":{"krate":0,"index":13668},"children":[],"decl_id":null,"docs":" Prints `-` only for any negative values (including the negative zero).\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6575},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247364,"byte_end":247373,"line_start":366,"line_end":366,"column_start":5,"column_end":14},"name":"MinusPlus","qualname":"::num::flt2dec::Sign::MinusPlus","value":"Sign::MinusPlus","parent":{"krate":0,"index":13668},"children":[],"decl_id":null,"docs":" Prints `-` for the negative non-zero values, or `+` otherwise.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6579},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247503,"byte_end":247515,"line_start":368,"line_end":368,"column_start":5,"column_end":17},"name":"MinusPlusRaw","qualname":"::num::flt2dec::Sign::MinusPlusRaw","value":"Sign::MinusPlusRaw","parent":{"krate":0,"index":13668},"children":[],"decl_id":null,"docs":" Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":13668},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247051,"byte_end":247055,"line_start":360,"line_end":360,"column_start":10,"column_end":14},"name":"Sign","qualname":"::num::flt2dec::Sign","value":"Sign::{Minus, MinusRaw, MinusPlus, MinusPlusRaw}","parent":null,"children":[{"krate":0,"index":6567},{"krate":0,"index":6571},{"krate":0,"index":6575},{"krate":0,"index":6579}],"decl_id":null,"docs":" Sign formatting options.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247042,"byte_end":247547,"line_start":360,"line_end":369,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":247042,"byte_end":247547,"line_start":360,"line_end":369,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":518},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":249415,"byte_end":249430,"line_start":403,"line_end":403,"column_start":8,"column_end":23},"name":"to_shortest_str","qualname":"::num::flt2dec::to_shortest_str","value":"fn <'a, T, F> (mut format_shortest: F, v: T, sign: Sign, frac_digits: usize, _upper: bool, buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>","parent":null,"children":[],"decl_id":null,"docs":" Formats the given floating point number into the decimal form with at least\n given number of fractional digits. The result is stored to the supplied parts\n array while utilizing given byte buffer as a scratch. `upper` is currently\n unused but left for the future decision to change the case of non-finite values,\n i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n (which can be an empty string if no sign is rendered).","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":520},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":251948,"byte_end":251967,"line_start":458,"line_end":458,"column_start":8,"column_end":27},"name":"to_shortest_exp_str","qualname":"::num::flt2dec::to_shortest_exp_str","value":"fn <'a, T, F> (mut format_shortest: F, v: T, sign: Sign, dec_bounds: (i16, i16), upper: bool, buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>","parent":null,"children":[],"decl_id":null,"docs":" Formats the given floating point number into the decimal form or\n the exponential form, depending on the resulting exponent. The result is\n stored to the supplied parts array while utilizing given byte buffer\n as a scratch. `upper` is used to determine the case of non-finite values\n (`inf` and `nan`) or the case of the exponent prefix (`e` or `E`).\n The first part to be rendered is always a `Part::Sign` (which can be\n an empty string if no sign is rendered).","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":524},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":255726,"byte_end":255742,"line_start":537,"line_end":537,"column_start":8,"column_end":24},"name":"to_exact_exp_str","qualname":"::num::flt2dec::to_exact_exp_str","value":"fn <'a, T, F> (mut format_exact: F, v: T, sign: Sign, ndigits: usize, upper: bool, buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>","parent":null,"children":[],"decl_id":null,"docs":" Formats given floating point number into the exponential form with\n exactly given number of significant digits. The result is stored to\n the supplied parts array while utilizing given byte buffer as a scratch.\n `upper` is used to determine the case of the exponent prefix (`e` or `E`).\n The first part to be rendered is always a `Part::Sign` (which can be\n an empty string if no sign is rendered).","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":526},"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":258427,"byte_end":258445,"line_start":593,"line_end":593,"column_start":8,"column_end":26},"name":"to_exact_fixed_str","qualname":"::num::flt2dec::to_exact_fixed_str","value":"fn <'a, T, F> (mut format_exact: F, v: T, sign: Sign, frac_digits: usize, _upper: bool, buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>","parent":null,"children":[],"decl_id":null,"docs":" Formats given floating point number into the decimal form with exactly\n given number of fractional digits. The result is stored to the supplied parts\n array while utilizing given byte buffer as a scratch. `upper` is currently\n unused but left for the future decision to change the case of non-finite values,\n i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n (which can be an empty string if no sign is rendered).","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":528},"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"dec2flt","qualname":"::num::dec2flt","value":"src/libcore/num/dec2flt/mod.rs","parent":null,"children":[{"krate":0,"index":530},{"krate":0,"index":532},{"krate":0,"index":534},{"krate":0,"index":544},{"krate":0,"index":546},{"krate":0,"index":548},{"krate":0,"index":608},{"krate":0,"index":620},{"krate":0,"index":644},{"krate":0,"index":832},{"krate":0,"index":856},{"krate":0,"index":13778},{"krate":0,"index":13784},{"krate":0,"index":13790},{"krate":0,"index":13806},{"krate":0,"index":13802},{"krate":0,"index":13796},{"krate":0,"index":13792},{"krate":0,"index":13810},{"krate":0,"index":13824},{"krate":0,"index":13820},{"krate":0,"index":13816},{"krate":0,"index":13812},{"krate":0,"index":858},{"krate":0,"index":862},{"krate":0,"index":866},{"krate":0,"index":868},{"krate":0,"index":870},{"krate":0,"index":872},{"krate":0,"index":874},{"krate":0,"index":876},{"krate":0,"index":878},{"krate":0,"index":880}],"decl_id":null,"docs":" Converting decimal strings into IEEE 754 binary floating point numbers.","sig":null,"attributes":[{"value":"unstable(feature = \"dec2flt\",\n           reason = \"internal routines only exposed for testing\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":315447,"byte_end":315572,"line_start":81,"line_end":83,"column_start":1,"column_end":26}}]},{"kind":"Function","id":{"krate":0,"index":590},"span":{"file_name":"src/libcore/num/dec2flt/algorithm.rs","byte_start":326806,"byte_end":326819,"line_start":28,"line_end":28,"column_start":12,"column_end":25},"name":"set_precision","qualname":"::num::dec2flt::algorithm::fpu_precision::set_precision","value":"fn <T> () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":592},"span":{"file_name":"src/libcore/num/dec2flt/algorithm.rs","byte_start":329727,"byte_end":329736,"line_start":97,"line_end":97,"column_start":8,"column_end":17},"name":"fast_path","qualname":"::num::dec2flt::algorithm::fast_path","value":"fn <T> (integral: &[u8], fractional: &[u8], e: i64) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" The fast path of Bellerophon using machine-sized integers and floats.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":594},"span":{"file_name":"src/libcore/num/dec2flt/algorithm.rs","byte_start":332322,"byte_end":332333,"line_start":145,"line_end":145,"column_start":8,"column_end":19},"name":"bellerophon","qualname":"::num::dec2flt::algorithm::bellerophon","value":"fn <T> (f: &Big, e: i16) -> T","parent":null,"children":[],"decl_id":null,"docs":" Algorithm Bellerophon is trivial code justified by non-trivial numeric analysis.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":600},"span":{"file_name":"src/libcore/num/dec2flt/algorithm.rs","byte_start":338130,"byte_end":338141,"line_start":277,"line_end":277,"column_start":8,"column_end":19},"name":"algorithm_m","qualname":"::num::dec2flt::algorithm::algorithm_m","value":"fn <T> (f: &Big, e: i16) -> T","parent":null,"children":[],"decl_id":null,"docs":" Conceptually, Algorithm M is the simplest way to convert a decimal to a float.","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":610},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":343328,"byte_end":343333,"line_start":4,"line_end":4,"column_start":11,"column_end":16},"name":"MIN_E","qualname":"::num::dec2flt::table::MIN_E","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":612},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":343357,"byte_end":343362,"line_start":5,"line_end":5,"column_start":11,"column_end":16},"name":"MAX_E","qualname":"::num::dec2flt::table::MAX_E","value":"i16","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":614},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":343386,"byte_end":343392,"line_start":7,"line_end":7,"column_start":11,"column_end":17},"name":"POWERS","qualname":"::num::dec2flt::table::POWERS","value":"([u64; 611], [i16; 611])","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":616},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":363890,"byte_end":363906,"line_start":1233,"line_end":1233,"column_start":11,"column_end":27},"name":"F32_SHORT_POWERS","qualname":"::num::dec2flt::table::F32_SHORT_POWERS","value":"[f32; 11]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":618},"span":{"file_name":"src/libcore/num/dec2flt/table.rs","byte_start":364036,"byte_end":364052,"line_start":1247,"line_end":1247,"column_start":11,"column_end":27},"name":"F64_SHORT_POWERS","qualname":"::num::dec2flt::table::F64_SHORT_POWERS","value":"[f64; 23]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":634},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":364728,"byte_end":364749,"line_start":11,"line_end":11,"column_start":8,"column_end":29},"name":"compare_with_half_ulp","qualname":"::num::dec2flt::num::compare_with_half_ulp","value":"fn (f: &Big, ones_place: usize) -> Ordering","parent":null,"children":[],"decl_id":null,"docs":" Test whether truncating all bits less significant than `ones_place` introduces\n a relative error less, equal, or greater than 0.5 ULP.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":636},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":365793,"byte_end":365811,"line_start":39,"line_end":39,"column_start":8,"column_end":26},"name":"from_str_unchecked","qualname":"::num::dec2flt::num::from_str_unchecked","value":"fn <'a, T> (bytes: T) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Converts an ASCII string containing only decimal digits to a `u64`.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":638},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":366144,"byte_end":366157,"line_start":50,"line_end":50,"column_start":8,"column_end":21},"name":"digits_to_big","qualname":"::num::dec2flt::num::digits_to_big","value":"fn (integral: &[u8], fractional: &[u8]) -> Big","parent":null,"children":[],"decl_id":null,"docs":" Converts a string of ASCII digits into a bignum.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":640},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":366474,"byte_end":366480,"line_start":61,"line_end":61,"column_start":8,"column_end":14},"name":"to_u64","qualname":"::num::dec2flt::num::to_u64","value":"fn (x: &Big) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a bignum into a 64 bit integer. Panics if the number is too large.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":642},"span":{"file_name":"src/libcore/num/dec2flt/num.rs","byte_start":366851,"byte_end":366859,"line_start":76,"line_end":76,"column_start":8,"column_end":16},"name":"get_bits","qualname":"::num::dec2flt::num::get_bits","value":"fn (x: &Big, start: usize, end: usize) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Extracts a range of bits.\n Index 0 is the least significant bit and the range is half-open as usual.\n Panics if asked to extract more bits than fit into the return type.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":644},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"rawfp","qualname":"::num::dec2flt::rawfp","value":"src/libcore/num/dec2flt/rawfp.rs","parent":null,"children":[{"krate":0,"index":646},{"krate":0,"index":654},{"krate":0,"index":660},{"krate":0,"index":670},{"krate":0,"index":676},{"krate":0,"index":678},{"krate":0,"index":690},{"krate":0,"index":692},{"krate":0,"index":698},{"krate":0,"index":13688},{"krate":0,"index":13694},{"krate":0,"index":13690},{"krate":0,"index":47074},{"krate":0,"index":700},{"krate":0,"index":704},{"krate":0,"index":756},{"krate":0,"index":758},{"krate":0,"index":788},{"krate":0,"index":818},{"krate":0,"index":820},{"krate":0,"index":822},{"krate":0,"index":824},{"krate":0,"index":826},{"krate":0,"index":828},{"krate":0,"index":830}],"decl_id":null,"docs":" Bit fiddling on positive IEEE 754 floats. Negative numbers aren't and needn't be handled.\n Normal floating point numbers have a canonical representation as (frac, exp) such that the\n value is 2<sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>)) where N is the number of bits.\n Subnormals are slightly different and weird, but the same principle applies.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":13688},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":368601,"byte_end":368609,"line_start":31,"line_end":31,"column_start":12,"column_end":20},"name":"Unpacked","qualname":"::num::dec2flt::rawfp::Unpacked","value":"Unpacked { sig, k }","parent":null,"children":[{"krate":0,"index":6583},{"krate":0,"index":6585}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":368590,"byte_end":368647,"line_start":31,"line_end":34,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":6583},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":368620,"byte_end":368623,"line_start":32,"line_end":32,"column_start":9,"column_end":12},"name":"sig","qualname":"::num::dec2flt::rawfp::Unpacked::sig","value":"u64","parent":{"krate":0,"index":13688},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6585},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":368638,"byte_end":368639,"line_start":33,"line_end":33,"column_start":9,"column_end":10},"name":"k","qualname":"::num::dec2flt::rawfp::Unpacked::k","value":"i16","parent":{"krate":0,"index":13688},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":702},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":368676,"byte_end":368679,"line_start":37,"line_end":37,"column_start":12,"column_end":15},"name":"new","qualname":"<Unpacked>::new","value":"fn (sig: u64, k: i16) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":704},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369021,"byte_end":369029,"line_start":47,"line_end":47,"column_start":11,"column_end":19},"name":"RawFloat","qualname":"::num::dec2flt::rawfp::RawFloat","value":"RawFloat: Copy + Debug + LowerExp + Mul<Output = Self> + Div<Output = Self> + Neg<Output\n= Self>","parent":null,"children":[{"krate":0,"index":706},{"krate":0,"index":708},{"krate":0,"index":710},{"krate":0,"index":712},{"krate":0,"index":714},{"krate":0,"index":716},{"krate":0,"index":718},{"krate":0,"index":720},{"krate":0,"index":722},{"krate":0,"index":724},{"krate":0,"index":726},{"krate":0,"index":728},{"krate":0,"index":730},{"krate":0,"index":732},{"krate":0,"index":734},{"krate":0,"index":736},{"krate":0,"index":738},{"krate":0,"index":740},{"krate":0,"index":742},{"krate":0,"index":744},{"krate":0,"index":746},{"krate":0,"index":748},{"krate":0,"index":750},{"krate":0,"index":752},{"krate":0,"index":754}],"decl_id":null,"docs":" A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":706},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369149,"byte_end":369157,"line_start":55,"line_end":55,"column_start":11,"column_end":19},"name":"INFINITY","qualname":"::num::dec2flt::rawfp::RawFloat::INFINITY","value":"Self","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":708},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369175,"byte_end":369178,"line_start":56,"line_end":56,"column_start":11,"column_end":14},"name":"NAN","qualname":"::num::dec2flt::rawfp::RawFloat::NAN","value":"Self","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":710},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369196,"byte_end":369200,"line_start":57,"line_end":57,"column_start":11,"column_end":15},"name":"ZERO","qualname":"::num::dec2flt::rawfp::RawFloat::ZERO","value":"Self","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":712},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369266,"byte_end":369270,"line_start":60,"line_end":60,"column_start":10,"column_end":14},"name":"Bits","qualname":"::num::dec2flt::rawfp::RawFloat::Bits","value":"type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" Type used by `to_bits` and `from_bits`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":714},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369384,"byte_end":369391,"line_start":63,"line_end":63,"column_start":8,"column_end":15},"name":"to_bits","qualname":"::num::dec2flt::rawfp::RawFloat::to_bits","value":"fn (self) -> Self::Bits","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" Performs a raw transmutation to an integer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":716},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369475,"byte_end":369484,"line_start":66,"line_end":66,"column_start":8,"column_end":17},"name":"from_bits","qualname":"::num::dec2flt::rawfp::RawFloat::from_bits","value":"fn (v: Self::Bits) -> Self","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" Performs a raw transmutation from an integer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":718},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369575,"byte_end":369583,"line_start":69,"line_end":69,"column_start":8,"column_end":16},"name":"classify","qualname":"::num::dec2flt::rawfp::RawFloat::classify","value":"fn (self) -> FpCategory","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" Returns the category that this number falls into.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":720},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369674,"byte_end":369688,"line_start":72,"line_end":72,"column_start":8,"column_end":22},"name":"integer_decode","qualname":"::num::dec2flt::rawfp::RawFloat::integer_decode","value":"fn (self) -> (u64, i16, i8)","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" Returns the mantissa, exponent and sign as integers.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":722},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369749,"byte_end":369755,"line_start":75,"line_end":75,"column_start":8,"column_end":14},"name":"unpack","qualname":"::num::dec2flt::rawfp::RawFloat::unpack","value":"fn (self) -> Unpacked","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" Decodes the float.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":724},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369969,"byte_end":369977,"line_start":79,"line_end":79,"column_start":8,"column_end":16},"name":"from_int","qualname":"::num::dec2flt::rawfp::RawFloat::from_int","value":"fn (x: u64) -> Self","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" Casts from a small integer that can be represented exactly. Panic if the integer can't be\n represented, the other code in this module makes sure to never let that happen.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":726},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":370116,"byte_end":370132,"line_start":83,"line_end":83,"column_start":8,"column_end":24},"name":"short_fast_pow10","qualname":"::num::dec2flt::rawfp::RawFloat::short_fast_pow10","value":"fn (e: usize) -> Self","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" Gets the value 10<sup>e</sup> from a pre-computed table.\n Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":728},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":370284,"byte_end":370304,"line_start":87,"line_end":87,"column_start":11,"column_end":31},"name":"CEIL_LOG5_OF_MAX_SIG","qualname":"::num::dec2flt::rawfp::RawFloat::CEIL_LOG5_OF_MAX_SIG","value":"i16","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" What the name says. It's easier to hard code than juggling intrinsics and\n hoping LLVM constant folds it.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":730},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":370516,"byte_end":370533,"line_start":91,"line_end":91,"column_start":11,"column_end":28},"name":"MAX_NORMAL_DIGITS","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_NORMAL_DIGITS","value":"usize","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" subnormals. Probably the decimal exponent of the maximum normal value, hence the name.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":732},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":370691,"byte_end":370701,"line_start":95,"line_end":95,"column_start":11,"column_end":21},"name":"INF_CUTOFF","qualname":"::num::dec2flt::rawfp::RawFloat::INF_CUTOFF","value":"i64","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" When the most significant decimal digit has a place value greater than this, the number\n is certainly rounded to infinity.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":734},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":370850,"byte_end":370861,"line_start":99,"line_end":99,"column_start":11,"column_end":22},"name":"ZERO_CUTOFF","qualname":"::num::dec2flt::rawfp::RawFloat::ZERO_CUTOFF","value":"i64","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" When the most significant decimal digit has a place value less than this, the number\n is certainly rounded to zero.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":736},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":370923,"byte_end":370931,"line_start":102,"line_end":102,"column_start":11,"column_end":19},"name":"EXP_BITS","qualname":"::num::dec2flt::rawfp::RawFloat::EXP_BITS","value":"u8","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" The number of bits in the exponent.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":738},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371023,"byte_end":371031,"line_start":105,"line_end":105,"column_start":11,"column_end":19},"name":"SIG_BITS","qualname":"::num::dec2flt::rawfp::RawFloat::SIG_BITS","value":"u8","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" The number of bits in the significand, *including* the hidden bit.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":740},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371123,"byte_end":371140,"line_start":108,"line_end":108,"column_start":11,"column_end":28},"name":"EXPLICIT_SIG_BITS","qualname":"::num::dec2flt::rawfp::RawFloat::EXPLICIT_SIG_BITS","value":"u8","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" The number of bits in the significand, *excluding* the hidden bit.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":742},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371222,"byte_end":371229,"line_start":111,"line_end":111,"column_start":11,"column_end":18},"name":"MAX_EXP","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_EXP","value":"i16","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" The maximum legal exponent in fractional representation.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":744},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371334,"byte_end":371341,"line_start":114,"line_end":114,"column_start":11,"column_end":18},"name":"MIN_EXP","qualname":"::num::dec2flt::rawfp::RawFloat::MIN_EXP","value":"i16","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" The minimum legal exponent in fractional representation, excluding subnormals.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":746},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371436,"byte_end":371447,"line_start":117,"line_end":117,"column_start":11,"column_end":22},"name":"MAX_EXP_INT","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_EXP_INT","value":"i16","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" `MAX_EXP` for integral representation, i.e., with the shift applied.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":748},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371516,"byte_end":371531,"line_start":120,"line_end":120,"column_start":11,"column_end":26},"name":"MAX_ENCODED_EXP","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_ENCODED_EXP","value":"i16","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" `MAX_EXP` encoded (i.e., with offset bias)\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":750},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371626,"byte_end":371637,"line_start":123,"line_end":123,"column_start":11,"column_end":22},"name":"MIN_EXP_INT","qualname":"::num::dec2flt::rawfp::RawFloat::MIN_EXP_INT","value":"i16","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" `MIN_EXP` for integral representation, i.e., with the shift applied.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":752},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371726,"byte_end":371733,"line_start":126,"line_end":126,"column_start":11,"column_end":18},"name":"MAX_SIG","qualname":"::num::dec2flt::rawfp::RawFloat::MAX_SIG","value":"u64","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" The maximum normalized significand in integral representation.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":754},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":371822,"byte_end":371829,"line_start":129,"line_end":129,"column_start":11,"column_end":18},"name":"MIN_SIG","qualname":"::num::dec2flt::rawfp::RawFloat::MIN_SIG","value":"u64","parent":{"krate":0,"index":704},"children":[],"decl_id":null,"docs":" The minimal normalized significand in integral representation.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":818},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":375512,"byte_end":375523,"line_start":245,"line_end":245,"column_start":8,"column_end":19},"name":"fp_to_float","qualname":"::num::dec2flt::rawfp::fp_to_float","value":"fn <T> (x: Fp) -> T","parent":null,"children":[],"decl_id":null,"docs":" Converts an `Fp` to the closest machine float type.\n Does not handle subnormal results.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":820},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376008,"byte_end":376020,"line_start":260,"line_end":260,"column_start":8,"column_end":20},"name":"round_normal","qualname":"::num::dec2flt::rawfp::round_normal","value":"fn <T> (x: Fp) -> Unpacked","parent":null,"children":[],"decl_id":null,"docs":" Round the 64-bit significand to T::SIG_BITS bits with half-to-even.\n Does not handle exponent overflow.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":822},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":376688,"byte_end":376701,"line_start":280,"line_end":280,"column_start":8,"column_end":21},"name":"encode_normal","qualname":"::num::dec2flt::rawfp::encode_normal","value":"fn <T> (x: Unpacked) -> T","parent":null,"children":[],"decl_id":null,"docs":" Inverse of `RawFloat::unpack()` for normalized numbers.\n Panics if the significand or exponent are not valid for normalized numbers.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":824},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377455,"byte_end":377471,"line_start":295,"line_end":295,"column_start":8,"column_end":24},"name":"encode_subnormal","qualname":"::num::dec2flt::rawfp::encode_subnormal","value":"fn <T> (significand: u64) -> T","parent":null,"children":[],"decl_id":null,"docs":" Construct a subnormal. A mantissa of 0 is allowed and constructs zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":826},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":377847,"byte_end":377856,"line_start":302,"line_end":302,"column_start":8,"column_end":17},"name":"big_to_fp","qualname":"::num::dec2flt::rawfp::big_to_fp","value":"fn (f: &Big) -> Fp","parent":null,"children":[],"decl_id":null,"docs":" Approximate a bignum with an Fp. Rounds within 0.5 ULP with half-to-even.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":828},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":378811,"byte_end":378821,"line_start":324,"line_end":324,"column_start":8,"column_end":18},"name":"prev_float","qualname":"::num::dec2flt::rawfp::prev_float","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Finds the largest floating point number strictly smaller than the argument.\n Does not handle subnormals, zero, or exponent underflow.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":830},"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":379723,"byte_end":379733,"line_start":345,"line_end":345,"column_start":8,"column_end":18},"name":"next_float","qualname":"::num::dec2flt::rawfp::next_float","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":832},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"parse","qualname":"::num::dec2flt::parse","value":"src/libcore/num/dec2flt/parse.rs","parent":null,"children":[{"krate":0,"index":834},{"krate":0,"index":836},{"krate":0,"index":13740},{"krate":0,"index":13742},{"krate":0,"index":13746},{"krate":0,"index":13758},{"krate":0,"index":13752},{"krate":0,"index":13748},{"krate":0,"index":846},{"krate":0,"index":13762},{"krate":0,"index":13774},{"krate":0,"index":13768},{"krate":0,"index":13764},{"krate":0,"index":850},{"krate":0,"index":852},{"krate":0,"index":854}],"decl_id":null,"docs":" Validating and decomposing a decimal string of the form:","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6587},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381486,"byte_end":381494,"line_start":18,"line_end":18,"column_start":5,"column_end":13},"name":"Positive","qualname":"::num::dec2flt::parse::Sign::Positive","value":"Sign::Positive","parent":{"krate":0,"index":13740},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6591},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381500,"byte_end":381508,"line_start":19,"line_end":19,"column_start":5,"column_end":13},"name":"Negative","qualname":"::num::dec2flt::parse::Sign::Negative","value":"Sign::Negative","parent":{"krate":0,"index":13740},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":13740},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381475,"byte_end":381479,"line_start":17,"line_end":17,"column_start":10,"column_end":14},"name":"Sign","qualname":"::num::dec2flt::parse::Sign","value":"Sign::{Positive, Negative}","parent":null,"children":[{"krate":0,"index":6587},{"krate":0,"index":6591}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":13746},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381603,"byte_end":381610,"line_start":24,"line_end":24,"column_start":12,"column_end":19},"name":"Decimal","qualname":"::num::dec2flt::parse::Decimal","value":"Decimal { integral, fractional, exp }","parent":null,"children":[{"krate":0,"index":6597},{"krate":0,"index":6599},{"krate":0,"index":6601}],"decl_id":null,"docs":" The interesting parts of a decimal string.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381592,"byte_end":381773,"line_start":24,"line_end":29,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":6597},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381625,"byte_end":381633,"line_start":25,"line_end":25,"column_start":9,"column_end":17},"name":"integral","qualname":"::num::dec2flt::parse::Decimal::integral","value":"&'a [u8]","parent":{"krate":0,"index":13746},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6599},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381653,"byte_end":381663,"line_start":26,"line_end":26,"column_start":9,"column_end":19},"name":"fractional","qualname":"::num::dec2flt::parse::Decimal::fractional","value":"&'a [u8]","parent":{"krate":0,"index":13746},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6601},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381762,"byte_end":381765,"line_start":28,"line_end":28,"column_start":9,"column_end":12},"name":"exp","qualname":"::num::dec2flt::parse::Decimal::exp","value":"i64","parent":{"krate":0,"index":13746},"children":[],"decl_id":null,"docs":" The decimal exponent, guaranteed to have fewer than 18 decimal digits.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":848},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381809,"byte_end":381812,"line_start":32,"line_end":32,"column_start":12,"column_end":15},"name":"new","qualname":"<Decimal>::new","value":"fn (integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6611},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":382000,"byte_end":382005,"line_start":39,"line_end":39,"column_start":5,"column_end":10},"name":"Valid","qualname":"::num::dec2flt::parse::ParseResult::Valid","value":"ParseResult::Valid(Decimal<'a>)","parent":{"krate":0,"index":13762},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6617},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":382024,"byte_end":382037,"line_start":40,"line_end":40,"column_start":5,"column_end":18},"name":"ShortcutToInf","qualname":"::num::dec2flt::parse::ParseResult::ShortcutToInf","value":"ParseResult::ShortcutToInf","parent":{"krate":0,"index":13762},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6621},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":382043,"byte_end":382057,"line_start":41,"line_end":41,"column_start":5,"column_end":19},"name":"ShortcutToZero","qualname":"::num::dec2flt::parse::ParseResult::ShortcutToZero","value":"ParseResult::ShortcutToZero","parent":{"krate":0,"index":13762},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6625},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":382063,"byte_end":382070,"line_start":42,"line_end":42,"column_start":5,"column_end":12},"name":"Invalid","qualname":"::num::dec2flt::parse::ParseResult::Invalid","value":"ParseResult::Invalid","parent":{"krate":0,"index":13762},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":13762},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381978,"byte_end":381989,"line_start":38,"line_end":38,"column_start":10,"column_end":21},"name":"ParseResult","qualname":"::num::dec2flt::parse::ParseResult","value":"ParseResult::{Valid, ShortcutToInf, ShortcutToZero, Invalid}","parent":null,"children":[{"krate":0,"index":6611},{"krate":0,"index":6617},{"krate":0,"index":6621},{"krate":0,"index":6625}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381969,"byte_end":382073,"line_start":38,"line_end":43,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":850},"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":382255,"byte_end":382268,"line_start":47,"line_end":47,"column_start":8,"column_end":21},"name":"parse_decimal","qualname":"::num::dec2flt::parse::parse_decimal","value":"fn (s: &str) -> ParseResult<'_>","parent":null,"children":[],"decl_id":null,"docs":" Checks if the input string is a valid floating point number and if so, locate the integral\n part, the fractional part, and the exponent in it. Does not handle signs.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":13790},"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":318446,"byte_end":318461,"line_start":173,"line_end":173,"column_start":12,"column_end":27},"name":"ParseFloatError","qualname":"::num::dec2flt::ParseFloatError","value":"ParseFloatError {  }","parent":null,"children":[{"krate":0,"index":6635}],"decl_id":null,"docs":" An error which can be returned when parsing a float.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":318389,"byte_end":318434,"line_start":172,"line_end":172,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":318435,"byte_end":318490,"line_start":173,"line_end":175,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":860},"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":318841,"byte_end":318854,"line_start":189,"line_end":189,"column_start":12,"column_end":25},"name":"__description","qualname":"<ParseFloatError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_internals\",\n           reason =\n               \"available through Error trait and this method should not be exposed publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":318607,"byte_end":318810,"line_start":184,"line_end":187,"column_start":5,"column_end":29}}]},{"kind":"Mod","id":{"krate":0,"index":882},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"bignum","qualname":"::num::bignum","value":"src/libcore/num/bignum.rs","parent":null,"children":[{"krate":0,"index":884},{"krate":0,"index":886},{"krate":0,"index":888},{"krate":0,"index":898},{"krate":0,"index":13828},{"krate":0,"index":13838},{"krate":0,"index":13848},{"krate":0,"index":900},{"krate":0,"index":902},{"krate":0,"index":904},{"krate":0,"index":13858},{"krate":0,"index":13860},{"krate":0,"index":13924},{"krate":0,"index":13928},{"krate":0,"index":13930},{"krate":0,"index":13934},{"krate":0,"index":13940},{"krate":0,"index":13944},{"krate":0,"index":906}],"decl_id":null,"docs":" Custom arbitrary-precision number (bignum) implementation.","sig":null,"attributes":[{"value":"unstable(feature = \"core_private_bignum\",\n           reason = \"internal routines only exposed for testing\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/bignum.rs","byte_start":385737,"byte_end":385874,"line_start":15,"line_end":17,"column_start":1,"column_end":26}},{"value":"macro_use","span":{"file_name":"src/libcore/num/bignum.rs","byte_start":385875,"byte_end":385888,"line_start":18,"line_end":18,"column_start":1,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":888},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":385987,"byte_end":385994,"line_start":24,"line_end":24,"column_start":11,"column_end":18},"name":"FullOps","qualname":"::num::bignum::FullOps","value":"FullOps: Sized","parent":null,"children":[{"krate":0,"index":890},{"krate":0,"index":892},{"krate":0,"index":894},{"krate":0,"index":896}],"decl_id":null,"docs":" Arithmetic operations required by bignums.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":890},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":386147,"byte_end":386155,"line_start":27,"line_end":27,"column_start":8,"column_end":16},"name":"full_add","qualname":"::num::bignum::FullOps::full_add","value":"fn (self, other: Self, carry: bool) -> (bool, Self)","parent":{"krate":0,"index":888},"children":[],"decl_id":null,"docs":" Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n where `W` is the number of bits in `Self`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":892},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":386361,"byte_end":386369,"line_start":31,"line_end":31,"column_start":8,"column_end":16},"name":"full_mul","qualname":"::num::bignum::FullOps::full_mul","value":"fn (self, other: Self, carry: Self) -> (Self, Self)","parent":{"krate":0,"index":888},"children":[],"decl_id":null,"docs":" Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n where `W` is the number of bits in `Self`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":894},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":386584,"byte_end":386596,"line_start":35,"line_end":35,"column_start":8,"column_end":20},"name":"full_mul_add","qualname":"::num::bignum::FullOps::full_mul_add","value":"fn (self, other: Self, other2: Self, carry: Self) -> (Self, Self)","parent":{"krate":0,"index":888},"children":[],"decl_id":null,"docs":" Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n where `W` is the number of bits in `Self`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":896},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":386836,"byte_end":386848,"line_start":39,"line_end":39,"column_start":8,"column_end":20},"name":"full_div_rem","qualname":"::num::bignum::FullOps::full_div_rem","value":"fn (self, other: Self, borrow: Self) -> (Self, Self)","parent":{"krate":0,"index":888},"children":[],"decl_id":null,"docs":" Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":904},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":404401,"byte_end":404408,"line_start":479,"line_end":479,"column_start":10,"column_end":17},"name":"Digit32","qualname":"::num::bignum::Digit32","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" The digit type for `Big32x40`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":13858},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":404432,"byte_end":404440,"line_start":481,"line_end":481,"column_start":16,"column_end":24},"name":"Big32x40","qualname":"::num::bignum::Big32x40","value":"Big32x40 {  }","parent":null,"children":[{"krate":0,"index":6645},{"krate":0,"index":6647}],"decl_id":null,"docs":" Stack-allocated arbitrary-precision (up to certain limit) integer.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":906},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":404525,"byte_end":404530,"line_start":485,"line_end":485,"column_start":9,"column_end":14},"name":"tests","qualname":"::num::bignum::tests","value":"src/libcore/num/bignum.rs","parent":null,"children":[{"krate":0,"index":13950},{"krate":0,"index":13952},{"krate":0,"index":14016},{"krate":0,"index":14020},{"krate":0,"index":14022},{"krate":0,"index":14026},{"krate":0,"index":14032},{"krate":0,"index":14036}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":13950},"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":404552,"byte_end":404558,"line_start":486,"line_end":486,"column_start":20,"column_end":26},"name":"Big8x3","qualname":"::num::bignum::tests::Big8x3","value":"Big8x3 {  }","parent":null,"children":[{"krate":0,"index":6675},{"krate":0,"index":6677}],"decl_id":null,"docs":" Stack-allocated arbitrary-precision (up to certain limit) integer.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":908},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"diy_float","qualname":"::num::diy_float","value":"src/libcore/num/diy_float.rs","parent":null,"children":[{"krate":0,"index":14042},{"krate":0,"index":14052},{"krate":0,"index":14048},{"krate":0,"index":14044},{"krate":0,"index":910}],"decl_id":null,"docs":" Extended precision \"soft float\", for internal use only.\n","sig":null,"attributes":[{"value":"unstable(feature = \"core_private_diy_float\",\n           reason = \"internal routines only exposed for testing\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":404786,"byte_end":404926,"line_start":6,"line_end":8,"column_start":1,"column_end":26}}]},{"kind":"Struct","id":{"krate":0,"index":14042},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":405049,"byte_end":405051,"line_start":13,"line_end":13,"column_start":12,"column_end":14},"name":"Fp","qualname":"::num::diy_float::Fp","value":"Fp { f, e }","parent":null,"children":[{"krate":0,"index":6705},{"krate":0,"index":6707}],"decl_id":null,"docs":" A custom 64-bit floating point type, representing `f * 2^e`.\n","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":405038,"byte_end":405149,"line_start":13,"line_end":18,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":6705},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":405092,"byte_end":405093,"line_start":15,"line_end":15,"column_start":9,"column_end":10},"name":"f","qualname":"::num::diy_float::Fp::f","value":"u64","parent":{"krate":0,"index":14042},"children":[],"decl_id":null,"docs":" The integer mantissa.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":6707},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":405140,"byte_end":405141,"line_start":17,"line_end":17,"column_start":9,"column_end":10},"name":"e","qualname":"::num::diy_float::Fp::e","value":"i16","parent":{"krate":0,"index":14042},"children":[],"decl_id":null,"docs":" The exponent in base 2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":912},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":405239,"byte_end":405242,"line_start":22,"line_end":22,"column_start":12,"column_end":15},"name":"mul","qualname":"<Fp>::mul","value":"fn (&self, other: &Fp) -> Fp","parent":null,"children":[],"decl_id":null,"docs":" Returns a correctly rounded product of itself and `other`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":916},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":405824,"byte_end":405833,"line_start":39,"line_end":39,"column_start":12,"column_end":21},"name":"normalize","qualname":"<Fp>::normalize","value":"fn (&self) -> Fp","parent":null,"children":[],"decl_id":null,"docs":" Normalizes itself so that the resulting mantissa is at least `2^63`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":918},"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":406617,"byte_end":406629,"line_start":72,"line_end":72,"column_start":12,"column_end":24},"name":"normalize_to","qualname":"<Fp>::normalize_to","value":"fn (&self, e: i16) -> Fp","parent":null,"children":[],"decl_id":null,"docs":" Normalizes itself to have the shared exponent.\n It can only decrease the exponent (and thus increase the mantissa).\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":944},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434422,"byte_end":434427,"line_start":905,"line_end":905,"column_start":19,"column_end":24},"name":"usize","qualname":"::num::wrapping::shift_max::platform::usize","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":946},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434465,"byte_end":434470,"line_start":906,"line_end":906,"column_start":19,"column_end":24},"name":"isize","qualname":"::num::wrapping::shift_max::platform::isize","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":948},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434511,"byte_end":434513,"line_start":909,"line_end":909,"column_start":15,"column_end":17},"name":"i8","qualname":"::num::wrapping::shift_max::i8","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":950},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434549,"byte_end":434552,"line_start":910,"line_end":910,"column_start":15,"column_end":18},"name":"i16","qualname":"::num::wrapping::shift_max::i16","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":952},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434588,"byte_end":434591,"line_start":911,"line_end":911,"column_start":15,"column_end":18},"name":"i32","qualname":"::num::wrapping::shift_max::i32","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":954},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434627,"byte_end":434630,"line_start":912,"line_end":912,"column_start":15,"column_end":18},"name":"i64","qualname":"::num::wrapping::shift_max::i64","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":956},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434666,"byte_end":434670,"line_start":913,"line_end":913,"column_start":15,"column_end":19},"name":"i128","qualname":"::num::wrapping::shift_max::i128","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":960},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434742,"byte_end":434744,"line_start":916,"line_end":916,"column_start":15,"column_end":17},"name":"u8","qualname":"::num::wrapping::shift_max::u8","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":962},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434770,"byte_end":434773,"line_start":917,"line_end":917,"column_start":15,"column_end":18},"name":"u16","qualname":"::num::wrapping::shift_max::u16","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":964},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434800,"byte_end":434803,"line_start":918,"line_end":918,"column_start":15,"column_end":18},"name":"u32","qualname":"::num::wrapping::shift_max::u32","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":966},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434830,"byte_end":434833,"line_start":919,"line_end":919,"column_start":15,"column_end":18},"name":"u64","qualname":"::num::wrapping::shift_max::u64","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":968},"span":{"file_name":"src/libcore/num/wrapping.rs","byte_start":434860,"byte_end":434864,"line_start":920,"line_end":920,"column_start":15,"column_end":19},"name":"u128","qualname":"::num::wrapping::shift_max::u128","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":990},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":191695,"byte_end":191703,"line_start":3792,"line_end":3792,"column_start":12,"column_end":20},"name":"is_ascii","qualname":"<u8>::is_ascii","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is within the ASCII range.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":191601,"byte_end":191669,"line_start":3790,"line_end":3790,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":191674,"byte_end":191683,"line_start":3791,"line_end":3791,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":992},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":192340,"byte_end":192358,"line_start":3814,"line_end":3814,"column_start":12,"column_end":30},"name":"to_ascii_uppercase","qualname":"<u8>::to_ascii_uppercase","value":"fn (&self) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Makes a copy of the value in its ASCII upper case equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":192246,"byte_end":192314,"line_start":3812,"line_end":3812,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":192319,"byte_end":192328,"line_start":3813,"line_end":3813,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":994},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":193086,"byte_end":193104,"line_start":3837,"line_end":3837,"column_start":12,"column_end":30},"name":"to_ascii_lowercase","qualname":"<u8>::to_ascii_lowercase","value":"fn (&self) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Makes a copy of the value in its ASCII lower case equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":192992,"byte_end":193060,"line_start":3835,"line_end":3835,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":193065,"byte_end":193074,"line_start":3836,"line_end":3836,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":996},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":193693,"byte_end":193713,"line_start":3856,"line_end":3856,"column_start":12,"column_end":32},"name":"eq_ignore_ascii_case","qualname":"<u8>::eq_ignore_ascii_case","value":"fn (&self, other: &u8) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that two values are an ASCII case-insensitive match.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":193599,"byte_end":193667,"line_start":3854,"line_end":3854,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":193672,"byte_end":193681,"line_start":3855,"line_end":3855,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":998},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":194458,"byte_end":194478,"line_start":3881,"line_end":3881,"column_start":12,"column_end":32},"name":"make_ascii_uppercase","qualname":"<u8>::make_ascii_uppercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this value to its ASCII upper case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":194364,"byte_end":194432,"line_start":3879,"line_end":3879,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":194437,"byte_end":194446,"line_start":3880,"line_end":3880,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1000},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":195186,"byte_end":195206,"line_start":3906,"line_end":3906,"column_start":12,"column_end":32},"name":"make_ascii_lowercase","qualname":"<u8>::make_ascii_lowercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this value to its ASCII lower case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":195092,"byte_end":195160,"line_start":3904,"line_end":3904,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":195165,"byte_end":195174,"line_start":3905,"line_end":3905,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1002},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":196237,"byte_end":196256,"line_start":3940,"line_end":3940,"column_start":12,"column_end":31},"name":"is_ascii_alphabetic","qualname":"<u8>::is_ascii_alphabetic","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII alphabetic character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":196145,"byte_end":196211,"line_start":3938,"line_end":3938,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":196216,"byte_end":196225,"line_start":3939,"line_end":3939,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1004},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":197292,"byte_end":197310,"line_start":3975,"line_end":3975,"column_start":12,"column_end":30},"name":"is_ascii_uppercase","qualname":"<u8>::is_ascii_uppercase","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII uppercase character:\n U+0041 'A' ... U+005A 'Z'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":197200,"byte_end":197266,"line_start":3973,"line_end":3973,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":197271,"byte_end":197280,"line_start":3974,"line_end":3974,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1006},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":198332,"byte_end":198350,"line_start":4010,"line_end":4010,"column_start":12,"column_end":30},"name":"is_ascii_lowercase","qualname":"<u8>::is_ascii_lowercase","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII lowercase character:\n U+0061 'a' ... U+007A 'z'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":198240,"byte_end":198306,"line_start":4008,"line_end":4008,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":198311,"byte_end":198320,"line_start":4009,"line_end":4009,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1008},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":199489,"byte_end":199510,"line_start":4048,"line_end":4048,"column_start":12,"column_end":33},"name":"is_ascii_alphanumeric","qualname":"<u8>::is_ascii_alphanumeric","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII alphanumeric character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":199397,"byte_end":199463,"line_start":4046,"line_end":4046,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":199468,"byte_end":199477,"line_start":4047,"line_end":4047,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1010},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":200519,"byte_end":200533,"line_start":4083,"line_end":4083,"column_start":12,"column_end":26},"name":"is_ascii_digit","qualname":"<u8>::is_ascii_digit","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII decimal digit:\n U+0030 '0' ... U+0039 '9'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":200427,"byte_end":200493,"line_start":4081,"line_end":4081,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":200498,"byte_end":200507,"line_start":4082,"line_end":4082,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1012},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":201633,"byte_end":201650,"line_start":4121,"line_end":4121,"column_start":12,"column_end":29},"name":"is_ascii_hexdigit","qualname":"<u8>::is_ascii_hexdigit","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII hexadecimal digit:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":201541,"byte_end":201607,"line_start":4119,"line_end":4119,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":201612,"byte_end":201621,"line_start":4120,"line_end":4120,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1014},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":202893,"byte_end":202913,"line_start":4160,"line_end":4160,"column_start":12,"column_end":32},"name":"is_ascii_punctuation","qualname":"<u8>::is_ascii_punctuation","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII punctuation character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":202801,"byte_end":202867,"line_start":4158,"line_end":4158,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":202872,"byte_end":202881,"line_start":4159,"line_end":4159,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1016},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":203953,"byte_end":203969,"line_start":4195,"line_end":4195,"column_start":12,"column_end":28},"name":"is_ascii_graphic","qualname":"<u8>::is_ascii_graphic","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII graphic character:\n U+0021 '!' ... U+007E '~'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":203861,"byte_end":203927,"line_start":4193,"line_end":4193,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":203932,"byte_end":203941,"line_start":4194,"line_end":4194,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1018},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":206019,"byte_end":206038,"line_start":4247,"line_end":4247,"column_start":12,"column_end":31},"name":"is_ascii_whitespace","qualname":"<u8>::is_ascii_whitespace","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII whitespace character:\n U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n U+000C FORM FEED, or U+000D CARRIAGE RETURN.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":205927,"byte_end":205993,"line_start":4245,"line_end":4245,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":205998,"byte_end":206007,"line_start":4246,"line_end":4246,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1020},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":207197,"byte_end":207213,"line_start":4284,"line_end":4284,"column_start":12,"column_end":28},"name":"is_ascii_control","qualname":"<u8>::is_ascii_control","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII control character:\n U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n Note that most ASCII whitespace characters are control\n characters, but SPACE is not.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":207105,"byte_end":207171,"line_start":4282,"line_end":4282,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/num/mod.rs","byte_start":207176,"byte_end":207185,"line_start":4283,"line_end":4283,"column_start":5,"column_end":14}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7057},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":210453,"byte_end":210456,"line_start":4376,"line_end":4376,"column_start":5,"column_end":8},"name":"Nan","qualname":"::num::FpCategory::Nan","value":"FpCategory::Nan","parent":{"krate":0,"index":19790},"children":[],"decl_id":null,"docs":" \"Not a Number\", often obtained by dividing by zero.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210403,"byte_end":210448,"line_start":4375,"line_end":4375,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7061},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":210552,"byte_end":210560,"line_start":4380,"line_end":4380,"column_start":5,"column_end":13},"name":"Infinite","qualname":"::num::FpCategory::Infinite","value":"FpCategory::Infinite","parent":{"krate":0,"index":19790},"children":[],"decl_id":null,"docs":" Positive or negative infinity.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210502,"byte_end":210547,"line_start":4379,"line_end":4379,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7065},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":210652,"byte_end":210656,"line_start":4384,"line_end":4384,"column_start":5,"column_end":9},"name":"Zero","qualname":"::num::FpCategory::Zero","value":"FpCategory::Zero","parent":{"krate":0,"index":19790},"children":[],"decl_id":null,"docs":" Positive or negative zero.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210602,"byte_end":210647,"line_start":4383,"line_end":4383,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7069},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":210795,"byte_end":210804,"line_start":4388,"line_end":4388,"column_start":5,"column_end":14},"name":"Subnormal","qualname":"::num::FpCategory::Subnormal","value":"FpCategory::Subnormal","parent":{"krate":0,"index":19790},"children":[],"decl_id":null,"docs":" De-normalized floating point representation (less precise than `Normal`).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210745,"byte_end":210790,"line_start":4387,"line_end":4387,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7073},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":210902,"byte_end":210908,"line_start":4392,"line_end":4392,"column_start":5,"column_end":11},"name":"Normal","qualname":"::num::FpCategory::Normal","value":"FpCategory::Normal","parent":{"krate":0,"index":19790},"children":[],"decl_id":null,"docs":" A regular floating point number.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210852,"byte_end":210897,"line_start":4391,"line_end":4391,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":19790},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":210326,"byte_end":210336,"line_start":4373,"line_end":4373,"column_start":10,"column_end":20},"name":"FpCategory","qualname":"::num::FpCategory","value":"FpCategory::{Nan, Infinite, Zero, Subnormal, Normal}","parent":null,"children":[{"krate":0,"index":7057},{"krate":0,"index":7061},{"krate":0,"index":7065},{"krate":0,"index":7069},{"krate":0,"index":7073}],"decl_id":null,"docs":" A classification of floating point numbers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210271,"byte_end":210316,"line_start":4372,"line_end":4372,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210317,"byte_end":210911,"line_start":4373,"line_end":4393,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":210317,"byte_end":210911,"line_start":4373,"line_end":4393,"column_start":1,"column_end":2}}]},{"kind":"Struct","id":{"krate":0,"index":19882},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":211502,"byte_end":211517,"line_start":4411,"line_end":4411,"column_start":12,"column_end":27},"name":"TryFromIntError","qualname":"::num::TryFromIntError","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type returned when a checked integral type conversion fails.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":211396,"byte_end":211445,"line_start":4409,"line_end":4409,"column_start":1,"column_end":50}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":211491,"byte_end":211522,"line_start":4411,"line_end":4411,"column_start":1,"column_end":32}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/num/mod.rs","byte_start":211491,"byte_end":211522,"line_start":4411,"line_end":4411,"column_start":1,"column_end":32}}]},{"kind":"Method","id":{"krate":0,"index":1036},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":211785,"byte_end":211798,"line_start":4419,"line_end":4419,"column_start":12,"column_end":25},"name":"__description","qualname":"<TryFromIntError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_internals\",\n           reason =\n               \"available through Error trait and this method should not be exposed publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":211551,"byte_end":211754,"line_start":4414,"line_end":4417,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":1068},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219477,"byte_end":219486,"line_start":4650,"line_end":4650,"column_start":8,"column_end":17},"name":"min_value","qualname":"::num::FromStrRadixHelper::min_value","value":"fn () -> Self","parent":{"krate":0,"index":1066},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1070},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219505,"byte_end":219514,"line_start":4651,"line_end":4651,"column_start":8,"column_end":17},"name":"max_value","qualname":"::num::FromStrRadixHelper::max_value","value":"fn () -> Self","parent":{"krate":0,"index":1066},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1072},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219533,"byte_end":219541,"line_start":4652,"line_end":4652,"column_start":8,"column_end":16},"name":"from_u32","qualname":"::num::FromStrRadixHelper::from_u32","value":"fn (u: u32) -> Self","parent":{"krate":0,"index":1066},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1074},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219566,"byte_end":219577,"line_start":4653,"line_end":4653,"column_start":8,"column_end":19},"name":"checked_mul","qualname":"::num::FromStrRadixHelper::checked_mul","value":"fn (&self, other: u32) -> Option<Self>","parent":{"krate":0,"index":1066},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1076},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219621,"byte_end":219632,"line_start":4654,"line_end":4654,"column_start":8,"column_end":19},"name":"checked_sub","qualname":"::num::FromStrRadixHelper::checked_sub","value":"fn (&self, other: u32) -> Option<Self>","parent":{"krate":0,"index":1066},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1078},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219676,"byte_end":219687,"line_start":4655,"line_end":4655,"column_start":8,"column_end":19},"name":"checked_add","qualname":"::num::FromStrRadixHelper::checked_add","value":"fn (&self, other: u32) -> Option<Self>","parent":{"krate":0,"index":1066},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":20654},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":223454,"byte_end":223467,"line_start":4764,"line_end":4764,"column_start":12,"column_end":25},"name":"ParseIntError","qualname":"::num::ParseIntError","value":"ParseIntError {  }","parent":null,"children":[{"krate":0,"index":7081}],"decl_id":null,"docs":" An error which can be returned when parsing an integer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":223397,"byte_end":223442,"line_start":4763,"line_end":4763,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":223443,"byte_end":223495,"line_start":4764,"line_end":4766,"column_start":1,"column_end":2}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7083},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":224005,"byte_end":224010,"line_start":4779,"line_end":4779,"column_start":5,"column_end":10},"name":"Empty","qualname":"::num::IntErrorKind::Empty","value":"IntErrorKind::Empty","parent":{"krate":0,"index":20674},"children":[],"decl_id":null,"docs":" Value being parsed is empty.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7087},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":224174,"byte_end":224186,"line_start":4784,"line_end":4784,"column_start":5,"column_end":17},"name":"InvalidDigit","qualname":"::num::IntErrorKind::InvalidDigit","value":"IntErrorKind::InvalidDigit","parent":{"krate":0,"index":20674},"children":[],"decl_id":null,"docs":" Contains an invalid digit.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7091},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":224254,"byte_end":224262,"line_start":4786,"line_end":4786,"column_start":5,"column_end":13},"name":"Overflow","qualname":"::num::IntErrorKind::Overflow","value":"IntErrorKind::Overflow","parent":{"krate":0,"index":20674},"children":[],"decl_id":null,"docs":" Integer is too large to store in target integer type.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7095},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":224330,"byte_end":224339,"line_start":4788,"line_end":4788,"column_start":5,"column_end":14},"name":"Underflow","qualname":"::num::IntErrorKind::Underflow","value":"IntErrorKind::Underflow","parent":{"krate":0,"index":20674},"children":[],"decl_id":null,"docs":" Integer is too small to store in target integer type.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7099},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":224509,"byte_end":224513,"line_start":4793,"line_end":4793,"column_start":5,"column_end":9},"name":"Zero","qualname":"::num::IntErrorKind::Zero","value":"IntErrorKind::Zero","parent":{"krate":0,"index":20674},"children":[],"decl_id":null,"docs":" Value was Zero","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":20674},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":223850,"byte_end":223862,"line_start":4775,"line_end":4775,"column_start":10,"column_end":22},"name":"IntErrorKind","qualname":"::num::IntErrorKind","value":"IntErrorKind::{Empty, InvalidDigit, Overflow, Underflow, Zero}","parent":null,"children":[{"krate":0,"index":7083},{"krate":0,"index":7087},{"krate":0,"index":7091},{"krate":0,"index":7095},{"krate":0,"index":7099}],"decl_id":null,"docs":" Enum to store the various types of errors that can cause parsing an integer to fail.\n","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_matching\",\n           reason =\n               \"it can be useful to match errors when making error messages for integer parsing\",\n           issue = \"22639\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":223586,"byte_end":223783,"line_start":4769,"line_end":4772,"column_start":1,"column_end":29}},{"value":"non_exhaustive","span":{"file_name":"src/libcore/num/mod.rs","byte_start":223823,"byte_end":223840,"line_start":4774,"line_end":4774,"column_start":1,"column_end":18}},{"value":"structural_match","span":{"file_name":"src/libcore/num/mod.rs","byte_start":223841,"byte_end":224516,"line_start":4775,"line_end":4794,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":1090},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":224830,"byte_end":224834,"line_start":4802,"line_end":4802,"column_start":12,"column_end":16},"name":"kind","qualname":"<ParseIntError>::kind","value":"fn (&self) -> &IntErrorKind","parent":null,"children":[],"decl_id":null,"docs":" Outputs the detailed cause of parsing an integer failing.\n","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_matching\",\n           reason =\n               \"it can be useful to match errors when making error messages for integer parsing\",\n           issue = \"22639\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":224609,"byte_end":224818,"line_start":4798,"line_end":4801,"column_start":5,"column_end":33}}]},{"kind":"Method","id":{"krate":0,"index":1092},"span":{"file_name":"src/libcore/num/mod.rs","byte_start":225124,"byte_end":225137,"line_start":4810,"line_end":4810,"column_start":12,"column_end":25},"name":"__description","qualname":"<ParseIntError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"int_error_internals\",\n           reason =\n               \"available through Error trait and this method should not be exposed publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/num/mod.rs","byte_start":224890,"byte_end":225093,"line_start":4805,"line_end":4808,"column_start":5,"column_end":29}}]},{"kind":"Mod","id":{"krate":0,"index":1104},"span":{"file_name":"src/libcore/prelude/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"prelude","qualname":"::prelude","value":"src/libcore/prelude/mod.rs","parent":null,"children":[{"krate":0,"index":1106}],"decl_id":null,"docs":" The libcore prelude\n","sig":null,"attributes":[{"value":"stable(feature = \"core_prelude\", since = \"1.4.0\")","span":{"file_name":"src/libcore/prelude/mod.rs","byte_start":434941,"byte_end":434994,"line_start":3,"line_end":3,"column_start":1,"column_end":54}}]},{"kind":"Mod","id":{"krate":0,"index":1106},"span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"v1","qualname":"::prelude::v1","value":"src/libcore/prelude/v1.rs","parent":null,"children":[{"krate":0,"index":1108},{"krate":0,"index":1120},{"krate":0,"index":1130},{"krate":0,"index":1132},{"krate":0,"index":1134},{"krate":0,"index":1144},{"krate":0,"index":1154},{"krate":0,"index":1156},{"krate":0,"index":1164},{"krate":0,"index":1170},{"krate":0,"index":1178}],"decl_id":null,"docs":" The core prelude","sig":null,"attributes":[{"value":"stable(feature = \"core_prelude\", since = \"1.4.0\")","span":{"file_name":"src/libcore/prelude/v1.rs","byte_start":435244,"byte_end":435297,"line_start":7,"line_end":7,"column_start":1,"column_end":54}}]},{"kind":"Mod","id":{"krate":0,"index":1186},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"intrinsics","qualname":"::intrinsics","value":"src/libcore/intrinsics.rs","parent":null,"children":[{"krate":0,"index":1188},{"krate":0,"index":1190},{"krate":0,"index":1192},{"krate":0,"index":1194},{"krate":0,"index":1198},{"krate":0,"index":1200},{"krate":0,"index":1202}],"decl_id":null,"docs":" Compiler intrinsics.","sig":null,"attributes":[{"value":"unstable(feature = \"core_intrinsics\",\n           reason =\n               \"intrinsics are unlikely to ever be stabilized, instead they should be used through stabilized interfaces in the rest of the standard library\",\n           issue = \"0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":437889,"byte_end":438168,"line_start":32,"line_end":36,"column_start":1,"column_end":26}},{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":438169,"byte_end":438192,"line_start":37,"line_end":37,"column_start":1,"column_end":24}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":145},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":439115,"byte_end":439127,"line_start":56,"line_end":56,"column_start":12,"column_end":24},"name":"atomic_cxchg","qualname":"::intrinsics::atomic_cxchg","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":149},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":439715,"byte_end":439731,"line_start":65,"line_end":65,"column_start":12,"column_end":28},"name":"atomic_cxchg_acq","qualname":"::intrinsics::atomic_cxchg_acq","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":153},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":440401,"byte_end":440417,"line_start":76,"line_end":76,"column_start":12,"column_end":28},"name":"atomic_cxchg_rel","qualname":"::intrinsics::atomic_cxchg_rel","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":157},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":441086,"byte_end":441105,"line_start":87,"line_end":87,"column_start":12,"column_end":31},"name":"atomic_cxchg_acqrel","qualname":"::intrinsics::atomic_cxchg_acqrel","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":161},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":441693,"byte_end":441713,"line_start":96,"line_end":96,"column_start":12,"column_end":32},"name":"atomic_cxchg_relaxed","qualname":"::intrinsics::atomic_cxchg_relaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":165},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":442382,"byte_end":442406,"line_start":107,"line_end":107,"column_start":12,"column_end":36},"name":"atomic_cxchg_failrelaxed","qualname":"::intrinsics::atomic_cxchg_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":169},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":443075,"byte_end":443095,"line_start":118,"line_end":118,"column_start":12,"column_end":32},"name":"atomic_cxchg_failacq","qualname":"::intrinsics::atomic_cxchg_failacq","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":173},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":443765,"byte_end":443793,"line_start":129,"line_end":129,"column_start":12,"column_end":40},"name":"atomic_cxchg_acq_failrelaxed","qualname":"::intrinsics::atomic_cxchg_acq_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":177},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":444462,"byte_end":444493,"line_start":140,"line_end":140,"column_start":12,"column_end":43},"name":"atomic_cxchg_acqrel_failrelaxed","qualname":"::intrinsics::atomic_cxchg_acqrel_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange`][compare_exchange].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":181},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":445070,"byte_end":445086,"line_start":150,"line_end":150,"column_start":12,"column_end":28},"name":"atomic_cxchgweak","qualname":"::intrinsics::atomic_cxchgweak","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":185},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":445663,"byte_end":445683,"line_start":159,"line_end":159,"column_start":12,"column_end":32},"name":"atomic_cxchgweak_acq","qualname":"::intrinsics::atomic_cxchgweak_acq","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":189},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":446342,"byte_end":446362,"line_start":170,"line_end":170,"column_start":12,"column_end":32},"name":"atomic_cxchgweak_rel","qualname":"::intrinsics::atomic_cxchgweak_rel","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":193},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":447020,"byte_end":447043,"line_start":181,"line_end":181,"column_start":12,"column_end":35},"name":"atomic_cxchgweak_acqrel","qualname":"::intrinsics::atomic_cxchgweak_acqrel","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":197},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":447620,"byte_end":447644,"line_start":190,"line_end":190,"column_start":12,"column_end":36},"name":"atomic_cxchgweak_relaxed","qualname":"::intrinsics::atomic_cxchgweak_relaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as both the `success` and `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":201},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":448302,"byte_end":448330,"line_start":201,"line_end":201,"column_start":12,"column_end":40},"name":"atomic_cxchgweak_failrelaxed","qualname":"::intrinsics::atomic_cxchgweak_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":205},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":448988,"byte_end":449012,"line_start":212,"line_end":212,"column_start":12,"column_end":36},"name":"atomic_cxchgweak_failacq","qualname":"::intrinsics::atomic_cxchgweak_failacq","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":209},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":449671,"byte_end":449703,"line_start":223,"line_end":223,"column_start":12,"column_end":44},"name":"atomic_cxchgweak_acq_failrelaxed","qualname":"::intrinsics::atomic_cxchgweak_acq_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":213},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":450361,"byte_end":450396,"line_start":234,"line_end":234,"column_start":12,"column_end":47},"name":"atomic_cxchgweak_acqrel_failrelaxed","qualname":"::intrinsics::atomic_cxchgweak_acqrel_failrelaxed","value":"fn <T> (dst: *mut T, old: T, src: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Stores a value if the current value is the same as the `old` value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `success` and\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `failure` parameters. For example,\n [`AtomicBool::compare_exchange_weak`][cew].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":217},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":450835,"byte_end":450846,"line_start":242,"line_end":242,"column_start":12,"column_end":23},"name":"atomic_load","qualname":"::intrinsics::atomic_load","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Loads the current value of the pointer.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `load` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":221},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":451263,"byte_end":451278,"line_start":249,"line_end":249,"column_start":12,"column_end":27},"name":"atomic_load_acq","qualname":"::intrinsics::atomic_load_acq","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Loads the current value of the pointer.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `load` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":225},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":451695,"byte_end":451714,"line_start":256,"line_end":256,"column_start":12,"column_end":31},"name":"atomic_load_relaxed","qualname":"::intrinsics::atomic_load_relaxed","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Loads the current value of the pointer.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `load` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":229},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":451750,"byte_end":451771,"line_start":257,"line_end":257,"column_start":12,"column_end":33},"name":"atomic_load_unordered","qualname":"::intrinsics::atomic_load_unordered","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":233},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":452202,"byte_end":452214,"line_start":265,"line_end":265,"column_start":12,"column_end":24},"name":"atomic_store","qualname":"::intrinsics::atomic_store","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `store` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":237},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":452646,"byte_end":452662,"line_start":272,"line_end":272,"column_start":12,"column_end":28},"name":"atomic_store_rel","qualname":"::intrinsics::atomic_store_rel","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `store` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":241},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":453094,"byte_end":453114,"line_start":279,"line_end":279,"column_start":12,"column_end":32},"name":"atomic_store_relaxed","qualname":"::intrinsics::atomic_store_relaxed","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `store` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":245},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":453151,"byte_end":453173,"line_start":280,"line_end":280,"column_start":12,"column_end":34},"name":"atomic_store_unordered","qualname":"::intrinsics::atomic_store_unordered","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":249},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":453627,"byte_end":453638,"line_start":288,"line_end":288,"column_start":12,"column_end":23},"name":"atomic_xchg","qualname":"::intrinsics::atomic_xchg","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":253},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":454097,"byte_end":454112,"line_start":295,"line_end":295,"column_start":12,"column_end":27},"name":"atomic_xchg_acq","qualname":"::intrinsics::atomic_xchg_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":257},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":454571,"byte_end":454586,"line_start":302,"line_end":302,"column_start":12,"column_end":27},"name":"atomic_xchg_rel","qualname":"::intrinsics::atomic_xchg_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":261},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":455044,"byte_end":455062,"line_start":309,"line_end":309,"column_start":12,"column_end":30},"name":"atomic_xchg_acqrel","qualname":"::intrinsics::atomic_xchg_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":265},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":455521,"byte_end":455540,"line_start":316,"line_end":316,"column_start":12,"column_end":31},"name":"atomic_xchg_relaxed","qualname":"::intrinsics::atomic_xchg_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Stores the value at the specified memory location, returning the old value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `swap` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":269},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":455997,"byte_end":456008,"line_start":324,"line_end":324,"column_start":12,"column_end":23},"name":"atomic_xadd","qualname":"::intrinsics::atomic_xadd","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":273},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":456465,"byte_end":456480,"line_start":331,"line_end":331,"column_start":12,"column_end":27},"name":"atomic_xadd_acq","qualname":"::intrinsics::atomic_xadd_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":277},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":456937,"byte_end":456952,"line_start":338,"line_end":338,"column_start":12,"column_end":27},"name":"atomic_xadd_rel","qualname":"::intrinsics::atomic_xadd_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":281},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":457408,"byte_end":457426,"line_start":345,"line_end":345,"column_start":12,"column_end":30},"name":"atomic_xadd_acqrel","qualname":"::intrinsics::atomic_xadd_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":285},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":457883,"byte_end":457902,"line_start":352,"line_end":352,"column_start":12,"column_end":31},"name":"atomic_xadd_relaxed","qualname":"::intrinsics::atomic_xadd_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Adds to the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_add` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":289},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":458365,"byte_end":458376,"line_start":360,"line_end":360,"column_start":12,"column_end":23},"name":"atomic_xsub","qualname":"::intrinsics::atomic_xsub","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":293},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":458839,"byte_end":458854,"line_start":367,"line_end":367,"column_start":12,"column_end":27},"name":"atomic_xsub_acq","qualname":"::intrinsics::atomic_xsub_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":297},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":459317,"byte_end":459332,"line_start":374,"line_end":374,"column_start":12,"column_end":27},"name":"atomic_xsub_rel","qualname":"::intrinsics::atomic_xsub_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":301},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":459794,"byte_end":459812,"line_start":381,"line_end":381,"column_start":12,"column_end":30},"name":"atomic_xsub_acqrel","qualname":"::intrinsics::atomic_xsub_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":305},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":460275,"byte_end":460294,"line_start":388,"line_end":388,"column_start":12,"column_end":31},"name":"atomic_xsub_relaxed","qualname":"::intrinsics::atomic_xsub_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Subtract from the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_sub` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":309},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":460758,"byte_end":460768,"line_start":396,"line_end":396,"column_start":12,"column_end":22},"name":"atomic_and","qualname":"::intrinsics::atomic_and","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":313},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":461232,"byte_end":461246,"line_start":403,"line_end":403,"column_start":12,"column_end":26},"name":"atomic_and_acq","qualname":"::intrinsics::atomic_and_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":317},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":461710,"byte_end":461724,"line_start":410,"line_end":410,"column_start":12,"column_end":26},"name":"atomic_and_rel","qualname":"::intrinsics::atomic_and_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":321},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":462187,"byte_end":462204,"line_start":417,"line_end":417,"column_start":12,"column_end":29},"name":"atomic_and_acqrel","qualname":"::intrinsics::atomic_and_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":325},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":462668,"byte_end":462686,"line_start":424,"line_end":424,"column_start":12,"column_end":30},"name":"atomic_and_relaxed","qualname":"::intrinsics::atomic_and_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise and with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_and` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":329},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":463165,"byte_end":463176,"line_start":432,"line_end":432,"column_start":12,"column_end":23},"name":"atomic_nand","qualname":"::intrinsics::atomic_nand","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":333},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":463655,"byte_end":463670,"line_start":439,"line_end":439,"column_start":12,"column_end":27},"name":"atomic_nand_acq","qualname":"::intrinsics::atomic_nand_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":337},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":464149,"byte_end":464164,"line_start":446,"line_end":446,"column_start":12,"column_end":27},"name":"atomic_nand_rel","qualname":"::intrinsics::atomic_nand_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":341},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":464642,"byte_end":464660,"line_start":453,"line_end":453,"column_start":12,"column_end":30},"name":"atomic_nand_acqrel","qualname":"::intrinsics::atomic_nand_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":345},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":465139,"byte_end":465158,"line_start":460,"line_end":460,"column_start":12,"column_end":31},"name":"atomic_nand_relaxed","qualname":"::intrinsics::atomic_nand_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise nand with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":349},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":465618,"byte_end":465627,"line_start":468,"line_end":468,"column_start":12,"column_end":21},"name":"atomic_or","qualname":"::intrinsics::atomic_or","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":353},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":466087,"byte_end":466100,"line_start":475,"line_end":475,"column_start":12,"column_end":25},"name":"atomic_or_acq","qualname":"::intrinsics::atomic_or_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":357},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":466560,"byte_end":466573,"line_start":482,"line_end":482,"column_start":12,"column_end":25},"name":"atomic_or_rel","qualname":"::intrinsics::atomic_or_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":361},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":467032,"byte_end":467048,"line_start":489,"line_end":489,"column_start":12,"column_end":28},"name":"atomic_or_acqrel","qualname":"::intrinsics::atomic_or_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":365},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":467508,"byte_end":467525,"line_start":496,"line_end":496,"column_start":12,"column_end":29},"name":"atomic_or_relaxed","qualname":"::intrinsics::atomic_or_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise or with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_or` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":369},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":467989,"byte_end":467999,"line_start":504,"line_end":504,"column_start":12,"column_end":22},"name":"atomic_xor","qualname":"::intrinsics::atomic_xor","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":373},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":468463,"byte_end":468477,"line_start":511,"line_end":511,"column_start":12,"column_end":26},"name":"atomic_xor_acq","qualname":"::intrinsics::atomic_xor_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":377},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":468941,"byte_end":468955,"line_start":518,"line_end":518,"column_start":12,"column_end":26},"name":"atomic_xor_rel","qualname":"::intrinsics::atomic_xor_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":381},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":469418,"byte_end":469435,"line_start":525,"line_end":525,"column_start":12,"column_end":29},"name":"atomic_xor_acqrel","qualname":"::intrinsics::atomic_xor_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":385},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":469899,"byte_end":469917,"line_start":532,"line_end":532,"column_start":12,"column_end":30},"name":"atomic_xor_relaxed","qualname":"::intrinsics::atomic_xor_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Bitwise xor with the current value, returning the previous value.\n The stabilized version of this intrinsic is available on the\n `std::sync::atomic` types via the `fetch_xor` method by passing\n [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n as the `order`. For example,\n [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":389},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":469960,"byte_end":469970,"line_start":534,"line_end":534,"column_start":12,"column_end":22},"name":"atomic_max","qualname":"::intrinsics::atomic_max","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":393},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470012,"byte_end":470026,"line_start":535,"line_end":535,"column_start":12,"column_end":26},"name":"atomic_max_acq","qualname":"::intrinsics::atomic_max_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":397},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470068,"byte_end":470082,"line_start":536,"line_end":536,"column_start":12,"column_end":26},"name":"atomic_max_rel","qualname":"::intrinsics::atomic_max_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":401},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470124,"byte_end":470141,"line_start":537,"line_end":537,"column_start":12,"column_end":29},"name":"atomic_max_acqrel","qualname":"::intrinsics::atomic_max_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":405},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470183,"byte_end":470201,"line_start":538,"line_end":538,"column_start":12,"column_end":30},"name":"atomic_max_relaxed","qualname":"::intrinsics::atomic_max_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":409},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470244,"byte_end":470254,"line_start":540,"line_end":540,"column_start":12,"column_end":22},"name":"atomic_min","qualname":"::intrinsics::atomic_min","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":413},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470296,"byte_end":470310,"line_start":541,"line_end":541,"column_start":12,"column_end":26},"name":"atomic_min_acq","qualname":"::intrinsics::atomic_min_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":417},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470352,"byte_end":470366,"line_start":542,"line_end":542,"column_start":12,"column_end":26},"name":"atomic_min_rel","qualname":"::intrinsics::atomic_min_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":421},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470408,"byte_end":470425,"line_start":543,"line_end":543,"column_start":12,"column_end":29},"name":"atomic_min_acqrel","qualname":"::intrinsics::atomic_min_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":425},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470467,"byte_end":470485,"line_start":544,"line_end":544,"column_start":12,"column_end":30},"name":"atomic_min_relaxed","qualname":"::intrinsics::atomic_min_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":429},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470528,"byte_end":470539,"line_start":546,"line_end":546,"column_start":12,"column_end":23},"name":"atomic_umin","qualname":"::intrinsics::atomic_umin","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":433},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470581,"byte_end":470596,"line_start":547,"line_end":547,"column_start":12,"column_end":27},"name":"atomic_umin_acq","qualname":"::intrinsics::atomic_umin_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":437},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470638,"byte_end":470653,"line_start":548,"line_end":548,"column_start":12,"column_end":27},"name":"atomic_umin_rel","qualname":"::intrinsics::atomic_umin_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":441},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470695,"byte_end":470713,"line_start":549,"line_end":549,"column_start":12,"column_end":30},"name":"atomic_umin_acqrel","qualname":"::intrinsics::atomic_umin_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":445},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470755,"byte_end":470774,"line_start":550,"line_end":550,"column_start":12,"column_end":31},"name":"atomic_umin_relaxed","qualname":"::intrinsics::atomic_umin_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":449},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470817,"byte_end":470828,"line_start":552,"line_end":552,"column_start":12,"column_end":23},"name":"atomic_umax","qualname":"::intrinsics::atomic_umax","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":453},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470870,"byte_end":470885,"line_start":553,"line_end":553,"column_start":12,"column_end":27},"name":"atomic_umax_acq","qualname":"::intrinsics::atomic_umax_acq","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":457},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470927,"byte_end":470942,"line_start":554,"line_end":554,"column_start":12,"column_end":27},"name":"atomic_umax_rel","qualname":"::intrinsics::atomic_umax_rel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":461},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":470984,"byte_end":471002,"line_start":555,"line_end":555,"column_start":12,"column_end":30},"name":"atomic_umax_acqrel","qualname":"::intrinsics::atomic_umax_acqrel","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":465},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":471044,"byte_end":471063,"line_start":556,"line_end":556,"column_start":12,"column_end":31},"name":"atomic_umax_relaxed","qualname":"::intrinsics::atomic_umax_relaxed","value":"fn <T> (dst: *mut T, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":469},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":471556,"byte_end":471574,"line_start":565,"line_end":565,"column_start":12,"column_end":30},"name":"prefetch_read_data","qualname":"::intrinsics::prefetch_read_data","value":"fn <T> (data: *const T, locality: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n if supported; otherwise, it is a no-op.\n Prefetches have no effect on the behavior of the program but can change its performance\n characteristics.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":473},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":472071,"byte_end":472090,"line_start":573,"line_end":573,"column_start":12,"column_end":31},"name":"prefetch_write_data","qualname":"::intrinsics::prefetch_write_data","value":"fn <T> (data: *const T, locality: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n if supported; otherwise, it is a no-op.\n Prefetches have no effect on the behavior of the program but can change its performance\n characteristics.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":477},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":472587,"byte_end":472612,"line_start":581,"line_end":581,"column_start":12,"column_end":37},"name":"prefetch_read_instruction","qualname":"::intrinsics::prefetch_read_instruction","value":"fn <T> (data: *const T, locality: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n if supported; otherwise, it is a no-op.\n Prefetches have no effect on the behavior of the program but can change its performance\n characteristics.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":481},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473109,"byte_end":473135,"line_start":589,"line_end":589,"column_start":12,"column_end":38},"name":"prefetch_write_instruction","qualname":"::intrinsics::prefetch_write_instruction","value":"fn <T> (data: *const T, locality: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n if supported; otherwise, it is a no-op.\n Prefetches have no effect on the behavior of the program but can change its performance\n characteristics.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":485},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473212,"byte_end":473224,"line_start":594,"line_end":594,"column_start":12,"column_end":24},"name":"atomic_fence","qualname":"::intrinsics::atomic_fence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":487},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473239,"byte_end":473255,"line_start":595,"line_end":595,"column_start":12,"column_end":28},"name":"atomic_fence_acq","qualname":"::intrinsics::atomic_fence_acq","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":489},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473270,"byte_end":473286,"line_start":596,"line_end":596,"column_start":12,"column_end":28},"name":"atomic_fence_rel","qualname":"::intrinsics::atomic_fence_rel","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":491},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473301,"byte_end":473320,"line_start":597,"line_end":597,"column_start":12,"column_end":31},"name":"atomic_fence_acqrel","qualname":"::intrinsics::atomic_fence_acqrel","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":493},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473661,"byte_end":473685,"line_start":605,"line_end":605,"column_start":12,"column_end":36},"name":"atomic_singlethreadfence","qualname":"::intrinsics::atomic_singlethreadfence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" A compiler-only memory barrier.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":495},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473700,"byte_end":473728,"line_start":606,"line_end":606,"column_start":12,"column_end":40},"name":"atomic_singlethreadfence_acq","qualname":"::intrinsics::atomic_singlethreadfence_acq","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":497},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473743,"byte_end":473771,"line_start":607,"line_end":607,"column_start":12,"column_end":40},"name":"atomic_singlethreadfence_rel","qualname":"::intrinsics::atomic_singlethreadfence_rel","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":499},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":473786,"byte_end":473817,"line_start":608,"line_end":608,"column_start":12,"column_end":43},"name":"atomic_singlethreadfence_acqrel","qualname":"::intrinsics::atomic_singlethreadfence_acqrel","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":501},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":474201,"byte_end":474211,"line_start":617,"line_end":617,"column_start":12,"column_end":22},"name":"rustc_peek","qualname":"::intrinsics::rustc_peek","value":"fn <T> (_: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Magic intrinsic that derives its meaning from attributes\n attached to the function.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":505},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":474409,"byte_end":474414,"line_start":623,"line_end":623,"column_start":12,"column_end":17},"name":"abort","qualname":"::intrinsics::abort","value":"fn () -> !","parent":null,"children":[],"decl_id":null,"docs":" Aborts the execution of the process.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":507},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":474906,"byte_end":474917,"line_start":634,"line_end":634,"column_start":12,"column_end":23},"name":"unreachable","qualname":"::intrinsics::unreachable","value":"fn () -> !","parent":null,"children":[],"decl_id":null,"docs":" Tells LLVM that this point in the code is not reachable, enabling\n further optimizations.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":509},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":475454,"byte_end":475460,"line_start":644,"line_end":644,"column_start":12,"column_end":18},"name":"assume","qualname":"::intrinsics::assume","value":"fn (b: bool) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Informs the optimizer that a condition is always true.\n If the condition is false, the behavior is undefined.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":511},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":475687,"byte_end":475693,"line_start":650,"line_end":650,"column_start":12,"column_end":18},"name":"likely","qualname":"::intrinsics::likely","value":"fn (b: bool) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Hints to the compiler that branch condition is likely to be true.\n Returns the value passed to it.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":513},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":475929,"byte_end":475937,"line_start":656,"line_end":656,"column_start":12,"column_end":20},"name":"unlikely","qualname":"::intrinsics::unlikely","value":"fn (b: bool) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Hints to the compiler that branch condition is likely to be false.\n Returns the value passed to it.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":515},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476034,"byte_end":476044,"line_start":659,"line_end":659,"column_start":12,"column_end":22},"name":"breakpoint","qualname":"::intrinsics::breakpoint","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Executes a breakpoint trap, for inspection by a debugger.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":517},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476362,"byte_end":476369,"line_start":668,"line_end":668,"column_start":12,"column_end":19},"name":"size_of","qualname":"::intrinsics::size_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":" The size of a type in bytes.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":521},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476513,"byte_end":476526,"line_start":673,"line_end":673,"column_start":12,"column_end":25},"name":"move_val_init","qualname":"::intrinsics::move_val_init","value":"fn <T> (dst: *mut T, src: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves a value to an uninitialized memory location.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":525},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476564,"byte_end":476576,"line_start":675,"line_end":675,"column_start":12,"column_end":24},"name":"min_align_of","qualname":"::intrinsics::min_align_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":529},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476603,"byte_end":476616,"line_start":676,"line_end":676,"column_start":12,"column_end":25},"name":"pref_align_of","qualname":"::intrinsics::pref_align_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":533},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476825,"byte_end":476836,"line_start":682,"line_end":682,"column_start":12,"column_end":23},"name":"size_of_val","qualname":"::intrinsics::size_of_val","value":"fn <T> (_: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":" The size of the referenced value in bytes.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":537},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476876,"byte_end":476892,"line_start":683,"line_end":683,"column_start":12,"column_end":28},"name":"min_align_of_val","qualname":"::intrinsics::min_align_of_val","value":"fn <T> (_: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":541},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":476999,"byte_end":477008,"line_start":686,"line_end":686,"column_start":12,"column_end":21},"name":"type_name","qualname":"::intrinsics::type_name","value":"fn <T> () -> &'static str","parent":null,"children":[],"decl_id":null,"docs":" Gets a static string slice containing the name of a type.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":545},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477242,"byte_end":477249,"line_start":691,"line_end":691,"column_start":12,"column_end":19},"name":"type_id","qualname":"::intrinsics::type_id","value":"fn <T> () -> u64","parent":null,"children":[],"decl_id":null,"docs":" Gets an identifier which is globally unique to the specified type. This\n function will return the same value for a type regardless of whichever\n crate it is invoked in.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":549},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477440,"byte_end":477460,"line_start":695,"line_end":695,"column_start":12,"column_end":32},"name":"panic_if_uninhabited","qualname":"::intrinsics::panic_if_uninhabited","value":"fn <T> () -> ()","parent":null,"children":[],"decl_id":null,"docs":" A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n This will statically either panic, or do nothing.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":553},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":477772,"byte_end":477776,"line_start":703,"line_end":703,"column_start":12,"column_end":16},"name":"init","qualname":"::intrinsics::init","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Creates a value initialized to zero.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":557},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478177,"byte_end":478183,"line_start":712,"line_end":712,"column_start":12,"column_end":18},"name":"uninit","qualname":"::intrinsics::uninit","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Creates an uninitialized value.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":561},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":478269,"byte_end":478275,"line_start":715,"line_end":715,"column_start":12,"column_end":18},"name":"forget","qualname":"::intrinsics::forget","value":"fn <T> (_: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves a value out of scope without running drop glue.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":565},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":486012,"byte_end":486021,"line_start":916,"line_end":916,"column_start":12,"column_end":21},"name":"transmute","qualname":"::intrinsics::transmute","value":"fn <T, U> (e: T) -> U","parent":null,"children":[],"decl_id":null,"docs":" Reinterprets the bits of a value of one type as another type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":485955,"byte_end":486000,"line_start":915,"line_end":915,"column_start":5,"column_end":50}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":571},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":486470,"byte_end":486480,"line_start":927,"line_end":927,"column_start":12,"column_end":22},"name":"needs_drop","qualname":"::intrinsics::needs_drop","value":"fn <T> () -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the actual type given as `T` requires drop\n glue; returns `false` if the actual type provided for `T`\n implements `Copy`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":575},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":487039,"byte_end":487045,"line_start":940,"line_end":940,"column_start":12,"column_end":18},"name":"offset","qualname":"::intrinsics::offset","value":"fn <T> (dst: *const T, offset: isize) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":579},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":487673,"byte_end":487685,"line_start":953,"line_end":953,"column_start":12,"column_end":24},"name":"arith_offset","qualname":"::intrinsics::arith_offset","value":"fn <T> (dst: *const T, offset: isize) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer, potentially wrapping.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":583},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":488045,"byte_end":488080,"line_start":961,"line_end":961,"column_start":12,"column_end":47},"name":"volatile_copy_nonoverlapping_memory","qualname":"::intrinsics::volatile_copy_nonoverlapping_memory","value":"fn <T> (dst: *mut T, src: *const T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n a size of `count` * `size_of::<T>()` and an alignment of\n `min_align_of::<T>()`","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":587},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":488490,"byte_end":488510,"line_start":969,"line_end":969,"column_start":12,"column_end":32},"name":"volatile_copy_memory","qualname":"::intrinsics::volatile_copy_memory","value":"fn <T> (dst: *mut T, src: *const T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n a size of `count` * `size_of::<T>()` and an alignment of\n `min_align_of::<T>()`","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":591},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":488866,"byte_end":488885,"line_start":976,"line_end":976,"column_start":12,"column_end":31},"name":"volatile_set_memory","qualname":"::intrinsics::volatile_set_memory","value":"fn <T> (dst: *mut T, val: u8, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n size of `count` * `size_of::<T>()` and an alignment of\n `min_align_of::<T>()`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":595},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":489121,"byte_end":489134,"line_start":981,"line_end":981,"column_start":12,"column_end":25},"name":"volatile_load","qualname":"::intrinsics::volatile_load","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile load from the `src` pointer.\n The stabilized version of this intrinsic is\n [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":599},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":489354,"byte_end":489368,"line_start":985,"line_end":985,"column_start":12,"column_end":26},"name":"volatile_store","qualname":"::intrinsics::volatile_store","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile store to the `dst` pointer.\n The stabilized version of this intrinsic is\n [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":603},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":489513,"byte_end":489536,"line_start":989,"line_end":989,"column_start":12,"column_end":35},"name":"unaligned_volatile_load","qualname":"::intrinsics::unaligned_volatile_load","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile load from the `src` pointer\n The pointer is not required to be aligned.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":607},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":489679,"byte_end":489703,"line_start":992,"line_end":992,"column_start":12,"column_end":36},"name":"unaligned_volatile_store","qualname":"::intrinsics::unaligned_volatile_store","value":"fn <T> (dst: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile store to the `dst` pointer.\n The pointer is not required to be aligned.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":611},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":489785,"byte_end":489792,"line_start":995,"line_end":995,"column_start":12,"column_end":19},"name":"sqrtf32","qualname":"::intrinsics::sqrtf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of an `f32`\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":613},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":489864,"byte_end":489871,"line_start":997,"line_end":997,"column_start":12,"column_end":19},"name":"sqrtf64","qualname":"::intrinsics::sqrtf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of an `f64`\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":615},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":489945,"byte_end":489952,"line_start":1000,"line_end":1000,"column_start":12,"column_end":19},"name":"powif32","qualname":"::intrinsics::powif32","value":"fn (a: f32, x: i32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Raises an `f32` to an integer power.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":617},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490033,"byte_end":490040,"line_start":1002,"line_end":1002,"column_start":12,"column_end":19},"name":"powif64","qualname":"::intrinsics::powif64","value":"fn (a: f64, x: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Raises an `f64` to an integer power.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":619},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490115,"byte_end":490121,"line_start":1005,"line_end":1005,"column_start":12,"column_end":18},"name":"sinf32","qualname":"::intrinsics::sinf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the sine of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":621},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490187,"byte_end":490193,"line_start":1007,"line_end":1007,"column_start":12,"column_end":18},"name":"sinf64","qualname":"::intrinsics::sinf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the sine of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":623},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490262,"byte_end":490268,"line_start":1010,"line_end":1010,"column_start":12,"column_end":18},"name":"cosf32","qualname":"::intrinsics::cosf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the cosine of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":625},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490336,"byte_end":490342,"line_start":1012,"line_end":1012,"column_start":12,"column_end":18},"name":"cosf64","qualname":"::intrinsics::cosf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the cosine of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":627},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490414,"byte_end":490420,"line_start":1015,"line_end":1015,"column_start":12,"column_end":18},"name":"powf32","qualname":"::intrinsics::powf32","value":"fn (a: f32, x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Raises an `f32` to an `f32` power.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":629},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490499,"byte_end":490505,"line_start":1017,"line_end":1017,"column_start":12,"column_end":18},"name":"powf64","qualname":"::intrinsics::powf64","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Raises an `f64` to an `f64` power.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":631},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490587,"byte_end":490593,"line_start":1020,"line_end":1020,"column_start":12,"column_end":18},"name":"expf32","qualname":"::intrinsics::expf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the exponential of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":633},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490666,"byte_end":490672,"line_start":1022,"line_end":1022,"column_start":12,"column_end":18},"name":"expf64","qualname":"::intrinsics::expf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the exponential of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":635},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490752,"byte_end":490759,"line_start":1025,"line_end":1025,"column_start":12,"column_end":19},"name":"exp2f32","qualname":"::intrinsics::exp2f32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns 2 raised to the power of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":637},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490838,"byte_end":490845,"line_start":1027,"line_end":1027,"column_start":12,"column_end":19},"name":"exp2f64","qualname":"::intrinsics::exp2f64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns 2 raised to the power of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":639},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":490925,"byte_end":490931,"line_start":1030,"line_end":1030,"column_start":12,"column_end":18},"name":"logf32","qualname":"::intrinsics::logf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the natural logarithm of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":641},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491010,"byte_end":491016,"line_start":1032,"line_end":1032,"column_start":12,"column_end":18},"name":"logf64","qualname":"::intrinsics::logf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the natural logarithm of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":643},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491096,"byte_end":491104,"line_start":1035,"line_end":1035,"column_start":12,"column_end":20},"name":"log10f32","qualname":"::intrinsics::log10f32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the base 10 logarithm of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":645},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491183,"byte_end":491191,"line_start":1037,"line_end":1037,"column_start":12,"column_end":20},"name":"log10f64","qualname":"::intrinsics::log10f64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the base 10 logarithm of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":647},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491270,"byte_end":491277,"line_start":1040,"line_end":1040,"column_start":12,"column_end":19},"name":"log2f32","qualname":"::intrinsics::log2f32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the base 2 logarithm of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":649},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491355,"byte_end":491362,"line_start":1042,"line_end":1042,"column_start":12,"column_end":19},"name":"log2f64","qualname":"::intrinsics::log2f64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the base 2 logarithm of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":651},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491437,"byte_end":491443,"line_start":1045,"line_end":1045,"column_start":12,"column_end":18},"name":"fmaf32","qualname":"::intrinsics::fmaf32","value":"fn (a: f32, b: f32, c: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns `a * b + c` for `f32` values.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":653},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491533,"byte_end":491539,"line_start":1047,"line_end":1047,"column_start":12,"column_end":18},"name":"fmaf64","qualname":"::intrinsics::fmaf64","value":"fn (a: f64, b: f64, c: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns `a * b + c` for `f64` values.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":655},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491632,"byte_end":491639,"line_start":1050,"line_end":1050,"column_start":12,"column_end":19},"name":"fabsf32","qualname":"::intrinsics::fabsf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the absolute value of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":657},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491715,"byte_end":491722,"line_start":1052,"line_end":1052,"column_start":12,"column_end":19},"name":"fabsf64","qualname":"::intrinsics::fabsf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the absolute value of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":659},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491809,"byte_end":491820,"line_start":1055,"line_end":1055,"column_start":12,"column_end":23},"name":"copysignf32","qualname":"::intrinsics::copysignf32","value":"fn (x: f32, y: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Copies the sign from `y` to `x` for `f32` values.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":661},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":491914,"byte_end":491925,"line_start":1057,"line_end":1057,"column_start":12,"column_end":23},"name":"copysignf64","qualname":"::intrinsics::copysignf64","value":"fn (x: f64, y: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Copies the sign from `y` to `x` for `f64` values.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":663},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492030,"byte_end":492038,"line_start":1060,"line_end":1060,"column_start":12,"column_end":20},"name":"floorf32","qualname":"::intrinsics::floorf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the largest integer less than or equal to an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":665},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492134,"byte_end":492142,"line_start":1062,"line_end":1062,"column_start":12,"column_end":20},"name":"floorf64","qualname":"::intrinsics::floorf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the largest integer less than or equal to an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":667},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492243,"byte_end":492250,"line_start":1065,"line_end":1065,"column_start":12,"column_end":19},"name":"ceilf32","qualname":"::intrinsics::ceilf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the smallest integer greater than or equal to an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":669},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492350,"byte_end":492357,"line_start":1067,"line_end":1067,"column_start":12,"column_end":19},"name":"ceilf64","qualname":"::intrinsics::ceilf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the smallest integer greater than or equal to an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":671},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492432,"byte_end":492440,"line_start":1070,"line_end":1070,"column_start":12,"column_end":20},"name":"truncf32","qualname":"::intrinsics::truncf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the integer part of an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":673},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492514,"byte_end":492522,"line_start":1072,"line_end":1072,"column_start":12,"column_end":20},"name":"truncf64","qualname":"::intrinsics::truncf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the integer part of an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":675},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492689,"byte_end":492696,"line_start":1076,"line_end":1076,"column_start":12,"column_end":19},"name":"rintf32","qualname":"::intrinsics::rintf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n if the argument is not an integer.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":677},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492862,"byte_end":492869,"line_start":1079,"line_end":1079,"column_start":12,"column_end":19},"name":"rintf64","qualname":"::intrinsics::rintf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n if the argument is not an integer.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":679},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":492947,"byte_end":492959,"line_start":1082,"line_end":1082,"column_start":12,"column_end":24},"name":"nearbyintf32","qualname":"::intrinsics::nearbyintf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f32`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":681},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493036,"byte_end":493048,"line_start":1084,"line_end":1084,"column_start":12,"column_end":24},"name":"nearbyintf64","qualname":"::intrinsics::nearbyintf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f64`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":683},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493164,"byte_end":493172,"line_start":1087,"line_end":1087,"column_start":12,"column_end":20},"name":"roundf32","qualname":"::intrinsics::roundf32","value":"fn (x: f32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":685},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493287,"byte_end":493295,"line_start":1089,"line_end":1089,"column_start":12,"column_end":20},"name":"roundf64","qualname":"::intrinsics::roundf64","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":687},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493437,"byte_end":493446,"line_start":1093,"line_end":1093,"column_start":12,"column_end":21},"name":"fadd_fast","qualname":"::intrinsics::fadd_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float addition that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":691},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493596,"byte_end":493605,"line_start":1097,"line_end":1097,"column_start":12,"column_end":21},"name":"fsub_fast","qualname":"::intrinsics::fsub_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float subtraction that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":695},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493758,"byte_end":493767,"line_start":1101,"line_end":1101,"column_start":12,"column_end":21},"name":"fmul_fast","qualname":"::intrinsics::fmul_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float multiplication that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":699},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":493914,"byte_end":493923,"line_start":1105,"line_end":1105,"column_start":12,"column_end":21},"name":"fdiv_fast","qualname":"::intrinsics::fdiv_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float division that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":703},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":494071,"byte_end":494080,"line_start":1109,"line_end":1109,"column_start":12,"column_end":21},"name":"frem_fast","qualname":"::intrinsics::frem_fast","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Float remainder that allows optimizations based on algebraic rules.\n May assume inputs are finite.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":707},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":494177,"byte_end":494182,"line_start":1113,"line_end":1113,"column_start":12,"column_end":17},"name":"ctpop","qualname":"::intrinsics::ctpop","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of bits set in an integer type `T`\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":711},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":494828,"byte_end":494832,"line_start":1140,"line_end":1140,"column_start":12,"column_end":16},"name":"ctlz","qualname":"::intrinsics::ctlz","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of leading unset bits (zeroes) in an integer type `T`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":715},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":495239,"byte_end":495251,"line_start":1156,"line_end":1156,"column_start":12,"column_end":24},"name":"ctlz_nonzero","qualname":"::intrinsics::ctlz_nonzero","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Like `ctlz`, but extra-unsafe as it returns `undef` when\n given an `x` with value `0`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":719},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":495902,"byte_end":495906,"line_start":1183,"line_end":1183,"column_start":12,"column_end":16},"name":"cttz","qualname":"::intrinsics::cttz","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of trailing unset bits (zeroes) in an integer type `T`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":723},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":496315,"byte_end":496327,"line_start":1199,"line_end":1199,"column_start":12,"column_end":24},"name":"cttz_nonzero","qualname":"::intrinsics::cttz_nonzero","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Like `cttz`, but extra-unsafe as it returns `undef` when\n given an `x` with value `0`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":727},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":496406,"byte_end":496411,"line_start":1202,"line_end":1202,"column_start":12,"column_end":17},"name":"bswap","qualname":"::intrinsics::bswap","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reverses the bytes in an integer type `T`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":731},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":496489,"byte_end":496499,"line_start":1205,"line_end":1205,"column_start":12,"column_end":22},"name":"bitreverse","qualname":"::intrinsics::bitreverse","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reverses the bits in an integer type `T`.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":735},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":496806,"byte_end":496823,"line_start":1211,"line_end":1211,"column_start":12,"column_end":29},"name":"add_with_overflow","qualname":"::intrinsics::add_with_overflow","value":"fn <T> (x: T, y: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Performs checked integer addition.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `overflowing_add` method. For example,\n [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":739},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497146,"byte_end":497163,"line_start":1217,"line_end":1217,"column_start":12,"column_end":29},"name":"sub_with_overflow","qualname":"::intrinsics::sub_with_overflow","value":"fn <T> (x: T, y: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Performs checked integer subtraction\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `overflowing_sub` method. For example,\n [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":743},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497489,"byte_end":497506,"line_start":1223,"line_end":1223,"column_start":12,"column_end":29},"name":"mul_with_overflow","qualname":"::intrinsics::mul_with_overflow","value":"fn <T> (x: T, y: T) -> (T, bool)","parent":null,"children":[],"decl_id":null,"docs":" Performs checked integer multiplication\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `overflowing_mul` method. For example,\n [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":747},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497691,"byte_end":497700,"line_start":1227,"line_end":1227,"column_start":12,"column_end":21},"name":"exact_div","qualname":"::intrinsics::exact_div","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs an exact division, resulting in undefined behavior where\n `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":751},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":497861,"byte_end":497874,"line_start":1231,"line_end":1231,"column_start":12,"column_end":25},"name":"unchecked_div","qualname":"::intrinsics::unchecked_div","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs an unchecked division, resulting in undefined behavior\n where y = 0 or x = `T::min_value()` and y = -1\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":755},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498050,"byte_end":498063,"line_start":1234,"line_end":1234,"column_start":12,"column_end":25},"name":"unchecked_rem","qualname":"::intrinsics::unchecked_rem","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of an unchecked division, resulting in\n undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":759},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498236,"byte_end":498249,"line_start":1238,"line_end":1238,"column_start":12,"column_end":25},"name":"unchecked_shl","qualname":"::intrinsics::unchecked_shl","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs an unchecked left shift, resulting in undefined behavior when\n y < 0 or y >= N, where N is the width of T in bits.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":763},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498422,"byte_end":498435,"line_start":1241,"line_end":1241,"column_start":12,"column_end":25},"name":"unchecked_shr","qualname":"::intrinsics::unchecked_shr","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs an unchecked right shift, resulting in undefined behavior when\n y < 0 or y >= N, where N is the width of T in bits.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":767},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":498723,"byte_end":498734,"line_start":1247,"line_end":1247,"column_start":12,"column_end":23},"name":"rotate_left","qualname":"::intrinsics::rotate_left","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs rotate left.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `rotate_left` method. For example,\n [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":771},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499026,"byte_end":499038,"line_start":1253,"line_end":1253,"column_start":12,"column_end":24},"name":"rotate_right","qualname":"::intrinsics::rotate_right","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs rotate right.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `rotate_right` method. For example,\n [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":775},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499377,"byte_end":499392,"line_start":1259,"line_end":1259,"column_start":12,"column_end":27},"name":"overflowing_add","qualname":"::intrinsics::overflowing_add","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `wrapping_add` method. For example,\n [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":779},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":499730,"byte_end":499745,"line_start":1264,"line_end":1264,"column_start":12,"column_end":27},"name":"overflowing_sub","qualname":"::intrinsics::overflowing_sub","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `wrapping_sub` method. For example,\n [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":783},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500083,"byte_end":500098,"line_start":1269,"line_end":1269,"column_start":12,"column_end":27},"name":"overflowing_mul","qualname":"::intrinsics::overflowing_mul","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `wrapping_mul` method. For example,\n [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":787},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500427,"byte_end":500441,"line_start":1275,"line_end":1275,"column_start":12,"column_end":26},"name":"saturating_add","qualname":"::intrinsics::saturating_add","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Computes `a + b`, while saturating at numeric bounds.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `saturating_add` method. For example,\n [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":791},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500769,"byte_end":500783,"line_start":1280,"line_end":1280,"column_start":12,"column_end":26},"name":"saturating_sub","qualname":"::intrinsics::saturating_sub","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Computes `a - b`, while saturating at numeric bounds.\n The stabilized versions of this intrinsic are available on the integer\n primitives via the `saturating_sub` method. For example,\n [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":795},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":500951,"byte_end":500969,"line_start":1284,"line_end":1284,"column_start":12,"column_end":30},"name":"discriminant_value","qualname":"::intrinsics::discriminant_value","value":"fn <T> (v: &T) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Returns the value of the discriminant for the variant in 'v',\n cast to a `u64`; if `T` has no discriminant, returns 0.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":799},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501496,"byte_end":501501,"line_start":1294,"line_end":1294,"column_start":12,"column_end":17},"name":"try","qualname":"::intrinsics::try","value":"fn (f: fn(*mut u8), data: *mut u8, local_ptr: *mut u8) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Rust's \"try catch\" construct which invokes the function pointer `f` with\n the data pointer `data`.","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":801},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":501689,"byte_end":501706,"line_start":1298,"line_end":1298,"column_start":12,"column_end":29},"name":"nontemporal_store","qualname":"::intrinsics::nontemporal_store","value":"fn <T> (ptr: *mut T, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Emits a `!nontemporal` store according to LLVM (see their docs).\n Probably will never become stable.\n","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":805},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":502080,"byte_end":502099,"line_start":1308,"line_end":1308,"column_start":12,"column_end":31},"name":"copy_nonoverlapping","qualname":"::intrinsics::real_intrinsics::copy_nonoverlapping","value":"fn <T> (src: *const T, dst: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n For the full docs, see the stabilized wrapper [`copy_nonoverlapping`].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":809},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":502390,"byte_end":502394,"line_start":1315,"line_end":1315,"column_start":12,"column_end":16},"name":"copy","qualname":"::intrinsics::real_intrinsics::copy","value":"fn <T> (src: *const T, dst: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.\n For the full docs, see the stabilized wrapper [`copy`].","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":813},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":502681,"byte_end":502692,"line_start":1322,"line_end":1322,"column_start":12,"column_end":23},"name":"write_bytes","qualname":"::intrinsics::real_intrinsics::write_bytes","value":"fn <T> (dst: *mut T, val: u8, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n `val`.\n For the full docs, see the stabilized wrapper [`write_bytes`].","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":1198},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":505798,"byte_end":505817,"line_start":1411,"line_end":1411,"column_start":15,"column_end":34},"name":"copy_nonoverlapping","qualname":"::intrinsics::copy_nonoverlapping","value":"fn <T> (src: *const T, dst: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":505728,"byte_end":505773,"line_start":1409,"line_end":1409,"column_start":1,"column_end":46}},{"value":"inline","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":505774,"byte_end":505783,"line_start":1410,"line_end":1410,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":1200},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":507850,"byte_end":507854,"line_start":1468,"line_end":1468,"column_start":15,"column_end":19},"name":"copy","qualname":"::intrinsics::copy","value":"fn <T> (src: *const T, dst: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":507780,"byte_end":507825,"line_start":1466,"line_end":1466,"column_start":1,"column_end":46}},{"value":"inline","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":507826,"byte_end":507835,"line_start":1467,"line_end":1467,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":1202},"span":{"file_name":"src/libcore/intrinsics.rs","byte_start":510069,"byte_end":510080,"line_start":1546,"line_end":1546,"column_start":15,"column_end":26},"name":"write_bytes","qualname":"::intrinsics::write_bytes","value":"fn <T> (dst: *mut T, val: u8, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n `val`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":509999,"byte_end":510044,"line_start":1544,"line_end":1544,"column_start":1,"column_end":46}},{"value":"inline","span":{"file_name":"src/libcore/intrinsics.rs","byte_start":510045,"byte_end":510054,"line_start":1545,"line_end":1545,"column_start":1,"column_end":10}}]},{"kind":"Mod","id":{"krate":0,"index":1204},"span":{"file_name":"src/libcore/mem.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"mem","qualname":"::mem","value":"src/libcore/mem.rs","parent":null,"children":[{"krate":0,"index":1206},{"krate":0,"index":1208},{"krate":0,"index":1210},{"krate":0,"index":1212},{"krate":0,"index":1214},{"krate":0,"index":1216},{"krate":0,"index":1224},{"krate":0,"index":1226},{"krate":0,"index":1232},{"krate":0,"index":1234},{"krate":0,"index":1236},{"krate":0,"index":47098},{"krate":0,"index":1238},{"krate":0,"index":1240},{"krate":0,"index":1242},{"krate":0,"index":47096},{"krate":0,"index":1244},{"krate":0,"index":1246},{"krate":0,"index":1248},{"krate":0,"index":1250},{"krate":0,"index":1252},{"krate":0,"index":1254},{"krate":0,"index":1256},{"krate":0,"index":1258},{"krate":0,"index":1260},{"krate":0,"index":1262},{"krate":0,"index":1264},{"krate":0,"index":1268},{"krate":0,"index":1272},{"krate":0,"index":1274},{"krate":0,"index":1278},{"krate":0,"index":1282},{"krate":0,"index":20924},{"krate":0,"index":47072},{"krate":0,"index":20964},{"krate":0,"index":20960},{"krate":0,"index":20956},{"krate":0,"index":20950},{"krate":0,"index":20946},{"krate":0,"index":20934},{"krate":0,"index":20930},{"krate":0,"index":20926},{"krate":0,"index":1284},{"krate":0,"index":1292},{"krate":0,"index":1296},{"krate":0,"index":1302},{"krate":0,"index":20968},{"krate":0,"index":47070},{"krate":0,"index":1306},{"krate":0,"index":1310}],"decl_id":null,"docs":" Basic functions for dealing with memory.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":510348,"byte_end":510394,"line_start":6,"line_end":6,"column_start":1,"column_end":47}}]},{"kind":"Function","id":{"krate":0,"index":1234},"span":{"file_name":"src/libcore/mem.rs","byte_start":514717,"byte_end":514723,"line_start":132,"line_end":132,"column_start":8,"column_end":14},"name":"forget","qualname":"::mem::forget","value":"fn <T> (t: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Takes ownership and \"forgets\" about the value **without running its destructor**.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":514654,"byte_end":514663,"line_start":130,"line_end":130,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":514664,"byte_end":514709,"line_start":131,"line_end":131,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1236},"span":{"file_name":"src/libcore/mem.rs","byte_start":515038,"byte_end":515052,"line_start":144,"line_end":144,"column_start":8,"column_end":22},"name":"forget_unsized","qualname":"::mem::forget_unsized","value":"fn <T> (t: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Like [`forget`], but also accepts unsized values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":514968,"byte_end":514977,"line_start":142,"line_end":142,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"forget_unsized\", issue = \"0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":514978,"byte_end":515030,"line_start":143,"line_end":143,"column_start":1,"column_end":53}}]},{"kind":"Function","id":{"krate":0,"index":47098},"span":{"file_name":"src/libcore/mem.rs","byte_start":519619,"byte_end":519626,"line_start":291,"line_end":291,"column_start":14,"column_end":21},"name":"size_of","qualname":"::mem::size_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the size of a type in bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":519530,"byte_end":519539,"line_start":288,"line_end":288,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":519540,"byte_end":519585,"line_start":289,"line_end":289,"column_start":1,"column_end":46}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/mem.rs","byte_start":519586,"byte_end":519605,"line_start":290,"line_end":290,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":1238},"span":{"file_name":"src/libcore/mem.rs","byte_start":520333,"byte_end":520344,"line_start":317,"line_end":317,"column_start":8,"column_end":19},"name":"size_of_val","qualname":"::mem::size_of_val","value":"fn <T> (val: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the size of the pointed-to value in bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":520270,"byte_end":520279,"line_start":315,"line_end":315,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":520280,"byte_end":520325,"line_start":316,"line_end":316,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1240},"span":{"file_name":"src/libcore/mem.rs","byte_start":521016,"byte_end":521028,"line_start":340,"line_end":340,"column_start":8,"column_end":20},"name":"min_align_of","qualname":"::mem::min_align_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the [ABI]-required minimum alignment of a type.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":520881,"byte_end":520890,"line_start":337,"line_end":337,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":520891,"byte_end":520936,"line_start":338,"line_end":338,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":520937,"byte_end":521008,"line_start":339,"line_end":339,"column_start":1,"column_end":72}}]},{"kind":"Function","id":{"krate":0,"index":1242},"span":{"file_name":"src/libcore/mem.rs","byte_start":521617,"byte_end":521633,"line_start":361,"line_end":361,"column_start":8,"column_end":24},"name":"min_align_of_val","qualname":"::mem::min_align_of_val","value":"fn <T> (val: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":521478,"byte_end":521487,"line_start":358,"line_end":358,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":521488,"byte_end":521533,"line_start":359,"line_end":359,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":521534,"byte_end":521609,"line_start":360,"line_end":360,"column_start":1,"column_end":76}}]},{"kind":"Function","id":{"krate":0,"index":47096},"span":{"file_name":"src/libcore/mem.rs","byte_start":522232,"byte_end":522240,"line_start":383,"line_end":383,"column_start":14,"column_end":22},"name":"align_of","qualname":"::mem::align_of","value":"fn <T> () -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the [ABI]-required minimum alignment of a type.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":522143,"byte_end":522152,"line_start":380,"line_end":380,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":522153,"byte_end":522198,"line_start":381,"line_end":381,"column_start":1,"column_end":46}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/mem.rs","byte_start":522199,"byte_end":522218,"line_start":382,"line_end":382,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":1244},"span":{"file_name":"src/libcore/mem.rs","byte_start":522721,"byte_end":522733,"line_start":402,"line_end":402,"column_start":8,"column_end":20},"name":"align_of_val","qualname":"::mem::align_of_val","value":"fn <T> (val: &T) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":522658,"byte_end":522667,"line_start":400,"line_end":400,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":522668,"byte_end":522713,"line_start":401,"line_end":401,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1246},"span":{"file_name":"src/libcore/mem.rs","byte_start":525011,"byte_end":525021,"line_start":463,"line_end":463,"column_start":14,"column_end":24},"name":"needs_drop","qualname":"::mem::needs_drop","value":"fn <T> () -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if dropping values of type `T` matters.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":524882,"byte_end":524891,"line_start":460,"line_end":460,"column_start":1,"column_end":10}},{"value":"stable(feature = \"needs_drop\", since = \"1.21.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":524892,"byte_end":524943,"line_start":461,"line_end":461,"column_start":1,"column_end":52}},{"value":"rustc_const_unstable(feature = \"const_needs_drop\")","span":{"file_name":"src/libcore/mem.rs","byte_start":524944,"byte_end":524997,"line_start":462,"line_end":462,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":1248},"span":{"file_name":"src/libcore/mem.rs","byte_start":526035,"byte_end":526041,"line_start":494,"line_end":494,"column_start":15,"column_end":21},"name":"zeroed","qualname":"::mem::zeroed","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Creates a value whose bytes are all zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":525965,"byte_end":525974,"line_start":492,"line_end":492,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":525975,"byte_end":526020,"line_start":493,"line_end":493,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1250},"span":{"file_name":"src/libcore/mem.rs","byte_start":531050,"byte_end":531063,"line_start":627,"line_end":627,"column_start":15,"column_end":28},"name":"uninitialized","qualname":"::mem::uninitialized","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Bypasses Rust's normal memory-initialization checks by pretending to\n produce a value of type `T`, while doing nothing at all.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":530892,"byte_end":530901,"line_start":624,"line_end":624,"column_start":1,"column_end":10}},{"value":"rustc_deprecated(since = \"2.0.0\",\n                   reason = \"use `mem::MaybeUninit::uninit` instead\")","span":{"file_name":"src/libcore/mem.rs","byte_start":530902,"byte_end":530989,"line_start":625,"line_end":625,"column_start":1,"column_end":88}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":530990,"byte_end":531035,"line_start":626,"line_end":626,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1252},"span":{"file_name":"src/libcore/mem.rs","byte_start":531478,"byte_end":531482,"line_start":649,"line_end":649,"column_start":8,"column_end":12},"name":"swap","qualname":"::mem::swap","value":"fn <T> (x: &mut T, y: &mut T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the values at two mutable locations, without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":531415,"byte_end":531424,"line_start":647,"line_end":647,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":531425,"byte_end":531470,"line_start":648,"line_end":648,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1254},"span":{"file_name":"src/libcore/mem.rs","byte_start":532999,"byte_end":533006,"line_start":708,"line_end":708,"column_start":8,"column_end":15},"name":"replace","qualname":"::mem::replace","value":"fn <T> (dest: &mut T, mut src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Moves `src` into the referenced `dest`, returning the previous `dest` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":532936,"byte_end":532945,"line_start":706,"line_end":706,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":532946,"byte_end":532991,"line_start":707,"line_end":707,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1256},"span":{"file_name":"src/libcore/mem.rs","byte_start":534693,"byte_end":534697,"line_start":777,"line_end":777,"column_start":8,"column_end":12},"name":"drop","qualname":"::mem::drop","value":"fn <T> (_x: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Disposes of a value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":534630,"byte_end":534639,"line_start":775,"line_end":775,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":534640,"byte_end":534685,"line_start":776,"line_end":776,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1258},"span":{"file_name":"src/libcore/mem.rs","byte_start":536056,"byte_end":536070,"line_start":822,"line_end":822,"column_start":15,"column_end":29},"name":"transmute_copy","qualname":"::mem::transmute_copy","value":"fn <T, U> (src: &T) -> U","parent":null,"children":[],"decl_id":null,"docs":" Interprets `src` as having type `&U`, and then reads `src` without moving\n the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":535986,"byte_end":535995,"line_start":820,"line_end":820,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":535996,"byte_end":536041,"line_start":821,"line_end":821,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":1260},"span":{"file_name":"src/libcore/mem.rs","byte_start":536404,"byte_end":536416,"line_start":832,"line_end":832,"column_start":12,"column_end":24},"name":"Discriminant","qualname":"::mem::Discriminant","value":"","parent":null,"children":[],"decl_id":null,"docs":" Opaque type representing the discriminant of an enum.","sig":null,"attributes":[{"value":"stable(feature = \"discriminant_value\", since = \"1.21.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":536333,"byte_end":536392,"line_start":831,"line_end":831,"column_start":1,"column_end":60}}]},{"kind":"Function","id":{"krate":0,"index":1282},"span":{"file_name":"src/libcore/mem.rs","byte_start":538458,"byte_end":538470,"line_start":897,"line_end":897,"column_start":8,"column_end":20},"name":"discriminant","qualname":"::mem::discriminant","value":"fn <T> (v: &T) -> Discriminant<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a value uniquely identifying the enum variant in `v`.","sig":null,"attributes":[{"value":"stable(feature = \"discriminant_value\", since = \"1.21.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":538391,"byte_end":538450,"line_start":896,"line_end":896,"column_start":1,"column_end":60}}]},{"kind":"Struct","id":{"krate":0,"index":20924},"span":{"file_name":"src/libcore/mem.rs","byte_start":540519,"byte_end":540531,"line_start":950,"line_end":950,"column_start":12,"column_end":24},"name":"ManuallyDrop","qualname":"::mem::ManuallyDrop","value":"ManuallyDrop {  }","parent":null,"children":[{"krate":0,"index":7105}],"decl_id":null,"docs":" A wrapper to inhibit compiler from automatically calling `T`s destructor.","sig":null,"attributes":[{"value":"stable(feature = \"manually_drop\", since = \"1.20.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":540329,"byte_end":540383,"line_start":946,"line_end":946,"column_start":1,"column_end":55}},{"value":"lang = \"manually_drop\"","span":{"file_name":"src/libcore/mem.rs","byte_start":540384,"byte_end":540409,"line_start":947,"line_end":947,"column_start":1,"column_end":26}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/mem.rs","byte_start":540487,"byte_end":540507,"line_start":949,"line_end":949,"column_start":1,"column_end":21}},{"value":"structural_match","span":{"file_name":"src/libcore/mem.rs","byte_start":540508,"byte_end":540560,"line_start":950,"line_end":952,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/mem.rs","byte_start":540508,"byte_end":540560,"line_start":950,"line_end":952,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":1286},"span":{"file_name":"src/libcore/mem.rs","byte_start":540871,"byte_end":540874,"line_start":965,"line_end":965,"column_start":18,"column_end":21},"name":"new","qualname":"<ManuallyDrop<T>>::new","value":"fn (value: T) -> ManuallyDrop<T>","parent":null,"children":[],"decl_id":null,"docs":" Wrap a value to be manually dropped.","sig":null,"attributes":[{"value":"stable(feature = \"manually_drop\", since = \"1.20.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":540777,"byte_end":540831,"line_start":963,"line_end":963,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":540836,"byte_end":540853,"line_start":964,"line_end":964,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1288},"span":{"file_name":"src/libcore/mem.rs","byte_start":541390,"byte_end":541400,"line_start":982,"line_end":982,"column_start":18,"column_end":28},"name":"into_inner","qualname":"<ManuallyDrop<T>>::into_inner","value":"fn (slot: ManuallyDrop<T>) -> T","parent":null,"children":[],"decl_id":null,"docs":" Extracts the value from the `ManuallyDrop` container.","sig":null,"attributes":[{"value":"stable(feature = \"manually_drop\", since = \"1.20.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":541296,"byte_end":541350,"line_start":980,"line_end":980,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":541355,"byte_end":541372,"line_start":981,"line_end":981,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1290},"span":{"file_name":"src/libcore/mem.rs","byte_start":542449,"byte_end":542453,"line_start":1005,"line_end":1005,"column_start":19,"column_end":23},"name":"take","qualname":"<ManuallyDrop<T>>::take","value":"fn (slot: &mut ManuallyDrop<T>) -> T","parent":null,"children":[],"decl_id":null,"docs":" Takes the contained value out.","sig":null,"attributes":[{"value":"must_use =\n      \"if you don\\'t need the value, you can use `ManuallyDrop::drop` instead\"","span":{"file_name":"src/libcore/mem.rs","byte_start":542266,"byte_end":542351,"line_start":1002,"line_end":1002,"column_start":5,"column_end":90}},{"value":"unstable(feature = \"manually_drop_take\", issue = \"55422\")","span":{"file_name":"src/libcore/mem.rs","byte_start":542356,"byte_end":542416,"line_start":1003,"line_end":1003,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":542421,"byte_end":542430,"line_start":1004,"line_end":1004,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1294},"span":{"file_name":"src/libcore/mem.rs","byte_start":543151,"byte_end":543155,"line_start":1024,"line_end":1024,"column_start":19,"column_end":23},"name":"drop","qualname":"<ManuallyDrop<T>>::drop","value":"fn (slot: &mut ManuallyDrop<T>) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Manually drops the contained value.","sig":null,"attributes":[{"value":"stable(feature = \"manually_drop\", since = \"1.20.0\")","span":{"file_name":"src/libcore/mem.rs","byte_start":543064,"byte_end":543118,"line_start":1022,"line_end":1022,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":543123,"byte_end":543132,"line_start":1023,"line_end":1023,"column_start":5,"column_end":14}}]},{"kind":"Union","id":{"krate":0,"index":20968},"span":{"file_name":"src/libcore/mem.rs","byte_start":546889,"byte_end":546900,"line_start":1120,"line_end":1120,"column_start":11,"column_end":22},"name":"MaybeUninit","qualname":"::mem::MaybeUninit","value":"MaybeUninit {  }","parent":null,"children":[{"krate":0,"index":7127},{"krate":0,"index":7129}],"decl_id":null,"docs":" A wrapper to construct uninitialized instances of `T`.","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/mem.rs","byte_start":546683,"byte_end":546722,"line_start":1116,"line_end":1116,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":546723,"byte_end":546777,"line_start":1117,"line_end":1117,"column_start":1,"column_end":55}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/mem.rs","byte_start":546879,"byte_end":546951,"line_start":1120,"line_end":1123,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":1312},"span":{"file_name":"src/libcore/mem.rs","byte_start":547585,"byte_end":547588,"line_start":1141,"line_end":1141,"column_start":18,"column_end":21},"name":"new","qualname":"<MaybeUninit<T>>::new","value":"fn (val: T) -> MaybeUninit<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `MaybeUninit<T>` initialized with the given value.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":547491,"byte_end":547545,"line_start":1139,"line_end":1139,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":547550,"byte_end":547567,"line_start":1140,"line_end":1140,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1314},"span":{"file_name":"src/libcore/mem.rs","byte_start":548016,"byte_end":548022,"line_start":1151,"line_end":1151,"column_start":18,"column_end":24},"name":"uninit","qualname":"<MaybeUninit<T>>::uninit","value":"fn () -> MaybeUninit<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `MaybeUninit<T>` in an uninitialized state.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":547922,"byte_end":547976,"line_start":1149,"line_end":1149,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":547981,"byte_end":547998,"line_start":1150,"line_end":1150,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1316},"span":{"file_name":"src/libcore/mem.rs","byte_start":549684,"byte_end":549690,"line_start":1194,"line_end":1194,"column_start":12,"column_end":18},"name":"zeroed","qualname":"<MaybeUninit<T>>::zeroed","value":"fn () -> MaybeUninit<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n filled with `0` bytes. It depends on `T` whether that already makes for\n proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n be null.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":549604,"byte_end":549658,"line_start":1192,"line_end":1192,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/mem.rs","byte_start":549663,"byte_end":549672,"line_start":1193,"line_end":1193,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1318},"span":{"file_name":"src/libcore/mem.rs","byte_start":550269,"byte_end":550274,"line_start":1208,"line_end":1208,"column_start":12,"column_end":17},"name":"write","qualname":"<MaybeUninit<T>>::write","value":"fn (&mut self, val: T) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n without dropping it, so be careful not to use this twice unless you want to\n skip running the destructor. For your convenience, this also returns a mutable\n reference to the (now safely initialized) contents of `self`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":550181,"byte_end":550235,"line_start":1206,"line_end":1206,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":550240,"byte_end":550257,"line_start":1207,"line_end":1207,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1320},"span":{"file_name":"src/libcore/mem.rs","byte_start":551682,"byte_end":551688,"line_start":1248,"line_end":1248,"column_start":12,"column_end":18},"name":"as_ptr","qualname":"<MaybeUninit<T>>::as_ptr","value":"fn (&self) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Gets a pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":551594,"byte_end":551648,"line_start":1246,"line_end":1246,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":551653,"byte_end":551670,"line_start":1247,"line_end":1247,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1322},"span":{"file_name":"src/libcore/mem.rs","byte_start":553096,"byte_end":553106,"line_start":1287,"line_end":1287,"column_start":12,"column_end":22},"name":"as_mut_ptr","qualname":"<MaybeUninit<T>>::as_mut_ptr","value":"fn (&mut self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":553008,"byte_end":553062,"line_start":1285,"line_end":1285,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":553067,"byte_end":553084,"line_start":1286,"line_end":1286,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1324},"span":{"file_name":"src/libcore/mem.rs","byte_start":554456,"byte_end":554467,"line_start":1327,"line_end":1327,"column_start":19,"column_end":30},"name":"assume_init","qualname":"<MaybeUninit<T>>::assume_init","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Extracts the value from the `MaybeUninit<T>` container. This is a great way\n to ensure that the data will get dropped, because the resulting `T` is\n subject to the usual drop handling.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":554361,"byte_end":554415,"line_start":1325,"line_end":1325,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":554420,"byte_end":554437,"line_start":1326,"line_end":1326,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1326},"span":{"file_name":"src/libcore/mem.rs","byte_start":556739,"byte_end":556743,"line_start":1389,"line_end":1389,"column_start":19,"column_end":23},"name":"read","qualname":"<MaybeUninit<T>>::read","value":"fn (&self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n to the usual drop handling.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":556644,"byte_end":556698,"line_start":1387,"line_end":1387,"column_start":5,"column_end":59}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":556703,"byte_end":556720,"line_start":1388,"line_end":1388,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1328},"span":{"file_name":"src/libcore/mem.rs","byte_start":557235,"byte_end":557242,"line_start":1403,"line_end":1403,"column_start":19,"column_end":26},"name":"get_ref","qualname":"<MaybeUninit<T>>::get_ref","value":"fn (&self) -> &T","parent":null,"children":[],"decl_id":null,"docs":" Gets a reference to the contained value.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":557136,"byte_end":557194,"line_start":1401,"line_end":1401,"column_start":5,"column_end":63}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":557199,"byte_end":557216,"line_start":1402,"line_end":1402,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1330},"span":{"file_name":"src/libcore/mem.rs","byte_start":557923,"byte_end":557930,"line_start":1419,"line_end":1419,"column_start":19,"column_end":26},"name":"get_mut","qualname":"<MaybeUninit<T>>::get_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable reference to the contained value.","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":557824,"byte_end":557882,"line_start":1417,"line_end":1417,"column_start":5,"column_end":63}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":557887,"byte_end":557904,"line_start":1418,"line_end":1418,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1332},"span":{"file_name":"src/libcore/mem.rs","byte_start":558142,"byte_end":558151,"line_start":1426,"line_end":1426,"column_start":12,"column_end":21},"name":"first_ptr","qualname":"<MaybeUninit<T>>::first_ptr","value":"fn (this: &[MaybeUninit<T>]) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Gets a pointer to the first element of the array.\n","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":558048,"byte_end":558108,"line_start":1424,"line_end":1424,"column_start":5,"column_end":65}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":558113,"byte_end":558130,"line_start":1425,"line_end":1425,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":1334},"span":{"file_name":"src/libcore/mem.rs","byte_start":558414,"byte_end":558427,"line_start":1433,"line_end":1433,"column_start":12,"column_end":25},"name":"first_ptr_mut","qualname":"<MaybeUninit<T>>::first_ptr_mut","value":"fn (this: &mut [MaybeUninit<T>]) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable pointer to the first element of the array.\n","sig":null,"attributes":[{"value":"unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")","span":{"file_name":"src/libcore/mem.rs","byte_start":558320,"byte_end":558380,"line_start":1431,"line_end":1431,"column_start":5,"column_end":65}},{"value":"inline(always)","span":{"file_name":"src/libcore/mem.rs","byte_start":558385,"byte_end":558402,"line_start":1432,"line_end":1432,"column_start":5,"column_end":22}}]},{"kind":"Mod","id":{"krate":0,"index":1336},"span":{"file_name":"src/libcore/ptr.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ptr","qualname":"::ptr","value":"src/libcore/ptr.rs","parent":null,"children":[{"krate":0,"index":1338},{"krate":0,"index":1340},{"krate":0,"index":1342},{"krate":0,"index":1348},{"krate":0,"index":1350},{"krate":0,"index":1352},{"krate":0,"index":1358},{"krate":0,"index":1364},{"krate":0,"index":1374},{"krate":0,"index":1376},{"krate":0,"index":1378},{"krate":0,"index":1380},{"krate":0,"index":1382},{"krate":0,"index":47094},{"krate":0,"index":47092},{"krate":0,"index":1384},{"krate":0,"index":1386},{"krate":0,"index":1388},{"krate":0,"index":1390},{"krate":0,"index":1396},{"krate":0,"index":1398},{"krate":0,"index":1400},{"krate":0,"index":1402},{"krate":0,"index":1404},{"krate":0,"index":1406},{"krate":0,"index":1408},{"krate":0,"index":1410},{"krate":0,"index":1444},{"krate":0,"index":1498},{"krate":0,"index":1508},{"krate":0,"index":1512},{"krate":0,"index":1514},{"krate":0,"index":1518},{"krate":0,"index":1520},{"krate":0,"index":1522},{"krate":0,"index":1526},{"krate":0,"index":1528},{"krate":0,"index":20970},{"krate":0,"index":20974},{"krate":0,"index":20976},{"krate":0,"index":20980},{"krate":0,"index":20984},{"krate":0,"index":20988},{"krate":0,"index":20992},{"krate":0,"index":20996},{"krate":0,"index":21000},{"krate":0,"index":21002},{"krate":0,"index":21006},{"krate":0,"index":21010},{"krate":0,"index":21014},{"krate":0,"index":21018},{"krate":0,"index":21022},{"krate":0,"index":21026},{"krate":0,"index":21028},{"krate":0,"index":21032},{"krate":0,"index":21036},{"krate":0,"index":21040},{"krate":0,"index":21044},{"krate":0,"index":21048},{"krate":0,"index":21052},{"krate":0,"index":21054},{"krate":0,"index":21058},{"krate":0,"index":21062},{"krate":0,"index":21066},{"krate":0,"index":21070},{"krate":0,"index":21074},{"krate":0,"index":21078},{"krate":0,"index":21080},{"krate":0,"index":21084},{"krate":0,"index":21088},{"krate":0,"index":21092},{"krate":0,"index":21096},{"krate":0,"index":21100},{"krate":0,"index":21104},{"krate":0,"index":21106},{"krate":0,"index":21110},{"krate":0,"index":21114},{"krate":0,"index":21118},{"krate":0,"index":21122},{"krate":0,"index":21126},{"krate":0,"index":21130},{"krate":0,"index":21132},{"krate":0,"index":21136},{"krate":0,"index":21140},{"krate":0,"index":21144},{"krate":0,"index":21148},{"krate":0,"index":21152},{"krate":0,"index":21156},{"krate":0,"index":21158},{"krate":0,"index":21162},{"krate":0,"index":21166},{"krate":0,"index":21170},{"krate":0,"index":21174},{"krate":0,"index":21178},{"krate":0,"index":21182},{"krate":0,"index":21184},{"krate":0,"index":21188},{"krate":0,"index":21192},{"krate":0,"index":21196},{"krate":0,"index":21200},{"krate":0,"index":21204},{"krate":0,"index":21208},{"krate":0,"index":21210},{"krate":0,"index":21214},{"krate":0,"index":21218},{"krate":0,"index":21222},{"krate":0,"index":21226},{"krate":0,"index":21230},{"krate":0,"index":21234},{"krate":0,"index":21236},{"krate":0,"index":21240},{"krate":0,"index":21244},{"krate":0,"index":21248},{"krate":0,"index":21252},{"krate":0,"index":21256},{"krate":0,"index":21260},{"krate":0,"index":21262},{"krate":0,"index":21266},{"krate":0,"index":21270},{"krate":0,"index":21274},{"krate":0,"index":21278},{"krate":0,"index":21282},{"krate":0,"index":21286},{"krate":0,"index":21288},{"krate":0,"index":21292},{"krate":0,"index":21296},{"krate":0,"index":21300},{"krate":0,"index":21304},{"krate":0,"index":21308},{"krate":0,"index":21312},{"krate":0,"index":21314},{"krate":0,"index":21318},{"krate":0,"index":21322},{"krate":0,"index":21326},{"krate":0,"index":21330},{"krate":0,"index":21334},{"krate":0,"index":21338},{"krate":0,"index":21340},{"krate":0,"index":21344},{"krate":0,"index":21348},{"krate":0,"index":21352},{"krate":0,"index":21356},{"krate":0,"index":21360},{"krate":0,"index":21364},{"krate":0,"index":21366},{"krate":0,"index":21370},{"krate":0,"index":21374},{"krate":0,"index":21378},{"krate":0,"index":21382},{"krate":0,"index":21386},{"krate":0,"index":21390},{"krate":0,"index":21392},{"krate":0,"index":21396},{"krate":0,"index":21400},{"krate":0,"index":21404},{"krate":0,"index":21408},{"krate":0,"index":21412},{"krate":0,"index":21416},{"krate":0,"index":21418},{"krate":0,"index":21422},{"krate":0,"index":21426},{"krate":0,"index":21430},{"krate":0,"index":21434},{"krate":0,"index":21438},{"krate":0,"index":21442},{"krate":0,"index":21444},{"krate":0,"index":21448},{"krate":0,"index":21452},{"krate":0,"index":21456},{"krate":0,"index":21460},{"krate":0,"index":21464},{"krate":0,"index":21468},{"krate":0,"index":21470},{"krate":0,"index":21474},{"krate":0,"index":21478},{"krate":0,"index":21482},{"krate":0,"index":21486},{"krate":0,"index":21490},{"krate":0,"index":21494},{"krate":0,"index":21496},{"krate":0,"index":21500},{"krate":0,"index":21504},{"krate":0,"index":21508},{"krate":0,"index":21512},{"krate":0,"index":21516},{"krate":0,"index":21520},{"krate":0,"index":21522},{"krate":0,"index":21526},{"krate":0,"index":21530},{"krate":0,"index":21534},{"krate":0,"index":21538},{"krate":0,"index":21542},{"krate":0,"index":21546},{"krate":0,"index":21548},{"krate":0,"index":21552},{"krate":0,"index":21556},{"krate":0,"index":21560},{"krate":0,"index":21564},{"krate":0,"index":21568},{"krate":0,"index":21572},{"krate":0,"index":21574},{"krate":0,"index":21578},{"krate":0,"index":21582},{"krate":0,"index":21586},{"krate":0,"index":21590},{"krate":0,"index":21594},{"krate":0,"index":21598},{"krate":0,"index":21600},{"krate":0,"index":21604},{"krate":0,"index":21608},{"krate":0,"index":21612},{"krate":0,"index":21616},{"krate":0,"index":21620},{"krate":0,"index":21624},{"krate":0,"index":21626},{"krate":0,"index":21630},{"krate":0,"index":21634},{"krate":0,"index":21638},{"krate":0,"index":21642},{"krate":0,"index":21646},{"krate":0,"index":21650},{"krate":0,"index":21652},{"krate":0,"index":21656},{"krate":0,"index":21660},{"krate":0,"index":21664},{"krate":0,"index":21668},{"krate":0,"index":21672},{"krate":0,"index":21676},{"krate":0,"index":21678},{"krate":0,"index":21682},{"krate":0,"index":21686},{"krate":0,"index":21690},{"krate":0,"index":21694},{"krate":0,"index":21698},{"krate":0,"index":21702},{"krate":0,"index":21704},{"krate":0,"index":21708},{"krate":0,"index":21712},{"krate":0,"index":21716},{"krate":0,"index":21720},{"krate":0,"index":21724},{"krate":0,"index":21728},{"krate":0,"index":21730},{"krate":0,"index":21734},{"krate":0,"index":21738},{"krate":0,"index":21742},{"krate":0,"index":21746},{"krate":0,"index":21750},{"krate":0,"index":21754},{"krate":0,"index":21756},{"krate":0,"index":21760},{"krate":0,"index":21764},{"krate":0,"index":21768},{"krate":0,"index":21772},{"krate":0,"index":21776},{"krate":0,"index":21780},{"krate":0,"index":21782},{"krate":0,"index":21786},{"krate":0,"index":21790},{"krate":0,"index":21794},{"krate":0,"index":21798},{"krate":0,"index":21802},{"krate":0,"index":21806},{"krate":0,"index":21808},{"krate":0,"index":21812},{"krate":0,"index":21816},{"krate":0,"index":21820},{"krate":0,"index":21824},{"krate":0,"index":21828},{"krate":0,"index":21832},{"krate":0,"index":21834},{"krate":0,"index":21838},{"krate":0,"index":21842},{"krate":0,"index":21846},{"krate":0,"index":21850},{"krate":0,"index":21854},{"krate":0,"index":21858},{"krate":0,"index":21860},{"krate":0,"index":21864},{"krate":0,"index":21868},{"krate":0,"index":21872},{"krate":0,"index":21876},{"krate":0,"index":21880},{"krate":0,"index":21884},{"krate":0,"index":21886},{"krate":0,"index":21890},{"krate":0,"index":21894},{"krate":0,"index":21898},{"krate":0,"index":21902},{"krate":0,"index":21906},{"krate":0,"index":21910},{"krate":0,"index":21912},{"krate":0,"index":21916},{"krate":0,"index":21920},{"krate":0,"index":21924},{"krate":0,"index":21928},{"krate":0,"index":21932},{"krate":0,"index":21936},{"krate":0,"index":21938},{"krate":0,"index":21942},{"krate":0,"index":21946},{"krate":0,"index":21950},{"krate":0,"index":21954},{"krate":0,"index":21958},{"krate":0,"index":21962},{"krate":0,"index":21964},{"krate":0,"index":21968},{"krate":0,"index":21972},{"krate":0,"index":21976},{"krate":0,"index":21980},{"krate":0,"index":21984},{"krate":0,"index":21988},{"krate":0,"index":21990},{"krate":0,"index":21994},{"krate":0,"index":21998},{"krate":0,"index":22002},{"krate":0,"index":22006},{"krate":0,"index":22010},{"krate":0,"index":22014},{"krate":0,"index":22016},{"krate":0,"index":22020},{"krate":0,"index":22024},{"krate":0,"index":22028},{"krate":0,"index":22032},{"krate":0,"index":22036},{"krate":0,"index":22040},{"krate":0,"index":22042},{"krate":0,"index":22046},{"krate":0,"index":22050},{"krate":0,"index":22054},{"krate":0,"index":22058},{"krate":0,"index":22062},{"krate":0,"index":22066},{"krate":0,"index":22068},{"krate":0,"index":22072},{"krate":0,"index":22076},{"krate":0,"index":22080},{"krate":0,"index":22084},{"krate":0,"index":22088},{"krate":0,"index":22092},{"krate":0,"index":22094},{"krate":0,"index":22098},{"krate":0,"index":22102},{"krate":0,"index":22106},{"krate":0,"index":22110},{"krate":0,"index":22114},{"krate":0,"index":22118},{"krate":0,"index":22120},{"krate":0,"index":22124},{"krate":0,"index":22128},{"krate":0,"index":22132},{"krate":0,"index":22136},{"krate":0,"index":22140},{"krate":0,"index":22144},{"krate":0,"index":22146},{"krate":0,"index":22150},{"krate":0,"index":22154},{"krate":0,"index":22158},{"krate":0,"index":22162},{"krate":0,"index":22166},{"krate":0,"index":22170},{"krate":0,"index":22172},{"krate":0,"index":22176},{"krate":0,"index":22180},{"krate":0,"index":22184},{"krate":0,"index":22188},{"krate":0,"index":22192},{"krate":0,"index":22196},{"krate":0,"index":22198},{"krate":0,"index":22202},{"krate":0,"index":22206},{"krate":0,"index":22210},{"krate":0,"index":22214},{"krate":0,"index":22218},{"krate":0,"index":22222},{"krate":0,"index":22224},{"krate":0,"index":22228},{"krate":0,"index":22232},{"krate":0,"index":22236},{"krate":0,"index":22240},{"krate":0,"index":22244},{"krate":0,"index":22248},{"krate":0,"index":22250},{"krate":0,"index":22254},{"krate":0,"index":22258},{"krate":0,"index":22262},{"krate":0,"index":22266},{"krate":0,"index":22270},{"krate":0,"index":22274},{"krate":0,"index":22276},{"krate":0,"index":22280},{"krate":0,"index":22284},{"krate":0,"index":22288},{"krate":0,"index":22292},{"krate":0,"index":22296},{"krate":0,"index":22300},{"krate":0,"index":22302},{"krate":0,"index":22306},{"krate":0,"index":22310},{"krate":0,"index":22314},{"krate":0,"index":22318},{"krate":0,"index":22322},{"krate":0,"index":22326},{"krate":0,"index":22328},{"krate":0,"index":22332},{"krate":0,"index":22336},{"krate":0,"index":22340},{"krate":0,"index":22344},{"krate":0,"index":22348},{"krate":0,"index":22352},{"krate":0,"index":22354},{"krate":0,"index":22358},{"krate":0,"index":22362},{"krate":0,"index":22366},{"krate":0,"index":22370},{"krate":0,"index":22374},{"krate":0,"index":22378},{"krate":0,"index":22380},{"krate":0,"index":22384},{"krate":0,"index":22388},{"krate":0,"index":22392},{"krate":0,"index":22396},{"krate":0,"index":22400},{"krate":0,"index":22404},{"krate":0,"index":22406},{"krate":0,"index":22410},{"krate":0,"index":22414},{"krate":0,"index":22418},{"krate":0,"index":22422},{"krate":0,"index":22426},{"krate":0,"index":22430},{"krate":0,"index":22432},{"krate":0,"index":22436},{"krate":0,"index":22440},{"krate":0,"index":22444},{"krate":0,"index":22448},{"krate":0,"index":22452},{"krate":0,"index":22456},{"krate":0,"index":22458},{"krate":0,"index":22462},{"krate":0,"index":22466},{"krate":0,"index":22470},{"krate":0,"index":22474},{"krate":0,"index":22478},{"krate":0,"index":22482},{"krate":0,"index":22484},{"krate":0,"index":22488},{"krate":0,"index":22492},{"krate":0,"index":22496},{"krate":0,"index":22500},{"krate":0,"index":22504},{"krate":0,"index":22508},{"krate":0,"index":22510},{"krate":0,"index":22514},{"krate":0,"index":22518},{"krate":0,"index":22522},{"krate":0,"index":22526},{"krate":0,"index":22530},{"krate":0,"index":22534},{"krate":0,"index":22536},{"krate":0,"index":22540},{"krate":0,"index":22544},{"krate":0,"index":22548},{"krate":0,"index":22552},{"krate":0,"index":22556},{"krate":0,"index":22560},{"krate":0,"index":22562},{"krate":0,"index":22566},{"krate":0,"index":22570},{"krate":0,"index":22574},{"krate":0,"index":22578},{"krate":0,"index":22582},{"krate":0,"index":22586},{"krate":0,"index":22588},{"krate":0,"index":22592},{"krate":0,"index":22596},{"krate":0,"index":22600},{"krate":0,"index":22604},{"krate":0,"index":22608},{"krate":0,"index":22612},{"krate":0,"index":22614},{"krate":0,"index":22618},{"krate":0,"index":22622},{"krate":0,"index":22626},{"krate":0,"index":22630},{"krate":0,"index":22634},{"krate":0,"index":22638},{"krate":0,"index":22640},{"krate":0,"index":22644},{"krate":0,"index":22648},{"krate":0,"index":22652},{"krate":0,"index":22656},{"krate":0,"index":22660},{"krate":0,"index":22664},{"krate":0,"index":22666},{"krate":0,"index":22670},{"krate":0,"index":22674},{"krate":0,"index":22678},{"krate":0,"index":22682},{"krate":0,"index":22686},{"krate":0,"index":22690},{"krate":0,"index":22692},{"krate":0,"index":22696},{"krate":0,"index":22700},{"krate":0,"index":22704},{"krate":0,"index":22708},{"krate":0,"index":22712},{"krate":0,"index":22716},{"krate":0,"index":22718},{"krate":0,"index":22722},{"krate":0,"index":22726},{"krate":0,"index":22730},{"krate":0,"index":22734},{"krate":0,"index":22738},{"krate":0,"index":22742},{"krate":0,"index":22744},{"krate":0,"index":22748},{"krate":0,"index":22752},{"krate":0,"index":22756},{"krate":0,"index":22760},{"krate":0,"index":22764},{"krate":0,"index":22768},{"krate":0,"index":22770},{"krate":0,"index":22774},{"krate":0,"index":22778},{"krate":0,"index":22782},{"krate":0,"index":22786},{"krate":0,"index":22790},{"krate":0,"index":22794},{"krate":0,"index":22796},{"krate":0,"index":22800},{"krate":0,"index":22804},{"krate":0,"index":22808},{"krate":0,"index":22812},{"krate":0,"index":22816},{"krate":0,"index":22820},{"krate":0,"index":22822},{"krate":0,"index":22826},{"krate":0,"index":22830},{"krate":0,"index":22834},{"krate":0,"index":22838},{"krate":0,"index":22842},{"krate":0,"index":22846},{"krate":0,"index":22848},{"krate":0,"index":22852},{"krate":0,"index":22856},{"krate":0,"index":22860},{"krate":0,"index":22864},{"krate":0,"index":22868},{"krate":0,"index":22872},{"krate":0,"index":22874},{"krate":0,"index":22878},{"krate":0,"index":22882},{"krate":0,"index":22886},{"krate":0,"index":22890},{"krate":0,"index":22894},{"krate":0,"index":22898},{"krate":0,"index":22900},{"krate":0,"index":22904},{"krate":0,"index":22908},{"krate":0,"index":22912},{"krate":0,"index":22916},{"krate":0,"index":22920},{"krate":0,"index":22924},{"krate":0,"index":22926},{"krate":0,"index":22930},{"krate":0,"index":22934},{"krate":0,"index":22938},{"krate":0,"index":22942},{"krate":0,"index":1530},{"krate":0,"index":1534},{"krate":0,"index":1546},{"krate":0,"index":1550},{"krate":0,"index":1562},{"krate":0,"index":1564},{"krate":0,"index":1568},{"krate":0,"index":1570},{"krate":0,"index":1572},{"krate":0,"index":1576},{"krate":0,"index":1588},{"krate":0,"index":1592},{"krate":0,"index":1594},{"krate":0,"index":1596},{"krate":0,"index":1598},{"krate":0,"index":1602},{"krate":0,"index":1606},{"krate":0,"index":1610},{"krate":0,"index":1614},{"krate":0,"index":1616},{"krate":0,"index":1618},{"krate":0,"index":1620},{"krate":0,"index":1624},{"krate":0,"index":1638},{"krate":0,"index":1642},{"krate":0,"index":1644},{"krate":0,"index":1646},{"krate":0,"index":1648},{"krate":0,"index":1652},{"krate":0,"index":1656},{"krate":0,"index":1658},{"krate":0,"index":1662},{"krate":0,"index":1666},{"krate":0,"index":1670},{"krate":0,"index":1674},{"krate":0,"index":1678},{"krate":0,"index":1682}],"decl_id":null,"docs":" Manually manage memory through raw pointers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":561932,"byte_end":561978,"line_start":64,"line_end":64,"column_start":1,"column_end":47}}]},{"kind":"Function","id":{"krate":0,"index":1380},"span":{"file_name":"src/libcore/ptr.rs","byte_start":565657,"byte_end":565670,"line_start":182,"line_end":182,"column_start":15,"column_end":28},"name":"drop_in_place","qualname":"::ptr::drop_in_place","value":"fn <T> (to_drop: *mut T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Executes the destructor (if any) of the pointed-to value.","sig":null,"attributes":[{"value":"stable(feature = \"drop_in_place\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":565571,"byte_end":565624,"line_start":180,"line_end":180,"column_start":1,"column_end":54}},{"value":"inline(always)","span":{"file_name":"src/libcore/ptr.rs","byte_start":565625,"byte_end":565642,"line_start":181,"line_end":181,"column_start":1,"column_end":18}}]},{"kind":"Function","id":{"krate":0,"index":47094},"span":{"file_name":"src/libcore/ptr.rs","byte_start":566610,"byte_end":566614,"line_start":212,"line_end":212,"column_start":14,"column_end":18},"name":"null","qualname":"::ptr::null","value":"fn <T> () -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Creates a null raw pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":566521,"byte_end":566530,"line_start":209,"line_end":209,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":566531,"byte_end":566576,"line_start":210,"line_end":210,"column_start":1,"column_end":46}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/ptr.rs","byte_start":566577,"byte_end":566596,"line_start":211,"line_end":211,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":47092},"span":{"file_name":"src/libcore/ptr.rs","byte_start":566906,"byte_end":566914,"line_start":227,"line_end":227,"column_start":14,"column_end":22},"name":"null_mut","qualname":"::ptr::null_mut","value":"fn <T> () -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Creates a null mutable raw pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":566817,"byte_end":566826,"line_start":224,"line_end":224,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":566827,"byte_end":566872,"line_start":225,"line_end":225,"column_start":1,"column_end":46}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/ptr.rs","byte_start":566873,"byte_end":566892,"line_start":226,"line_end":226,"column_start":1,"column_end":20}}]},{"kind":"Function","id":{"krate":0,"index":1384},"span":{"file_name":"src/libcore/ptr.rs","byte_start":569112,"byte_end":569116,"line_start":296,"line_end":296,"column_start":15,"column_end":19},"name":"swap","qualname":"::ptr::swap","value":"fn <T> (x: *mut T, y: *mut T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the values at two mutable locations of the same type, without\n deinitializing either.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":569042,"byte_end":569051,"line_start":294,"line_end":294,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":569052,"byte_end":569097,"line_start":295,"line_end":295,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1386},"span":{"file_name":"src/libcore/ptr.rs","byte_start":570651,"byte_end":570670,"line_start":347,"line_end":347,"column_start":15,"column_end":34},"name":"swap_nonoverlapping","qualname":"::ptr::swap_nonoverlapping","value":"fn <T> (x: *mut T, y: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps `count * size_of::<T>()` bytes between the two regions of memory\n beginning at `x` and `y`. The two regions must *not* overlap.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":570566,"byte_end":570575,"line_start":345,"line_end":345,"column_start":1,"column_end":10}},{"value":"stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":570576,"byte_end":570636,"line_start":346,"line_end":346,"column_start":1,"column_end":61}}]},{"kind":"Function","id":{"krate":0,"index":1396},"span":{"file_name":"src/libcore/ptr.rs","byte_start":574406,"byte_end":574413,"line_start":459,"line_end":459,"column_start":15,"column_end":22},"name":"replace","qualname":"::ptr::replace","value":"fn <T> (dst: *mut T, mut src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Moves `src` into the pointed `dst`, returning the previous `dst` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":574336,"byte_end":574345,"line_start":457,"line_end":457,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":574346,"byte_end":574391,"line_start":458,"line_end":458,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1398},"span":{"file_name":"src/libcore/ptr.rs","byte_start":577909,"byte_end":577913,"line_start":573,"line_end":573,"column_start":15,"column_end":19},"name":"read","qualname":"::ptr::read","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":577839,"byte_end":577848,"line_start":571,"line_end":571,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":577849,"byte_end":577894,"line_start":572,"line_end":572,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1400},"span":{"file_name":"src/libcore/ptr.rs","byte_start":579914,"byte_end":579928,"line_start":640,"line_end":640,"column_start":15,"column_end":29},"name":"read_unaligned","qualname":"::ptr::read_unaligned","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":579835,"byte_end":579844,"line_start":638,"line_end":638,"column_start":1,"column_end":10}},{"value":"stable(feature = \"ptr_unaligned\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":579845,"byte_end":579899,"line_start":639,"line_end":639,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":1402},"span":{"file_name":"src/libcore/ptr.rs","byte_start":582791,"byte_end":582796,"line_start":734,"line_end":734,"column_start":15,"column_end":20},"name":"write","qualname":"::ptr::write","value":"fn <T> (dst: *mut T, src: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Overwrites a memory location with the given value without reading or\n dropping the old value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":582721,"byte_end":582730,"line_start":732,"line_end":732,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":582731,"byte_end":582776,"line_start":733,"line_end":733,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":1404},"span":{"file_name":"src/libcore/ptr.rs","byte_start":584772,"byte_end":584787,"line_start":800,"line_end":800,"column_start":15,"column_end":30},"name":"write_unaligned","qualname":"::ptr::write_unaligned","value":"fn <T> (dst: *mut T, src: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Overwrites a memory location with the given value without reading or\n dropping the old value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":584693,"byte_end":584702,"line_start":798,"line_end":798,"column_start":1,"column_end":10}},{"value":"stable(feature = \"ptr_unaligned\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":584703,"byte_end":584757,"line_start":799,"line_end":799,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":1406},"span":{"file_name":"src/libcore/ptr.rs","byte_start":587483,"byte_end":587496,"line_start":874,"line_end":874,"column_start":15,"column_end":28},"name":"read_volatile","qualname":"::ptr::read_volatile","value":"fn <T> (src: *const T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile read of the value from `src` without moving it. This\n leaves the memory in `src` unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":587410,"byte_end":587419,"line_start":872,"line_end":872,"column_start":1,"column_end":10}},{"value":"stable(feature = \"volatile\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":587420,"byte_end":587468,"line_start":873,"line_end":873,"column_start":1,"column_end":49}}]},{"kind":"Function","id":{"krate":0,"index":1408},"span":{"file_name":"src/libcore/ptr.rs","byte_start":589994,"byte_end":590008,"line_start":945,"line_end":945,"column_start":15,"column_end":29},"name":"write_volatile","qualname":"::ptr::write_volatile","value":"fn <T> (dst: *mut T, src: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile write of a memory location with the given value without\n reading or dropping the old value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":589921,"byte_end":589930,"line_start":943,"line_end":943,"column_start":1,"column_end":10}},{"value":"stable(feature = \"volatile\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":589931,"byte_end":589979,"line_start":944,"line_end":944,"column_start":1,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":1412},"span":{"file_name":"src/libcore/ptr.rs","byte_start":590710,"byte_end":590717,"line_start":969,"line_end":969,"column_start":12,"column_end":19},"name":"is_null","qualname":"<*const T>::is_null","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the pointer is null.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":590639,"byte_end":590684,"line_start":967,"line_end":967,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":590689,"byte_end":590698,"line_start":968,"line_end":968,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1414},"span":{"file_name":"src/libcore/ptr.rs","byte_start":592315,"byte_end":592321,"line_start":1018,"line_end":1018,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<*const T>::as_ref","value":"fn <'a> (self) -> Option<&'a T>","parent":null,"children":[],"decl_id":null,"docs":" Returns `None` if the pointer is null, or else returns a reference to\n the value wrapped in `Some`.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_as_ref\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":592232,"byte_end":592282,"line_start":1016,"line_end":1016,"column_start":5,"column_end":55}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":592287,"byte_end":592296,"line_start":1017,"line_end":1017,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1416},"span":{"file_name":"src/libcore/ptr.rs","byte_start":594619,"byte_end":594625,"line_start":1076,"line_end":1076,"column_start":19,"column_end":25},"name":"offset","qualname":"<*const T>::offset","value":"fn (self, count: isize) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":594541,"byte_end":594586,"line_start":1074,"line_end":1074,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":594591,"byte_end":594600,"line_start":1075,"line_end":1075,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1418},"span":{"file_name":"src/libcore/ptr.rs","byte_start":596316,"byte_end":596331,"line_start":1120,"line_end":1120,"column_start":12,"column_end":27},"name":"wrapping_offset","qualname":"<*const T>::wrapping_offset","value":"fn (self, count: isize) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":596230,"byte_end":596290,"line_start":1118,"line_end":1118,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":596295,"byte_end":596304,"line_start":1119,"line_end":1119,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1420},"span":{"file_name":"src/libcore/ptr.rs","byte_start":599113,"byte_end":599124,"line_start":1189,"line_end":1189,"column_start":19,"column_end":30},"name":"offset_from","qualname":"<*const T>::offset_from","value":"fn (self, origin: *const T) -> isize","parent":null,"children":[],"decl_id":null,"docs":" Calculates the distance between two pointers. The returned value is in\n units of T: the distance in bytes is divided by `mem::size_of::<T>()`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_offset_from\", issue = \"41079\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":599023,"byte_end":599080,"line_start":1187,"line_end":1187,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":599085,"byte_end":599094,"line_start":1188,"line_end":1188,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1422},"span":{"file_name":"src/libcore/ptr.rs","byte_start":601034,"byte_end":601054,"line_start":1236,"line_end":1236,"column_start":12,"column_end":32},"name":"wrapping_offset_from","qualname":"<*const T>::wrapping_offset_from","value":"fn (self, origin: *const T) -> isize","parent":null,"children":[],"decl_id":null,"docs":" Calculates the distance between two pointers. The returned value is in\n units of T: the distance in bytes is divided by `mem::size_of::<T>()`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":600942,"byte_end":601008,"line_start":1234,"line_end":1234,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":601013,"byte_end":601022,"line_start":1235,"line_end":1235,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1424},"span":{"file_name":"src/libcore/ptr.rs","byte_start":603547,"byte_end":603550,"line_start":1294,"line_end":1294,"column_start":19,"column_end":22},"name":"add","qualname":"<*const T>::add","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer (convenience for `.offset(count as isize)`).","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":603458,"byte_end":603514,"line_start":1292,"line_end":1292,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":603519,"byte_end":603528,"line_start":1293,"line_end":1293,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1426},"span":{"file_name":"src/libcore/ptr.rs","byte_start":605897,"byte_end":605900,"line_start":1351,"line_end":1351,"column_start":19,"column_end":22},"name":"sub","qualname":"<*const T>::sub","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer (convenience for\n `.offset((count as isize).wrapping_neg())`).","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":605808,"byte_end":605864,"line_start":1349,"line_end":1349,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":605869,"byte_end":605878,"line_start":1350,"line_end":1350,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1428},"span":{"file_name":"src/libcore/ptr.rs","byte_start":607196,"byte_end":607208,"line_start":1392,"line_end":1392,"column_start":12,"column_end":24},"name":"wrapping_add","qualname":"<*const T>::wrapping_add","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n (convenience for `.wrapping_offset(count as isize)`)","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":607114,"byte_end":607170,"line_start":1390,"line_end":1390,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":607175,"byte_end":607184,"line_start":1391,"line_end":1391,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1430},"span":{"file_name":"src/libcore/ptr.rs","byte_start":608560,"byte_end":608572,"line_start":1433,"line_end":1433,"column_start":12,"column_end":24},"name":"wrapping_sub","qualname":"<*const T>::wrapping_sub","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":608478,"byte_end":608534,"line_start":1431,"line_end":1431,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":608539,"byte_end":608548,"line_start":1432,"line_end":1432,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1432},"span":{"file_name":"src/libcore/ptr.rs","byte_start":609018,"byte_end":609022,"line_start":1447,"line_end":1447,"column_start":19,"column_end":23},"name":"read","qualname":"<*const T>::read","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":608929,"byte_end":608985,"line_start":1445,"line_end":1445,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":608990,"byte_end":608999,"line_start":1446,"line_end":1446,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1434},"span":{"file_name":"src/libcore/ptr.rs","byte_start":609643,"byte_end":609656,"line_start":1465,"line_end":1465,"column_start":19,"column_end":32},"name":"read_volatile","qualname":"<*const T>::read_volatile","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile read of the value from `self` without moving it. This\n leaves the memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":609554,"byte_end":609610,"line_start":1463,"line_end":1463,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":609615,"byte_end":609624,"line_start":1464,"line_end":1464,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1436},"span":{"file_name":"src/libcore/ptr.rs","byte_start":610142,"byte_end":610156,"line_start":1481,"line_end":1481,"column_start":19,"column_end":33},"name":"read_unaligned","qualname":"<*const T>::read_unaligned","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":610053,"byte_end":610109,"line_start":1479,"line_end":1479,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":610114,"byte_end":610123,"line_start":1480,"line_end":1480,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1438},"span":{"file_name":"src/libcore/ptr.rs","byte_start":610633,"byte_end":610640,"line_start":1497,"line_end":1497,"column_start":19,"column_end":26},"name":"copy_to","qualname":"<*const T>::copy_to","value":"fn (self, dest: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n and destination may overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":610544,"byte_end":610600,"line_start":1495,"line_end":1495,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":610605,"byte_end":610614,"line_start":1496,"line_end":1496,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1440},"span":{"file_name":"src/libcore/ptr.rs","byte_start":611209,"byte_end":611231,"line_start":1513,"line_end":1513,"column_start":19,"column_end":41},"name":"copy_to_nonoverlapping","qualname":"<*const T>::copy_to_nonoverlapping","value":"fn (self, dest: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n and destination may *not* overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":611120,"byte_end":611176,"line_start":1511,"line_end":1511,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":611181,"byte_end":611190,"line_start":1512,"line_end":1512,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1442},"span":{"file_name":"src/libcore/ptr.rs","byte_start":612840,"byte_end":612852,"line_start":1558,"line_end":1558,"column_start":12,"column_end":24},"name":"align_offset","qualname":"<*const T>::align_offset","value":"fn (self, align: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Computes the offset that needs to be applied to the pointer in order to make it aligned to\n `align`.","sig":null,"attributes":[{"value":"unstable(feature = \"align_offset\", issue = \"44488\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":612774,"byte_end":612828,"line_start":1557,"line_end":1557,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":1446},"span":{"file_name":"src/libcore/ptr.rs","byte_start":613704,"byte_end":613711,"line_start":1589,"line_end":1589,"column_start":12,"column_end":19},"name":"is_null","qualname":"<*mut T>::is_null","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the pointer is null.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":613633,"byte_end":613678,"line_start":1587,"line_end":1587,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":613683,"byte_end":613692,"line_start":1588,"line_end":1588,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1448},"span":{"file_name":"src/libcore/ptr.rs","byte_start":615311,"byte_end":615317,"line_start":1638,"line_end":1638,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<*mut T>::as_ref","value":"fn <'a> (self) -> Option<&'a T>","parent":null,"children":[],"decl_id":null,"docs":" Returns `None` if the pointer is null, or else returns a reference to\n the value wrapped in `Some`.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_as_ref\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":615228,"byte_end":615278,"line_start":1636,"line_end":1636,"column_start":5,"column_end":55}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":615283,"byte_end":615292,"line_start":1637,"line_end":1637,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1450},"span":{"file_name":"src/libcore/ptr.rs","byte_start":617604,"byte_end":617610,"line_start":1696,"line_end":1696,"column_start":19,"column_end":25},"name":"offset","qualname":"<*mut T>::offset","value":"fn (self, count: isize) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":617526,"byte_end":617571,"line_start":1694,"line_end":1694,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":617576,"byte_end":617585,"line_start":1695,"line_end":1695,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1452},"span":{"file_name":"src/libcore/ptr.rs","byte_start":619300,"byte_end":619315,"line_start":1739,"line_end":1739,"column_start":12,"column_end":27},"name":"wrapping_offset","qualname":"<*mut T>::wrapping_offset","value":"fn (self, count: isize) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":619214,"byte_end":619274,"line_start":1737,"line_end":1737,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":619279,"byte_end":619288,"line_start":1738,"line_end":1738,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1454},"span":{"file_name":"src/libcore/ptr.rs","byte_start":620228,"byte_end":620234,"line_start":1767,"line_end":1767,"column_start":19,"column_end":25},"name":"as_mut","qualname":"<*mut T>::as_mut","value":"fn <'a> (self) -> Option<&'a mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns `None` if the pointer is null, or else returns a mutable\n reference to the value wrapped in `Some`.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_as_ref\", since = \"1.9.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":620145,"byte_end":620195,"line_start":1765,"line_end":1765,"column_start":5,"column_end":55}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":620200,"byte_end":620209,"line_start":1766,"line_end":1766,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1456},"span":{"file_name":"src/libcore/ptr.rs","byte_start":623036,"byte_end":623047,"line_start":1838,"line_end":1838,"column_start":19,"column_end":30},"name":"offset_from","qualname":"<*mut T>::offset_from","value":"fn (self, origin: *const T) -> isize","parent":null,"children":[],"decl_id":null,"docs":" Calculates the distance between two pointers. The returned value is in\n units of T: the distance in bytes is divided by `mem::size_of::<T>()`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_offset_from\", issue = \"41079\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":622946,"byte_end":623003,"line_start":1836,"line_end":1836,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":623008,"byte_end":623017,"line_start":1837,"line_end":1837,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1458},"span":{"file_name":"src/libcore/ptr.rs","byte_start":624528,"byte_end":624548,"line_start":1878,"line_end":1878,"column_start":12,"column_end":32},"name":"wrapping_offset_from","qualname":"<*mut T>::wrapping_offset_from","value":"fn (self, origin: *const T) -> isize","parent":null,"children":[],"decl_id":null,"docs":" Calculates the distance between two pointers. The returned value is in\n units of T: the distance in bytes is divided by `mem::size_of::<T>()`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":624436,"byte_end":624502,"line_start":1876,"line_end":1876,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":624507,"byte_end":624516,"line_start":1877,"line_end":1877,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1460},"span":{"file_name":"src/libcore/ptr.rs","byte_start":626863,"byte_end":626866,"line_start":1932,"line_end":1932,"column_start":19,"column_end":22},"name":"add","qualname":"<*mut T>::add","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer (convenience for `.offset(count as isize)`).","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":626774,"byte_end":626830,"line_start":1930,"line_end":1930,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":626835,"byte_end":626844,"line_start":1931,"line_end":1931,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1462},"span":{"file_name":"src/libcore/ptr.rs","byte_start":629213,"byte_end":629216,"line_start":1989,"line_end":1989,"column_start":19,"column_end":22},"name":"sub","qualname":"<*mut T>::sub","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer (convenience for\n `.offset((count as isize).wrapping_neg())`).","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":629124,"byte_end":629180,"line_start":1987,"line_end":1987,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":629185,"byte_end":629194,"line_start":1988,"line_end":1988,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1464},"span":{"file_name":"src/libcore/ptr.rs","byte_start":630512,"byte_end":630524,"line_start":2030,"line_end":2030,"column_start":12,"column_end":24},"name":"wrapping_add","qualname":"<*mut T>::wrapping_add","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n (convenience for `.wrapping_offset(count as isize)`)","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":630430,"byte_end":630486,"line_start":2028,"line_end":2028,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":630491,"byte_end":630500,"line_start":2029,"line_end":2029,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1466},"span":{"file_name":"src/libcore/ptr.rs","byte_start":631876,"byte_end":631888,"line_start":2071,"line_end":2071,"column_start":12,"column_end":24},"name":"wrapping_sub","qualname":"<*mut T>::wrapping_sub","value":"fn (self, count: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Calculates the offset from a pointer using wrapping arithmetic.\n (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":631794,"byte_end":631850,"line_start":2069,"line_end":2069,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":631855,"byte_end":631864,"line_start":2070,"line_end":2070,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1468},"span":{"file_name":"src/libcore/ptr.rs","byte_start":632334,"byte_end":632338,"line_start":2085,"line_end":2085,"column_start":19,"column_end":23},"name":"read","qualname":"<*mut T>::read","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":632245,"byte_end":632301,"line_start":2083,"line_end":2083,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":632306,"byte_end":632315,"line_start":2084,"line_end":2084,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1470},"span":{"file_name":"src/libcore/ptr.rs","byte_start":632959,"byte_end":632972,"line_start":2103,"line_end":2103,"column_start":19,"column_end":32},"name":"read_volatile","qualname":"<*mut T>::read_volatile","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile read of the value from `self` without moving it. This\n leaves the memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":632870,"byte_end":632926,"line_start":2101,"line_end":2101,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":632931,"byte_end":632940,"line_start":2102,"line_end":2102,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1472},"span":{"file_name":"src/libcore/ptr.rs","byte_start":633458,"byte_end":633472,"line_start":2119,"line_end":2119,"column_start":19,"column_end":33},"name":"read_unaligned","qualname":"<*mut T>::read_unaligned","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":633369,"byte_end":633425,"line_start":2117,"line_end":2117,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":633430,"byte_end":633439,"line_start":2118,"line_end":2118,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1474},"span":{"file_name":"src/libcore/ptr.rs","byte_start":633949,"byte_end":633956,"line_start":2135,"line_end":2135,"column_start":19,"column_end":26},"name":"copy_to","qualname":"<*mut T>::copy_to","value":"fn (self, dest: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n and destination may overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":633860,"byte_end":633916,"line_start":2133,"line_end":2133,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":633921,"byte_end":633930,"line_start":2134,"line_end":2134,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1476},"span":{"file_name":"src/libcore/ptr.rs","byte_start":634525,"byte_end":634547,"line_start":2151,"line_end":2151,"column_start":19,"column_end":41},"name":"copy_to_nonoverlapping","qualname":"<*mut T>::copy_to_nonoverlapping","value":"fn (self, dest: *mut T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n and destination may *not* overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":634436,"byte_end":634492,"line_start":2149,"line_end":2149,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":634497,"byte_end":634506,"line_start":2150,"line_end":2150,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1478},"span":{"file_name":"src/libcore/ptr.rs","byte_start":635068,"byte_end":635077,"line_start":2167,"line_end":2167,"column_start":19,"column_end":28},"name":"copy_from","qualname":"<*mut T>::copy_from","value":"fn (self, src: *const T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `src` to `self`. The source\n and destination may overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":634979,"byte_end":635035,"line_start":2165,"line_end":2165,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":635040,"byte_end":635049,"line_start":2166,"line_end":2166,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1480},"span":{"file_name":"src/libcore/ptr.rs","byte_start":635649,"byte_end":635673,"line_start":2183,"line_end":2183,"column_start":19,"column_end":43},"name":"copy_from_nonoverlapping","qualname":"<*mut T>::copy_from_nonoverlapping","value":"fn (self, src: *const T, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies `count * size_of<T>` bytes from `src` to `self`. The source\n and destination may *not* overlap.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":635560,"byte_end":635616,"line_start":2181,"line_end":2181,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":635621,"byte_end":635630,"line_start":2182,"line_end":2182,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1482},"span":{"file_name":"src/libcore/ptr.rs","byte_start":636096,"byte_end":636109,"line_start":2196,"line_end":2196,"column_start":19,"column_end":32},"name":"drop_in_place","qualname":"<*mut T>::drop_in_place","value":"fn (self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Executes the destructor (if any) of the pointed-to value.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":636007,"byte_end":636063,"line_start":2194,"line_end":2194,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":636068,"byte_end":636077,"line_start":2195,"line_end":2195,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1484},"span":{"file_name":"src/libcore/ptr.rs","byte_start":636476,"byte_end":636481,"line_start":2208,"line_end":2208,"column_start":19,"column_end":24},"name":"write","qualname":"<*mut T>::write","value":"fn (self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Overwrites a memory location with the given value without reading or\n dropping the old value.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":636387,"byte_end":636443,"line_start":2206,"line_end":2206,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":636448,"byte_end":636457,"line_start":2207,"line_end":2207,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1486},"span":{"file_name":"src/libcore/ptr.rs","byte_start":636925,"byte_end":636936,"line_start":2222,"line_end":2222,"column_start":19,"column_end":30},"name":"write_bytes","qualname":"<*mut T>::write_bytes","value":"fn (self, val: u8, count: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n bytes of memory starting at `self` to `val`.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":636836,"byte_end":636892,"line_start":2220,"line_end":2220,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":636897,"byte_end":636906,"line_start":2221,"line_end":2221,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1488},"span":{"file_name":"src/libcore/ptr.rs","byte_start":637595,"byte_end":637609,"line_start":2240,"line_end":2240,"column_start":19,"column_end":33},"name":"write_volatile","qualname":"<*mut T>::write_volatile","value":"fn (self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a volatile write of a memory location with the given value without\n reading or dropping the old value.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":637506,"byte_end":637562,"line_start":2238,"line_end":2238,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":637567,"byte_end":637576,"line_start":2239,"line_end":2239,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1490},"span":{"file_name":"src/libcore/ptr.rs","byte_start":638110,"byte_end":638125,"line_start":2256,"line_end":2256,"column_start":19,"column_end":34},"name":"write_unaligned","qualname":"<*mut T>::write_unaligned","value":"fn (self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Overwrites a memory location with the given value without reading or\n dropping the old value.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":638021,"byte_end":638077,"line_start":2254,"line_end":2254,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":638082,"byte_end":638091,"line_start":2255,"line_end":2255,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1492},"span":{"file_name":"src/libcore/ptr.rs","byte_start":638539,"byte_end":638546,"line_start":2270,"line_end":2270,"column_start":19,"column_end":26},"name":"replace","qualname":"<*mut T>::replace","value":"fn (self, src: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replaces the value at `self` with `src`, returning the old\n value, without dropping either.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":638450,"byte_end":638506,"line_start":2268,"line_end":2268,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":638511,"byte_end":638520,"line_start":2269,"line_end":2269,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1494},"span":{"file_name":"src/libcore/ptr.rs","byte_start":639024,"byte_end":639028,"line_start":2285,"line_end":2285,"column_start":19,"column_end":23},"name":"swap","qualname":"<*mut T>::swap","value":"fn (self, with: *mut T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the values at two mutable locations of the same type, without\n deinitializing either. They may overlap, unlike `mem::swap` which is\n otherwise equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"pointer_methods\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":638935,"byte_end":638991,"line_start":2283,"line_end":2283,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":638996,"byte_end":639005,"line_start":2284,"line_end":2284,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1496},"span":{"file_name":"src/libcore/ptr.rs","byte_start":640601,"byte_end":640613,"line_start":2330,"line_end":2330,"column_start":12,"column_end":24},"name":"align_offset","qualname":"<*mut T>::align_offset","value":"fn (self, align: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Computes the offset that needs to be applied to the pointer in order to make it aligned to\n `align`.","sig":null,"attributes":[{"value":"unstable(feature = \"align_offset\", issue = \"44488\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":640535,"byte_end":640589,"line_start":2329,"line_end":2329,"column_start":5,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":1520},"span":{"file_name":"src/libcore/ptr.rs","byte_start":648418,"byte_end":648420,"line_start":2551,"line_end":2551,"column_start":8,"column_end":10},"name":"eq","qualname":"::ptr::eq","value":"fn <T> (a: *const T, b: *const T) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Compares raw pointers for equality.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_eq\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":648353,"byte_end":648400,"line_start":2549,"line_end":2549,"column_start":1,"column_end":48}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":648401,"byte_end":648410,"line_start":2550,"line_end":2550,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":1522},"span":{"file_name":"src/libcore/ptr.rs","byte_start":649246,"byte_end":649250,"line_start":2582,"line_end":2582,"column_start":8,"column_end":12},"name":"hash","qualname":"::ptr::hash","value":"fn <T, S> (hashee: *const T, into: &mut S) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Hash a raw pointer.","sig":null,"attributes":[{"value":"stable(feature = \"ptr_hash\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":649189,"byte_end":649238,"line_start":2581,"line_end":2581,"column_start":1,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":1562},"span":{"file_name":"src/libcore/ptr.rs","byte_start":655683,"byte_end":655689,"line_start":2767,"line_end":2767,"column_start":12,"column_end":18},"name":"Unique","qualname":"::ptr::Unique","value":"Unique {  }","parent":null,"children":[{"krate":0,"index":969},{"krate":0,"index":971}],"decl_id":null,"docs":" A wrapper around a raw non-null `*mut T` that indicates that the possessor\n of this wrapper owns the referent. Useful for building abstractions like\n `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.","sig":null,"attributes":[{"value":"unstable(feature = \"ptr_internals\",\n           issue = \"0\",\n           reason =\n               \"use NonNull instead and consider PhantomData<T> (if you also use #[may_dangle]), Send, and/or Sync\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":655395,"byte_end":655591,"line_start":2761,"line_end":2763,"column_start":1,"column_end":75}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/ptr.rs","byte_start":655607,"byte_end":655627,"line_start":2765,"line_end":2765,"column_start":1,"column_end":21}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/ptr.rs","byte_start":655628,"byte_end":655671,"line_start":2766,"line_end":2766,"column_start":1,"column_end":44}}]},{"kind":"Method","id":{"krate":0,"index":1574},"span":{"file_name":"src/libcore/ptr.rs","byte_start":657499,"byte_end":657504,"line_start":2810,"line_end":2810,"column_start":18,"column_end":23},"name":"empty","qualname":"<Unique<T>>::empty","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Unique` that is dangling, but well-aligned.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1578},"span":{"file_name":"src/libcore/ptr.rs","byte_start":657820,"byte_end":657833,"line_start":2824,"line_end":2824,"column_start":25,"column_end":38},"name":"new_unchecked","qualname":"<Unique<T>>::new_unchecked","value":"fn (ptr: *mut T) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Unique`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1580},"span":{"file_name":"src/libcore/ptr.rs","byte_start":657987,"byte_end":657990,"line_start":2829,"line_end":2829,"column_start":12,"column_end":15},"name":"new","qualname":"<Unique<T>>::new","value":"fn (ptr: *mut T) -> Option<Self>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Unique` if `ptr` is non-null.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1582},"span":{"file_name":"src/libcore/ptr.rs","byte_start":658246,"byte_end":658252,"line_start":2838,"line_end":2838,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<Unique<T>>::as_ptr","value":"fn (self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Acquires the underlying `*mut` pointer.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1584},"span":{"file_name":"src/libcore/ptr.rs","byte_start":658584,"byte_end":658590,"line_start":2847,"line_end":2847,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<Unique<T>>::as_ref","value":"fn (&self) -> &T","parent":null,"children":[],"decl_id":null,"docs":" Dereferences the content.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":1586},"span":{"file_name":"src/libcore/ptr.rs","byte_start":658924,"byte_end":658930,"line_start":2856,"line_end":2856,"column_start":19,"column_end":25},"name":"as_mut","qualname":"<Unique<T>>::as_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Mutably dereferences the content.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":1614},"span":{"file_name":"src/libcore/ptr.rs","byte_start":662249,"byte_end":662256,"line_start":2936,"line_end":2936,"column_start":12,"column_end":19},"name":"NonNull","qualname":"::ptr::NonNull","value":"NonNull {  }","parent":null,"children":[{"krate":0,"index":1007}],"decl_id":null,"docs":" `*mut T` but non-zero and covariant.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":662124,"byte_end":662172,"line_start":2933,"line_end":2933,"column_start":1,"column_end":49}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/ptr.rs","byte_start":662173,"byte_end":662193,"line_start":2934,"line_end":2934,"column_start":1,"column_end":21}},{"value":"rustc_layout_scalar_valid_range_start(1)","span":{"file_name":"src/libcore/ptr.rs","byte_start":662194,"byte_end":662237,"line_start":2935,"line_end":2935,"column_start":1,"column_end":44}}]},{"kind":"Method","id":{"krate":0,"index":1622},"span":{"file_name":"src/libcore/ptr.rs","byte_start":663421,"byte_end":663429,"line_start":2963,"line_end":2963,"column_start":18,"column_end":26},"name":"dangling","qualname":"<NonNull<T>>::dangling","value":"fn () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `NonNull` that is dangling, but well-aligned.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":663282,"byte_end":663330,"line_start":2960,"line_end":2960,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":663335,"byte_end":663344,"line_start":2961,"line_end":2961,"column_start":5,"column_end":14}},{"value":"rustc_const_unstable(feature = \"const_ptr_nonnull\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":663349,"byte_end":663403,"line_start":2962,"line_end":2962,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":1626},"span":{"file_name":"src/libcore/ptr.rs","byte_start":663790,"byte_end":663803,"line_start":2979,"line_end":2979,"column_start":25,"column_end":38},"name":"new_unchecked","qualname":"<NonNull<T>>::new_unchecked","value":"fn (ptr: *mut T) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `NonNull`.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":663703,"byte_end":663751,"line_start":2977,"line_end":2977,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":663756,"byte_end":663765,"line_start":2978,"line_end":2978,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1628},"span":{"file_name":"src/libcore/ptr.rs","byte_start":664004,"byte_end":664007,"line_start":2986,"line_end":2986,"column_start":12,"column_end":15},"name":"new","qualname":"<NonNull<T>>::new","value":"fn (ptr: *mut T) -> Option<Self>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `NonNull` if `ptr` is non-null.\n","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":663930,"byte_end":663978,"line_start":2984,"line_end":2984,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":663983,"byte_end":663992,"line_start":2985,"line_end":2985,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1630},"span":{"file_name":"src/libcore/ptr.rs","byte_start":664304,"byte_end":664310,"line_start":2997,"line_end":2997,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<NonNull<T>>::as_ptr","value":"fn (self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Acquires the underlying `*mut` pointer.\n","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":664224,"byte_end":664272,"line_start":2995,"line_end":2995,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":664277,"byte_end":664286,"line_start":2996,"line_end":2996,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1632},"span":{"file_name":"src/libcore/ptr.rs","byte_start":664709,"byte_end":664715,"line_start":3008,"line_end":3008,"column_start":19,"column_end":25},"name":"as_ref","qualname":"<NonNull<T>>::as_ref","value":"fn (&self) -> &T","parent":null,"children":[],"decl_id":null,"docs":" Dereferences the content.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":664628,"byte_end":664676,"line_start":3006,"line_end":3006,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":664681,"byte_end":664690,"line_start":3007,"line_end":3007,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1634},"span":{"file_name":"src/libcore/ptr.rs","byte_start":665116,"byte_end":665122,"line_start":3019,"line_end":3019,"column_start":19,"column_end":25},"name":"as_mut","qualname":"<NonNull<T>>::as_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Mutably dereferences the content.","sig":null,"attributes":[{"value":"stable(feature = \"nonnull\", since = \"1.25.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":665035,"byte_end":665083,"line_start":3017,"line_end":3017,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":665088,"byte_end":665097,"line_start":3018,"line_end":3018,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":1636},"span":{"file_name":"src/libcore/ptr.rs","byte_start":665371,"byte_end":665375,"line_start":3027,"line_end":3027,"column_start":18,"column_end":22},"name":"cast","qualname":"<NonNull<T>>::cast","value":"fn <U> (self) -> NonNull<U>","parent":null,"children":[],"decl_id":null,"docs":" Cast to a pointer of another type\n","sig":null,"attributes":[{"value":"stable(feature = \"nonnull_cast\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":665227,"byte_end":665280,"line_start":3024,"line_end":3024,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/ptr.rs","byte_start":665285,"byte_end":665294,"line_start":3025,"line_end":3025,"column_start":5,"column_end":14}},{"value":"rustc_const_unstable(feature = \"const_ptr_nonnull\")","span":{"file_name":"src/libcore/ptr.rs","byte_start":665299,"byte_end":665353,"line_start":3026,"line_end":3026,"column_start":5,"column_end":59}}]},{"kind":"Mod","id":{"krate":0,"index":1686},"span":{"file_name":"src/libcore/hint.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"hint","qualname":"::hint","value":"src/libcore/hint.rs","parent":null,"children":[{"krate":0,"index":1688},{"krate":0,"index":1690},{"krate":0,"index":1692},{"krate":0,"index":1694}],"decl_id":null,"docs":" Hints to compiler that affects how code should be emitted or optimized.\n","sig":null,"attributes":[{"value":"stable(feature = \"core_hint\", since = \"1.27.0\")","span":{"file_name":"src/libcore/hint.rs","byte_start":668014,"byte_end":668065,"line_start":1,"line_end":1,"column_start":1,"column_end":52}}]},{"kind":"Function","id":{"krate":0,"index":1690},"span":{"file_name":"src/libcore/hint.rs","byte_start":669745,"byte_end":669766,"line_start":48,"line_end":48,"column_start":15,"column_end":36},"name":"unreachable_unchecked","qualname":"::hint::unreachable_unchecked","value":"fn () -> !","parent":null,"children":[],"decl_id":null,"docs":" Informs the compiler that this point in the code is not reachable, enabling\n further optimizations.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hint.rs","byte_start":669668,"byte_end":669677,"line_start":46,"line_end":46,"column_start":1,"column_end":10}},{"value":"stable(feature = \"unreachable\", since = \"1.27.0\")","span":{"file_name":"src/libcore/hint.rs","byte_start":669678,"byte_end":669730,"line_start":47,"line_end":47,"column_start":1,"column_end":53}}]},{"kind":"Function","id":{"krate":0,"index":1692},"span":{"file_name":"src/libcore/hint.rs","byte_start":671271,"byte_end":671280,"line_start":76,"line_end":76,"column_start":8,"column_end":17},"name":"spin_loop","qualname":"::hint::spin_loop","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Signals the processor that it is entering a busy-wait spin-loop.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hint.rs","byte_start":671194,"byte_end":671203,"line_start":74,"line_end":74,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"renamed_spin_loop\", issue = \"55002\")","span":{"file_name":"src/libcore/hint.rs","byte_start":671204,"byte_end":671263,"line_start":75,"line_end":75,"column_start":1,"column_end":60}}]},{"kind":"Function","id":{"krate":0,"index":1694},"span":{"file_name":"src/libcore/hint.rs","byte_start":672283,"byte_end":672292,"line_start":114,"line_end":114,"column_start":8,"column_end":17},"name":"black_box","qualname":"::hint::black_box","value":"fn <T> (dummy: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" A function that is opaque to the optimizer, to allow benchmarks to\n pretend to use outputs to assist in avoiding dead-code\n elimination.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hint.rs","byte_start":672219,"byte_end":672228,"line_start":112,"line_end":112,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"test\", issue = \"27812\")","span":{"file_name":"src/libcore/hint.rs","byte_start":672229,"byte_end":672275,"line_start":113,"line_end":113,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":1696},"span":{"file_name":"src/libcore/marker.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"marker","qualname":"::marker","value":"src/libcore/marker.rs","parent":null,"children":[{"krate":0,"index":1698},{"krate":0,"index":1700},{"krate":0,"index":1702},{"krate":0,"index":1704},{"krate":0,"index":1706},{"krate":0,"index":1708},{"krate":0,"index":1710},{"krate":0,"index":1712},{"krate":0,"index":1714},{"krate":0,"index":1716},{"krate":0,"index":1718},{"krate":0,"index":1720},{"krate":0,"index":1722},{"krate":0,"index":1724},{"krate":0,"index":1726},{"krate":0,"index":22948},{"krate":0,"index":22952},{"krate":0,"index":22956},{"krate":0,"index":22958},{"krate":0,"index":22962},{"krate":0,"index":22966},{"krate":0,"index":22968},{"krate":0,"index":22972},{"krate":0,"index":1728},{"krate":0,"index":1734},{"krate":0,"index":1736},{"krate":0,"index":1738},{"krate":0,"index":1740},{"krate":0,"index":1742},{"krate":0,"index":1744},{"krate":0,"index":1746},{"krate":0,"index":1748},{"krate":0,"index":22976},{"krate":0,"index":23004},{"krate":0,"index":23002},{"krate":0,"index":22998},{"krate":0,"index":22994},{"krate":0,"index":22990},{"krate":0,"index":22986},{"krate":0,"index":22982},{"krate":0,"index":22978},{"krate":0,"index":1750},{"krate":0,"index":1752},{"krate":0,"index":1754},{"krate":0,"index":1756}],"decl_id":null,"docs":" Primitive traits and types representing basic properties of types.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":673330,"byte_end":673376,"line_start":7,"line_end":7,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":1706},"span":{"file_name":"src/libcore/marker.rs","byte_start":674520,"byte_end":674524,"line_start":36,"line_end":36,"column_start":23,"column_end":27},"name":"Send","qualname":"::marker::Send","value":"Send","parent":null,"children":[],"decl_id":null,"docs":" Types that can be transferred across thread boundaries.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":674302,"byte_end":674347,"line_start":31,"line_end":31,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message =\n                             \"`{Self}` cannot be sent between threads safely\",\n                         label =\n                             \"`{Self}` cannot be sent between threads safely\")","span":{"file_name":"src/libcore/marker.rs","byte_start":674348,"byte_end":674497,"line_start":32,"line_end":35,"column_start":1,"column_end":3}}]},{"kind":"Trait","id":{"krate":0,"index":1712},"span":{"file_name":"src/libcore/marker.rs","byte_start":676489,"byte_end":676494,"line_start":92,"line_end":92,"column_start":11,"column_end":16},"name":"Sized","qualname":"::marker::Sized","value":"Sized","parent":null,"children":[],"decl_id":null,"docs":" Types with a constant size known at compile time.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":675923,"byte_end":675968,"line_start":82,"line_end":82,"column_start":1,"column_end":46}},{"value":"lang = \"sized\"","span":{"file_name":"src/libcore/marker.rs","byte_start":675969,"byte_end":675986,"line_start":83,"line_end":83,"column_start":1,"column_end":18}},{"value":"rustc_on_unimplemented(on(parent_trait = \"std::path::Path\",\n                            label = \"borrow the `Path` instead\"),\n                         message =\n                             \"the size for values of type `{Self}` cannot be known at compilation time\",\n                         label = \"doesn\\'t have a size known at compile-time\",\n                         note =\n                             \"to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\")","span":{"file_name":"src/libcore/marker.rs","byte_start":675987,"byte_end":676383,"line_start":84,"line_end":90,"column_start":1,"column_end":3}},{"value":"fundamental","span":{"file_name":"src/libcore/marker.rs","byte_start":676384,"byte_end":676398,"line_start":91,"line_end":91,"column_start":1,"column_end":15}}]},{"kind":"Trait","id":{"krate":0,"index":1714},"span":{"file_name":"src/libcore/marker.rs","byte_start":677783,"byte_end":677789,"line_start":125,"line_end":125,"column_start":11,"column_end":17},"name":"Unsize","qualname":"::marker::Unsize","value":"Unsize<T: ?Sized>","parent":null,"children":[],"decl_id":null,"docs":" Types that can be \"unsized\" to a dynamically-sized type.","sig":null,"attributes":[{"value":"unstable(feature = \"unsize\", issue = \"27732\")","span":{"file_name":"src/libcore/marker.rs","byte_start":677705,"byte_end":677753,"line_start":123,"line_end":123,"column_start":1,"column_end":49}},{"value":"lang = \"unsize\"","span":{"file_name":"src/libcore/marker.rs","byte_start":677754,"byte_end":677772,"line_start":124,"line_end":124,"column_start":1,"column_end":19}}]},{"kind":"Trait","id":{"krate":0,"index":1716},"span":{"file_name":"src/libcore/marker.rs","byte_start":683343,"byte_end":683347,"line_start":287,"line_end":287,"column_start":11,"column_end":15},"name":"Copy","qualname":"::marker::Copy","value":"Copy: Clone","parent":null,"children":[],"decl_id":null,"docs":" Types whose values can be duplicated simply by copying bits.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":683270,"byte_end":683315,"line_start":285,"line_end":285,"column_start":1,"column_end":46}},{"value":"lang = \"copy\"","span":{"file_name":"src/libcore/marker.rs","byte_start":683316,"byte_end":683332,"line_start":286,"line_end":286,"column_start":1,"column_end":17}}]},{"kind":"Trait","id":{"krate":0,"index":1718},"span":{"file_name":"src/libcore/marker.rs","byte_start":687010,"byte_end":687014,"line_start":365,"line_end":365,"column_start":23,"column_end":27},"name":"Sync","qualname":"::marker::Sync","value":"Sync","parent":null,"children":[],"decl_id":null,"docs":" Types for which it is safe to share references between threads.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":686771,"byte_end":686816,"line_start":359,"line_end":359,"column_start":1,"column_end":46}},{"value":"lang = \"sync\"","span":{"file_name":"src/libcore/marker.rs","byte_start":686817,"byte_end":686833,"line_start":360,"line_end":360,"column_start":1,"column_end":17}},{"value":"rustc_on_unimplemented(message =\n                             \"`{Self}` cannot be shared between threads safely\",\n                         label =\n                             \"`{Self}` cannot be shared between threads safely\")","span":{"file_name":"src/libcore/marker.rs","byte_start":686834,"byte_end":686987,"line_start":361,"line_end":364,"column_start":1,"column_end":3}}]},{"kind":"Struct","id":{"krate":0,"index":1726},"span":{"file_name":"src/libcore/marker.rs","byte_start":693876,"byte_end":693887,"line_start":573,"line_end":573,"column_start":12,"column_end":23},"name":"PhantomData","qualname":"::marker::PhantomData","value":"","parent":null,"children":[],"decl_id":null,"docs":" Zero-sized type used to mark things that \"act like\" they own a `T`.","sig":null,"attributes":[{"value":"lang = \"phantom_data\"","span":{"file_name":"src/libcore/marker.rs","byte_start":693774,"byte_end":693798,"line_start":570,"line_end":570,"column_start":1,"column_end":25}},{"value":"structural_match","span":{"file_name":"src/libcore/marker.rs","byte_start":693799,"byte_end":693818,"line_start":571,"line_end":571,"column_start":1,"column_end":20}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":693819,"byte_end":693864,"line_start":572,"line_end":572,"column_start":1,"column_end":46}}]},{"kind":"Trait","id":{"krate":0,"index":1748},"span":{"file_name":"src/libcore/marker.rs","byte_start":696633,"byte_end":696638,"line_start":640,"line_end":640,"column_start":16,"column_end":21},"name":"Unpin","qualname":"::marker::Unpin","value":"Unpin","parent":null,"children":[],"decl_id":null,"docs":" Types which can be safely moved after being pinned.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":696555,"byte_end":696599,"line_start":638,"line_end":638,"column_start":1,"column_end":45}},{"value":"lang = \"unpin\"","span":{"file_name":"src/libcore/marker.rs","byte_start":696600,"byte_end":696617,"line_start":639,"line_end":639,"column_start":1,"column_end":18}}]},{"kind":"Struct","id":{"krate":0,"index":22976},"span":{"file_name":"src/libcore/marker.rs","byte_start":696907,"byte_end":696920,"line_start":647,"line_end":647,"column_start":12,"column_end":25},"name":"PhantomPinned","qualname":"::marker::PhantomPinned","value":"","parent":null,"children":[],"decl_id":null,"docs":" A marker type which does not implement `Unpin`.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/marker.rs","byte_start":696783,"byte_end":696827,"line_start":645,"line_end":645,"column_start":1,"column_end":45}},{"value":"structural_match","span":{"file_name":"src/libcore/marker.rs","byte_start":696896,"byte_end":696921,"line_start":647,"line_end":647,"column_start":1,"column_end":26}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/marker.rs","byte_start":696896,"byte_end":696921,"line_start":647,"line_end":647,"column_start":1,"column_end":26}}]},{"kind":"Mod","id":{"krate":0,"index":1770},"span":{"file_name":"src/libcore/ops/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ops","qualname":"::ops","value":"src/libcore/ops/mod.rs","parent":null,"children":[{"krate":0,"index":1772},{"krate":0,"index":1860},{"krate":0,"index":1948},{"krate":0,"index":1982},{"krate":0,"index":1988},{"krate":0,"index":2030},{"krate":0,"index":2060},{"krate":0,"index":2072},{"krate":0,"index":2256},{"krate":0,"index":2270},{"krate":0,"index":2304},{"krate":0,"index":2318},{"krate":0,"index":2330},{"krate":0,"index":2344},{"krate":0,"index":2356},{"krate":0,"index":2362},{"krate":0,"index":2364},{"krate":0,"index":2366},{"krate":0,"index":2374},{"krate":0,"index":2380},{"krate":0,"index":2390},{"krate":0,"index":2400},{"krate":0,"index":2402},{"krate":0,"index":2408},{"krate":0,"index":2410}],"decl_id":null,"docs":" Overloadable operators.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/mod.rs","byte_start":703126,"byte_end":703172,"line_start":145,"line_end":145,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":1774},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":706825,"byte_end":706828,"line_start":81,"line_end":81,"column_start":11,"column_end":14},"name":"Add","qualname":"::ops::arith::Add","value":"Add<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1776},{"krate":0,"index":1778}],"decl_id":null,"docs":" The addition operator `+`.","sig":null,"attributes":[{"value":"lang = \"add\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":706378,"byte_end":706393,"line_start":66,"line_end":66,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":706394,"byte_end":706439,"line_start":67,"line_end":67,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(on(all(_Self = \"{integer}\", Rhs = \"{float}\"),\n                            message = \"cannot add a float to an integer\"),\n                         on(all(_Self = \"{float}\", Rhs = \"{integer}\"),\n                            message = \"cannot add an integer to a float\"),\n                         message = \"cannot add `{Rhs}` to `{Self}`\",\n                         label = \"no implementation for `{Self} + {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":706440,"byte_end":706794,"line_start":68,"line_end":79,"column_start":1,"column_end":3}}]},{"kind":"Type","id":{"krate":0,"index":1776},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":706960,"byte_end":706966,"line_start":84,"line_end":84,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Add::Output","value":"type Output;","parent":{"krate":0,"index":1774},"children":[],"decl_id":null,"docs":" The resulting type after applying the `+` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":706905,"byte_end":706950,"line_start":83,"line_end":83,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1778},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":707078,"byte_end":707081,"line_start":89,"line_end":89,"column_start":8,"column_end":11},"name":"add","qualname":"::ops::arith::Add::add","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1774},"children":[],"decl_id":null,"docs":" Performs the `+` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":707009,"byte_end":707020,"line_start":87,"line_end":87,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":707025,"byte_end":707070,"line_start":88,"line_end":88,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1782},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709364,"byte_end":709367,"line_start":179,"line_end":179,"column_start":11,"column_end":14},"name":"Sub","qualname":"::ops::arith::Sub","value":"Sub<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1784},{"krate":0,"index":1786}],"decl_id":null,"docs":" The subtraction operator `-`.","sig":null,"attributes":[{"value":"lang = \"sub\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709124,"byte_end":709139,"line_start":174,"line_end":174,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709140,"byte_end":709185,"line_start":175,"line_end":175,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"cannot subtract `{Rhs}` from `{Self}`\",\n                         label = \"no implementation for `{Self} - {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709186,"byte_end":709333,"line_start":176,"line_end":177,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1784},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709499,"byte_end":709505,"line_start":182,"line_end":182,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Sub::Output","value":"type Output;","parent":{"krate":0,"index":1782},"children":[],"decl_id":null,"docs":" The resulting type after applying the `-` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709444,"byte_end":709489,"line_start":181,"line_end":181,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1786},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709617,"byte_end":709620,"line_start":187,"line_end":187,"column_start":8,"column_end":11},"name":"sub","qualname":"::ops::arith::Sub::sub","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1782},"children":[],"decl_id":null,"docs":" Performs the `-` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709548,"byte_end":709559,"line_start":185,"line_end":185,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":709564,"byte_end":709609,"line_start":186,"line_end":186,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1790},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":712778,"byte_end":712781,"line_start":299,"line_end":299,"column_start":11,"column_end":14},"name":"Mul","qualname":"::ops::arith::Mul","value":"Mul<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1792},{"krate":0,"index":1794}],"decl_id":null,"docs":" The multiplication operator `*`.","sig":null,"attributes":[{"value":"lang = \"mul\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":712540,"byte_end":712555,"line_start":294,"line_end":294,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":712556,"byte_end":712601,"line_start":295,"line_end":295,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"cannot multiply `{Rhs}` to `{Self}`\",\n                         label = \"no implementation for `{Self} * {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":712602,"byte_end":712747,"line_start":296,"line_end":297,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1792},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":712913,"byte_end":712919,"line_start":302,"line_end":302,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Mul::Output","value":"type Output;","parent":{"krate":0,"index":1790},"children":[],"decl_id":null,"docs":" The resulting type after applying the `*` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":712858,"byte_end":712903,"line_start":301,"line_end":301,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1794},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":713031,"byte_end":713034,"line_start":307,"line_end":307,"column_start":8,"column_end":11},"name":"mul","qualname":"::ops::arith::Mul::mul","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1790},"children":[],"decl_id":null,"docs":" Performs the `*` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":712962,"byte_end":712973,"line_start":305,"line_end":305,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":712978,"byte_end":713023,"line_start":306,"line_end":306,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1798},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716317,"byte_end":716320,"line_start":423,"line_end":423,"column_start":11,"column_end":14},"name":"Div","qualname":"::ops::arith::Div","value":"Div<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1800},{"krate":0,"index":1802}],"decl_id":null,"docs":" The division operator `/`.","sig":null,"attributes":[{"value":"lang = \"div\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716081,"byte_end":716096,"line_start":418,"line_end":418,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716097,"byte_end":716142,"line_start":419,"line_end":419,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"cannot divide `{Self}` by `{Rhs}`\",\n                         label = \"no implementation for `{Self} / {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716143,"byte_end":716286,"line_start":420,"line_end":421,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1800},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716452,"byte_end":716458,"line_start":426,"line_end":426,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Div::Output","value":"type Output;","parent":{"krate":0,"index":1798},"children":[],"decl_id":null,"docs":" The resulting type after applying the `/` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716397,"byte_end":716442,"line_start":425,"line_end":425,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1802},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716570,"byte_end":716573,"line_start":431,"line_end":431,"column_start":8,"column_end":11},"name":"div","qualname":"::ops::arith::Div::div","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1798},"children":[],"decl_id":null,"docs":" Performs the `/` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716501,"byte_end":716512,"line_start":429,"line_end":429,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":716517,"byte_end":716562,"line_start":430,"line_end":430,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1808},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":718784,"byte_end":718787,"line_start":508,"line_end":508,"column_start":11,"column_end":14},"name":"Rem","qualname":"::ops::arith::Rem","value":"Rem<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1810},{"krate":0,"index":1812}],"decl_id":null,"docs":" The remainder operator `%`.","sig":null,"attributes":[{"value":"lang = \"rem\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":718551,"byte_end":718566,"line_start":503,"line_end":503,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":718567,"byte_end":718612,"line_start":504,"line_end":504,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"cannot mod `{Self}` by `{Rhs}`\",\n                         label = \"no implementation for `{Self} % {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":718613,"byte_end":718753,"line_start":505,"line_end":506,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1810},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":718919,"byte_end":718925,"line_start":511,"line_end":511,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Rem::Output","value":"type Output = Self;","parent":{"krate":0,"index":1808},"children":[],"decl_id":null,"docs":" The resulting type after applying the `%` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":718864,"byte_end":718909,"line_start":510,"line_end":510,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1812},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":719044,"byte_end":719047,"line_start":516,"line_end":516,"column_start":8,"column_end":11},"name":"rem","qualname":"::ops::arith::Rem::rem","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1808},"children":[],"decl_id":null,"docs":" Performs the `%` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":718975,"byte_end":718986,"line_start":514,"line_end":514,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":718991,"byte_end":719036,"line_start":515,"line_end":515,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1818},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":721399,"byte_end":721402,"line_start":608,"line_end":608,"column_start":11,"column_end":14},"name":"Neg","qualname":"::ops::arith::Neg","value":"Neg","parent":null,"children":[{"krate":0,"index":1820},{"krate":0,"index":1822}],"decl_id":null,"docs":" The unary negation operator `-`.","sig":null,"attributes":[{"value":"lang = \"neg\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":721307,"byte_end":721322,"line_start":605,"line_end":605,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":721323,"byte_end":721368,"line_start":606,"line_end":606,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":1820},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":721524,"byte_end":721530,"line_start":611,"line_end":611,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::arith::Neg::Output","value":"type Output;","parent":{"krate":0,"index":1818},"children":[],"decl_id":null,"docs":" The resulting type after applying the `-` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":721469,"byte_end":721514,"line_start":610,"line_end":610,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1822},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":721648,"byte_end":721651,"line_start":616,"line_end":616,"column_start":8,"column_end":11},"name":"neg","qualname":"::ops::arith::Neg::neg","value":"fn (self) -> Self::Output","parent":{"krate":0,"index":1818},"children":[],"decl_id":null,"docs":" Performs the unary `-` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":721579,"byte_end":721590,"line_start":614,"line_end":614,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":721595,"byte_end":721640,"line_start":615,"line_end":615,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1830},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":723396,"byte_end":723405,"line_start":686,"line_end":686,"column_start":11,"column_end":20},"name":"AddAssign","qualname":"::ops::arith::AddAssign","value":"AddAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1832}],"decl_id":null,"docs":" The addition assignment operator `+=`.","sig":null,"attributes":[{"value":"lang = \"add_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":723116,"byte_end":723138,"line_start":680,"line_end":680,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":723139,"byte_end":723195,"line_start":681,"line_end":681,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"cannot add-assign `{Rhs}` to `{Self}`\",\n                         label = \"no implementation for `{Self} += {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":723196,"byte_end":723344,"line_start":682,"line_end":683,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1832},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":723523,"byte_end":723533,"line_start":689,"line_end":689,"column_start":8,"column_end":18},"name":"add_assign","qualname":"::ops::arith::AddAssign::add_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1830},"children":[],"decl_id":null,"docs":" Performs the `+=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":723459,"byte_end":723515,"line_start":688,"line_end":688,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1836},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":725001,"byte_end":725010,"line_start":742,"line_end":742,"column_start":11,"column_end":20},"name":"SubAssign","qualname":"::ops::arith::SubAssign","value":"SubAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1838}],"decl_id":null,"docs":" The subtraction assignment operator `-=`.","sig":null,"attributes":[{"value":"lang = \"sub_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724714,"byte_end":724736,"line_start":736,"line_end":736,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724737,"byte_end":724793,"line_start":737,"line_end":737,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message =\n                             \"cannot subtract-assign `{Rhs}` from `{Self}`\",\n                         label = \"no implementation for `{Self} -= {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":724794,"byte_end":724949,"line_start":738,"line_end":739,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1838},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":725128,"byte_end":725138,"line_start":745,"line_end":745,"column_start":8,"column_end":18},"name":"sub_assign","qualname":"::ops::arith::SubAssign::sub_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1836},"children":[],"decl_id":null,"docs":" Performs the `-=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":725064,"byte_end":725120,"line_start":744,"line_end":744,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1842},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726368,"byte_end":726377,"line_start":789,"line_end":789,"column_start":11,"column_end":20},"name":"MulAssign","qualname":"::ops::arith::MulAssign","value":"MulAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1844}],"decl_id":null,"docs":" The multiplication assignment operator `*=`.","sig":null,"attributes":[{"value":"lang = \"mul_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726083,"byte_end":726105,"line_start":783,"line_end":783,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726106,"byte_end":726162,"line_start":784,"line_end":784,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message =\n                             \"cannot multiply-assign `{Rhs}` to `{Self}`\",\n                         label = \"no implementation for `{Self} *= {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726163,"byte_end":726316,"line_start":785,"line_end":786,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1844},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726495,"byte_end":726505,"line_start":792,"line_end":792,"column_start":8,"column_end":18},"name":"mul_assign","qualname":"::ops::arith::MulAssign::mul_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1842},"children":[],"decl_id":null,"docs":" Performs the `*=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":726431,"byte_end":726487,"line_start":791,"line_end":791,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1848},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727727,"byte_end":727736,"line_start":836,"line_end":836,"column_start":11,"column_end":20},"name":"DivAssign","qualname":"::ops::arith::DivAssign","value":"DivAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1850}],"decl_id":null,"docs":" The division assignment operator `/=`.","sig":null,"attributes":[{"value":"lang = \"div_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727444,"byte_end":727466,"line_start":830,"line_end":830,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727467,"byte_end":727523,"line_start":831,"line_end":831,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"cannot divide-assign `{Self}` by `{Rhs}`\",\n                         label = \"no implementation for `{Self} /= {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727524,"byte_end":727675,"line_start":832,"line_end":833,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1850},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727854,"byte_end":727864,"line_start":839,"line_end":839,"column_start":8,"column_end":18},"name":"div_assign","qualname":"::ops::arith::DivAssign::div_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1848},"children":[],"decl_id":null,"docs":" Performs the `/=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":727790,"byte_end":727846,"line_start":838,"line_end":838,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1854},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":729130,"byte_end":729139,"line_start":886,"line_end":886,"column_start":11,"column_end":20},"name":"RemAssign","qualname":"::ops::arith::RemAssign","value":"RemAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1856}],"decl_id":null,"docs":" The remainder assignment operator `%=`.","sig":null,"attributes":[{"value":"lang = \"rem_assign\"","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":728849,"byte_end":728871,"line_start":880,"line_end":880,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":728872,"byte_end":728928,"line_start":881,"line_end":881,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"cannot mod-assign `{Self}` by `{Rhs}``\",\n                         label = \"no implementation for `{Self} %= {Rhs}`\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":728929,"byte_end":729078,"line_start":882,"line_end":883,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1856},"span":{"file_name":"src/libcore/ops/arith.rs","byte_start":729257,"byte_end":729267,"line_start":889,"line_end":889,"column_start":8,"column_end":18},"name":"rem_assign","qualname":"::ops::arith::RemAssign::rem_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1854},"children":[],"decl_id":null,"docs":" Performs the `%=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/arith.rs","byte_start":729193,"byte_end":729249,"line_start":888,"line_end":888,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1862},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":730408,"byte_end":730411,"line_start":33,"line_end":33,"column_start":11,"column_end":14},"name":"Not","qualname":"::ops::bit::Not","value":"Not","parent":null,"children":[{"krate":0,"index":1864},{"krate":0,"index":1866}],"decl_id":null,"docs":" The unary logical negation operator `!`.","sig":null,"attributes":[{"value":"lang = \"not\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":730336,"byte_end":730351,"line_start":31,"line_end":31,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":730352,"byte_end":730397,"line_start":32,"line_end":32,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":1864},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":730533,"byte_end":730539,"line_start":36,"line_end":36,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::Not::Output","value":"type Output;","parent":{"krate":0,"index":1862},"children":[],"decl_id":null,"docs":" The resulting type after applying the `!` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":730478,"byte_end":730523,"line_start":35,"line_end":35,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1866},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":730657,"byte_end":730660,"line_start":41,"line_end":41,"column_start":8,"column_end":11},"name":"not","qualname":"::ops::bit::Not::not","value":"fn (self) -> Self::Output","parent":{"krate":0,"index":1862},"children":[],"decl_id":null,"docs":" Performs the unary `!` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":730588,"byte_end":730599,"line_start":39,"line_end":39,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":730604,"byte_end":730649,"line_start":40,"line_end":40,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1870},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":732832,"byte_end":732838,"line_start":117,"line_end":117,"column_start":11,"column_end":17},"name":"BitAnd","qualname":"::ops::bit::BitAnd","value":"BitAnd<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1872},{"krate":0,"index":1874}],"decl_id":null,"docs":" The bitwise AND operator `&`.","sig":null,"attributes":[{"value":"lang = \"bitand\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":732588,"byte_end":732606,"line_start":112,"line_end":112,"column_start":1,"column_end":19}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":732627,"byte_end":732672,"line_start":114,"line_end":114,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} & {Rhs}`\",\n                         label = \"no implementation for `{Self} & {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":732673,"byte_end":732821,"line_start":115,"line_end":116,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1872},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":732970,"byte_end":732976,"line_start":120,"line_end":120,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::BitAnd::Output","value":"type Output;","parent":{"krate":0,"index":1870},"children":[],"decl_id":null,"docs":" The resulting type after applying the `&` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":732915,"byte_end":732960,"line_start":119,"line_end":119,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1874},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":733088,"byte_end":733094,"line_start":125,"line_end":125,"column_start":8,"column_end":14},"name":"bitand","qualname":"::ops::bit::BitAnd::bitand","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1870},"children":[],"decl_id":null,"docs":" Performs the `&` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":733019,"byte_end":733030,"line_start":123,"line_end":123,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":733035,"byte_end":733080,"line_start":124,"line_end":124,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1878},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735291,"byte_end":735296,"line_start":201,"line_end":201,"column_start":11,"column_end":16},"name":"BitOr","qualname":"::ops::bit::BitOr","value":"BitOr<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1880},{"krate":0,"index":1882}],"decl_id":null,"docs":" The bitwise OR operator `|`.","sig":null,"attributes":[{"value":"lang = \"bitor\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735048,"byte_end":735065,"line_start":196,"line_end":196,"column_start":1,"column_end":18}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735086,"byte_end":735131,"line_start":198,"line_end":198,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} | {Rhs}`\",\n                         label = \"no implementation for `{Self} | {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735132,"byte_end":735280,"line_start":199,"line_end":200,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1880},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735428,"byte_end":735434,"line_start":204,"line_end":204,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::BitOr::Output","value":"type Output;","parent":{"krate":0,"index":1878},"children":[],"decl_id":null,"docs":" The resulting type after applying the `|` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735373,"byte_end":735418,"line_start":203,"line_end":203,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1882},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735546,"byte_end":735551,"line_start":209,"line_end":209,"column_start":8,"column_end":13},"name":"bitor","qualname":"::ops::bit::BitOr::bitor","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1878},"children":[],"decl_id":null,"docs":" Performs the `|` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735477,"byte_end":735488,"line_start":207,"line_end":207,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":735493,"byte_end":735538,"line_start":208,"line_end":208,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1886},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":737889,"byte_end":737895,"line_start":288,"line_end":288,"column_start":11,"column_end":17},"name":"BitXor","qualname":"::ops::bit::BitXor","value":"BitXor<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1888},{"krate":0,"index":1890}],"decl_id":null,"docs":" The bitwise XOR operator `^`.","sig":null,"attributes":[{"value":"lang = \"bitxor\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":737645,"byte_end":737663,"line_start":283,"line_end":283,"column_start":1,"column_end":19}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":737684,"byte_end":737729,"line_start":285,"line_end":285,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} ^ {Rhs}`\",\n                         label = \"no implementation for `{Self} ^ {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":737730,"byte_end":737878,"line_start":286,"line_end":287,"column_start":1,"column_end":74}}]},{"kind":"Type","id":{"krate":0,"index":1888},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":738027,"byte_end":738033,"line_start":291,"line_end":291,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::BitXor::Output","value":"type Output;","parent":{"krate":0,"index":1886},"children":[],"decl_id":null,"docs":" The resulting type after applying the `^` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":737972,"byte_end":738017,"line_start":290,"line_end":290,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1890},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":738145,"byte_end":738151,"line_start":296,"line_end":296,"column_start":8,"column_end":14},"name":"bitxor","qualname":"::ops::bit::BitXor::bitxor","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1886},"children":[],"decl_id":null,"docs":" Performs the `^` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":738076,"byte_end":738087,"line_start":294,"line_end":294,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":738092,"byte_end":738137,"line_start":295,"line_end":295,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1894},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740570,"byte_end":740573,"line_start":376,"line_end":376,"column_start":11,"column_end":14},"name":"Shl","qualname":"::ops::bit::Shl","value":"Shl<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1896},{"krate":0,"index":1898}],"decl_id":null,"docs":" The left shift operator `<<`. Note that because this trait is implemented\n for all integer types with multiple right-hand-side types, Rust's type\n checker has special handling for `_ << _`, setting the result type for\n integer operations to the type of the left-hand-side operand. This means\n that though `a << b` and `a.shl(b)` are one and the same from an evaluation\n standpoint, they are different when it comes to type inference.","sig":null,"attributes":[{"value":"lang = \"shl\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740326,"byte_end":740341,"line_start":371,"line_end":371,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740363,"byte_end":740408,"line_start":373,"line_end":373,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} << {Rhs}`\",\n                         label = \"no implementation for `{Self} << {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740409,"byte_end":740559,"line_start":374,"line_end":375,"column_start":1,"column_end":75}}]},{"kind":"Type","id":{"krate":0,"index":1896},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740706,"byte_end":740712,"line_start":379,"line_end":379,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::Shl::Output","value":"type Output;","parent":{"krate":0,"index":1894},"children":[],"decl_id":null,"docs":" The resulting type after applying the `<<` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740651,"byte_end":740696,"line_start":378,"line_end":378,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1898},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740825,"byte_end":740828,"line_start":384,"line_end":384,"column_start":8,"column_end":11},"name":"shl","qualname":"::ops::bit::Shl::shl","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1894},"children":[],"decl_id":null,"docs":" Performs the `<<` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740756,"byte_end":740767,"line_start":382,"line_end":382,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":740772,"byte_end":740817,"line_start":383,"line_end":383,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1904},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":743751,"byte_end":743754,"line_start":485,"line_end":485,"column_start":11,"column_end":14},"name":"Shr","qualname":"::ops::bit::Shr","value":"Shr<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1906},{"krate":0,"index":1908}],"decl_id":null,"docs":" The right shift operator `>>`. Note that because this trait is implemented\n for all integer types with multiple right-hand-side types, Rust's type\n checker has special handling for `_ >> _`, setting the result type for\n integer operations to the type of the left-hand-side operand. This means\n that though `a >> b` and `a.shr(b)` are one and the same from an evaluation\n standpoint, they are different when it comes to type inference.","sig":null,"attributes":[{"value":"lang = \"shr\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":743507,"byte_end":743522,"line_start":480,"line_end":480,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":743544,"byte_end":743589,"line_start":482,"line_end":482,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} >> {Rhs}`\",\n                         label = \"no implementation for `{Self} >> {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":743590,"byte_end":743740,"line_start":483,"line_end":484,"column_start":1,"column_end":75}}]},{"kind":"Type","id":{"krate":0,"index":1906},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":743887,"byte_end":743893,"line_start":488,"line_end":488,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::bit::Shr::Output","value":"type Output;","parent":{"krate":0,"index":1904},"children":[],"decl_id":null,"docs":" The resulting type after applying the `>>` operator.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":743832,"byte_end":743877,"line_start":487,"line_end":487,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1908},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":744006,"byte_end":744009,"line_start":493,"line_end":493,"column_start":8,"column_end":11},"name":"shr","qualname":"::ops::bit::Shr::shr","value":"fn (self, rhs: Rhs) -> Self::Output","parent":{"krate":0,"index":1904},"children":[],"decl_id":null,"docs":" Performs the `>>` operation.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":743937,"byte_end":743948,"line_start":491,"line_end":491,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":743953,"byte_end":743998,"line_start":492,"line_end":492,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1914},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":747055,"byte_end":747067,"line_start":601,"line_end":601,"column_start":11,"column_end":23},"name":"BitAndAssign","qualname":"::ops::bit::BitAndAssign","value":"BitAndAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1916}],"decl_id":null,"docs":" The bitwise AND assignment operator `&=`.","sig":null,"attributes":[{"value":"lang = \"bitand_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":746790,"byte_end":746815,"line_start":596,"line_end":596,"column_start":1,"column_end":26}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":746837,"byte_end":746893,"line_start":598,"line_end":598,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} &= {Rhs}`\",\n                         label = \"no implementation for `{Self} &= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":746894,"byte_end":747044,"line_start":599,"line_end":600,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1916},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":747185,"byte_end":747198,"line_start":604,"line_end":604,"column_start":8,"column_end":21},"name":"bitand_assign","qualname":"::ops::bit::BitAndAssign::bitand_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1914},"children":[],"decl_id":null,"docs":" Performs the `&=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":747121,"byte_end":747177,"line_start":603,"line_end":603,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1920},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748613,"byte_end":748624,"line_start":650,"line_end":650,"column_start":11,"column_end":22},"name":"BitOrAssign","qualname":"::ops::bit::BitOrAssign","value":"BitOrAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1922}],"decl_id":null,"docs":" The bitwise OR assignment operator `|=`.","sig":null,"attributes":[{"value":"lang = \"bitor_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748349,"byte_end":748373,"line_start":645,"line_end":645,"column_start":1,"column_end":25}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748395,"byte_end":748451,"line_start":647,"line_end":647,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} |= {Rhs}`\",\n                         label = \"no implementation for `{Self} |= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748452,"byte_end":748602,"line_start":648,"line_end":649,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1922},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748742,"byte_end":748754,"line_start":653,"line_end":653,"column_start":8,"column_end":20},"name":"bitor_assign","qualname":"::ops::bit::BitOrAssign::bitor_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1920},"children":[],"decl_id":null,"docs":" Performs the `|=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":748678,"byte_end":748734,"line_start":652,"line_end":652,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1926},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750157,"byte_end":750169,"line_start":699,"line_end":699,"column_start":11,"column_end":23},"name":"BitXorAssign","qualname":"::ops::bit::BitXorAssign","value":"BitXorAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1928}],"decl_id":null,"docs":" The bitwise XOR assignment operator `^=`.","sig":null,"attributes":[{"value":"lang = \"bitxor_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":749892,"byte_end":749917,"line_start":694,"line_end":694,"column_start":1,"column_end":26}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":749939,"byte_end":749995,"line_start":696,"line_end":696,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} ^= {Rhs}`\",\n                         label = \"no implementation for `{Self} ^= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":749996,"byte_end":750146,"line_start":697,"line_end":698,"column_start":1,"column_end":75}}]},{"kind":"Method","id":{"krate":0,"index":1928},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750287,"byte_end":750300,"line_start":702,"line_end":702,"column_start":8,"column_end":21},"name":"bitxor_assign","qualname":"::ops::bit::BitXorAssign::bitxor_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1926},"children":[],"decl_id":null,"docs":" Performs the `^=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":750223,"byte_end":750279,"line_start":701,"line_end":701,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1932},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":751494,"byte_end":751503,"line_start":746,"line_end":746,"column_start":11,"column_end":20},"name":"ShlAssign","qualname":"::ops::bit::ShlAssign","value":"ShlAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1934}],"decl_id":null,"docs":" The left shift assignment operator `<<=`.","sig":null,"attributes":[{"value":"lang = \"shl_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":751229,"byte_end":751251,"line_start":741,"line_end":741,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":751274,"byte_end":751330,"line_start":743,"line_end":743,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} <<= {Rhs}`\",\n                         label = \"no implementation for `{Self} <<= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":751331,"byte_end":751483,"line_start":744,"line_end":745,"column_start":1,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":1934},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":751622,"byte_end":751632,"line_start":749,"line_end":749,"column_start":8,"column_end":18},"name":"shl_assign","qualname":"::ops::bit::ShlAssign::shl_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1932},"children":[],"decl_id":null,"docs":" Performs the `<<=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":751558,"byte_end":751614,"line_start":748,"line_end":748,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1940},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753403,"byte_end":753412,"line_start":814,"line_end":814,"column_start":11,"column_end":20},"name":"ShrAssign","qualname":"::ops::bit::ShrAssign","value":"ShrAssign<Rhs = Self>","parent":null,"children":[{"krate":0,"index":1942}],"decl_id":null,"docs":" The right shift assignment operator `>>=`.","sig":null,"attributes":[{"value":"lang = \"shr_assign\"","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753138,"byte_end":753160,"line_start":809,"line_end":809,"column_start":1,"column_end":23}},{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753183,"byte_end":753239,"line_start":811,"line_end":811,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(message = \"no implementation for `{Self} >>= {Rhs}`\",\n                         label = \"no implementation for `{Self} >>= {Rhs}`\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753240,"byte_end":753392,"line_start":812,"line_end":813,"column_start":1,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":1942},"span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753531,"byte_end":753541,"line_start":817,"line_end":817,"column_start":8,"column_end":18},"name":"shr_assign","qualname":"::ops::bit::ShrAssign::shr_assign","value":"fn (&mut self, rhs: Rhs) -> ()","parent":{"krate":0,"index":1940},"children":[],"decl_id":null,"docs":" Performs the `>>=` operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"op_assign_traits\", since = \"1.8.0\")","span":{"file_name":"src/libcore/ops/bit.rs","byte_start":753467,"byte_end":753523,"line_start":816,"line_end":816,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":1950},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":756940,"byte_end":756945,"line_start":64,"line_end":64,"column_start":11,"column_end":16},"name":"Deref","qualname":"::ops::deref::Deref","value":"Deref","parent":null,"children":[{"krate":0,"index":1952},{"krate":0,"index":1954}],"decl_id":null,"docs":" Used for immutable dereferencing operations, like `*v`.","sig":null,"attributes":[{"value":"lang = \"deref\"","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":756825,"byte_end":756842,"line_start":60,"line_end":60,"column_start":1,"column_end":18}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":756884,"byte_end":756929,"line_start":63,"line_end":63,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":1952},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":757055,"byte_end":757061,"line_start":67,"line_end":67,"column_start":10,"column_end":16},"name":"Target","qualname":"::ops::deref::Deref::Target","value":"type Target: ?Sized;","parent":{"krate":0,"index":1950},"children":[],"decl_id":null,"docs":" The resulting type after dereferencing.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":757000,"byte_end":757045,"line_start":66,"line_end":66,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":1954},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":757177,"byte_end":757182,"line_start":72,"line_end":72,"column_start":8,"column_end":13},"name":"deref","qualname":"::ops::deref::Deref::deref","value":"fn (&self) -> &Self::Target","parent":{"krate":0,"index":1950},"children":[],"decl_id":null,"docs":" Dereferences the value.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":757108,"byte_end":757119,"line_start":70,"line_end":70,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":757124,"byte_end":757169,"line_start":71,"line_end":71,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1968},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":760064,"byte_end":760072,"line_start":160,"line_end":160,"column_start":11,"column_end":19},"name":"DerefMut","qualname":"::ops::deref::DerefMut","value":"DerefMut: Deref","parent":null,"children":[{"krate":0,"index":1970}],"decl_id":null,"docs":" Used for mutable dereferencing operations, like in `*v = 1;`.","sig":null,"attributes":[{"value":"lang = \"deref_mut\"","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":759966,"byte_end":759987,"line_start":157,"line_end":157,"column_start":1,"column_end":22}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":760008,"byte_end":760053,"line_start":159,"line_end":159,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":1970},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":760179,"byte_end":760188,"line_start":163,"line_end":163,"column_start":8,"column_end":17},"name":"deref_mut","qualname":"::ops::deref::DerefMut::deref_mut","value":"fn (&mut self) -> &mut Self::Target","parent":{"krate":0,"index":1968},"children":[],"decl_id":null,"docs":" Mutably dereferences the value.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":760126,"byte_end":760171,"line_start":162,"line_end":162,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1976},"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":760661,"byte_end":760669,"line_start":177,"line_end":177,"column_start":11,"column_end":19},"name":"Receiver","qualname":"::ops::deref::Receiver","value":"Receiver","parent":null,"children":[],"decl_id":null,"docs":" Indicates that a struct can be used as a method receiver, without the\n `arbitrary_self_types` feature. This is implemented by stdlib pointer types like `Box<T>`,\n `Rc<T>`, `&T`, and `Pin<P>`.\n","sig":null,"attributes":[{"value":"lang = \"receiver\"","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":760562,"byte_end":760582,"line_start":174,"line_end":174,"column_start":1,"column_end":21}},{"value":"unstable(feature = \"receiver_trait\", issue = \"0\")","span":{"file_name":"src/libcore/ops/deref.rs","byte_start":760583,"byte_end":760635,"line_start":175,"line_end":175,"column_start":1,"column_end":53}}]},{"kind":"Trait","id":{"krate":0,"index":1984},"span":{"file_name":"src/libcore/ops/drop.rs","byte_start":762989,"byte_end":762993,"line_start":85,"line_end":85,"column_start":11,"column_end":15},"name":"Drop","qualname":"::ops::drop::Drop","value":"Drop","parent":null,"children":[{"krate":0,"index":1986}],"decl_id":null,"docs":" Used to run some code when a value goes out of scope.\n This is sometimes called a 'destructor'.","sig":null,"attributes":[{"value":"lang = \"drop\"","span":{"file_name":"src/libcore/ops/drop.rs","byte_start":762916,"byte_end":762932,"line_start":83,"line_end":83,"column_start":1,"column_end":17}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/drop.rs","byte_start":762933,"byte_end":762978,"line_start":84,"line_end":84,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":1986},"span":{"file_name":"src/libcore/ops/drop.rs","byte_start":763912,"byte_end":763916,"line_start":106,"line_end":106,"column_start":8,"column_end":12},"name":"drop","qualname":"::ops::drop::Drop::drop","value":"fn (&mut self) -> ()","parent":{"krate":0,"index":1984},"children":[],"decl_id":null,"docs":" Executes the destructor for this type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/drop.rs","byte_start":763859,"byte_end":763904,"line_start":105,"line_end":105,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":1990},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":766339,"byte_end":766341,"line_start":66,"line_end":66,"column_start":11,"column_end":13},"name":"Fn","qualname":"::ops::function::Fn","value":"Fn<Args>: FnMut<Args>","parent":null,"children":[{"krate":0,"index":1992}],"decl_id":null,"docs":" The version of the call operator that takes an immutable receiver.","sig":null,"attributes":[{"value":"lang = \"fn\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":765869,"byte_end":765883,"line_start":56,"line_end":56,"column_start":1,"column_end":15}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":765884,"byte_end":765929,"line_start":57,"line_end":57,"column_start":1,"column_end":46}},{"value":"rustc_paren_sugar","span":{"file_name":"src/libcore/ops/function.rs","byte_start":765930,"byte_end":765950,"line_start":58,"line_end":58,"column_start":1,"column_end":21}},{"value":"rustc_on_unimplemented(on(Args = \"()\",\n                            note =\n                                \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n                         message =\n                             \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n                         label =\n                             \"expected an `Fn<{Args}>` closure, found `{Self}`\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":765951,"byte_end":766204,"line_start":59,"line_end":63,"column_start":1,"column_end":3}},{"value":"fundamental","span":{"file_name":"src/libcore/ops/function.rs","byte_start":766205,"byte_end":766219,"line_start":64,"line_end":64,"column_start":1,"column_end":15}},{"value":"must_use = \"closures are lazy and do nothing unless called\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":766266,"byte_end":766328,"line_start":65,"line_end":65,"column_start":1,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":1992},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":766483,"byte_end":766487,"line_start":69,"line_end":69,"column_start":27,"column_end":31},"name":"call","qualname":"::ops::function::Fn::call","value":"fn (&self, args: Args) -> Self::Output","parent":{"krate":0,"index":1990},"children":[],"decl_id":null,"docs":" Performs the call operation.\n","sig":null,"attributes":[{"value":"unstable(feature = \"fn_traits\", issue = \"29625\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":766405,"byte_end":766456,"line_start":68,"line_end":68,"column_start":5,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":1994},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":769059,"byte_end":769064,"line_start":145,"line_end":145,"column_start":11,"column_end":16},"name":"FnMut","qualname":"::ops::function::FnMut","value":"FnMut<Args>: FnOnce<Args>","parent":null,"children":[{"krate":0,"index":1996}],"decl_id":null,"docs":" The version of the call operator that takes a mutable receiver.","sig":null,"attributes":[{"value":"lang = \"fn_mut\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":768579,"byte_end":768597,"line_start":135,"line_end":135,"column_start":1,"column_end":19}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":768598,"byte_end":768643,"line_start":136,"line_end":136,"column_start":1,"column_end":46}},{"value":"rustc_paren_sugar","span":{"file_name":"src/libcore/ops/function.rs","byte_start":768644,"byte_end":768664,"line_start":137,"line_end":137,"column_start":1,"column_end":21}},{"value":"rustc_on_unimplemented(on(Args = \"()\",\n                            note =\n                                \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n                         message =\n                             \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n                         label =\n                             \"expected an `FnMut<{Args}>` closure, found `{Self}`\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":768665,"byte_end":768924,"line_start":138,"line_end":142,"column_start":1,"column_end":3}},{"value":"fundamental","span":{"file_name":"src/libcore/ops/function.rs","byte_start":768925,"byte_end":768939,"line_start":143,"line_end":143,"column_start":1,"column_end":15}},{"value":"must_use = \"closures are lazy and do nothing unless called\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":768986,"byte_end":769048,"line_start":144,"line_end":144,"column_start":1,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":1996},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":769207,"byte_end":769215,"line_start":148,"line_end":148,"column_start":27,"column_end":35},"name":"call_mut","qualname":"::ops::function::FnMut::call_mut","value":"fn (&mut self, args: Args) -> Self::Output","parent":{"krate":0,"index":1994},"children":[],"decl_id":null,"docs":" Performs the call operation.\n","sig":null,"attributes":[{"value":"unstable(feature = \"fn_traits\", issue = \"29625\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":769129,"byte_end":769180,"line_start":147,"line_end":147,"column_start":5,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":1998},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":771993,"byte_end":771999,"line_start":224,"line_end":224,"column_start":11,"column_end":17},"name":"FnOnce","qualname":"::ops::function::FnOnce","value":"FnOnce<Args>","parent":null,"children":[{"krate":0,"index":2000},{"krate":0,"index":2002}],"decl_id":null,"docs":" The version of the call operator that takes a by-value receiver.","sig":null,"attributes":[{"value":"lang = \"fn_once\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":771510,"byte_end":771529,"line_start":214,"line_end":214,"column_start":1,"column_end":20}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":771530,"byte_end":771575,"line_start":215,"line_end":215,"column_start":1,"column_end":46}},{"value":"rustc_paren_sugar","span":{"file_name":"src/libcore/ops/function.rs","byte_start":771576,"byte_end":771596,"line_start":216,"line_end":216,"column_start":1,"column_end":21}},{"value":"rustc_on_unimplemented(on(Args = \"()\",\n                            note =\n                                \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n                         message =\n                             \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n                         label =\n                             \"expected an `FnOnce<{Args}>` closure, found `{Self}`\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":771597,"byte_end":771858,"line_start":217,"line_end":221,"column_start":1,"column_end":3}},{"value":"fundamental","span":{"file_name":"src/libcore/ops/function.rs","byte_start":771859,"byte_end":771873,"line_start":222,"line_end":222,"column_start":1,"column_end":15}},{"value":"must_use = \"closures are lazy and do nothing unless called\"","span":{"file_name":"src/libcore/ops/function.rs","byte_start":771920,"byte_end":771982,"line_start":223,"line_end":223,"column_start":1,"column_end":63}}]},{"kind":"Type","id":{"krate":0,"index":2000},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":772136,"byte_end":772142,"line_start":227,"line_end":227,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::function::FnOnce::Output","value":"type Output;","parent":{"krate":0,"index":1998},"children":[],"decl_id":null,"docs":" The returned type after the call operator is used.\n","sig":null,"attributes":[{"value":"stable(feature = \"fn_once_output\", since = \"1.12.0\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":772071,"byte_end":772126,"line_start":226,"line_end":226,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":2002},"span":{"file_name":"src/libcore/ops/function.rs","byte_start":772264,"byte_end":772273,"line_start":231,"line_end":231,"column_start":27,"column_end":36},"name":"call_once","qualname":"::ops::function::FnOnce::call_once","value":"fn (self, args: Args) -> Self::Output","parent":{"krate":0,"index":1998},"children":[],"decl_id":null,"docs":" Performs the call operation.\n","sig":null,"attributes":[{"value":"unstable(feature = \"fn_traits\", issue = \"29625\")","span":{"file_name":"src/libcore/ops/function.rs","byte_start":772186,"byte_end":772237,"line_start":230,"line_end":230,"column_start":5,"column_end":56}}]},{"kind":"TupleVariant","id":{"krate":0,"index":15721},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":774451,"byte_end":774458,"line_start":19,"line_end":19,"column_start":5,"column_end":12},"name":"Yielded","qualname":"::ops::generator::GeneratorState::Yielded","value":"GeneratorState::Yielded(Y)","parent":{"krate":0,"index":35996},"children":[],"decl_id":null,"docs":" The generator suspended with a value.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":15727},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":774740,"byte_end":774748,"line_start":26,"line_end":26,"column_start":5,"column_end":13},"name":"Complete","qualname":"::ops::generator::GeneratorState::Complete","value":"GeneratorState::Complete(R)","parent":{"krate":0,"index":35996},"children":[],"decl_id":null,"docs":" The generator completed with a return value.","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":35996},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":774084,"byte_end":774098,"line_start":12,"line_end":12,"column_start":10,"column_end":24},"name":"GeneratorState","qualname":"::ops::generator::GeneratorState","value":"GeneratorState::{Yielded, Complete}","parent":null,"children":[{"krate":0,"index":15721},{"krate":0,"index":15727}],"decl_id":null,"docs":" The result of a generator resumption.","sig":null,"attributes":[{"value":"lang = \"generator_state\"","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":773989,"byte_end":774016,"line_start":10,"line_end":10,"column_start":1,"column_end":28}},{"value":"unstable(feature = \"generator_trait\", issue = \"43122\")","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":774017,"byte_end":774074,"line_start":11,"line_end":11,"column_start":1,"column_end":58}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":774075,"byte_end":774754,"line_start":12,"line_end":27,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":774075,"byte_end":774754,"line_start":12,"line_end":27,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":2036},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":776166,"byte_end":776175,"line_start":70,"line_end":70,"column_start":11,"column_end":20},"name":"Generator","qualname":"::ops::generator::Generator","value":"Generator","parent":null,"children":[{"krate":0,"index":2038},{"krate":0,"index":2040},{"krate":0,"index":2042}],"decl_id":null,"docs":" The trait implemented by builtin generator types.","sig":null,"attributes":[{"value":"lang = \"generator\"","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":776061,"byte_end":776082,"line_start":67,"line_end":67,"column_start":1,"column_end":22}},{"value":"unstable(feature = \"generator_trait\", issue = \"43122\")","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":776083,"byte_end":776140,"line_start":68,"line_end":68,"column_start":1,"column_end":58}},{"value":"fundamental","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":776141,"byte_end":776155,"line_start":69,"line_end":69,"column_start":1,"column_end":15}}]},{"kind":"Type","id":{"krate":0,"index":2038},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":776518,"byte_end":776523,"line_start":77,"line_end":77,"column_start":10,"column_end":15},"name":"Yield","qualname":"::ops::generator::Generator::Yield","value":"type Yield;","parent":{"krate":0,"index":2036},"children":[],"decl_id":null,"docs":" The type of value this generator yields.","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":2040},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":776864,"byte_end":776870,"line_start":85,"line_end":85,"column_start":10,"column_end":16},"name":"Return","qualname":"::ops::generator::Generator::Return","value":"type Return;","parent":{"krate":0,"index":2036},"children":[],"decl_id":null,"docs":" The type of value this generator returns.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2042},"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":778195,"byte_end":778201,"line_start":113,"line_end":113,"column_start":8,"column_end":14},"name":"resume","qualname":"::ops::generator::Generator::resume","value":"fn (self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return>","parent":{"krate":0,"index":2036},"children":[],"decl_id":null,"docs":" Resumes the execution of this generator.","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":2062},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":780724,"byte_end":780729,"line_start":61,"line_end":61,"column_start":11,"column_end":16},"name":"Index","qualname":"::ops::index::Index","value":"Index<Idx: ?Sized>","parent":null,"children":[{"krate":0,"index":2064},{"krate":0,"index":2066}],"decl_id":null,"docs":" Used for indexing operations (`container[index]`) in immutable contexts.","sig":null,"attributes":[{"value":"lang = \"index\"","span":{"file_name":"src/libcore/ops/index.rs","byte_start":780447,"byte_end":780464,"line_start":52,"line_end":52,"column_start":1,"column_end":18}},{"value":"rustc_on_unimplemented(message =\n                             \"the type `{Self}` cannot be indexed by `{Idx}`\",\n                         label = \"`{Self}` cannot be indexed by `{Idx}`\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":780465,"byte_end":780606,"line_start":53,"line_end":56,"column_start":1,"column_end":3}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":780607,"byte_end":780652,"line_start":57,"line_end":57,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":2064},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":780846,"byte_end":780852,"line_start":64,"line_end":64,"column_start":10,"column_end":16},"name":"Output","qualname":"::ops::index::Index::Output","value":"type Output: ?Sized;","parent":{"krate":0,"index":2062},"children":[],"decl_id":null,"docs":" The returned type after indexing.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":780791,"byte_end":780836,"line_start":63,"line_end":63,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2066},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":780982,"byte_end":780987,"line_start":68,"line_end":68,"column_start":8,"column_end":13},"name":"index","qualname":"::ops::index::Index::index","value":"fn (&self, index: Idx) -> &Self::Output","parent":{"krate":0,"index":2062},"children":[],"decl_id":null,"docs":" Performs the indexing (`container[index]`) operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":780929,"byte_end":780974,"line_start":67,"line_end":67,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2068},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":784057,"byte_end":784065,"line_start":166,"line_end":166,"column_start":11,"column_end":19},"name":"IndexMut","qualname":"::ops::index::IndexMut","value":"IndexMut<Idx: ?Sized>: Index<Idx>","parent":null,"children":[{"krate":0,"index":2070}],"decl_id":null,"docs":" Used for indexing operations (`container[index]`) in mutable contexts.","sig":null,"attributes":[{"value":"lang = \"index_mut\"","span":{"file_name":"src/libcore/ops/index.rs","byte_start":783143,"byte_end":783164,"line_start":142,"line_end":142,"column_start":1,"column_end":22}},{"value":"rustc_on_unimplemented(on(_Self = \"&str\",\n                            note =\n                                \"you can use `.chars().nth()` or `.bytes().nth()`\\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"),\n                         on(_Self = \"str\",\n                            note =\n                                \"you can use `.chars().nth()` or `.bytes().nth()`\\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"),\n                         on(_Self = \"std::string::String\",\n                            note =\n                                \"you can use `.chars().nth()` or `.bytes().nth()`\\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"),\n                         message =\n                             \"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n                         label =\n                             \"`{Self}` cannot be mutably indexed by `{Idx}`\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":783165,"byte_end":783939,"line_start":143,"line_end":161,"column_start":1,"column_end":3}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":783940,"byte_end":783985,"line_start":162,"line_end":162,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2070},"span":{"file_name":"src/libcore/ops/index.rs","byte_start":784220,"byte_end":784229,"line_start":169,"line_end":169,"column_start":8,"column_end":17},"name":"index_mut","qualname":"::ops::index::IndexMut::index_mut","value":"fn (&mut self, index: Idx) -> &mut Self::Output","parent":{"krate":0,"index":2068},"children":[],"decl_id":null,"docs":" Performs the mutable indexing (`container[index]`) operation.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/index.rs","byte_start":784167,"byte_end":784212,"line_start":168,"line_end":168,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":36038},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":785526,"byte_end":785535,"line_start":44,"line_end":44,"column_start":12,"column_end":21},"name":"RangeFull","qualname":"::ops::range::RangeFull","value":"","parent":null,"children":[],"decl_id":null,"docs":" An unbounded range (`..`).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":785469,"byte_end":785514,"line_start":43,"line_end":43,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":785515,"byte_end":785536,"line_start":44,"line_end":44,"column_start":1,"column_end":22}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/range.rs","byte_start":785515,"byte_end":785536,"line_start":44,"line_end":44,"column_start":1,"column_end":22}}]},{"kind":"Struct","id":{"krate":0,"index":36058},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":786507,"byte_end":786512,"line_start":76,"line_end":76,"column_start":12,"column_end":17},"name":"Range","qualname":"::ops::range::Range","value":"Range { start, end }","parent":null,"children":[{"krate":0,"index":15773},{"krate":0,"index":15775}],"decl_id":null,"docs":" A (half-open) range bounded inclusively below and exclusively above\n (`start..end`).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":786450,"byte_end":786495,"line_start":75,"line_end":75,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":786496,"byte_end":786759,"line_start":76,"line_end":83,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":15773},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":786628,"byte_end":786633,"line_start":79,"line_end":79,"column_start":9,"column_end":14},"name":"start","qualname":"::ops::range::Range::start","value":"Idx","parent":{"krate":0,"index":36058},"children":[],"decl_id":null,"docs":" The lower bound of the range (inclusive).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":786574,"byte_end":786619,"line_start":78,"line_end":78,"column_start":5,"column_end":50}}]},{"kind":"Field","id":{"krate":0,"index":15775},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":786748,"byte_end":786751,"line_start":82,"line_end":82,"column_start":9,"column_end":12},"name":"end","qualname":"::ops::range::Range::end","value":"Idx","parent":{"krate":0,"index":36058},"children":[],"decl_id":null,"docs":" The upper bound of the range (exclusive).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":786694,"byte_end":786739,"line_start":81,"line_end":81,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2092},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":787737,"byte_end":787745,"line_start":117,"line_end":117,"column_start":12,"column_end":20},"name":"contains","qualname":"<Range<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":787670,"byte_end":787725,"line_start":116,"line_end":116,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":2094},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":788580,"byte_end":788588,"line_start":148,"line_end":148,"column_start":12,"column_end":20},"name":"is_empty","qualname":"<Range<Idx>>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the range contains no items.","sig":null,"attributes":[{"value":"unstable(feature = \"range_is_empty\",\n           reason = \"recently added\",\n           issue = \"48111\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":788485,"byte_end":788568,"line_start":147,"line_end":147,"column_start":5,"column_end":88}}]},{"kind":"Struct","id":{"krate":0,"index":36078},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":789699,"byte_end":789708,"line_start":181,"line_end":181,"column_start":12,"column_end":21},"name":"RangeFrom","qualname":"::ops::range::RangeFrom","value":"RangeFrom { start }","parent":null,"children":[{"krate":0,"index":15789}],"decl_id":null,"docs":" A range only bounded inclusively below (`start..`).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":789642,"byte_end":789687,"line_start":180,"line_end":180,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":789688,"byte_end":789837,"line_start":181,"line_end":185,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":15789},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":789824,"byte_end":789829,"line_start":184,"line_end":184,"column_start":9,"column_end":14},"name":"start","qualname":"::ops::range::RangeFrom::start","value":"Idx","parent":{"krate":0,"index":36078},"children":[],"decl_id":null,"docs":" The lower bound of the range (inclusive).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":789770,"byte_end":789815,"line_start":183,"line_end":183,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2102},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":790620,"byte_end":790628,"line_start":213,"line_end":213,"column_start":12,"column_end":20},"name":"contains","qualname":"<RangeFrom<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":790553,"byte_end":790608,"line_start":212,"line_end":212,"column_start":5,"column_end":60}}]},{"kind":"Struct","id":{"krate":0,"index":36098},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":792179,"byte_end":792186,"line_start":265,"line_end":265,"column_start":12,"column_end":19},"name":"RangeTo","qualname":"::ops::range::RangeTo","value":"RangeTo { end }","parent":null,"children":[{"krate":0,"index":15803}],"decl_id":null,"docs":" A range only bounded exclusively above (`..end`).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":792122,"byte_end":792167,"line_start":264,"line_end":264,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":792168,"byte_end":792313,"line_start":265,"line_end":269,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/range.rs","byte_start":792168,"byte_end":792313,"line_start":265,"line_end":269,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":15803},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":792302,"byte_end":792305,"line_start":268,"line_end":268,"column_start":9,"column_end":12},"name":"end","qualname":"::ops::range::RangeTo::end","value":"Idx","parent":{"krate":0,"index":36098},"children":[],"decl_id":null,"docs":" The upper bound of the range (exclusive).\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":792248,"byte_end":792293,"line_start":267,"line_end":267,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2110},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":793091,"byte_end":793099,"line_start":297,"line_end":297,"column_start":12,"column_end":20},"name":"contains","qualname":"<RangeTo<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":793024,"byte_end":793079,"line_start":296,"line_end":296,"column_start":5,"column_end":60}}]},{"kind":"Struct","id":{"krate":0,"index":36120},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":794365,"byte_end":794379,"line_start":335,"line_end":335,"column_start":12,"column_end":26},"name":"RangeInclusive","qualname":"::ops::range::RangeInclusive","value":"RangeInclusive {  }","parent":null,"children":[{"krate":0,"index":15819},{"krate":0,"index":15821},{"krate":0,"index":15823}],"decl_id":null,"docs":" A range bounded inclusively below and above (`start..=end`).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":794297,"byte_end":794353,"line_start":334,"line_end":334,"column_start":1,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2114},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":794862,"byte_end":794884,"line_start":348,"line_end":348,"column_start":8,"column_end":30},"name":"canonicalized_is_empty","qualname":"::ops::range::RangeInclusiveEquality::canonicalized_is_empty","value":"fn (range: &RangeInclusive<Self>) -> bool","parent":{"krate":0,"index":2112},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":47090},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":796458,"byte_end":796461,"line_start":401,"line_end":401,"column_start":18,"column_end":21},"name":"new","qualname":"<RangeInclusive<Idx>>::new","value":"fn (start: Idx, end: Idx) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new inclusive range. Equivalent to writing `start..=end`.","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":796338,"byte_end":796402,"line_start":398,"line_end":398,"column_start":5,"column_end":69}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":796407,"byte_end":796416,"line_start":399,"line_end":399,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/ops/range.rs","byte_start":796421,"byte_end":796440,"line_start":400,"line_end":400,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":2136},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":797343,"byte_end":797348,"line_start":429,"line_end":429,"column_start":18,"column_end":23},"name":"start","qualname":"<RangeInclusive<Idx>>::start","value":"fn (&self) -> &Idx","parent":null,"children":[],"decl_id":null,"docs":" Returns the lower bound of the range (inclusive).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":797247,"byte_end":797311,"line_start":427,"line_end":427,"column_start":5,"column_end":69}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":797316,"byte_end":797325,"line_start":428,"line_end":428,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2138},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":798148,"byte_end":798151,"line_start":453,"line_end":453,"column_start":18,"column_end":21},"name":"end","qualname":"<RangeInclusive<Idx>>::end","value":"fn (&self) -> &Idx","parent":null,"children":[],"decl_id":null,"docs":" Returns the upper bound of the range (inclusive).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":798052,"byte_end":798116,"line_start":451,"line_end":451,"column_start":5,"column_end":69}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":798121,"byte_end":798130,"line_start":452,"line_end":452,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2140},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":798612,"byte_end":798622,"line_start":469,"line_end":469,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<RangeInclusive<Idx>>::into_inner","value":"fn (self) -> (Idx, Idx)","parent":null,"children":[],"decl_id":null,"docs":" Destructures the `RangeInclusive` into (lower bound, upper (inclusive) bound).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":798522,"byte_end":798586,"line_start":467,"line_end":467,"column_start":5,"column_end":69}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":798591,"byte_end":798600,"line_start":468,"line_end":468,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2148},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":799741,"byte_end":799749,"line_start":507,"line_end":507,"column_start":12,"column_end":20},"name":"contains","qualname":"<RangeInclusive<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":799674,"byte_end":799729,"line_start":506,"line_end":506,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":2150},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":800895,"byte_end":800903,"line_start":550,"line_end":550,"column_start":12,"column_end":20},"name":"is_empty","qualname":"<RangeInclusive<Idx>>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the range contains no items.","sig":null,"attributes":[{"value":"unstable(feature = \"range_is_empty\",\n           reason = \"recently added\",\n           issue = \"48111\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":800786,"byte_end":800869,"line_start":548,"line_end":548,"column_start":5,"column_end":88}},{"value":"inline","span":{"file_name":"src/libcore/ops/range.rs","byte_start":800874,"byte_end":800883,"line_start":549,"line_end":549,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":36126},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":802731,"byte_end":802747,"line_start":606,"line_end":606,"column_start":12,"column_end":28},"name":"RangeToInclusive","qualname":"::ops::range::RangeToInclusive","value":"RangeToInclusive { end }","parent":null,"children":[{"krate":0,"index":15829}],"decl_id":null,"docs":" A range only bounded inclusively above (`..=end`).","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":802663,"byte_end":802719,"line_start":605,"line_end":605,"column_start":1,"column_end":57}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":802720,"byte_end":802884,"line_start":606,"line_end":610,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/range.rs","byte_start":802720,"byte_end":802884,"line_start":606,"line_end":610,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":15829},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":802873,"byte_end":802876,"line_start":609,"line_end":609,"column_start":9,"column_end":12},"name":"end","qualname":"::ops::range::RangeToInclusive::end","value":"Idx","parent":{"krate":0,"index":36126},"children":[],"decl_id":null,"docs":" The upper bound of the range (inclusive)\n","sig":null,"attributes":[{"value":"stable(feature = \"inclusive_range\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":802808,"byte_end":802864,"line_start":608,"line_end":608,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":2160},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":803698,"byte_end":803706,"line_start":638,"line_end":638,"column_start":12,"column_end":20},"name":"contains","qualname":"<RangeToInclusive<Idx>>::contains","value":"fn <U> (&self, item: &U) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":803631,"byte_end":803686,"line_start":637,"line_end":637,"column_start":5,"column_end":60}}]},{"kind":"TupleVariant","id":{"krate":0,"index":15845},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":805220,"byte_end":805228,"line_start":690,"line_end":690,"column_start":5,"column_end":13},"name":"Included","qualname":"::ops::range::Bound::Included","value":"Bound::Included(T)","parent":{"krate":0,"index":36148},"children":[],"decl_id":null,"docs":" An inclusive bound.\n","sig":null,"attributes":[{"value":"stable(feature = \"collections_bound\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":805157,"byte_end":805215,"line_start":689,"line_end":689,"column_start":5,"column_end":63}}]},{"kind":"TupleVariant","id":{"krate":0,"index":15851},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":805387,"byte_end":805395,"line_start":693,"line_end":693,"column_start":5,"column_end":13},"name":"Excluded","qualname":"::ops::range::Bound::Excluded","value":"Bound::Excluded(T)","parent":{"krate":0,"index":36148},"children":[],"decl_id":null,"docs":" An exclusive bound.\n","sig":null,"attributes":[{"value":"stable(feature = \"collections_bound\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":805324,"byte_end":805382,"line_start":692,"line_end":692,"column_start":5,"column_end":63}}]},{"kind":"TupleVariant","id":{"krate":0,"index":15857},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":805608,"byte_end":805617,"line_start":696,"line_end":696,"column_start":5,"column_end":14},"name":"Unbounded","qualname":"::ops::range::Bound::Unbounded","value":"Bound::Unbounded","parent":{"krate":0,"index":36148},"children":[],"decl_id":null,"docs":" An infinite endpoint. Indicates that there is no bound in this direction.\n","sig":null,"attributes":[{"value":"stable(feature = \"collections_bound\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":805545,"byte_end":805603,"line_start":695,"line_end":695,"column_start":5,"column_end":63}}]},{"kind":"Enum","id":{"krate":0,"index":36148},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":805114,"byte_end":805119,"line_start":687,"line_end":687,"column_start":10,"column_end":15},"name":"Bound","qualname":"::ops::range::Bound","value":"Bound::{Included, Excluded, Unbounded}","parent":null,"children":[{"krate":0,"index":15845},{"krate":0,"index":15851},{"krate":0,"index":15857}],"decl_id":null,"docs":" An endpoint of a range of keys.","sig":null,"attributes":[{"value":"stable(feature = \"collections_bound\", since = \"1.17.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":804995,"byte_end":805053,"line_start":685,"line_end":685,"column_start":1,"column_end":59}},{"value":"structural_match","span":{"file_name":"src/libcore/ops/range.rs","byte_start":805105,"byte_end":805620,"line_start":687,"line_end":697,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/ops/range.rs","byte_start":805105,"byte_end":805620,"line_start":687,"line_end":697,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":2162},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":805838,"byte_end":805849,"line_start":702,"line_end":702,"column_start":11,"column_end":22},"name":"RangeBounds","qualname":"::ops::range::RangeBounds","value":"RangeBounds<T: ?Sized>","parent":null,"children":[{"krate":0,"index":2164},{"krate":0,"index":2166},{"krate":0,"index":2168}],"decl_id":null,"docs":" `RangeBounds` is implemented by Rust's built-in range types, produced\n by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n","sig":null,"attributes":[{"value":"stable(feature = \"collections_range\", since = \"1.28.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":805622,"byte_end":805680,"line_start":699,"line_end":699,"column_start":1,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2164},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":806292,"byte_end":806303,"line_start":719,"line_end":719,"column_start":8,"column_end":19},"name":"start_bound","qualname":"::ops::range::RangeBounds::start_bound","value":"fn (&self) -> Bound<&T>","parent":{"krate":0,"index":2162},"children":[],"decl_id":null,"docs":" Start index bound.","sig":null,"attributes":[{"value":"stable(feature = \"collections_range\", since = \"1.28.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":806226,"byte_end":806284,"line_start":718,"line_end":718,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":2166},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":806747,"byte_end":806756,"line_start":737,"line_end":737,"column_start":8,"column_end":17},"name":"end_bound","qualname":"::ops::range::RangeBounds::end_bound","value":"fn (&self) -> Bound<&T>","parent":{"krate":0,"index":2162},"children":[],"decl_id":null,"docs":" End index bound.","sig":null,"attributes":[{"value":"stable(feature = \"collections_range\", since = \"1.28.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":806681,"byte_end":806739,"line_start":736,"line_end":736,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":2168},"span":{"file_name":"src/libcore/ops/range.rs","byte_start":807264,"byte_end":807272,"line_start":754,"line_end":754,"column_start":8,"column_end":16},"name":"contains","qualname":"::ops::range::RangeBounds::contains","value":"fn <U> (&self, item: &U) -> bool","parent":{"krate":0,"index":2162},"children":[],"decl_id":null,"docs":" Returns `true` if `item` is contained in the range.","sig":null,"attributes":[{"value":"stable(feature = \"range_contains\", since = \"1.35.0\")","span":{"file_name":"src/libcore/ops/range.rs","byte_start":807201,"byte_end":807256,"line_start":753,"line_end":753,"column_start":5,"column_end":60}}]},{"kind":"Trait","id":{"krate":0,"index":2258},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":812373,"byte_end":812376,"line_start":22,"line_end":22,"column_start":11,"column_end":14},"name":"Try","qualname":"::ops::try::Try","value":"Try","parent":null,"children":[{"krate":0,"index":2260},{"krate":0,"index":2262},{"krate":0,"index":2264},{"krate":0,"index":2266},{"krate":0,"index":2268}],"decl_id":null,"docs":" A trait for customizing the behavior of the `?` operator.","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":811676,"byte_end":811727,"line_start":7,"line_end":7,"column_start":1,"column_end":52}},{"value":"rustc_on_unimplemented(on(all(any(from_method = \"from_error\",\n                                    from_method = \"from_ok\"),\n                                from_desugaring = \"?\"),\n                            message =\n                                \"the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `{Try}`)\",\n                            label =\n                                \"cannot use the `?` operator in a function that returns `{Self}`\"),\n                         on(all(from_method = \"into_result\",\n                                from_desugaring = \"?\"),\n                            message =\n                                \"the `?` operator can only be applied to values that implement `{Try}`\",\n                            label =\n                                \"the `?` operator cannot be applied to type `{Self}`\"))","span":{"file_name":"src/libcore/ops/try.rs","byte_start":811728,"byte_end":812342,"line_start":8,"line_end":20,"column_start":1,"column_end":3}}]},{"kind":"Type","id":{"krate":0,"index":2260},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":812502,"byte_end":812504,"line_start":25,"line_end":25,"column_start":10,"column_end":12},"name":"Ok","qualname":"::ops::try::Try::Ok","value":"type Ok;","parent":{"krate":0,"index":2258},"children":[],"decl_id":null,"docs":" The type of this value when viewed as successful.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":812441,"byte_end":812492,"line_start":24,"line_end":24,"column_start":5,"column_end":56}}]},{"kind":"Type","id":{"krate":0,"index":2262},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":812625,"byte_end":812630,"line_start":28,"line_end":28,"column_start":10,"column_end":15},"name":"Error","qualname":"::ops::try::Try::Error","value":"type Error;","parent":{"krate":0,"index":2258},"children":[],"decl_id":null,"docs":" The type of this value when viewed as failed.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":812564,"byte_end":812615,"line_start":27,"line_end":27,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":2264},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":813296,"byte_end":813307,"line_start":40,"line_end":40,"column_start":8,"column_end":19},"name":"into_result","qualname":"::ops::try::Try::into_result","value":"fn (self) -> Result<Self::Ok, Self::Error>","parent":{"krate":0,"index":2258},"children":[],"decl_id":null,"docs":" Applies the \"?\" operator. A return of `Ok(t)` means that the\n execution should continue normally, and the result of `?` is the\n value `t`. A return of `Err(e)` means that execution should branch\n to the innermost enclosing `catch`, or return from the function.","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":813237,"byte_end":813288,"line_start":39,"line_end":39,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":2266},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":813557,"byte_end":813567,"line_start":45,"line_end":45,"column_start":8,"column_end":18},"name":"from_error","qualname":"::ops::try::Try::from_error","value":"fn (v: Self::Error) -> Self","parent":{"krate":0,"index":2258},"children":[],"decl_id":null,"docs":" Wrap an error value to construct the composite result. For example,\n `Result::Err(x)` and `Result::from_error(x)` are equivalent.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":813498,"byte_end":813549,"line_start":44,"line_end":44,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":2268},"span":{"file_name":"src/libcore/ops/try.rs","byte_start":813795,"byte_end":813802,"line_start":50,"line_end":50,"column_start":8,"column_end":15},"name":"from_ok","qualname":"::ops::try::Try::from_ok","value":"fn (v: Self::Ok) -> Self","parent":{"krate":0,"index":2258},"children":[],"decl_id":null,"docs":" Wrap an OK value to construct the composite result. For example,\n `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/ops/try.rs","byte_start":813736,"byte_end":813787,"line_start":49,"line_end":49,"column_start":5,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":2274},"span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":815694,"byte_end":815707,"line_start":36,"line_end":36,"column_start":11,"column_end":24},"name":"CoerceUnsized","qualname":"::ops::unsize::CoerceUnsized","value":"CoerceUnsized<T: ?Sized>","parent":null,"children":[],"decl_id":null,"docs":" Trait that indicates that this is a pointer or a wrapper for one,\n where unsizing can be performed on the pointee.","sig":null,"attributes":[{"value":"unstable(feature = \"coerce_unsized\", issue = \"27732\")","span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":815600,"byte_end":815656,"line_start":34,"line_end":34,"column_start":1,"column_end":57}},{"value":"lang = \"coerce_unsized\"","span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":815657,"byte_end":815683,"line_start":35,"line_end":35,"column_start":1,"column_end":27}}]},{"kind":"Trait","id":{"krate":0,"index":2294},"span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":817632,"byte_end":817647,"line_start":87,"line_end":87,"column_start":11,"column_end":26},"name":"DispatchFromDyn","qualname":"::ops::unsize::DispatchFromDyn","value":"DispatchFromDyn<T>","parent":null,"children":[],"decl_id":null,"docs":" This is used for object safety, to check that a method's receiver type can be dispatched on.","sig":null,"attributes":[{"value":"unstable(feature = \"dispatch_from_dyn\", issue = \"0\")","span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":817536,"byte_end":817591,"line_start":85,"line_end":85,"column_start":1,"column_end":56}},{"value":"lang = \"dispatch_from_dyn\"","span":{"file_name":"src/libcore/ops/unsize.rs","byte_start":817592,"byte_end":817621,"line_start":86,"line_end":86,"column_start":1,"column_end":30}}]},{"kind":"Mod","id":{"krate":0,"index":2412},"span":{"file_name":"src/libcore/cmp.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"cmp","qualname":"::cmp","value":"src/libcore/cmp.rs","parent":null,"children":[{"krate":0,"index":2414},{"krate":0,"index":2416},{"krate":0,"index":2422},{"krate":0,"index":2426},{"krate":0,"index":36174},{"krate":0,"index":36190},{"krate":0,"index":36188},{"krate":0,"index":36184},{"krate":0,"index":36180},{"krate":0,"index":36176},{"krate":0,"index":2428},{"krate":0,"index":36194},{"krate":0,"index":36218},{"krate":0,"index":36214},{"krate":0,"index":36210},{"krate":0,"index":36208},{"krate":0,"index":36204},{"krate":0,"index":36200},{"krate":0,"index":36196},{"krate":0,"index":2436},{"krate":0,"index":2448},{"krate":0,"index":2452},{"krate":0,"index":2462},{"krate":0,"index":2464},{"krate":0,"index":2468},{"krate":0,"index":2472},{"krate":0,"index":2484},{"krate":0,"index":2486},{"krate":0,"index":2488}],"decl_id":null,"docs":" Functionality for ordering and comparison.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":819308,"byte_end":819354,"line_start":21,"line_end":21,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2416},"span":{"file_name":"src/libcore/cmp.rs","byte_start":824144,"byte_end":824153,"line_start":189,"line_end":189,"column_start":11,"column_end":20},"name":"PartialEq","qualname":"::cmp::PartialEq","value":"PartialEq<Rhs: ?Sized = Self>","parent":null,"children":[{"krate":0,"index":2418},{"krate":0,"index":2420}],"decl_id":null,"docs":" Trait for equality comparisons which are [partial equivalence\n relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).","sig":null,"attributes":[{"value":"lang = \"eq\"","span":{"file_name":"src/libcore/cmp.rs","byte_start":823898,"byte_end":823912,"line_start":181,"line_end":181,"column_start":1,"column_end":15}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":823913,"byte_end":823958,"line_start":182,"line_end":182,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"can\\'t compare `{Self}` with `{Rhs}`\",\n                         label = \"no implementation for `{Self} == {Rhs}`\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":824001,"byte_end":824133,"line_start":185,"line_end":188,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":2418},"span":{"file_name":"src/libcore/cmp.rs","byte_start":824347,"byte_end":824349,"line_start":194,"line_end":194,"column_start":8,"column_end":10},"name":"eq","qualname":"::cmp::PartialEq::eq","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":2416},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be equal, and is used\n by `==`.\n","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":824278,"byte_end":824289,"line_start":192,"line_end":192,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":824294,"byte_end":824339,"line_start":193,"line_end":193,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2420},"span":{"file_name":"src/libcore/cmp.rs","byte_start":824503,"byte_end":824505,"line_start":200,"line_end":200,"column_start":8,"column_end":10},"name":"ne","qualname":"::cmp::PartialEq::ne","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":2416},"children":[],"decl_id":null,"docs":" This method tests for `!=`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":824420,"byte_end":824429,"line_start":197,"line_end":197,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":824434,"byte_end":824445,"line_start":198,"line_end":198,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":824450,"byte_end":824495,"line_start":199,"line_end":199,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2422},"span":{"file_name":"src/libcore/cmp.rs","byte_start":825971,"byte_end":825973,"line_start":245,"line_end":245,"column_start":11,"column_end":13},"name":"Eq","qualname":"::cmp::Eq","value":"Eq: PartialEq<Self>","parent":null,"children":[{"krate":0,"index":2424}],"decl_id":null,"docs":" Trait for equality comparisons which are [equivalence relations](\n https://en.wikipedia.org/wiki/Equivalence_relation).","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":825915,"byte_end":825960,"line_start":244,"line_end":244,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2424},"span":{"file_name":"src/libcore/cmp.rs","byte_start":826410,"byte_end":826437,"line_start":256,"line_end":256,"column_start":8,"column_end":35},"name":"assert_receiver_is_total_eq","qualname":"::cmp::Eq::assert_receiver_is_total_eq","value":"fn (&self) -> ()","parent":{"krate":0,"index":2422},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":826343,"byte_end":826352,"line_start":254,"line_end":254,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":826357,"byte_end":826402,"line_start":255,"line_end":255,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":2426},"span":{"file_name":"src/libcore/cmp.rs","byte_start":826796,"byte_end":826811,"line_start":268,"line_end":268,"column_start":12,"column_end":27},"name":"AssertParamIsEq","qualname":"::cmp::AssertParamIsEq","value":"AssertParamIsEq {  }","parent":null,"children":[{"krate":0,"index":1341}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/cmp.rs","byte_start":826627,"byte_end":826666,"line_start":264,"line_end":264,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"derive_eq\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":826667,"byte_end":826784,"line_start":265,"line_end":267,"column_start":1,"column_end":25}}]},{"kind":"TupleVariant","id":{"krate":0,"index":15875},"span":{"file_name":"src/libcore/cmp.rs","byte_start":827458,"byte_end":827462,"line_start":291,"line_end":291,"column_start":5,"column_end":9},"name":"Less","qualname":"::cmp::Ordering::Less","value":"Ordering::Less","parent":{"krate":0,"index":36174},"children":[],"decl_id":null,"docs":" An ordering where a compared value is less than another.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":827408,"byte_end":827453,"line_start":290,"line_end":290,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":15881},"span":{"file_name":"src/libcore/cmp.rs","byte_start":827587,"byte_end":827592,"line_start":294,"line_end":294,"column_start":5,"column_end":10},"name":"Equal","qualname":"::cmp::Ordering::Equal","value":"Ordering::Equal","parent":{"krate":0,"index":36174},"children":[],"decl_id":null,"docs":" An ordering where a compared value is equal to another.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":827537,"byte_end":827582,"line_start":293,"line_end":293,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":15887},"span":{"file_name":"src/libcore/cmp.rs","byte_start":827720,"byte_end":827727,"line_start":297,"line_end":297,"column_start":5,"column_end":12},"name":"Greater","qualname":"::cmp::Ordering::Greater","value":"Ordering::Greater","parent":{"krate":0,"index":36174},"children":[],"decl_id":null,"docs":" An ordering where a compared value is greater than another.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":827670,"byte_end":827715,"line_start":296,"line_end":296,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":36174},"span":{"file_name":"src/libcore/cmp.rs","byte_start":827328,"byte_end":827336,"line_start":288,"line_end":288,"column_start":10,"column_end":18},"name":"Ordering","qualname":"::cmp::Ordering","value":"Ordering::{Less, Equal, Greater}","parent":null,"children":[{"krate":0,"index":15875},{"krate":0,"index":15881},{"krate":0,"index":15887}],"decl_id":null,"docs":" An `Ordering` is the result of a comparison between two values.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":827273,"byte_end":827318,"line_start":287,"line_end":287,"column_start":1,"column_end":46}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/cmp.rs","byte_start":827319,"byte_end":827734,"line_start":288,"line_end":298,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":2430},"span":{"file_name":"src/libcore/cmp.rs","byte_start":828641,"byte_end":828648,"line_start":332,"line_end":332,"column_start":12,"column_end":19},"name":"reverse","qualname":"<Ordering>::reverse","value":"fn (self) -> Ordering","parent":null,"children":[],"decl_id":null,"docs":" Reverses the `Ordering`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":828570,"byte_end":828579,"line_start":330,"line_end":330,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":828584,"byte_end":828629,"line_start":331,"line_end":331,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2432},"span":{"file_name":"src/libcore/cmp.rs","byte_start":829747,"byte_end":829751,"line_start":368,"line_end":368,"column_start":12,"column_end":16},"name":"then","qualname":"<Ordering>::then","value":"fn (self, other: Ordering) -> Ordering","parent":null,"children":[],"decl_id":null,"docs":" Chains two orderings.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":829663,"byte_end":829672,"line_start":366,"line_end":366,"column_start":5,"column_end":14}},{"value":"stable(feature = \"ordering_chaining\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":829677,"byte_end":829735,"line_start":367,"line_end":367,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":2434},"span":{"file_name":"src/libcore/cmp.rs","byte_start":830937,"byte_end":830946,"line_start":405,"line_end":405,"column_start":12,"column_end":21},"name":"then_with","qualname":"<Ordering>::then_with","value":"fn <F> (self, f: F) -> Ordering","parent":null,"children":[],"decl_id":null,"docs":" Chains the ordering with the given function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":830853,"byte_end":830862,"line_start":403,"line_end":403,"column_start":5,"column_end":14}},{"value":"stable(feature = \"ordering_chaining\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":830867,"byte_end":830925,"line_start":404,"line_end":404,"column_start":5,"column_end":63}}]},{"kind":"Struct","id":{"krate":0,"index":36194},"span":{"file_name":"src/libcore/cmp.rs","byte_start":831601,"byte_end":831608,"line_start":429,"line_end":429,"column_start":12,"column_end":19},"name":"Reverse","qualname":"::cmp::Reverse","value":"","parent":null,"children":[],"decl_id":null,"docs":" A helper struct for reverse ordering.","sig":null,"attributes":[{"value":"stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":831533,"byte_end":831589,"line_start":428,"line_end":428,"column_start":1,"column_end":57}},{"value":"structural_match","span":{"file_name":"src/libcore/cmp.rs","byte_start":831590,"byte_end":831676,"line_start":429,"line_end":429,"column_start":1,"column_end":87}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/cmp.rs","byte_start":831590,"byte_end":831676,"line_start":429,"line_end":429,"column_start":1,"column_end":87}}]},{"kind":"Trait","id":{"krate":0,"index":2452},"span":{"file_name":"src/libcore/cmp.rs","byte_start":834509,"byte_end":834512,"line_start":519,"line_end":519,"column_start":11,"column_end":14},"name":"Ord","qualname":"::cmp::Ord","value":"Ord: Eq + PartialOrd<Self>","parent":null,"children":[{"krate":0,"index":2454},{"krate":0,"index":2456},{"krate":0,"index":2458},{"krate":0,"index":2460}],"decl_id":null,"docs":" Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).","sig":null,"attributes":[{"value":"lang = \"ord\"","span":{"file_name":"src/libcore/cmp.rs","byte_start":834355,"byte_end":834370,"line_start":513,"line_end":513,"column_start":1,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":834453,"byte_end":834498,"line_start":518,"line_end":518,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2454},"span":{"file_name":"src/libcore/cmp.rs","byte_start":835047,"byte_end":835050,"line_start":535,"line_end":535,"column_start":8,"column_end":11},"name":"cmp","qualname":"::cmp::Ord::cmp","value":"fn (&self, other: &Self) -> Ordering","parent":{"krate":0,"index":2452},"children":[],"decl_id":null,"docs":" This method returns an `Ordering` between `self` and `other`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":834994,"byte_end":835039,"line_start":534,"line_end":534,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2456},"span":{"file_name":"src/libcore/cmp.rs","byte_start":835436,"byte_end":835439,"line_start":549,"line_end":549,"column_start":8,"column_end":11},"name":"max","qualname":"::cmp::Ord::max","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":2452},"children":[],"decl_id":null,"docs":" Compares and returns the maximum of two values.","sig":null,"attributes":[{"value":"stable(feature = \"ord_max_min\", since = \"1.21.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":835362,"byte_end":835414,"line_start":547,"line_end":547,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":835419,"byte_end":835428,"line_start":548,"line_end":548,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2458},"span":{"file_name":"src/libcore/cmp.rs","byte_start":835896,"byte_end":835899,"line_start":566,"line_end":566,"column_start":8,"column_end":11},"name":"min","qualname":"::cmp::Ord::min","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":2452},"children":[],"decl_id":null,"docs":" Compares and returns the minimum of two values.","sig":null,"attributes":[{"value":"stable(feature = \"ord_max_min\", since = \"1.21.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":835822,"byte_end":835874,"line_start":564,"line_end":564,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":835879,"byte_end":835888,"line_start":565,"line_end":565,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2460},"span":{"file_name":"src/libcore/cmp.rs","byte_start":836532,"byte_end":836537,"line_start":590,"line_end":590,"column_start":8,"column_end":13},"name":"clamp","qualname":"::cmp::Ord::clamp","value":"fn (self, min: Self, max: Self) -> Self","parent":{"krate":0,"index":2452},"children":[],"decl_id":null,"docs":" Restrict a value to a certain interval.","sig":null,"attributes":[{"value":"unstable(feature = \"clamp\", issue = \"44095\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":836477,"byte_end":836524,"line_start":589,"line_end":589,"column_start":5,"column_end":52}}]},{"kind":"Trait","id":{"krate":0,"index":2472},"span":{"file_name":"src/libcore/cmp.rs","byte_start":840574,"byte_end":840584,"line_start":730,"line_end":730,"column_start":11,"column_end":21},"name":"PartialOrd","qualname":"::cmp::PartialOrd","value":"PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs>","parent":null,"children":[{"krate":0,"index":2474},{"krate":0,"index":2476},{"krate":0,"index":2478},{"krate":0,"index":2480},{"krate":0,"index":2482}],"decl_id":null,"docs":" Trait for values that can be compared for a sort-order.","sig":null,"attributes":[{"value":"lang = \"partial_ord\"","span":{"file_name":"src/libcore/cmp.rs","byte_start":840259,"byte_end":840282,"line_start":720,"line_end":720,"column_start":1,"column_end":24}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":840283,"byte_end":840328,"line_start":721,"line_end":721,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message = \"can\\'t compare `{Self}` with `{Rhs}`\",\n                         label =\n                             \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":840411,"byte_end":840563,"line_start":726,"line_end":729,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":2474},"span":{"file_name":"src/libcore/cmp.rs","byte_start":841353,"byte_end":841364,"line_start":756,"line_end":756,"column_start":8,"column_end":19},"name":"partial_cmp","qualname":"::cmp::PartialOrd::partial_cmp","value":"fn (&self, other: &Rhs) -> Option<Ordering>","parent":{"krate":0,"index":2472},"children":[],"decl_id":null,"docs":" This method returns an ordering between `self` and `other` values if one exists.","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":841284,"byte_end":841295,"line_start":754,"line_end":754,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":841300,"byte_end":841345,"line_start":755,"line_end":755,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2476},"span":{"file_name":"src/libcore/cmp.rs","byte_start":841788,"byte_end":841790,"line_start":772,"line_end":772,"column_start":8,"column_end":10},"name":"lt","qualname":"::cmp::PartialOrd::lt","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":2472},"children":[],"decl_id":null,"docs":" This method tests less than (for `self` and `other`) and is used by the `<` operator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":841705,"byte_end":841714,"line_start":769,"line_end":769,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":841719,"byte_end":841730,"line_start":770,"line_end":770,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":841735,"byte_end":841780,"line_start":771,"line_end":771,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2478},"span":{"file_name":"src/libcore/cmp.rs","byte_start":842337,"byte_end":842339,"line_start":794,"line_end":794,"column_start":8,"column_end":10},"name":"le","qualname":"::cmp::PartialOrd::le","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":2472},"children":[],"decl_id":null,"docs":" This method tests less than or equal to (for `self` and `other`) and is used by the `<=`\n operator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":842254,"byte_end":842263,"line_start":791,"line_end":791,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":842268,"byte_end":842279,"line_start":792,"line_end":792,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":842284,"byte_end":842329,"line_start":793,"line_end":793,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2480},"span":{"file_name":"src/libcore/cmp.rs","byte_start":842882,"byte_end":842884,"line_start":815,"line_end":815,"column_start":8,"column_end":10},"name":"gt","qualname":"::cmp::PartialOrd::gt","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":2472},"children":[],"decl_id":null,"docs":" This method tests greater than (for `self` and `other`) and is used by the `>` operator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":842799,"byte_end":842808,"line_start":812,"line_end":812,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":842813,"byte_end":842824,"line_start":813,"line_end":813,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":842829,"byte_end":842874,"line_start":814,"line_end":814,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2482},"span":{"file_name":"src/libcore/cmp.rs","byte_start":843437,"byte_end":843439,"line_start":837,"line_end":837,"column_start":8,"column_end":10},"name":"ge","qualname":"::cmp::PartialOrd::ge","value":"fn (&self, other: &Rhs) -> bool","parent":{"krate":0,"index":2472},"children":[],"decl_id":null,"docs":" This method tests greater than or equal to (for `self` and `other`) and is used by the `>=`\n operator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":843354,"byte_end":843363,"line_start":834,"line_end":834,"column_start":5,"column_end":14}},{"value":"must_use","span":{"file_name":"src/libcore/cmp.rs","byte_start":843368,"byte_end":843379,"line_start":835,"line_end":835,"column_start":5,"column_end":16}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":843384,"byte_end":843429,"line_start":836,"line_end":836,"column_start":5,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":2484},"span":{"file_name":"src/libcore/cmp.rs","byte_start":843978,"byte_end":843981,"line_start":861,"line_end":861,"column_start":8,"column_end":11},"name":"min","qualname":"::cmp::min","value":"fn <T> (v1: T, v2: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Compares and returns the minimum of two values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":843915,"byte_end":843924,"line_start":859,"line_end":859,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":843925,"byte_end":843970,"line_start":860,"line_end":860,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":2486},"span":{"file_name":"src/libcore/cmp.rs","byte_start":844406,"byte_end":844409,"line_start":881,"line_end":881,"column_start":8,"column_end":11},"name":"max","qualname":"::cmp::max","value":"fn <T> (v1: T, v2: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Compares and returns the maximum of two values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cmp.rs","byte_start":844343,"byte_end":844352,"line_start":879,"line_end":879,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cmp.rs","byte_start":844353,"byte_end":844398,"line_start":880,"line_end":880,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":2604},"span":{"file_name":"src/libcore/clone.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"clone","qualname":"::clone","value":"src/libcore/clone.rs","parent":null,"children":[{"krate":0,"index":2606},{"krate":0,"index":2612},{"krate":0,"index":2614},{"krate":0,"index":2616}],"decl_id":null,"docs":" The `Clone` trait for types that cannot be 'implicitly copied'.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":853657,"byte_end":853703,"line_start":39,"line_end":39,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2606},"span":{"file_name":"src/libcore/clone.rs","byte_start":856406,"byte_end":856411,"line_start":110,"line_end":110,"column_start":11,"column_end":16},"name":"Clone","qualname":"::clone::Clone","value":"Clone: Sized","parent":null,"children":[{"krate":0,"index":2608},{"krate":0,"index":2610}],"decl_id":null,"docs":" A common trait for the ability to explicitly duplicate an object.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":856332,"byte_end":856377,"line_start":108,"line_end":108,"column_start":1,"column_end":46}},{"value":"lang = \"clone\"","span":{"file_name":"src/libcore/clone.rs","byte_start":856378,"byte_end":856395,"line_start":109,"line_end":109,"column_start":1,"column_end":18}}]},{"kind":"Method","id":{"krate":0,"index":2608},"span":{"file_name":"src/libcore/clone.rs","byte_start":856769,"byte_end":856774,"line_start":122,"line_end":122,"column_start":8,"column_end":13},"name":"clone","qualname":"::clone::Clone::clone","value":"fn (&self) -> Self","parent":{"krate":0,"index":2606},"children":[],"decl_id":null,"docs":" Returns a copy of the value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":856628,"byte_end":856673,"line_start":120,"line_end":120,"column_start":5,"column_end":50}},{"value":"must_use =\n      \"cloning is often expensive and is not expected to have side effects\"","span":{"file_name":"src/libcore/clone.rs","byte_start":856678,"byte_end":856761,"line_start":121,"line_end":121,"column_start":5,"column_end":88}}]},{"kind":"Method","id":{"krate":0,"index":2610},"span":{"file_name":"src/libcore/clone.rs","byte_start":857099,"byte_end":857109,"line_start":131,"line_end":131,"column_start":8,"column_end":18},"name":"clone_from","qualname":"::clone::Clone::clone_from","value":"fn (&mut self, source: &Self) -> ()","parent":{"krate":0,"index":2606},"children":[],"decl_id":null,"docs":" Performs copy-assignment from `source`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/clone.rs","byte_start":857032,"byte_end":857041,"line_start":129,"line_end":129,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":857046,"byte_end":857091,"line_start":130,"line_end":130,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":2612},"span":{"file_name":"src/libcore/clone.rs","byte_start":857555,"byte_end":857573,"line_start":145,"line_end":145,"column_start":12,"column_end":30},"name":"AssertParamIsClone","qualname":"::clone::AssertParamIsClone","value":"AssertParamIsClone {  }","parent":null,"children":[{"krate":0,"index":1389}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/clone.rs","byte_start":857378,"byte_end":857417,"line_start":141,"line_end":141,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"derive_clone_copy\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":857418,"byte_end":857543,"line_start":142,"line_end":144,"column_start":1,"column_end":25}}]},{"kind":"Struct","id":{"krate":0,"index":2614},"span":{"file_name":"src/libcore/clone.rs","byte_start":857827,"byte_end":857844,"line_start":151,"line_end":151,"column_start":12,"column_end":29},"name":"AssertParamIsCopy","qualname":"::clone::AssertParamIsCopy","value":"AssertParamIsCopy {  }","parent":null,"children":[{"krate":0,"index":1393}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/clone.rs","byte_start":857650,"byte_end":857689,"line_start":147,"line_end":147,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"derive_clone_copy\",\n           reason = \"deriving hack, should not be public\",\n           issue = \"0\")","span":{"file_name":"src/libcore/clone.rs","byte_start":857690,"byte_end":857815,"line_start":148,"line_end":150,"column_start":1,"column_end":25}}]},{"kind":"Mod","id":{"krate":0,"index":2638},"span":{"file_name":"src/libcore/default.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"default","qualname":"::default","value":"src/libcore/default.rs","parent":null,"children":[{"krate":0,"index":2640},{"krate":0,"index":2644},{"krate":0,"index":36646},{"krate":0,"index":36650},{"krate":0,"index":36654},{"krate":0,"index":36658},{"krate":0,"index":36662},{"krate":0,"index":36666},{"krate":0,"index":36670},{"krate":0,"index":36674},{"krate":0,"index":36678},{"krate":0,"index":36682},{"krate":0,"index":36686},{"krate":0,"index":36690},{"krate":0,"index":36694},{"krate":0,"index":36698},{"krate":0,"index":36702},{"krate":0,"index":36706},{"krate":0,"index":36710}],"decl_id":null,"docs":" The `Default` trait for types which may have meaningful default values.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/default.rs","byte_start":859450,"byte_end":859496,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2640},"span":{"file_name":"src/libcore/default.rs","byte_start":861323,"byte_end":861330,"line_start":84,"line_end":84,"column_start":11,"column_end":18},"name":"Default","qualname":"::default::Default","value":"Default: Sized","parent":null,"children":[{"krate":0,"index":2642}],"decl_id":null,"docs":" A trait for giving a type a useful default value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/default.rs","byte_start":861267,"byte_end":861312,"line_start":83,"line_end":83,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2642},"span":{"file_name":"src/libcore/default.rs","byte_start":862139,"byte_end":862146,"line_start":115,"line_end":115,"column_start":8,"column_end":15},"name":"default","qualname":"::default::Default::default","value":"fn () -> Self","parent":{"krate":0,"index":2640},"children":[],"decl_id":null,"docs":" Returns the \"default value\" for a type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/default.rs","byte_start":862086,"byte_end":862131,"line_start":114,"line_end":114,"column_start":5,"column_end":50}}]},{"kind":"Mod","id":{"krate":0,"index":2646},"span":{"file_name":"src/libcore/convert.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"convert","qualname":"::convert","value":"src/libcore/convert.rs","parent":null,"children":[{"krate":0,"index":2648},{"krate":0,"index":2650},{"krate":0,"index":2652},{"krate":0,"index":2656},{"krate":0,"index":2660},{"krate":0,"index":2664},{"krate":0,"index":2668},{"krate":0,"index":2674},{"krate":0,"index":2680},{"krate":0,"index":2684},{"krate":0,"index":2688},{"krate":0,"index":2692},{"krate":0,"index":2696},{"krate":0,"index":2700},{"krate":0,"index":2706},{"krate":0,"index":2712},{"krate":0,"index":2716},{"krate":0,"index":2720},{"krate":0,"index":36714},{"krate":0,"index":36716},{"krate":0,"index":2724},{"krate":0,"index":2728},{"krate":0,"index":2732},{"krate":0,"index":2736},{"krate":0,"index":2740},{"krate":0,"index":2742},{"krate":0,"index":2746},{"krate":0,"index":2750}],"decl_id":null,"docs":" Traits for conversions between types.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":865448,"byte_end":865494,"line_start":41,"line_end":41,"column_start":1,"column_end":47}}]},{"kind":"Function","id":{"krate":0,"index":2650},"span":{"file_name":"src/libcore/convert.rs","byte_start":866986,"byte_end":866994,"line_start":99,"line_end":99,"column_start":14,"column_end":22},"name":"identity","qualname":"::convert::identity","value":"fn <T> (x: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" An identity function.","sig":null,"attributes":[{"value":"stable(feature = \"convert_id\", since = \"1.33.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":866911,"byte_end":866962,"line_start":97,"line_end":97,"column_start":1,"column_end":52}},{"value":"inline","span":{"file_name":"src/libcore/convert.rs","byte_start":866963,"byte_end":866972,"line_start":98,"line_end":98,"column_start":1,"column_end":10}}]},{"kind":"Trait","id":{"krate":0,"index":2652},"span":{"file_name":"src/libcore/convert.rs","byte_start":869069,"byte_end":869074,"line_start":154,"line_end":154,"column_start":11,"column_end":16},"name":"AsRef","qualname":"::convert::AsRef","value":"AsRef<T: ?Sized>","parent":null,"children":[{"krate":0,"index":2654}],"decl_id":null,"docs":" Used to do a cheap reference-to-reference conversion.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":869013,"byte_end":869058,"line_start":153,"line_end":153,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2654},"span":{"file_name":"src/libcore/convert.rs","byte_start":869178,"byte_end":869184,"line_start":157,"line_end":157,"column_start":8,"column_end":14},"name":"as_ref","qualname":"::convert::AsRef::as_ref","value":"fn (&self) -> &T","parent":{"krate":0,"index":2652},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":869125,"byte_end":869170,"line_start":156,"line_end":156,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2656},"span":{"file_name":"src/libcore/convert.rs","byte_start":870682,"byte_end":870687,"line_start":197,"line_end":197,"column_start":11,"column_end":16},"name":"AsMut","qualname":"::convert::AsMut","value":"AsMut<T: ?Sized>","parent":null,"children":[{"krate":0,"index":2658}],"decl_id":null,"docs":" Used to do a cheap mutable-to-mutable reference conversion.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":870626,"byte_end":870671,"line_start":196,"line_end":196,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2658},"span":{"file_name":"src/libcore/convert.rs","byte_start":870791,"byte_end":870797,"line_start":200,"line_end":200,"column_start":8,"column_end":14},"name":"as_mut","qualname":"::convert::AsMut::as_mut","value":"fn (&mut self) -> &mut T","parent":{"krate":0,"index":2656},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":870738,"byte_end":870783,"line_start":199,"line_end":199,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2660},"span":{"file_name":"src/libcore/convert.rs","byte_start":873680,"byte_end":873684,"line_start":279,"line_end":279,"column_start":11,"column_end":15},"name":"Into","qualname":"::convert::Into","value":"Into<T>: Sized","parent":null,"children":[{"krate":0,"index":2662}],"decl_id":null,"docs":" A value-to-value conversion that consumes the input value. The\n opposite of [`From`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":873624,"byte_end":873669,"line_start":278,"line_end":278,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2662},"span":{"file_name":"src/libcore/convert.rs","byte_start":873787,"byte_end":873791,"line_start":282,"line_end":282,"column_start":8,"column_end":12},"name":"into","qualname":"::convert::Into::into","value":"fn (self) -> T","parent":{"krate":0,"index":2660},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":873734,"byte_end":873779,"line_start":281,"line_end":281,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2664},"span":{"file_name":"src/libcore/convert.rs","byte_start":877309,"byte_end":877313,"line_start":374,"line_end":374,"column_start":11,"column_end":15},"name":"From","qualname":"::convert::From","value":"From<T>: Sized","parent":null,"children":[{"krate":0,"index":2666}],"decl_id":null,"docs":" Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n [`Into`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":877086,"byte_end":877131,"line_start":367,"line_end":367,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(on(all(_Self = \"&str\", T = \"std::string::String\"),\n                            note =\n                                \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\"))","span":{"file_name":"src/libcore/convert.rs","byte_start":877132,"byte_end":877298,"line_start":368,"line_end":373,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":2666},"span":{"file_name":"src/libcore/convert.rs","byte_start":877416,"byte_end":877420,"line_start":377,"line_end":377,"column_start":8,"column_end":12},"name":"from","qualname":"::convert::From::from","value":"fn (_: T) -> Self","parent":{"krate":0,"index":2664},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":877363,"byte_end":877408,"line_start":376,"line_end":376,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2668},"span":{"file_name":"src/libcore/convert.rs","byte_start":878170,"byte_end":878177,"line_start":398,"line_end":398,"column_start":11,"column_end":18},"name":"TryInto","qualname":"::convert::TryInto","value":"TryInto<T>: Sized","parent":null,"children":[{"krate":0,"index":2670},{"krate":0,"index":2672}],"decl_id":null,"docs":" An attempted conversion that consumes `self`, which may or may not be\n expensive.","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":878110,"byte_end":878159,"line_start":397,"line_end":397,"column_start":1,"column_end":50}}]},{"kind":"Type","id":{"krate":0,"index":2670},"span":{"file_name":"src/libcore/convert.rs","byte_start":878315,"byte_end":878320,"line_start":401,"line_end":401,"column_start":10,"column_end":15},"name":"Error","qualname":"::convert::TryInto::Error","value":"type Error;","parent":{"krate":0,"index":2668},"children":[],"decl_id":null,"docs":" The type returned in the event of a conversion error.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":878256,"byte_end":878305,"line_start":400,"line_end":400,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":2672},"span":{"file_name":"src/libcore/convert.rs","byte_start":878417,"byte_end":878425,"line_start":405,"line_end":405,"column_start":8,"column_end":16},"name":"try_into","qualname":"::convert::TryInto::try_into","value":"fn (self) -> Result<T, Self::Error>","parent":{"krate":0,"index":2668},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":878360,"byte_end":878409,"line_start":404,"line_end":404,"column_start":5,"column_end":54}}]},{"kind":"Trait","id":{"krate":0,"index":2674},"span":{"file_name":"src/libcore/convert.rs","byte_start":881034,"byte_end":881041,"line_start":478,"line_end":478,"column_start":11,"column_end":18},"name":"TryFrom","qualname":"::convert::TryFrom","value":"TryFrom<T>: Sized","parent":null,"children":[{"krate":0,"index":2676},{"krate":0,"index":2678}],"decl_id":null,"docs":" Simple and safe type conversions that may fail in a controlled\n way under some circumstances. It is the reciprocal of [`TryInto`].","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":880974,"byte_end":881023,"line_start":477,"line_end":477,"column_start":1,"column_end":50}}]},{"kind":"Type","id":{"krate":0,"index":2676},"span":{"file_name":"src/libcore/convert.rs","byte_start":881179,"byte_end":881184,"line_start":481,"line_end":481,"column_start":10,"column_end":15},"name":"Error","qualname":"::convert::TryFrom::Error","value":"type Error;","parent":{"krate":0,"index":2674},"children":[],"decl_id":null,"docs":" The type returned in the event of a conversion error.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":881120,"byte_end":881169,"line_start":480,"line_end":480,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":2678},"span":{"file_name":"src/libcore/convert.rs","byte_start":881281,"byte_end":881289,"line_start":485,"line_end":485,"column_start":8,"column_end":16},"name":"try_from","qualname":"::convert::TryFrom::try_from","value":"fn (value: T) -> Result<Self, Self::Error>","parent":{"krate":0,"index":2674},"children":[],"decl_id":null,"docs":" Performs the conversion.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":881224,"byte_end":881273,"line_start":484,"line_end":484,"column_start":5,"column_end":54}}]},{"kind":"Enum","id":{"krate":0,"index":36714},"span":{"file_name":"src/libcore/convert.rs","byte_start":886440,"byte_end":886450,"line_start":657,"line_end":657,"column_start":10,"column_end":20},"name":"Infallible","qualname":"::convert::Infallible","value":"Infallible::{}","parent":null,"children":[],"decl_id":null,"docs":" The error type for errors that can never happen.","sig":null,"attributes":[{"value":"stable(feature = \"convert_infallible\", since = \"1.34.0\")","span":{"file_name":"src/libcore/convert.rs","byte_start":886355,"byte_end":886414,"line_start":655,"line_end":655,"column_start":1,"column_end":60}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/convert.rs","byte_start":886431,"byte_end":886453,"line_start":657,"line_end":657,"column_start":1,"column_end":23}}]},{"kind":"Mod","id":{"krate":0,"index":2754},"span":{"file_name":"src/libcore/borrow.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"borrow","qualname":"::borrow","value":"src/libcore/borrow.rs","parent":null,"children":[{"krate":0,"index":2756},{"krate":0,"index":2760},{"krate":0,"index":2764},{"krate":0,"index":2768},{"krate":0,"index":2772},{"krate":0,"index":2776},{"krate":0,"index":2780}],"decl_id":null,"docs":" A module for working with borrowed data.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":887803,"byte_end":887849,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2756},"span":{"file_name":"src/libcore/borrow.rs","byte_start":894562,"byte_end":894568,"line_start":160,"line_end":160,"column_start":11,"column_end":17},"name":"Borrow","qualname":"::borrow::Borrow","value":"Borrow<Borrowed: ?Sized>","parent":null,"children":[{"krate":0,"index":2758}],"decl_id":null,"docs":" A trait for borrowing data.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":894506,"byte_end":894551,"line_start":159,"line_end":159,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2758},"span":{"file_name":"src/libcore/borrow.rs","byte_start":895019,"byte_end":895025,"line_start":181,"line_end":181,"column_start":8,"column_end":14},"name":"borrow","qualname":"::borrow::Borrow::borrow","value":"fn (&self) -> &Borrowed","parent":{"krate":0,"index":2756},"children":[],"decl_id":null,"docs":" Immutably borrows from an owned value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":894966,"byte_end":895011,"line_start":180,"line_end":180,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":2760},"span":{"file_name":"src/libcore/borrow.rs","byte_start":895395,"byte_end":895404,"line_start":192,"line_end":192,"column_start":11,"column_end":20},"name":"BorrowMut","qualname":"::borrow::BorrowMut","value":"BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed>","parent":null,"children":[{"krate":0,"index":2762}],"decl_id":null,"docs":" A trait for mutably borrowing data.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":895339,"byte_end":895384,"line_start":191,"line_end":191,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2762},"span":{"file_name":"src/libcore/borrow.rs","byte_start":895830,"byte_end":895840,"line_start":209,"line_end":209,"column_start":8,"column_end":18},"name":"borrow_mut","qualname":"::borrow::BorrowMut::borrow_mut","value":"fn (&mut self) -> &mut Borrowed","parent":{"krate":0,"index":2760},"children":[],"decl_id":null,"docs":" Mutably borrows from an owned value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/borrow.rs","byte_start":895777,"byte_end":895822,"line_start":208,"line_end":208,"column_start":5,"column_end":50}}]},{"kind":"Mod","id":{"krate":0,"index":2784},"span":{"file_name":"src/libcore/any.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"any","qualname":"::any","value":"src/libcore/any.rs","parent":null,"children":[{"krate":0,"index":2786},{"krate":0,"index":2788},{"krate":0,"index":2790},{"krate":0,"index":2794},{"krate":0,"index":2798},{"krate":0,"index":2802},{"krate":0,"index":2806},{"krate":0,"index":2810},{"krate":0,"index":2818},{"krate":0,"index":2826},{"krate":0,"index":36718},{"krate":0,"index":36756},{"krate":0,"index":36754},{"krate":0,"index":36748},{"krate":0,"index":36744},{"krate":0,"index":36732},{"krate":0,"index":36728},{"krate":0,"index":36724},{"krate":0,"index":36720},{"krate":0,"index":2834}],"decl_id":null,"docs":" This module implements the `Any` trait, which enables dynamic typing\n of any `'static` type through runtime reflection.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":898907,"byte_end":898953,"line_start":62,"line_end":62,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":2790},"span":{"file_name":"src/libcore/any.rs","byte_start":899458,"byte_end":899461,"line_start":78,"line_end":78,"column_start":11,"column_end":14},"name":"Any","qualname":"::any::Any","value":"Any: 'static","parent":null,"children":[{"krate":0,"index":2792}],"decl_id":null,"docs":" A type to emulate dynamic typing.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":899402,"byte_end":899447,"line_start":77,"line_end":77,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":2792},"span":{"file_name":"src/libcore/any.rs","byte_start":899938,"byte_end":899945,"line_start":96,"line_end":96,"column_start":8,"column_end":15},"name":"type_id","qualname":"::any::Any::type_id","value":"fn (&self) -> TypeId","parent":{"krate":0,"index":2790},"children":[],"decl_id":null,"docs":" Gets the `TypeId` of `self`.","sig":null,"attributes":[{"value":"stable(feature = \"get_type_id\", since = \"1.34.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":899878,"byte_end":899930,"line_start":95,"line_end":95,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":2812},"span":{"file_name":"src/libcore/any.rs","byte_start":901599,"byte_end":901601,"line_start":155,"line_end":155,"column_start":12,"column_end":14},"name":"is","qualname":"<Any>::is","value":"fn <T> (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the boxed type is the same as `T`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":901528,"byte_end":901573,"line_start":153,"line_end":153,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":901578,"byte_end":901587,"line_start":154,"line_end":154,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2814},"span":{"file_name":"src/libcore/any.rs","byte_start":902572,"byte_end":902584,"line_start":189,"line_end":189,"column_start":12,"column_end":24},"name":"downcast_ref","qualname":"<Any>::downcast_ref","value":"fn <T> (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Returns some reference to the boxed value if it is of type `T`, or\n `None` if it isn't.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":902501,"byte_end":902546,"line_start":187,"line_end":187,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":902551,"byte_end":902560,"line_start":188,"line_end":188,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2816},"span":{"file_name":"src/libcore/any.rs","byte_start":903497,"byte_end":903509,"line_start":226,"line_end":226,"column_start":12,"column_end":24},"name":"downcast_mut","qualname":"<Any>::downcast_mut","value":"fn <T> (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns some mutable reference to the boxed value if it is of type `T`, or\n `None` if it isn't.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":903426,"byte_end":903471,"line_start":224,"line_end":224,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":903476,"byte_end":903485,"line_start":225,"line_end":225,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2820},"span":{"file_name":"src/libcore/any.rs","byte_start":904305,"byte_end":904307,"line_start":260,"line_end":260,"column_start":12,"column_end":14},"name":"is","qualname":"<Any + Send>::is","value":"fn <T> (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":904234,"byte_end":904279,"line_start":258,"line_end":258,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":904284,"byte_end":904293,"line_start":259,"line_end":259,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2822},"span":{"file_name":"src/libcore/any.rs","byte_start":905004,"byte_end":905016,"line_start":286,"line_end":286,"column_start":12,"column_end":24},"name":"downcast_ref","qualname":"<Any + Send>::downcast_ref","value":"fn <T> (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":904933,"byte_end":904978,"line_start":284,"line_end":284,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":904983,"byte_end":904992,"line_start":285,"line_end":285,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2824},"span":{"file_name":"src/libcore/any.rs","byte_start":905754,"byte_end":905766,"line_start":316,"line_end":316,"column_start":12,"column_end":24},"name":"downcast_mut","qualname":"<Any + Send>::downcast_mut","value":"fn <T> (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":905683,"byte_end":905728,"line_start":314,"line_end":314,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":905733,"byte_end":905742,"line_start":315,"line_end":315,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2828},"span":{"file_name":"src/libcore/any.rs","byte_start":906460,"byte_end":906462,"line_start":344,"line_end":344,"column_start":12,"column_end":14},"name":"is","qualname":"<Any + Send + Sync>::is","value":"fn <T> (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":906372,"byte_end":906434,"line_start":342,"line_end":342,"column_start":5,"column_end":67}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":906439,"byte_end":906448,"line_start":343,"line_end":343,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2830},"span":{"file_name":"src/libcore/any.rs","byte_start":907183,"byte_end":907195,"line_start":370,"line_end":370,"column_start":12,"column_end":24},"name":"downcast_ref","qualname":"<Any + Send + Sync>::downcast_ref","value":"fn <T> (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":907095,"byte_end":907157,"line_start":368,"line_end":368,"column_start":5,"column_end":67}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":907162,"byte_end":907171,"line_start":369,"line_end":369,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":2832},"span":{"file_name":"src/libcore/any.rs","byte_start":907957,"byte_end":907969,"line_start":400,"line_end":400,"column_start":12,"column_end":24},"name":"downcast_mut","qualname":"<Any + Send + Sync>::downcast_mut","value":"fn <T> (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Forwards to the method defined on the type `Any`.","sig":null,"attributes":[{"value":"stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":907869,"byte_end":907931,"line_start":398,"line_end":398,"column_start":5,"column_end":67}},{"value":"inline","span":{"file_name":"src/libcore/any.rs","byte_start":907936,"byte_end":907945,"line_start":399,"line_end":399,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":36718},"span":{"file_name":"src/libcore/any.rs","byte_start":908959,"byte_end":908965,"line_start":423,"line_end":423,"column_start":12,"column_end":18},"name":"TypeId","qualname":"::any::TypeId","value":"TypeId {  }","parent":null,"children":[{"krate":0,"index":15917}],"decl_id":null,"docs":" A `TypeId` represents a globally unique identifier for a type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":908902,"byte_end":908947,"line_start":422,"line_end":422,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/any.rs","byte_start":908948,"byte_end":908981,"line_start":423,"line_end":425,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/any.rs","byte_start":908948,"byte_end":908981,"line_start":423,"line_end":425,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":2836},"span":{"file_name":"src/libcore/any.rs","byte_start":909598,"byte_end":909600,"line_start":447,"line_end":447,"column_start":18,"column_end":20},"name":"of","qualname":"<TypeId>::of","value":"fn <T> () -> TypeId","parent":null,"children":[],"decl_id":null,"docs":" Returns the `TypeId` of the type this generic function has been\n instantiated with.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/any.rs","byte_start":909482,"byte_end":909527,"line_start":445,"line_end":445,"column_start":5,"column_end":50}},{"value":"rustc_const_unstable(feature = \"const_type_id\")","span":{"file_name":"src/libcore/any.rs","byte_start":909532,"byte_end":909580,"line_start":446,"line_end":446,"column_start":5,"column_end":53}}]},{"kind":"Mod","id":{"krate":0,"index":2838},"span":{"file_name":"src/libcore/array.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"array","qualname":"::array","value":"src/libcore/array.rs","parent":null,"children":[{"krate":0,"index":2840},{"krate":0,"index":2846},{"krate":0,"index":2848},{"krate":0,"index":2850},{"krate":0,"index":2852},{"krate":0,"index":2858},{"krate":0,"index":2860},{"krate":0,"index":2866},{"krate":0,"index":2872},{"krate":0,"index":36760},{"krate":0,"index":36768},{"krate":0,"index":36766},{"krate":0,"index":36762},{"krate":0,"index":2878},{"krate":0,"index":2882},{"krate":0,"index":2886},{"krate":0,"index":2888},{"krate":0,"index":2890},{"krate":0,"index":36772},{"krate":0,"index":36776},{"krate":0,"index":36780},{"krate":0,"index":36784},{"krate":0,"index":36788},{"krate":0,"index":36794},{"krate":0,"index":36800},{"krate":0,"index":36806},{"krate":0,"index":36810},{"krate":0,"index":36814},{"krate":0,"index":36822},{"krate":0,"index":39280},{"krate":0,"index":39292},{"krate":0,"index":39286},{"krate":0,"index":39304},{"krate":0,"index":39298},{"krate":0,"index":39316},{"krate":0,"index":39310},{"krate":0,"index":36830},{"krate":0,"index":36832},{"krate":0,"index":36844},{"krate":0,"index":36848},{"krate":0,"index":36852},{"krate":0,"index":36856},{"krate":0,"index":36860},{"krate":0,"index":36864},{"krate":0,"index":36870},{"krate":0,"index":36876},{"krate":0,"index":36882},{"krate":0,"index":36886},{"krate":0,"index":36890},{"krate":0,"index":36898},{"krate":0,"index":39322},{"krate":0,"index":39334},{"krate":0,"index":39328},{"krate":0,"index":39346},{"krate":0,"index":39340},{"krate":0,"index":39358},{"krate":0,"index":39352},{"krate":0,"index":36906},{"krate":0,"index":36908},{"krate":0,"index":36920},{"krate":0,"index":36924},{"krate":0,"index":36928},{"krate":0,"index":36932},{"krate":0,"index":36936},{"krate":0,"index":36940},{"krate":0,"index":36946},{"krate":0,"index":36952},{"krate":0,"index":36958},{"krate":0,"index":36962},{"krate":0,"index":36966},{"krate":0,"index":36974},{"krate":0,"index":39364},{"krate":0,"index":39376},{"krate":0,"index":39370},{"krate":0,"index":39388},{"krate":0,"index":39382},{"krate":0,"index":39400},{"krate":0,"index":39394},{"krate":0,"index":36982},{"krate":0,"index":36984},{"krate":0,"index":36996},{"krate":0,"index":37000},{"krate":0,"index":37004},{"krate":0,"index":37008},{"krate":0,"index":37012},{"krate":0,"index":37016},{"krate":0,"index":37022},{"krate":0,"index":37028},{"krate":0,"index":37034},{"krate":0,"index":37038},{"krate":0,"index":37042},{"krate":0,"index":37050},{"krate":0,"index":39406},{"krate":0,"index":39418},{"krate":0,"index":39412},{"krate":0,"index":39430},{"krate":0,"index":39424},{"krate":0,"index":39442},{"krate":0,"index":39436},{"krate":0,"index":37058},{"krate":0,"index":37060},{"krate":0,"index":37072},{"krate":0,"index":37076},{"krate":0,"index":37080},{"krate":0,"index":37084},{"krate":0,"index":37088},{"krate":0,"index":37092},{"krate":0,"index":37098},{"krate":0,"index":37104},{"krate":0,"index":37110},{"krate":0,"index":37114},{"krate":0,"index":37118},{"krate":0,"index":37126},{"krate":0,"index":39448},{"krate":0,"index":39460},{"krate":0,"index":39454},{"krate":0,"index":39472},{"krate":0,"index":39466},{"krate":0,"index":39484},{"krate":0,"index":39478},{"krate":0,"index":37134},{"krate":0,"index":37136},{"krate":0,"index":37148},{"krate":0,"index":37152},{"krate":0,"index":37156},{"krate":0,"index":37160},{"krate":0,"index":37164},{"krate":0,"index":37168},{"krate":0,"index":37174},{"krate":0,"index":37180},{"krate":0,"index":37186},{"krate":0,"index":37190},{"krate":0,"index":37194},{"krate":0,"index":37202},{"krate":0,"index":39490},{"krate":0,"index":39502},{"krate":0,"index":39496},{"krate":0,"index":39514},{"krate":0,"index":39508},{"krate":0,"index":39526},{"krate":0,"index":39520},{"krate":0,"index":37210},{"krate":0,"index":37212},{"krate":0,"index":37224},{"krate":0,"index":37228},{"krate":0,"index":37232},{"krate":0,"index":37236},{"krate":0,"index":37240},{"krate":0,"index":37244},{"krate":0,"index":37250},{"krate":0,"index":37256},{"krate":0,"index":37262},{"krate":0,"index":37266},{"krate":0,"index":37270},{"krate":0,"index":37278},{"krate":0,"index":39532},{"krate":0,"index":39544},{"krate":0,"index":39538},{"krate":0,"index":39556},{"krate":0,"index":39550},{"krate":0,"index":39568},{"krate":0,"index":39562},{"krate":0,"index":37286},{"krate":0,"index":37288},{"krate":0,"index":37300},{"krate":0,"index":37304},{"krate":0,"index":37308},{"krate":0,"index":37312},{"krate":0,"index":37316},{"krate":0,"index":37320},{"krate":0,"index":37326},{"krate":0,"index":37332},{"krate":0,"index":37338},{"krate":0,"index":37342},{"krate":0,"index":37346},{"krate":0,"index":37354},{"krate":0,"index":39574},{"krate":0,"index":39586},{"krate":0,"index":39580},{"krate":0,"index":39598},{"krate":0,"index":39592},{"krate":0,"index":39610},{"krate":0,"index":39604},{"krate":0,"index":37362},{"krate":0,"index":37364},{"krate":0,"index":37376},{"krate":0,"index":37380},{"krate":0,"index":37384},{"krate":0,"index":37388},{"krate":0,"index":37392},{"krate":0,"index":37396},{"krate":0,"index":37402},{"krate":0,"index":37408},{"krate":0,"index":37414},{"krate":0,"index":37418},{"krate":0,"index":37422},{"krate":0,"index":37430},{"krate":0,"index":39616},{"krate":0,"index":39628},{"krate":0,"index":39622},{"krate":0,"index":39640},{"krate":0,"index":39634},{"krate":0,"index":39652},{"krate":0,"index":39646},{"krate":0,"index":37438},{"krate":0,"index":37440},{"krate":0,"index":37452},{"krate":0,"index":37456},{"krate":0,"index":37460},{"krate":0,"index":37464},{"krate":0,"index":37468},{"krate":0,"index":37472},{"krate":0,"index":37478},{"krate":0,"index":37484},{"krate":0,"index":37490},{"krate":0,"index":37494},{"krate":0,"index":37498},{"krate":0,"index":37506},{"krate":0,"index":39658},{"krate":0,"index":39670},{"krate":0,"index":39664},{"krate":0,"index":39682},{"krate":0,"index":39676},{"krate":0,"index":39694},{"krate":0,"index":39688},{"krate":0,"index":37514},{"krate":0,"index":37516},{"krate":0,"index":37528},{"krate":0,"index":37532},{"krate":0,"index":37536},{"krate":0,"index":37540},{"krate":0,"index":37544},{"krate":0,"index":37548},{"krate":0,"index":37554},{"krate":0,"index":37560},{"krate":0,"index":37566},{"krate":0,"index":37570},{"krate":0,"index":37574},{"krate":0,"index":37582},{"krate":0,"index":39700},{"krate":0,"index":39712},{"krate":0,"index":39706},{"krate":0,"index":39724},{"krate":0,"index":39718},{"krate":0,"index":39736},{"krate":0,"index":39730},{"krate":0,"index":37590},{"krate":0,"index":37592},{"krate":0,"index":37604},{"krate":0,"index":37608},{"krate":0,"index":37612},{"krate":0,"index":37616},{"krate":0,"index":37620},{"krate":0,"index":37624},{"krate":0,"index":37630},{"krate":0,"index":37636},{"krate":0,"index":37642},{"krate":0,"index":37646},{"krate":0,"index":37650},{"krate":0,"index":37658},{"krate":0,"index":39742},{"krate":0,"index":39754},{"krate":0,"index":39748},{"krate":0,"index":39766},{"krate":0,"index":39760},{"krate":0,"index":39778},{"krate":0,"index":39772},{"krate":0,"index":37666},{"krate":0,"index":37668},{"krate":0,"index":37680},{"krate":0,"index":37684},{"krate":0,"index":37688},{"krate":0,"index":37692},{"krate":0,"index":37696},{"krate":0,"index":37700},{"krate":0,"index":37706},{"krate":0,"index":37712},{"krate":0,"index":37718},{"krate":0,"index":37722},{"krate":0,"index":37726},{"krate":0,"index":37734},{"krate":0,"index":39784},{"krate":0,"index":39796},{"krate":0,"index":39790},{"krate":0,"index":39808},{"krate":0,"index":39802},{"krate":0,"index":39820},{"krate":0,"index":39814},{"krate":0,"index":37742},{"krate":0,"index":37744},{"krate":0,"index":37756},{"krate":0,"index":37760},{"krate":0,"index":37764},{"krate":0,"index":37768},{"krate":0,"index":37772},{"krate":0,"index":37776},{"krate":0,"index":37782},{"krate":0,"index":37788},{"krate":0,"index":37794},{"krate":0,"index":37798},{"krate":0,"index":37802},{"krate":0,"index":37810},{"krate":0,"index":39826},{"krate":0,"index":39838},{"krate":0,"index":39832},{"krate":0,"index":39850},{"krate":0,"index":39844},{"krate":0,"index":39862},{"krate":0,"index":39856},{"krate":0,"index":37818},{"krate":0,"index":37820},{"krate":0,"index":37832},{"krate":0,"index":37836},{"krate":0,"index":37840},{"krate":0,"index":37844},{"krate":0,"index":37848},{"krate":0,"index":37852},{"krate":0,"index":37858},{"krate":0,"index":37864},{"krate":0,"index":37870},{"krate":0,"index":37874},{"krate":0,"index":37878},{"krate":0,"index":37886},{"krate":0,"index":39868},{"krate":0,"index":39880},{"krate":0,"index":39874},{"krate":0,"index":39892},{"krate":0,"index":39886},{"krate":0,"index":39904},{"krate":0,"index":39898},{"krate":0,"index":37894},{"krate":0,"index":37896},{"krate":0,"index":37908},{"krate":0,"index":37912},{"krate":0,"index":37916},{"krate":0,"index":37920},{"krate":0,"index":37924},{"krate":0,"index":37928},{"krate":0,"index":37934},{"krate":0,"index":37940},{"krate":0,"index":37946},{"krate":0,"index":37950},{"krate":0,"index":37954},{"krate":0,"index":37962},{"krate":0,"index":39910},{"krate":0,"index":39922},{"krate":0,"index":39916},{"krate":0,"index":39934},{"krate":0,"index":39928},{"krate":0,"index":39946},{"krate":0,"index":39940},{"krate":0,"index":37970},{"krate":0,"index":37972},{"krate":0,"index":37984},{"krate":0,"index":37988},{"krate":0,"index":37992},{"krate":0,"index":37996},{"krate":0,"index":38000},{"krate":0,"index":38004},{"krate":0,"index":38010},{"krate":0,"index":38016},{"krate":0,"index":38022},{"krate":0,"index":38026},{"krate":0,"index":38030},{"krate":0,"index":38038},{"krate":0,"index":39952},{"krate":0,"index":39964},{"krate":0,"index":39958},{"krate":0,"index":39976},{"krate":0,"index":39970},{"krate":0,"index":39988},{"krate":0,"index":39982},{"krate":0,"index":38046},{"krate":0,"index":38048},{"krate":0,"index":38060},{"krate":0,"index":38064},{"krate":0,"index":38068},{"krate":0,"index":38072},{"krate":0,"index":38076},{"krate":0,"index":38080},{"krate":0,"index":38086},{"krate":0,"index":38092},{"krate":0,"index":38098},{"krate":0,"index":38102},{"krate":0,"index":38106},{"krate":0,"index":38114},{"krate":0,"index":39994},{"krate":0,"index":40006},{"krate":0,"index":40000},{"krate":0,"index":40018},{"krate":0,"index":40012},{"krate":0,"index":40030},{"krate":0,"index":40024},{"krate":0,"index":38122},{"krate":0,"index":38124},{"krate":0,"index":38136},{"krate":0,"index":38140},{"krate":0,"index":38144},{"krate":0,"index":38148},{"krate":0,"index":38152},{"krate":0,"index":38156},{"krate":0,"index":38162},{"krate":0,"index":38168},{"krate":0,"index":38174},{"krate":0,"index":38178},{"krate":0,"index":38182},{"krate":0,"index":38190},{"krate":0,"index":40036},{"krate":0,"index":40048},{"krate":0,"index":40042},{"krate":0,"index":40060},{"krate":0,"index":40054},{"krate":0,"index":40072},{"krate":0,"index":40066},{"krate":0,"index":38198},{"krate":0,"index":38200},{"krate":0,"index":38212},{"krate":0,"index":38216},{"krate":0,"index":38220},{"krate":0,"index":38224},{"krate":0,"index":38228},{"krate":0,"index":38232},{"krate":0,"index":38238},{"krate":0,"index":38244},{"krate":0,"index":38250},{"krate":0,"index":38254},{"krate":0,"index":38258},{"krate":0,"index":38266},{"krate":0,"index":40078},{"krate":0,"index":40090},{"krate":0,"index":40084},{"krate":0,"index":40102},{"krate":0,"index":40096},{"krate":0,"index":40114},{"krate":0,"index":40108},{"krate":0,"index":38274},{"krate":0,"index":38276},{"krate":0,"index":38288},{"krate":0,"index":38292},{"krate":0,"index":38296},{"krate":0,"index":38300},{"krate":0,"index":38304},{"krate":0,"index":38308},{"krate":0,"index":38314},{"krate":0,"index":38320},{"krate":0,"index":38326},{"krate":0,"index":38330},{"krate":0,"index":38334},{"krate":0,"index":38342},{"krate":0,"index":40120},{"krate":0,"index":40132},{"krate":0,"index":40126},{"krate":0,"index":40144},{"krate":0,"index":40138},{"krate":0,"index":40156},{"krate":0,"index":40150},{"krate":0,"index":38350},{"krate":0,"index":38352},{"krate":0,"index":38364},{"krate":0,"index":38368},{"krate":0,"index":38372},{"krate":0,"index":38376},{"krate":0,"index":38380},{"krate":0,"index":38384},{"krate":0,"index":38390},{"krate":0,"index":38396},{"krate":0,"index":38402},{"krate":0,"index":38406},{"krate":0,"index":38410},{"krate":0,"index":38418},{"krate":0,"index":40162},{"krate":0,"index":40174},{"krate":0,"index":40168},{"krate":0,"index":40186},{"krate":0,"index":40180},{"krate":0,"index":40198},{"krate":0,"index":40192},{"krate":0,"index":38426},{"krate":0,"index":38428},{"krate":0,"index":38440},{"krate":0,"index":38444},{"krate":0,"index":38448},{"krate":0,"index":38452},{"krate":0,"index":38456},{"krate":0,"index":38460},{"krate":0,"index":38466},{"krate":0,"index":38472},{"krate":0,"index":38478},{"krate":0,"index":38482},{"krate":0,"index":38486},{"krate":0,"index":38494},{"krate":0,"index":40204},{"krate":0,"index":40216},{"krate":0,"index":40210},{"krate":0,"index":40228},{"krate":0,"index":40222},{"krate":0,"index":40240},{"krate":0,"index":40234},{"krate":0,"index":38502},{"krate":0,"index":38504},{"krate":0,"index":38516},{"krate":0,"index":38520},{"krate":0,"index":38524},{"krate":0,"index":38528},{"krate":0,"index":38532},{"krate":0,"index":38536},{"krate":0,"index":38542},{"krate":0,"index":38548},{"krate":0,"index":38554},{"krate":0,"index":38558},{"krate":0,"index":38562},{"krate":0,"index":38570},{"krate":0,"index":40246},{"krate":0,"index":40258},{"krate":0,"index":40252},{"krate":0,"index":40270},{"krate":0,"index":40264},{"krate":0,"index":40282},{"krate":0,"index":40276},{"krate":0,"index":38578},{"krate":0,"index":38580},{"krate":0,"index":38592},{"krate":0,"index":38596},{"krate":0,"index":38600},{"krate":0,"index":38604},{"krate":0,"index":38608},{"krate":0,"index":38612},{"krate":0,"index":38618},{"krate":0,"index":38624},{"krate":0,"index":38630},{"krate":0,"index":38634},{"krate":0,"index":38638},{"krate":0,"index":38646},{"krate":0,"index":40288},{"krate":0,"index":40300},{"krate":0,"index":40294},{"krate":0,"index":40312},{"krate":0,"index":40306},{"krate":0,"index":40324},{"krate":0,"index":40318},{"krate":0,"index":38654},{"krate":0,"index":38656},{"krate":0,"index":38668},{"krate":0,"index":38672},{"krate":0,"index":38676},{"krate":0,"index":38680},{"krate":0,"index":38684},{"krate":0,"index":38688},{"krate":0,"index":38694},{"krate":0,"index":38700},{"krate":0,"index":38706},{"krate":0,"index":38710},{"krate":0,"index":38714},{"krate":0,"index":38722},{"krate":0,"index":40330},{"krate":0,"index":40342},{"krate":0,"index":40336},{"krate":0,"index":40354},{"krate":0,"index":40348},{"krate":0,"index":40366},{"krate":0,"index":40360},{"krate":0,"index":38730},{"krate":0,"index":38732},{"krate":0,"index":38744},{"krate":0,"index":38748},{"krate":0,"index":38752},{"krate":0,"index":38756},{"krate":0,"index":38760},{"krate":0,"index":38764},{"krate":0,"index":38770},{"krate":0,"index":38776},{"krate":0,"index":38782},{"krate":0,"index":38786},{"krate":0,"index":38790},{"krate":0,"index":38798},{"krate":0,"index":40372},{"krate":0,"index":40384},{"krate":0,"index":40378},{"krate":0,"index":40396},{"krate":0,"index":40390},{"krate":0,"index":40408},{"krate":0,"index":40402},{"krate":0,"index":38806},{"krate":0,"index":38808},{"krate":0,"index":38820},{"krate":0,"index":38824},{"krate":0,"index":38828},{"krate":0,"index":38832},{"krate":0,"index":38836},{"krate":0,"index":38840},{"krate":0,"index":38846},{"krate":0,"index":38852},{"krate":0,"index":38858},{"krate":0,"index":38862},{"krate":0,"index":38866},{"krate":0,"index":38874},{"krate":0,"index":40414},{"krate":0,"index":40426},{"krate":0,"index":40420},{"krate":0,"index":40438},{"krate":0,"index":40432},{"krate":0,"index":40450},{"krate":0,"index":40444},{"krate":0,"index":38882},{"krate":0,"index":38884},{"krate":0,"index":38896},{"krate":0,"index":38900},{"krate":0,"index":38904},{"krate":0,"index":38908},{"krate":0,"index":38912},{"krate":0,"index":38916},{"krate":0,"index":38922},{"krate":0,"index":38928},{"krate":0,"index":38934},{"krate":0,"index":38938},{"krate":0,"index":38942},{"krate":0,"index":38950},{"krate":0,"index":40456},{"krate":0,"index":40468},{"krate":0,"index":40462},{"krate":0,"index":40480},{"krate":0,"index":40474},{"krate":0,"index":40492},{"krate":0,"index":40486},{"krate":0,"index":38958},{"krate":0,"index":38960},{"krate":0,"index":38972},{"krate":0,"index":38976},{"krate":0,"index":38980},{"krate":0,"index":38984},{"krate":0,"index":38988},{"krate":0,"index":38992},{"krate":0,"index":38998},{"krate":0,"index":39004},{"krate":0,"index":39010},{"krate":0,"index":39014},{"krate":0,"index":39018},{"krate":0,"index":39026},{"krate":0,"index":40498},{"krate":0,"index":40510},{"krate":0,"index":40504},{"krate":0,"index":40522},{"krate":0,"index":40516},{"krate":0,"index":40534},{"krate":0,"index":40528},{"krate":0,"index":39034},{"krate":0,"index":39036},{"krate":0,"index":39048},{"krate":0,"index":39052},{"krate":0,"index":39056},{"krate":0,"index":39060},{"krate":0,"index":39064},{"krate":0,"index":39068},{"krate":0,"index":39074},{"krate":0,"index":39080},{"krate":0,"index":39086},{"krate":0,"index":39090},{"krate":0,"index":39094},{"krate":0,"index":39102},{"krate":0,"index":40540},{"krate":0,"index":40552},{"krate":0,"index":40546},{"krate":0,"index":40564},{"krate":0,"index":40558},{"krate":0,"index":40576},{"krate":0,"index":40570},{"krate":0,"index":39110},{"krate":0,"index":39112},{"krate":0,"index":39124},{"krate":0,"index":39128},{"krate":0,"index":39132},{"krate":0,"index":39136},{"krate":0,"index":39140},{"krate":0,"index":39144},{"krate":0,"index":39150},{"krate":0,"index":39156},{"krate":0,"index":39162},{"krate":0,"index":39166},{"krate":0,"index":39170},{"krate":0,"index":39178},{"krate":0,"index":40582},{"krate":0,"index":40594},{"krate":0,"index":40588},{"krate":0,"index":40606},{"krate":0,"index":40600},{"krate":0,"index":40618},{"krate":0,"index":40612},{"krate":0,"index":39186},{"krate":0,"index":39188},{"krate":0,"index":39200},{"krate":0,"index":39204},{"krate":0,"index":39208},{"krate":0,"index":39212},{"krate":0,"index":39216},{"krate":0,"index":39220},{"krate":0,"index":39226},{"krate":0,"index":39232},{"krate":0,"index":39238},{"krate":0,"index":39242},{"krate":0,"index":39246},{"krate":0,"index":39254},{"krate":0,"index":40624},{"krate":0,"index":40636},{"krate":0,"index":40630},{"krate":0,"index":40648},{"krate":0,"index":40642},{"krate":0,"index":40660},{"krate":0,"index":40654},{"krate":0,"index":39262},{"krate":0,"index":39264},{"krate":0,"index":39276},{"krate":0,"index":2892},{"krate":0,"index":40666},{"krate":0,"index":40670},{"krate":0,"index":40674},{"krate":0,"index":40678},{"krate":0,"index":40682},{"krate":0,"index":40686},{"krate":0,"index":40690},{"krate":0,"index":40694},{"krate":0,"index":40698},{"krate":0,"index":40702},{"krate":0,"index":40706},{"krate":0,"index":40710},{"krate":0,"index":40714},{"krate":0,"index":40718},{"krate":0,"index":40722},{"krate":0,"index":40726},{"krate":0,"index":40730},{"krate":0,"index":40734},{"krate":0,"index":40738},{"krate":0,"index":40742},{"krate":0,"index":40746},{"krate":0,"index":40750},{"krate":0,"index":40754},{"krate":0,"index":40758},{"krate":0,"index":40762},{"krate":0,"index":40766},{"krate":0,"index":40770},{"krate":0,"index":40774},{"krate":0,"index":40778},{"krate":0,"index":40782},{"krate":0,"index":40786},{"krate":0,"index":40790},{"krate":0,"index":40794}],"decl_id":null,"docs":" Implementations of things like `Eq` for fixed-length arrays\n up to a certain length. Eventually we should able to generalize\n to all lengths.","sig":null,"attributes":[{"value":"unstable(feature = \"fixed_size_array\",\n           reason =\n               \"traits and impls are better expressed through generic integer constants\",\n           issue = \"27778\")","span":{"file_name":"src/libcore/array.rs","byte_start":909958,"byte_end":910149,"line_start":7,"line_end":10,"column_start":1,"column_end":30}}]},{"kind":"Trait","id":{"krate":0,"index":2866},"span":{"file_name":"src/libcore/array.rs","byte_start":910969,"byte_end":910983,"line_start":33,"line_end":33,"column_start":18,"column_end":32},"name":"FixedSizeArray","qualname":"::array::FixedSizeArray","value":"FixedSizeArray<T>","parent":null,"children":[{"krate":0,"index":2868},{"krate":0,"index":2870}],"decl_id":null,"docs":" Utility trait implemented only on arrays of fixed size","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2868},"span":{"file_name":"src/libcore/array.rs","byte_start":911042,"byte_end":911050,"line_start":35,"line_end":35,"column_start":8,"column_end":16},"name":"as_slice","qualname":"::array::FixedSizeArray::as_slice","value":"fn (&self) -> &[T]","parent":{"krate":0,"index":2866},"children":[],"decl_id":null,"docs":" Converts the array to immutable slice\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2870},"span":{"file_name":"src/libcore/array.rs","byte_start":911118,"byte_end":911130,"line_start":37,"line_end":37,"column_start":8,"column_end":20},"name":"as_mut_slice","qualname":"::array::FixedSizeArray::as_mut_slice","value":"fn (&mut self) -> &mut [T]","parent":{"krate":0,"index":2866},"children":[],"decl_id":null,"docs":" Converts the array to mutable slice\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":36760},"span":{"file_name":"src/libcore/array.rs","byte_start":911531,"byte_end":911548,"line_start":54,"line_end":54,"column_start":12,"column_end":29},"name":"TryFromSliceError","qualname":"::array::TryFromSliceError","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type returned when a conversion from a slice to an array fails.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/array.rs","byte_start":911440,"byte_end":911489,"line_start":52,"line_end":52,"column_start":1,"column_end":50}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/array.rs","byte_start":911520,"byte_end":911553,"line_start":54,"line_end":54,"column_start":1,"column_end":34}}]},{"kind":"Method","id":{"krate":0,"index":2884},"span":{"file_name":"src/libcore/array.rs","byte_start":912001,"byte_end":912014,"line_start":70,"line_end":70,"column_start":12,"column_end":25},"name":"__description","qualname":"<TryFromSliceError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"array_error_internals\",\n           reason =\n               \"available through Error trait and this method should not be exposed publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/array.rs","byte_start":911763,"byte_end":911956,"line_start":64,"line_end":67,"column_start":5,"column_end":25}},{"value":"inline","span":{"file_name":"src/libcore/array.rs","byte_start":911961,"byte_end":911970,"line_start":68,"line_end":68,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":2894},"span":{"file_name":"src/libcore/ascii.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ascii","qualname":"::ascii","value":"src/libcore/ascii.rs","parent":null,"children":[{"krate":0,"index":2896},{"krate":0,"index":2898},{"krate":0,"index":2900},{"krate":0,"index":2902},{"krate":0,"index":2904},{"krate":0,"index":2908},{"krate":0,"index":2916},{"krate":0,"index":2920},{"krate":0,"index":2922},{"krate":0,"index":2924}],"decl_id":null,"docs":" Operations on ASCII strings and characters.","sig":null,"attributes":[{"value":"stable(feature = \"core_ascii\", since = \"1.26.0\")","span":{"file_name":"src/libcore/ascii.rs","byte_start":919853,"byte_end":919905,"line_start":12,"line_end":12,"column_start":1,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":2902},"span":{"file_name":"src/libcore/ascii.rs","byte_start":920244,"byte_end":920257,"line_start":25,"line_end":25,"column_start":12,"column_end":25},"name":"EscapeDefault","qualname":"::ascii::EscapeDefault","value":"EscapeDefault {  }","parent":null,"children":[{"krate":0,"index":1487},{"krate":0,"index":1489}],"decl_id":null,"docs":" An iterator over the escaped version of a byte.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ascii.rs","byte_start":920187,"byte_end":920232,"line_start":24,"line_end":24,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":2904},"span":{"file_name":"src/libcore/ascii.rs","byte_start":922404,"byte_end":922418,"line_start":93,"line_end":93,"column_start":8,"column_end":22},"name":"escape_default","qualname":"::ascii::escape_default","value":"fn (c: u8) -> EscapeDefault","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that produces an escaped version of a `u8`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/ascii.rs","byte_start":922351,"byte_end":922396,"line_start":92,"line_end":92,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":2928},"span":{"file_name":"src/libcore/sync/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"sync","qualname":"::sync","value":"src/libcore/sync/mod.rs","parent":null,"children":[{"krate":0,"index":2930}],"decl_id":null,"docs":" Synchronization primitives\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/mod.rs","byte_start":923905,"byte_end":923951,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":2930},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"atomic","qualname":"::sync::atomic","value":"src/libcore/sync/atomic.rs","parent":null,"children":[{"krate":0,"index":2932},{"krate":0,"index":2934},{"krate":0,"index":2936},{"krate":0,"index":2938},{"krate":0,"index":2940},{"krate":0,"index":2942},{"krate":0,"index":2944},{"krate":0,"index":2946},{"krate":0,"index":2950},{"krate":0,"index":2952},{"krate":0,"index":2954},{"krate":0,"index":2958},{"krate":0,"index":2960},{"krate":0,"index":40798},{"krate":0,"index":40820},{"krate":0,"index":40816},{"krate":0,"index":40812},{"krate":0,"index":40808},{"krate":0,"index":40804},{"krate":0,"index":40800},{"krate":0,"index":2962},{"krate":0,"index":2964},{"krate":0,"index":2992},{"krate":0,"index":3012},{"krate":0,"index":3016},{"krate":0,"index":3020},{"krate":0,"index":40822},{"krate":0,"index":40824},{"krate":0,"index":40826},{"krate":0,"index":40830},{"krate":0,"index":40832},{"krate":0,"index":40836},{"krate":0,"index":40838},{"krate":0,"index":40878},{"krate":0,"index":40880},{"krate":0,"index":40882},{"krate":0,"index":40886},{"krate":0,"index":40888},{"krate":0,"index":40892},{"krate":0,"index":40894},{"krate":0,"index":40934},{"krate":0,"index":40936},{"krate":0,"index":40938},{"krate":0,"index":40942},{"krate":0,"index":40944},{"krate":0,"index":40948},{"krate":0,"index":40950},{"krate":0,"index":40990},{"krate":0,"index":40992},{"krate":0,"index":40994},{"krate":0,"index":40998},{"krate":0,"index":41000},{"krate":0,"index":41004},{"krate":0,"index":41006},{"krate":0,"index":41046},{"krate":0,"index":41048},{"krate":0,"index":41050},{"krate":0,"index":41054},{"krate":0,"index":41056},{"krate":0,"index":41060},{"krate":0,"index":41062},{"krate":0,"index":41102},{"krate":0,"index":41104},{"krate":0,"index":41106},{"krate":0,"index":41110},{"krate":0,"index":41112},{"krate":0,"index":41116},{"krate":0,"index":41118},{"krate":0,"index":41158},{"krate":0,"index":41160},{"krate":0,"index":41162},{"krate":0,"index":41166},{"krate":0,"index":41168},{"krate":0,"index":41172},{"krate":0,"index":41174},{"krate":0,"index":41214},{"krate":0,"index":41216},{"krate":0,"index":41218},{"krate":0,"index":41222},{"krate":0,"index":41224},{"krate":0,"index":41228},{"krate":0,"index":41230},{"krate":0,"index":3022},{"krate":0,"index":41270},{"krate":0,"index":41272},{"krate":0,"index":41274},{"krate":0,"index":41278},{"krate":0,"index":41280},{"krate":0,"index":41284},{"krate":0,"index":41286},{"krate":0,"index":41326},{"krate":0,"index":41328},{"krate":0,"index":41330},{"krate":0,"index":41334},{"krate":0,"index":41336},{"krate":0,"index":41340},{"krate":0,"index":41342},{"krate":0,"index":3024},{"krate":0,"index":3026},{"krate":0,"index":3028},{"krate":0,"index":3030},{"krate":0,"index":3032},{"krate":0,"index":3034},{"krate":0,"index":3036},{"krate":0,"index":3038},{"krate":0,"index":3040},{"krate":0,"index":3042},{"krate":0,"index":3044},{"krate":0,"index":3046},{"krate":0,"index":3048},{"krate":0,"index":3050},{"krate":0,"index":3052},{"krate":0,"index":3054},{"krate":0,"index":3056},{"krate":0,"index":3058},{"krate":0,"index":3060},{"krate":0,"index":3064},{"krate":0,"index":3068}],"decl_id":null,"docs":" Atomic types","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":928579,"byte_end":928625,"line_start":115,"line_end":115,"column_start":1,"column_end":47}}]},{"kind":"Function","id":{"krate":0,"index":2942},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930347,"byte_end":930361,"line_start":151,"line_end":151,"column_start":8,"column_end":22},"name":"spin_loop_hint","qualname":"::sync::atomic::spin_loop_hint","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Signals the processor that it is entering a busy-wait spin-loop.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930274,"byte_end":930283,"line_start":149,"line_end":149,"column_start":1,"column_end":10}},{"value":"stable(feature = \"spin_loop_hint\", since = \"1.24.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930284,"byte_end":930339,"line_start":150,"line_end":150,"column_start":1,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":2944},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930680,"byte_end":930690,"line_start":163,"line_end":163,"column_start":12,"column_end":22},"name":"AtomicBool","qualname":"::sync::atomic::AtomicBool","value":"AtomicBool {  }","parent":null,"children":[{"krate":0,"index":1497}],"decl_id":null,"docs":" A boolean type which can be safely shared between threads.","sig":null,"attributes":[{"value":"cfg(target_has_atomic = \"8\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930570,"byte_end":930601,"line_start":160,"line_end":160,"column_start":1,"column_end":32}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930602,"byte_end":930647,"line_start":161,"line_end":161,"column_start":1,"column_end":46}},{"value":"repr(C, align(1))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930648,"byte_end":930668,"line_start":162,"line_end":162,"column_start":1,"column_end":21}}]},{"kind":"Struct","id":{"krate":0,"index":2952},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931517,"byte_end":931526,"line_start":189,"line_end":189,"column_start":12,"column_end":21},"name":"AtomicPtr","qualname":"::sync::atomic::AtomicPtr","value":"AtomicPtr {  }","parent":null,"children":[{"krate":0,"index":1501}],"decl_id":null,"docs":" A raw pointer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"cfg(target_has_atomic = \"ptr\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931246,"byte_end":931279,"line_start":184,"line_end":184,"column_start":1,"column_end":34}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931280,"byte_end":931325,"line_start":185,"line_end":185,"column_start":1,"column_end":46}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931486,"byte_end":931503,"line_start":188,"line_end":188,"column_start":41,"column_end":58}}]},{"kind":"TupleVariant","id":{"krate":0,"index":21997},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":933173,"byte_end":933180,"line_start":235,"line_end":235,"column_start":5,"column_end":12},"name":"Relaxed","qualname":"::sync::atomic::Ordering::Relaxed","value":"Ordering::Relaxed","parent":{"krate":0,"index":40798},"children":[],"decl_id":null,"docs":" No ordering constraints, only atomic operations.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":933123,"byte_end":933168,"line_start":234,"line_end":234,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":22001},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":934027,"byte_end":934034,"line_start":252,"line_end":252,"column_start":5,"column_end":12},"name":"Release","qualname":"::sync::atomic::Ordering::Release","value":"Ordering::Release","parent":{"krate":0,"index":40798},"children":[],"decl_id":null,"docs":" When coupled with a store, all previous operations become ordered\n before any load of this value with [`Acquire`] (or stronger) ordering.\n In particular, all previous writes become visible to all threads\n that perform an [`Acquire`] (or stronger) load of this value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":933977,"byte_end":934022,"line_start":251,"line_end":251,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":22005},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":934877,"byte_end":934884,"line_start":269,"line_end":269,"column_start":5,"column_end":12},"name":"Acquire","qualname":"::sync::atomic::Ordering::Acquire","value":"Ordering::Acquire","parent":{"krate":0,"index":40798},"children":[],"decl_id":null,"docs":" When coupled with a load, if the loaded value was written by a store operation with\n [`Release`] (or stronger) ordering, then all subsequent operations\n become ordered after that store. In particular, all subsequent loads will see data\n written before the store.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":934827,"byte_end":934872,"line_start":268,"line_end":268,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":22009},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":935819,"byte_end":935825,"line_start":286,"line_end":286,"column_start":5,"column_end":11},"name":"AcqRel","qualname":"::sync::atomic::Ordering::AcqRel","value":"Ordering::AcqRel","parent":{"krate":0,"index":40798},"children":[],"decl_id":null,"docs":" Has the effects of both [`Acquire`] and [`Release`] together:\n For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":935769,"byte_end":935814,"line_start":285,"line_end":285,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":22013},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":936493,"byte_end":936499,"line_start":298,"line_end":298,"column_start":5,"column_end":11},"name":"SeqCst","qualname":"::sync::atomic::Ordering::SeqCst","value":"Ordering::SeqCst","parent":{"krate":0,"index":40798},"children":[],"decl_id":null,"docs":" Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n operations, respectively) with the additional guarantee that all threads see all\n sequentially consistent operations in the same order.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":936443,"byte_end":936488,"line_start":297,"line_end":297,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":40798},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":932913,"byte_end":932921,"line_start":228,"line_end":228,"column_start":10,"column_end":18},"name":"Ordering","qualname":"::sync::atomic::Ordering","value":"Ordering::{Relaxed, Release, Acquire, AcqRel, SeqCst}","parent":null,"children":[{"krate":0,"index":21997},{"krate":0,"index":22001},{"krate":0,"index":22005},{"krate":0,"index":22009},{"krate":0,"index":22013}],"decl_id":null,"docs":" Atomic memory orderings","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":932789,"byte_end":932834,"line_start":225,"line_end":225,"column_start":1,"column_end":46}},{"value":"non_exhaustive","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":932886,"byte_end":932903,"line_start":227,"line_end":227,"column_start":1,"column_end":18}},{"value":"structural_match","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":932904,"byte_end":936502,"line_start":228,"line_end":299,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":932904,"byte_end":936502,"line_start":228,"line_end":299,"column_start":1,"column_end":2}}]},{"kind":"Const","id":{"krate":0,"index":2962},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":936825,"byte_end":936841,"line_start":311,"line_end":311,"column_start":11,"column_end":27},"name":"ATOMIC_BOOL_INIT","qualname":"::sync::atomic::ATOMIC_BOOL_INIT","value":"AtomicBool","parent":null,"children":[],"decl_id":null,"docs":" An [`AtomicBool`] initialized to `false`.","sig":null,"attributes":[{"value":"cfg(target_has_atomic = \"8\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":936597,"byte_end":936628,"line_start":304,"line_end":304,"column_start":1,"column_end":32}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":936629,"byte_end":936674,"line_start":305,"line_end":305,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicBool::new(false)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":936675,"byte_end":936814,"line_start":306,"line_end":310,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":2966},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":937259,"byte_end":937262,"line_start":327,"line_end":327,"column_start":18,"column_end":21},"name":"new","qualname":"<AtomicBool>::new","value":"fn (v: bool) -> AtomicBool","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `AtomicBool`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":937182,"byte_end":937191,"line_start":325,"line_end":325,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":937196,"byte_end":937241,"line_start":326,"line_end":326,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2968},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":938017,"byte_end":938024,"line_start":350,"line_end":350,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<AtomicBool>::get_mut","value":"fn (&mut self) -> &mut bool","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying [`bool`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":937937,"byte_end":937946,"line_start":348,"line_end":348,"column_start":5,"column_end":14}},{"value":"stable(feature = \"atomic_access\", since = \"1.15.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":937951,"byte_end":938005,"line_start":349,"line_end":349,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2970},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":938609,"byte_end":938619,"line_start":369,"line_end":369,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<AtomicBool>::into_inner","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Consumes the atomic and returns the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":938529,"byte_end":938538,"line_start":367,"line_end":367,"column_start":5,"column_end":14}},{"value":"stable(feature = \"atomic_access\", since = \"1.15.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":938543,"byte_end":938597,"line_start":368,"line_end":368,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2972},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":939618,"byte_end":939622,"line_start":400,"line_end":400,"column_start":12,"column_end":16},"name":"load","qualname":"<AtomicBool>::load","value":"fn (&self, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Loads a value from the bool.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":939547,"byte_end":939556,"line_start":398,"line_end":398,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":939561,"byte_end":939606,"line_start":399,"line_end":399,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2974},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":940717,"byte_end":940722,"line_start":432,"line_end":432,"column_start":12,"column_end":17},"name":"store","qualname":"<AtomicBool>::store","value":"fn (&self, val: bool, order: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the bool.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":940646,"byte_end":940655,"line_start":430,"line_end":430,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":940660,"byte_end":940705,"line_start":431,"line_end":431,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2976},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":941858,"byte_end":941862,"line_start":463,"line_end":463,"column_start":12,"column_end":16},"name":"swap","qualname":"<AtomicBool>::swap","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the bool, returning the previous value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":941749,"byte_end":941758,"line_start":460,"line_end":460,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":941763,"byte_end":941808,"line_start":461,"line_end":461,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":941813,"byte_end":941846,"line_start":462,"line_end":462,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2978},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":943563,"byte_end":943579,"line_start":501,"line_end":501,"column_start":12,"column_end":28},"name":"compare_and_swap","qualname":"<AtomicBool>::compare_and_swap","value":"fn (&self, current: bool, new: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the [`bool`] if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":943454,"byte_end":943463,"line_start":498,"line_end":498,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":943468,"byte_end":943513,"line_start":499,"line_end":499,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":943518,"byte_end":943551,"line_start":500,"line_end":500,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2980},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":945948,"byte_end":945964,"line_start":552,"line_end":552,"column_start":12,"column_end":28},"name":"compare_exchange","qualname":"<AtomicBool>::compare_exchange","value":"fn (&self, current: bool, new: bool, success: Ordering, failure: Ordering) -> Result<bool, bool>","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the [`bool`] if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":945818,"byte_end":945827,"line_start":549,"line_end":549,"column_start":5,"column_end":14}},{"value":"stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":945832,"byte_end":945898,"line_start":550,"line_end":550,"column_start":5,"column_end":71}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":945903,"byte_end":945936,"line_start":551,"line_end":551,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2982},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":948386,"byte_end":948407,"line_start":608,"line_end":608,"column_start":12,"column_end":33},"name":"compare_exchange_weak","qualname":"<AtomicBool>::compare_exchange_weak","value":"fn (&self, current: bool, new: bool, success: Ordering, failure: Ordering) -> Result<bool, bool>","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the [`bool`] if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":948256,"byte_end":948265,"line_start":605,"line_end":605,"column_start":5,"column_end":14}},{"value":"stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":948270,"byte_end":948336,"line_start":606,"line_end":606,"column_start":5,"column_end":71}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":948341,"byte_end":948374,"line_start":607,"line_end":607,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2984},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950377,"byte_end":950386,"line_start":659,"line_end":659,"column_start":12,"column_end":21},"name":"fetch_and","qualname":"<AtomicBool>::fetch_and","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Logical \"and\" with a boolean value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950268,"byte_end":950277,"line_start":656,"line_end":656,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950282,"byte_end":950327,"line_start":657,"line_end":657,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":950332,"byte_end":950365,"line_start":658,"line_end":658,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2986},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":952061,"byte_end":952071,"line_start":701,"line_end":701,"column_start":12,"column_end":22},"name":"fetch_nand","qualname":"<AtomicBool>::fetch_nand","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Logical \"nand\" with a boolean value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951952,"byte_end":951961,"line_start":698,"line_end":698,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":951966,"byte_end":952011,"line_start":699,"line_end":699,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":952016,"byte_end":952049,"line_start":700,"line_end":700,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2988},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":954169,"byte_end":954177,"line_start":754,"line_end":754,"column_start":12,"column_end":20},"name":"fetch_or","qualname":"<AtomicBool>::fetch_or","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Logical \"or\" with a boolean value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":954060,"byte_end":954069,"line_start":751,"line_end":751,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":954074,"byte_end":954119,"line_start":752,"line_end":752,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":954124,"byte_end":954157,"line_start":753,"line_end":753,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2990},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955786,"byte_end":955795,"line_start":795,"line_end":795,"column_start":12,"column_end":21},"name":"fetch_xor","qualname":"<AtomicBool>::fetch_xor","value":"fn (&self, val: bool, order: Ordering) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Logical \"xor\" with a boolean value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955677,"byte_end":955686,"line_start":792,"line_end":792,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955691,"byte_end":955736,"line_start":793,"line_end":793,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955741,"byte_end":955774,"line_start":794,"line_end":794,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":2994},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956272,"byte_end":956275,"line_start":814,"line_end":814,"column_start":18,"column_end":21},"name":"new","qualname":"<AtomicPtr<T>>::new","value":"fn (p: *mut T) -> AtomicPtr<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `AtomicPtr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956195,"byte_end":956204,"line_start":812,"line_end":812,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956209,"byte_end":956254,"line_start":813,"line_end":813,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":2996},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956932,"byte_end":956939,"line_start":834,"line_end":834,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<AtomicPtr<T>>::get_mut","value":"fn (&mut self) -> &mut *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956852,"byte_end":956861,"line_start":832,"line_end":832,"column_start":5,"column_end":14}},{"value":"stable(feature = \"atomic_access\", since = \"1.15.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":956866,"byte_end":956920,"line_start":833,"line_end":833,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":2998},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":957522,"byte_end":957532,"line_start":853,"line_end":853,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<AtomicPtr<T>>::into_inner","value":"fn (self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Consumes the atomic and returns the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":957442,"byte_end":957451,"line_start":851,"line_end":851,"column_start":5,"column_end":14}},{"value":"stable(feature = \"atomic_access\", since = \"1.15.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":957456,"byte_end":957510,"line_start":852,"line_end":852,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":3000},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":958547,"byte_end":958551,"line_start":885,"line_end":885,"column_start":12,"column_end":16},"name":"load","qualname":"<AtomicPtr<T>>::load","value":"fn (&self, order: Ordering) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Loads a value from the pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":958476,"byte_end":958485,"line_start":883,"line_end":883,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":958490,"byte_end":958535,"line_start":884,"line_end":884,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3002},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":959675,"byte_end":959680,"line_start":919,"line_end":919,"column_start":12,"column_end":17},"name":"store","qualname":"<AtomicPtr<T>>::store","value":"fn (&self, ptr: *mut T, order: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":959604,"byte_end":959613,"line_start":917,"line_end":917,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":959618,"byte_end":959663,"line_start":918,"line_end":918,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3004},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":960837,"byte_end":960841,"line_start":952,"line_end":952,"column_start":12,"column_end":16},"name":"swap","qualname":"<AtomicPtr<T>>::swap","value":"fn (&self, ptr: *mut T, order: Ordering) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer, returning the previous value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":960728,"byte_end":960737,"line_start":949,"line_end":949,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":960742,"byte_end":960787,"line_start":950,"line_end":950,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":960792,"byte_end":960825,"line_start":951,"line_end":951,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":3006},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":962403,"byte_end":962419,"line_start":989,"line_end":989,"column_start":12,"column_end":28},"name":"compare_and_swap","qualname":"<AtomicPtr<T>>::compare_and_swap","value":"fn (&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":962294,"byte_end":962303,"line_start":986,"line_end":986,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":962308,"byte_end":962353,"line_start":987,"line_end":987,"column_start":5,"column_end":50}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":962358,"byte_end":962391,"line_start":988,"line_end":988,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":3008},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":964371,"byte_end":964387,"line_start":1032,"line_end":1032,"column_start":12,"column_end":28},"name":"compare_exchange","qualname":"<AtomicPtr<T>>::compare_exchange","value":"fn (&self, current: *mut T, new: *mut T, success: Ordering, failure: Ordering) -> Result<*mut T, *mut T>","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":964241,"byte_end":964250,"line_start":1029,"line_end":1029,"column_start":5,"column_end":14}},{"value":"stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":964255,"byte_end":964321,"line_start":1030,"line_end":1030,"column_start":5,"column_end":71}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":964326,"byte_end":964359,"line_start":1031,"line_end":1031,"column_start":5,"column_end":38}}]},{"kind":"Method","id":{"krate":0,"index":3010},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":967035,"byte_end":967056,"line_start":1092,"line_end":1092,"column_start":12,"column_end":33},"name":"compare_exchange_weak","qualname":"<AtomicPtr<T>>::compare_exchange_weak","value":"fn (&self, current: *mut T, new: *mut T, success: Ordering, failure: Ordering) -> Result<*mut T, *mut T>","parent":null,"children":[],"decl_id":null,"docs":" Stores a value into the pointer if the current value is the same as the `current` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":966905,"byte_end":966914,"line_start":1089,"line_end":1089,"column_start":5,"column_end":14}},{"value":"stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":966919,"byte_end":966985,"line_start":1090,"line_end":1090,"column_start":5,"column_end":71}},{"value":"cfg(target_has_atomic = \"cas\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":966990,"byte_end":967023,"line_start":1091,"line_end":1091,"column_start":5,"column_end":38}}]},{"kind":"Struct","id":{"krate":0,"index":40822},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":996664,"byte_end":996672,"line_start":1906,"line_end":1906,"column_start":8,"column_end":16},"name":"AtomicI8","qualname":"::sync::atomic::AtomicI8","value":"AtomicI8 {  }","parent":null,"children":[{"krate":0,"index":22019}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(1))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":40824},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":996673,"byte_end":996687,"line_start":1906,"line_end":1906,"column_start":17,"column_end":31},"name":"ATOMIC_I8_INIT","qualname":"::sync::atomic::ATOMIC_I8_INIT","value":"AtomicI8","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicI8::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":40878},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":997344,"byte_end":997352,"line_start":1922,"line_end":1922,"column_start":8,"column_end":16},"name":"AtomicU8","qualname":"::sync::atomic::AtomicU8","value":"AtomicU8 {  }","parent":null,"children":[{"krate":0,"index":22023}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(1))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":40880},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":997353,"byte_end":997367,"line_start":1922,"line_end":1922,"column_start":17,"column_end":31},"name":"ATOMIC_U8_INIT","qualname":"::sync::atomic::ATOMIC_U8_INIT","value":"AtomicU8","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicU8::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":40934},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":998027,"byte_end":998036,"line_start":1938,"line_end":1938,"column_start":9,"column_end":18},"name":"AtomicI16","qualname":"::sync::atomic::AtomicI16","value":"AtomicI16 {  }","parent":null,"children":[{"krate":0,"index":22027}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(2))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":40936},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":998037,"byte_end":998052,"line_start":1938,"line_end":1938,"column_start":19,"column_end":34},"name":"ATOMIC_I16_INIT","qualname":"::sync::atomic::ATOMIC_I16_INIT","value":"AtomicI16","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicI16::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":40990},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":998714,"byte_end":998723,"line_start":1954,"line_end":1954,"column_start":9,"column_end":18},"name":"AtomicU16","qualname":"::sync::atomic::AtomicU16","value":"AtomicU16 {  }","parent":null,"children":[{"krate":0,"index":22031}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(2))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":40992},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":998724,"byte_end":998739,"line_start":1954,"line_end":1954,"column_start":19,"column_end":34},"name":"ATOMIC_U16_INIT","qualname":"::sync::atomic::ATOMIC_U16_INIT","value":"AtomicU16","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicU16::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":41046},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":999399,"byte_end":999408,"line_start":1970,"line_end":1970,"column_start":9,"column_end":18},"name":"AtomicI32","qualname":"::sync::atomic::AtomicI32","value":"AtomicI32 {  }","parent":null,"children":[{"krate":0,"index":22035}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(4))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":41048},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":999409,"byte_end":999424,"line_start":1970,"line_end":1970,"column_start":19,"column_end":34},"name":"ATOMIC_I32_INIT","qualname":"::sync::atomic::ATOMIC_I32_INIT","value":"AtomicI32","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicI32::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":41102},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1000086,"byte_end":1000095,"line_start":1986,"line_end":1986,"column_start":9,"column_end":18},"name":"AtomicU32","qualname":"::sync::atomic::AtomicU32","value":"AtomicU32 {  }","parent":null,"children":[{"krate":0,"index":22039}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(4))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":41104},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1000096,"byte_end":1000111,"line_start":1986,"line_end":1986,"column_start":19,"column_end":34},"name":"ATOMIC_U32_INIT","qualname":"::sync::atomic::ATOMIC_U32_INIT","value":"AtomicU32","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicU32::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":41158},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1000771,"byte_end":1000780,"line_start":2002,"line_end":2002,"column_start":9,"column_end":18},"name":"AtomicI64","qualname":"::sync::atomic::AtomicI64","value":"AtomicI64 {  }","parent":null,"children":[{"krate":0,"index":22043}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":41160},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1000781,"byte_end":1000796,"line_start":2002,"line_end":2002,"column_start":19,"column_end":34},"name":"ATOMIC_I64_INIT","qualname":"::sync::atomic::ATOMIC_I64_INIT","value":"AtomicI64","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicI64::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":41214},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1001458,"byte_end":1001467,"line_start":2018,"line_end":2018,"column_start":9,"column_end":18},"name":"AtomicU64","qualname":"::sync::atomic::AtomicU64","value":"AtomicU64 {  }","parent":null,"children":[{"krate":0,"index":22047}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":41216},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1001468,"byte_end":1001483,"line_start":2018,"line_end":2018,"column_start":19,"column_end":34},"name":"ATOMIC_U64_INIT","qualname":"::sync::atomic::ATOMIC_U64_INIT","value":"AtomicU64","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"unstable(feature = \"integer_atomics\", issue = \"32976\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicU64::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":41270},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1003614,"byte_end":1003625,"line_start":2078,"line_end":2078,"column_start":11,"column_end":22},"name":"AtomicIsize","qualname":"::sync::atomic::AtomicIsize","value":"AtomicIsize {  }","parent":null,"children":[{"krate":0,"index":22051}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":41272},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1003626,"byte_end":1003643,"line_start":2078,"line_end":2078,"column_start":23,"column_end":40},"name":"ATOMIC_ISIZE_INIT","qualname":"::sync::atomic::ATOMIC_ISIZE_INIT","value":"AtomicIsize","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicIsize::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Struct","id":{"krate":0,"index":41326},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1004223,"byte_end":1004234,"line_start":2094,"line_end":2094,"column_start":11,"column_end":22},"name":"AtomicUsize","qualname":"::sync::atomic::AtomicUsize","value":"AtomicUsize {  }","parent":null,"children":[{"krate":0,"index":22055}],"decl_id":null,"docs":" An integer type which can be safely shared between threads.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969443,"byte_end":969453,"line_start":1162,"line_end":1162,"column_start":9,"column_end":19}},{"value":"repr(C, align(8))","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969462,"byte_end":969487,"line_start":1163,"line_end":1163,"column_start":9,"column_end":34}}]},{"kind":"Const","id":{"krate":0,"index":41328},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1004235,"byte_end":1004252,"line_start":2094,"line_end":2094,"column_start":23,"column_end":40},"name":"ATOMIC_USIZE_INIT","qualname":"::sync::atomic::ATOMIC_USIZE_INIT","value":"AtomicUsize","parent":null,"children":[],"decl_id":null,"docs":" An atomic integer initialized to `0`.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969629,"byte_end":969650,"line_start":1169,"line_end":1169,"column_start":9,"column_end":30}},{"value":"rustc_deprecated(since = \"1.34.0\",\n                   reason = \"the `new` function is now preferred\",\n                   suggestion = \"AtomicUsize::new(0)\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":969659,"byte_end":969817,"line_start":1170,"line_end":1174,"column_start":9,"column_end":11}}]},{"kind":"Function","id":{"krate":0,"index":3056},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1016132,"byte_end":1016137,"line_start":2398,"line_end":2398,"column_start":8,"column_end":13},"name":"fence","qualname":"::sync::atomic::fence","value":"fn (order: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" An atomic fence.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1016008,"byte_end":1016017,"line_start":2395,"line_end":2395,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1016018,"byte_end":1016063,"line_start":2396,"line_end":2396,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":3058},"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1020471,"byte_end":1020485,"line_start":2493,"line_end":2493,"column_start":8,"column_end":22},"name":"compiler_fence","qualname":"::sync::atomic::compiler_fence","value":"fn (order: Ordering) -> ()","parent":null,"children":[],"decl_id":null,"docs":" A compiler memory fence.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1020397,"byte_end":1020406,"line_start":2491,"line_end":2491,"column_start":1,"column_end":10}},{"value":"stable(feature = \"compiler_fences\", since = \"1.21.0\")","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1020407,"byte_end":1020463,"line_start":2492,"line_end":2492,"column_start":1,"column_end":57}}]},{"kind":"Mod","id":{"krate":0,"index":3072},"span":{"file_name":"src/libcore/cell.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"cell","qualname":"::cell","value":"src/libcore/cell.rs","parent":null,"children":[{"krate":0,"index":3074},{"krate":0,"index":3076},{"krate":0,"index":3084},{"krate":0,"index":3086},{"krate":0,"index":3088},{"krate":0,"index":3096},{"krate":0,"index":3098},{"krate":0,"index":3100},{"krate":0,"index":3106},{"krate":0,"index":3108},{"krate":0,"index":3110},{"krate":0,"index":3114},{"krate":0,"index":3118},{"krate":0,"index":3122},{"krate":0,"index":3124},{"krate":0,"index":3136},{"krate":0,"index":3140},{"krate":0,"index":3144},{"krate":0,"index":3156},{"krate":0,"index":3164},{"krate":0,"index":3168},{"krate":0,"index":3170},{"krate":0,"index":3174},{"krate":0,"index":3176},{"krate":0,"index":3178},{"krate":0,"index":3182},{"krate":0,"index":3186},{"krate":0,"index":3188},{"krate":0,"index":3192},{"krate":0,"index":3196},{"krate":0,"index":3198},{"krate":0,"index":3200},{"krate":0,"index":3202},{"krate":0,"index":3204},{"krate":0,"index":3216},{"krate":0,"index":3232},{"krate":0,"index":3234},{"krate":0,"index":3236},{"krate":0,"index":3240},{"krate":0,"index":3244},{"krate":0,"index":3248},{"krate":0,"index":3250},{"krate":0,"index":3262},{"krate":0,"index":3266},{"krate":0,"index":3270},{"krate":0,"index":3272},{"krate":0,"index":3274},{"krate":0,"index":3278},{"krate":0,"index":3282},{"krate":0,"index":3286},{"krate":0,"index":3288},{"krate":0,"index":3294},{"krate":0,"index":3302},{"krate":0,"index":3304},{"krate":0,"index":3308},{"krate":0,"index":3314},{"krate":0,"index":3316},{"krate":0,"index":3320},{"krate":0,"index":3326},{"krate":0,"index":3328},{"krate":0,"index":3334},{"krate":0,"index":3338},{"krate":0,"index":3340},{"krate":0,"index":3344},{"krate":0,"index":3346},{"krate":0,"index":3348},{"krate":0,"index":3354},{"krate":0,"index":3358},{"krate":0,"index":3362},{"krate":0,"index":3366},{"krate":0,"index":3368}],"decl_id":null,"docs":" Shareable mutable containers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1029630,"byte_end":1029676,"line_start":187,"line_end":187,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":3098},"span":{"file_name":"src/libcore/cell.rs","byte_start":1030781,"byte_end":1030785,"line_start":230,"line_end":230,"column_start":12,"column_end":16},"name":"Cell","qualname":"::cell::Cell","value":"Cell {  }","parent":null,"children":[{"krate":0,"index":1549}],"decl_id":null,"docs":" A mutable memory location.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1030703,"byte_end":1030748,"line_start":228,"line_end":228,"column_start":1,"column_end":46}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/cell.rs","byte_start":1030749,"byte_end":1030769,"line_start":229,"line_end":229,"column_start":1,"column_end":21}}]},{"kind":"Method","id":{"krate":0,"index":3102},"span":{"file_name":"src/libcore/cell.rs","byte_start":1031135,"byte_end":1031138,"line_start":248,"line_end":248,"column_start":12,"column_end":15},"name":"get","qualname":"<Cell<T>>::get","value":"fn (&self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns a copy of the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1031064,"byte_end":1031073,"line_start":246,"line_end":246,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1031078,"byte_end":1031123,"line_start":247,"line_end":247,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3104},"span":{"file_name":"src/libcore/cell.rs","byte_start":1031633,"byte_end":1031639,"line_start":269,"line_end":269,"column_start":12,"column_end":18},"name":"update","qualname":"<Cell<T>>::update","value":"fn <F> (&self, f: F) -> T","parent":null,"children":[],"decl_id":null,"docs":" Updates the contained value using a function and returns the new value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1031554,"byte_end":1031563,"line_start":267,"line_end":267,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"cell_update\", issue = \"50186\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1031568,"byte_end":1031621,"line_start":268,"line_end":268,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":3146},"span":{"file_name":"src/libcore/cell.rs","byte_start":1033922,"byte_end":1033925,"line_start":369,"line_end":369,"column_start":18,"column_end":21},"name":"new","qualname":"<Cell<T>>::new","value":"fn (value: T) -> Cell<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Cell` containing the given value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1033845,"byte_end":1033890,"line_start":367,"line_end":367,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1033895,"byte_end":1033904,"line_start":368,"line_end":368,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3148},"span":{"file_name":"src/libcore/cell.rs","byte_start":1034286,"byte_end":1034289,"line_start":388,"line_end":388,"column_start":12,"column_end":15},"name":"set","qualname":"<Cell<T>>::set","value":"fn (&self, val: T) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sets the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1034215,"byte_end":1034224,"line_start":386,"line_end":386,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1034229,"byte_end":1034274,"line_start":387,"line_end":387,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3150},"span":{"file_name":"src/libcore/cell.rs","byte_start":1034840,"byte_end":1034844,"line_start":409,"line_end":409,"column_start":12,"column_end":16},"name":"swap","qualname":"<Cell<T>>::swap","value":"fn (&self, other: &Self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the values of two Cells.\n Difference with `std::mem::swap` is that this function doesn't require `&mut` reference.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1034764,"byte_end":1034773,"line_start":407,"line_end":407,"column_start":5,"column_end":14}},{"value":"stable(feature = \"move_cell\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1034778,"byte_end":1034828,"line_start":408,"line_end":408,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3152},"span":{"file_name":"src/libcore/cell.rs","byte_start":1035387,"byte_end":1035394,"line_start":431,"line_end":431,"column_start":12,"column_end":19},"name":"replace","qualname":"<Cell<T>>::replace","value":"fn (&self, val: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replaces the contained value, and returns it.","sig":null,"attributes":[{"value":"stable(feature = \"move_cell\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1035325,"byte_end":1035375,"line_start":430,"line_end":430,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3154},"span":{"file_name":"src/libcore/cell.rs","byte_start":1035776,"byte_end":1035786,"line_start":448,"line_end":448,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<Cell<T>>::into_inner","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps the value.","sig":null,"attributes":[{"value":"stable(feature = \"move_cell\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1035714,"byte_end":1035764,"line_start":447,"line_end":447,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3158},"span":{"file_name":"src/libcore/cell.rs","byte_start":1036186,"byte_end":1036192,"line_start":467,"line_end":467,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<Cell<T>>::as_ptr","value":"fn (&self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a raw pointer to the underlying data in this cell.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1036102,"byte_end":1036111,"line_start":465,"line_end":465,"column_start":5,"column_end":14}},{"value":"stable(feature = \"cell_as_ptr\", since = \"1.12.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1036116,"byte_end":1036168,"line_start":466,"line_end":466,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3160},"span":{"file_name":"src/libcore/cell.rs","byte_start":1036712,"byte_end":1036719,"line_start":488,"line_end":488,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<Cell<T>>::get_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1036633,"byte_end":1036642,"line_start":486,"line_end":486,"column_start":5,"column_end":14}},{"value":"stable(feature = \"cell_get_mut\", since = \"1.11.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1036647,"byte_end":1036700,"line_start":487,"line_end":487,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":3162},"span":{"file_name":"src/libcore/cell.rs","byte_start":1037289,"byte_end":1037297,"line_start":510,"line_end":510,"column_start":12,"column_end":20},"name":"from_mut","qualname":"<Cell<T>>::from_mut","value":"fn (t: &mut T) -> &Cell<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a `&Cell<T>` from a `&mut T`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1037216,"byte_end":1037225,"line_start":508,"line_end":508,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"as_cell\", issue = \"43038\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1037230,"byte_end":1037277,"line_start":509,"line_end":509,"column_start":5,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":3166},"span":{"file_name":"src/libcore/cell.rs","byte_start":1037809,"byte_end":1037813,"line_start":532,"line_end":532,"column_start":12,"column_end":16},"name":"take","qualname":"<Cell<T>>::take","value":"fn (&self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Takes the value of the cell, leaving `Default::default()` in its place.","sig":null,"attributes":[{"value":"stable(feature = \"move_cell\", since = \"1.17.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1037747,"byte_end":1037797,"line_start":531,"line_end":531,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":3172},"span":{"file_name":"src/libcore/cell.rs","byte_start":1038492,"byte_end":1038509,"line_start":556,"line_end":556,"column_start":12,"column_end":29},"name":"as_slice_of_cells","qualname":"<Cell<[T]>>::as_slice_of_cells","value":"fn (&self) -> &[Cell<T>]","parent":null,"children":[],"decl_id":null,"docs":" Returns a `&[Cell<T>]` from a `&Cell<[T]>`","sig":null,"attributes":[{"value":"unstable(feature = \"as_cell\", issue = \"43038\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1038433,"byte_end":1038480,"line_start":555,"line_end":555,"column_start":5,"column_end":52}}]},{"kind":"Struct","id":{"krate":0,"index":3174},"span":{"file_name":"src/libcore/cell.rs","byte_start":1038822,"byte_end":1038829,"line_start":567,"line_end":567,"column_start":12,"column_end":19},"name":"RefCell","qualname":"::cell::RefCell","value":"RefCell {  }","parent":null,"children":[{"krate":0,"index":1587},{"krate":0,"index":1589}],"decl_id":null,"docs":" A mutable memory location with dynamically checked borrow rules","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1038765,"byte_end":1038810,"line_start":566,"line_end":566,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":3176},"span":{"file_name":"src/libcore/cell.rs","byte_start":1039054,"byte_end":1039065,"line_start":574,"line_end":574,"column_start":12,"column_end":23},"name":"BorrowError","qualname":"::cell::BorrowError","value":"BorrowError {  }","parent":null,"children":[{"krate":0,"index":1591}],"decl_id":null,"docs":" An error returned by [`RefCell::try_borrow`](struct.RefCell.html#method.try_borrow).\n","sig":null,"attributes":[{"value":"stable(feature = \"try_borrow\", since = \"1.13.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1038991,"byte_end":1039042,"line_start":573,"line_end":573,"column_start":1,"column_end":52}}]},{"kind":"Struct","id":{"krate":0,"index":3186},"span":{"file_name":"src/libcore/cell.rs","byte_start":1039656,"byte_end":1039670,"line_start":594,"line_end":594,"column_start":12,"column_end":26},"name":"BorrowMutError","qualname":"::cell::BorrowMutError","value":"BorrowMutError {  }","parent":null,"children":[{"krate":0,"index":1593}],"decl_id":null,"docs":" An error returned by [`RefCell::try_borrow_mut`](struct.RefCell.html#method.try_borrow_mut).\n","sig":null,"attributes":[{"value":"stable(feature = \"try_borrow\", since = \"1.13.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1039593,"byte_end":1039644,"line_start":593,"line_end":593,"column_start":1,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":3206},"span":{"file_name":"src/libcore/cell.rs","byte_start":1041444,"byte_end":1041447,"line_start":650,"line_end":650,"column_start":18,"column_end":21},"name":"new","qualname":"<RefCell<T>>::new","value":"fn (value: T) -> RefCell<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `RefCell` containing `value`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1041367,"byte_end":1041412,"line_start":648,"line_end":648,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1041417,"byte_end":1041426,"line_start":649,"line_end":649,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3208},"span":{"file_name":"src/libcore/cell.rs","byte_start":1041902,"byte_end":1041912,"line_start":670,"line_end":670,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<RefCell<T>>::into_inner","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Consumes the `RefCell`, returning the wrapped value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1041831,"byte_end":1041876,"line_start":668,"line_end":668,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1041881,"byte_end":1041890,"line_start":669,"line_end":669,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3210},"span":{"file_name":"src/libcore/cell.rs","byte_start":1042862,"byte_end":1042869,"line_start":698,"line_end":698,"column_start":12,"column_end":19},"name":"replace","qualname":"<RefCell<T>>::replace","value":"fn (&self, t: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replaces the wrapped value with a new one, returning the old value,\n without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1042782,"byte_end":1042791,"line_start":696,"line_end":696,"column_start":5,"column_end":14}},{"value":"stable(feature = \"refcell_replace\", since = \"1.24.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1042796,"byte_end":1042850,"line_start":697,"line_end":697,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":3212},"span":{"file_name":"src/libcore/cell.rs","byte_start":1043523,"byte_end":1043535,"line_start":720,"line_end":720,"column_start":12,"column_end":24},"name":"replace_with","qualname":"<RefCell<T>>::replace_with","value":"fn <F> (&self, f: F) -> T","parent":null,"children":[],"decl_id":null,"docs":" Replaces the wrapped value with a new one computed from `f`, returning\n the old value, without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1043438,"byte_end":1043447,"line_start":718,"line_end":718,"column_start":5,"column_end":14}},{"value":"stable(feature = \"refcell_replace_swap\", since = \"1.35.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1043452,"byte_end":1043511,"line_start":719,"line_end":719,"column_start":5,"column_end":64}}]},{"kind":"Method","id":{"krate":0,"index":3214},"span":{"file_name":"src/libcore/cell.rs","byte_start":1044372,"byte_end":1044376,"line_start":747,"line_end":747,"column_start":12,"column_end":16},"name":"swap","qualname":"<RefCell<T>>::swap","value":"fn (&self, other: &Self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps the wrapped value of `self` with the wrapped value of `other`,\n without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1044295,"byte_end":1044304,"line_start":745,"line_end":745,"column_start":5,"column_end":14}},{"value":"stable(feature = \"refcell_swap\", since = \"1.24.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1044309,"byte_end":1044360,"line_start":746,"line_end":746,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":3218},"span":{"file_name":"src/libcore/cell.rs","byte_start":1045531,"byte_end":1045537,"line_start":791,"line_end":791,"column_start":12,"column_end":18},"name":"borrow","qualname":"<RefCell<T>>::borrow","value":"fn (&self) -> Ref<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Immutably borrows the wrapped value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1045460,"byte_end":1045505,"line_start":789,"line_end":789,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1045510,"byte_end":1045519,"line_start":790,"line_end":790,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3220},"span":{"file_name":"src/libcore/cell.rs","byte_start":1046395,"byte_end":1046405,"line_start":822,"line_end":822,"column_start":12,"column_end":22},"name":"try_borrow","qualname":"<RefCell<T>>::try_borrow","value":"fn (&self) -> Result<Ref<'_, T>, BorrowError>","parent":null,"children":[],"decl_id":null,"docs":" Immutably borrows the wrapped value, returning an error if the value is currently mutably\n borrowed.","sig":null,"attributes":[{"value":"stable(feature = \"try_borrow\", since = \"1.13.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1046318,"byte_end":1046369,"line_start":820,"line_end":820,"column_start":5,"column_end":56}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1046374,"byte_end":1046383,"line_start":821,"line_end":821,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3222},"span":{"file_name":"src/libcore/cell.rs","byte_start":1047749,"byte_end":1047759,"line_start":872,"line_end":872,"column_start":12,"column_end":22},"name":"borrow_mut","qualname":"<RefCell<T>>::borrow_mut","value":"fn (&self) -> RefMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Mutably borrows the wrapped value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1047678,"byte_end":1047723,"line_start":870,"line_end":870,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1047728,"byte_end":1047737,"line_start":871,"line_end":871,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3224},"span":{"file_name":"src/libcore/cell.rs","byte_start":1048593,"byte_end":1048607,"line_start":900,"line_end":900,"column_start":12,"column_end":26},"name":"try_borrow_mut","qualname":"<RefCell<T>>::try_borrow_mut","value":"fn (&self) -> Result<RefMut<'_, T>, BorrowMutError>","parent":null,"children":[],"decl_id":null,"docs":" Mutably borrows the wrapped value, returning an error if the value is currently borrowed.","sig":null,"attributes":[{"value":"stable(feature = \"try_borrow\", since = \"1.13.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1048516,"byte_end":1048567,"line_start":898,"line_end":898,"column_start":5,"column_end":56}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1048572,"byte_end":1048581,"line_start":899,"line_end":899,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3226},"span":{"file_name":"src/libcore/cell.rs","byte_start":1049236,"byte_end":1049242,"line_start":923,"line_end":923,"column_start":12,"column_end":18},"name":"as_ptr","qualname":"<RefCell<T>>::as_ptr","value":"fn (&self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a raw pointer to the underlying data in this cell.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1049158,"byte_end":1049167,"line_start":921,"line_end":921,"column_start":5,"column_end":14}},{"value":"stable(feature = \"cell_as_ptr\", since = \"1.12.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1049172,"byte_end":1049224,"line_start":922,"line_end":922,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3228},"span":{"file_name":"src/libcore/cell.rs","byte_start":1050219,"byte_end":1050226,"line_start":953,"line_end":953,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<RefCell<T>>::get_mut","value":"fn (&mut self) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to the underlying data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1050140,"byte_end":1050149,"line_start":951,"line_end":951,"column_start":5,"column_end":14}},{"value":"stable(feature = \"cell_get_mut\", since = \"1.11.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1050154,"byte_end":1050207,"line_start":952,"line_end":952,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":3230},"span":{"file_name":"src/libcore/cell.rs","byte_start":1051247,"byte_end":1051267,"line_start":989,"line_end":989,"column_start":19,"column_end":39},"name":"try_borrow_unguarded","qualname":"<RefCell<T>>::try_borrow_unguarded","value":"fn (&self) -> Result<&T, BorrowError>","parent":null,"children":[],"decl_id":null,"docs":" Immutably borrows the wrapped value, returning an error if the value is\n currently mutably borrowed.","sig":null,"attributes":[{"value":"unstable(feature = \"borrow_state\", issue = \"27733\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1051160,"byte_end":1051214,"line_start":987,"line_end":987,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1051219,"byte_end":1051228,"line_start":988,"line_end":988,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":3286},"span":{"file_name":"src/libcore/cell.rs","byte_start":1055777,"byte_end":1055780,"line_start":1150,"line_end":1150,"column_start":12,"column_end":15},"name":"Ref","qualname":"::cell::Ref","value":"Ref {  }","parent":null,"children":[{"krate":0,"index":1633},{"krate":0,"index":1635}],"decl_id":null,"docs":" Wraps a borrowed reference to a value in a `RefCell` box.\n A wrapper type for an immutably borrowed value from a `RefCell<T>`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1055720,"byte_end":1055765,"line_start":1149,"line_end":1149,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":3296},"span":{"file_name":"src/libcore/cell.rs","byte_start":1056503,"byte_end":1056508,"line_start":1176,"line_end":1176,"column_start":12,"column_end":17},"name":"clone","qualname":"<Ref>::clone","value":"fn (orig: &Ref<'b, T>) -> Ref<'b, T>","parent":null,"children":[],"decl_id":null,"docs":" Copies a `Ref`.","sig":null,"attributes":[{"value":"stable(feature = \"cell_extras\", since = \"1.15.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1056425,"byte_end":1056477,"line_start":1174,"line_end":1174,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1056482,"byte_end":1056491,"line_start":1175,"line_end":1175,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3298},"span":{"file_name":"src/libcore/cell.rs","byte_start":1057355,"byte_end":1057358,"line_start":1203,"line_end":1203,"column_start":12,"column_end":15},"name":"map","qualname":"<Ref>::map","value":"fn <U, F> (orig: Ref<'b, T>, f: F) -> Ref<'b, U>","parent":null,"children":[],"decl_id":null,"docs":" Makes a new `Ref` for a component of the borrowed data.","sig":null,"attributes":[{"value":"stable(feature = \"cell_map\", since = \"1.8.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1057281,"byte_end":1057329,"line_start":1201,"line_end":1201,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1057334,"byte_end":1057343,"line_start":1202,"line_end":1202,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3300},"span":{"file_name":"src/libcore/cell.rs","byte_start":1058374,"byte_end":1058383,"line_start":1234,"line_end":1234,"column_start":12,"column_end":21},"name":"map_split","qualname":"<Ref>::map_split","value":"fn <U, V, F> (orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>)","parent":null,"children":[],"decl_id":null,"docs":" Splits a `Ref` into multiple `Ref`s for different components of the\n borrowed data.","sig":null,"attributes":[{"value":"stable(feature = \"refcell_map_split\", since = \"1.35.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1058290,"byte_end":1058348,"line_start":1232,"line_end":1232,"column_start":5,"column_end":63}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1058353,"byte_end":1058362,"line_start":1233,"line_end":1233,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3310},"span":{"file_name":"src/libcore/cell.rs","byte_start":1059931,"byte_end":1059934,"line_start":1279,"line_end":1279,"column_start":12,"column_end":15},"name":"map","qualname":"<RefMut>::map","value":"fn <U, F> (orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>","parent":null,"children":[],"decl_id":null,"docs":" Makes a new `RefMut` for a component of the borrowed data, e.g., an enum\n variant.","sig":null,"attributes":[{"value":"stable(feature = \"cell_map\", since = \"1.8.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1059857,"byte_end":1059905,"line_start":1277,"line_end":1277,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1059910,"byte_end":1059919,"line_start":1278,"line_end":1278,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3312},"span":{"file_name":"src/libcore/cell.rs","byte_start":1061273,"byte_end":1061282,"line_start":1317,"line_end":1317,"column_start":12,"column_end":21},"name":"map_split","qualname":"<RefMut>::map_split","value":"fn <U, V, F> (orig: RefMut<'b, T>, f: F) -> (RefMut<'b, U>, RefMut<'b, V>)","parent":null,"children":[],"decl_id":null,"docs":" Splits a `RefMut` into multiple `RefMut`s for different components of the\n borrowed data.","sig":null,"attributes":[{"value":"stable(feature = \"refcell_map_split\", since = \"1.35.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1061189,"byte_end":1061247,"line_start":1315,"line_end":1315,"column_start":5,"column_end":63}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1061252,"byte_end":1061261,"line_start":1316,"line_end":1316,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":3326},"span":{"file_name":"src/libcore/cell.rs","byte_start":1063276,"byte_end":1063282,"line_start":1377,"line_end":1377,"column_start":12,"column_end":18},"name":"RefMut","qualname":"::cell::RefMut","value":"RefMut {  }","parent":null,"children":[{"krate":0,"index":1685},{"krate":0,"index":1687}],"decl_id":null,"docs":" A wrapper type for a mutably borrowed value from a `RefCell<T>`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1063219,"byte_end":1063264,"line_start":1376,"line_end":1376,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":3344},"span":{"file_name":"src/libcore/cell.rs","byte_start":1067217,"byte_end":1067227,"line_start":1470,"line_end":1470,"column_start":12,"column_end":22},"name":"UnsafeCell","qualname":"::cell::UnsafeCell","value":"UnsafeCell {  }","parent":null,"children":[{"krate":0,"index":1703}],"decl_id":null,"docs":" The core primitive for interior mutability in Rust.","sig":null,"attributes":[{"value":"lang = \"unsafe_cell\"","span":{"file_name":"src/libcore/cell.rs","byte_start":1067115,"byte_end":1067138,"line_start":1467,"line_end":1467,"column_start":1,"column_end":24}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1067139,"byte_end":1067184,"line_start":1468,"line_end":1468,"column_start":1,"column_end":46}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/cell.rs","byte_start":1067185,"byte_end":1067205,"line_start":1469,"line_end":1469,"column_start":1,"column_end":21}}]},{"kind":"Method","id":{"krate":0,"index":3350},"span":{"file_name":"src/libcore/cell.rs","byte_start":1067762,"byte_end":1067765,"line_start":1492,"line_end":1492,"column_start":18,"column_end":21},"name":"new","qualname":"<UnsafeCell<T>>::new","value":"fn (value: T) -> UnsafeCell<T>","parent":null,"children":[],"decl_id":null,"docs":" Constructs a new instance of `UnsafeCell` which will wrap the specified\n value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1067685,"byte_end":1067730,"line_start":1490,"line_end":1490,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1067735,"byte_end":1067744,"line_start":1491,"line_end":1491,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3352},"span":{"file_name":"src/libcore/cell.rs","byte_start":1068116,"byte_end":1068126,"line_start":1509,"line_end":1509,"column_start":12,"column_end":22},"name":"into_inner","qualname":"<UnsafeCell<T>>::into_inner","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps the value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1068045,"byte_end":1068054,"line_start":1507,"line_end":1507,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1068059,"byte_end":1068104,"line_start":1508,"line_end":1508,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":3356},"span":{"file_name":"src/libcore/cell.rs","byte_start":1068779,"byte_end":1068782,"line_start":1533,"line_end":1533,"column_start":18,"column_end":21},"name":"get","qualname":"<UnsafeCell<T>>::get","value":"fn (&self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable pointer to the wrapped value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/cell.rs","byte_start":1068702,"byte_end":1068711,"line_start":1531,"line_end":1531,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/cell.rs","byte_start":1068716,"byte_end":1068761,"line_start":1532,"line_end":1532,"column_start":5,"column_end":50}}]},{"kind":"Mod","id":{"krate":0,"index":3370},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"char","qualname":"::char","value":"src/libcore/char/mod.rs","parent":null,"children":[{"krate":0,"index":3372},{"krate":0,"index":3422},{"krate":0,"index":3446},{"krate":0,"index":3544},{"krate":0,"index":3550},{"krate":0,"index":3552},{"krate":0,"index":3554},{"krate":0,"index":3556},{"krate":0,"index":3564},{"krate":0,"index":3566},{"krate":0,"index":3568},{"krate":0,"index":3574},{"krate":0,"index":3576},{"krate":0,"index":3578},{"krate":0,"index":3580},{"krate":0,"index":3582},{"krate":0,"index":3584},{"krate":0,"index":3586},{"krate":0,"index":3588},{"krate":0,"index":3590},{"krate":0,"index":3592},{"krate":0,"index":41474},{"krate":0,"index":41480},{"krate":0,"index":41476},{"krate":0,"index":41484},{"krate":0,"index":41490},{"krate":0,"index":41486},{"krate":0,"index":3594},{"krate":0,"index":3606},{"krate":0,"index":3610},{"krate":0,"index":3612},{"krate":0,"index":41494},{"krate":0,"index":41500},{"krate":0,"index":41496},{"krate":0,"index":41504},{"krate":0,"index":41510},{"krate":0,"index":41506},{"krate":0,"index":3616},{"krate":0,"index":3630},{"krate":0,"index":3634},{"krate":0,"index":3636},{"krate":0,"index":41514},{"krate":0,"index":41520},{"krate":0,"index":41516},{"krate":0,"index":3640},{"krate":0,"index":3648},{"krate":0,"index":3650},{"krate":0,"index":3652},{"krate":0,"index":41524},{"krate":0,"index":41530},{"krate":0,"index":41526},{"krate":0,"index":3656},{"krate":0,"index":3664},{"krate":0,"index":3666},{"krate":0,"index":41534},{"krate":0,"index":41540},{"krate":0,"index":41536},{"krate":0,"index":3668},{"krate":0,"index":3676},{"krate":0,"index":3678},{"krate":0,"index":41544},{"krate":0,"index":41550},{"krate":0,"index":41546},{"krate":0,"index":3680},{"krate":0,"index":3684},{"krate":0,"index":3692},{"krate":0,"index":3696},{"krate":0,"index":3700}],"decl_id":null,"docs":" A character type.","sig":null,"attributes":[{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1070560,"byte_end":1070585,"line_start":19,"line_end":19,"column_start":1,"column_end":26}},{"value":"stable(feature = \"core_char\", since = \"1.2.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1070586,"byte_end":1070636,"line_start":20,"line_end":20,"column_start":1,"column_end":51}}]},{"kind":"Function","id":{"krate":0,"index":3384},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1087993,"byte_end":1088001,"line_start":57,"line_end":57,"column_start":8,"column_end":16},"name":"from_u32","qualname":"::char::convert::from_u32","value":"fn (i: u32) -> Option<char>","parent":null,"children":[],"decl_id":null,"docs":" Converts a `u32` to a `char`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1087930,"byte_end":1087939,"line_start":55,"line_end":55,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1087940,"byte_end":1087985,"line_start":56,"line_end":56,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":3386},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1089045,"byte_end":1089063,"line_start":101,"line_end":101,"column_start":15,"column_end":33},"name":"from_u32_unchecked","qualname":"::char::convert::from_u32_unchecked","value":"fn (i: u32) -> char","parent":null,"children":[],"decl_id":null,"docs":" Converts a `u32` to a `char`, ignoring validity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1088961,"byte_end":1088970,"line_start":99,"line_end":99,"column_start":1,"column_end":10}},{"value":"stable(feature = \"char_from_unchecked\", since = \"1.5.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1088971,"byte_end":1089030,"line_start":100,"line_end":100,"column_start":1,"column_end":60}}]},{"kind":"Struct","id":{"krate":0,"index":41382},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091106,"byte_end":1091120,"line_start":169,"line_end":169,"column_start":12,"column_end":26},"name":"ParseCharError","qualname":"::char::convert::ParseCharError","value":"ParseCharError {  }","parent":null,"children":[{"krate":0,"index":22059}],"decl_id":null,"docs":" An error which can be returned when parsing a char.\n","sig":null,"attributes":[{"value":"stable(feature = \"char_from_str\", since = \"1.20.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091001,"byte_end":1091055,"line_start":167,"line_end":167,"column_start":1,"column_end":55}},{"value":"structural_match","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091095,"byte_end":1091149,"line_start":169,"line_end":171,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":3398},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091353,"byte_end":1091366,"line_start":178,"line_end":178,"column_start":12,"column_end":25},"name":"__description","qualname":"<ParseCharError>::__description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"char_error_internals\",\n           reason = \"this method should not be available publicly\",\n           issue = \"0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091177,"byte_end":1091322,"line_start":174,"line_end":176,"column_start":5,"column_end":29}}]},{"kind":"Struct","id":{"krate":0,"index":41422},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1093008,"byte_end":1093024,"line_start":239,"line_end":239,"column_start":12,"column_end":28},"name":"CharTryFromError","qualname":"::char::convert::CharTryFromError","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type returned when a conversion from u32 to char fails.\n","sig":null,"attributes":[{"value":"stable(feature = \"try_from\", since = \"1.34.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1092902,"byte_end":1092951,"line_start":237,"line_end":237,"column_start":1,"column_end":50}},{"value":"structural_match","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1092997,"byte_end":1093029,"line_start":239,"line_end":239,"column_start":1,"column_end":33}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1092997,"byte_end":1093029,"line_start":239,"line_end":239,"column_start":1,"column_end":33}}]},{"kind":"Function","id":{"krate":0,"index":3420},"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1094467,"byte_end":1094477,"line_start":304,"line_end":304,"column_start":8,"column_end":18},"name":"from_digit","qualname":"::char::convert::from_digit","value":"fn (num: u32, radix: u32) -> Option<char>","parent":null,"children":[],"decl_id":null,"docs":" Converts a digit in the given radix to a `char`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1094404,"byte_end":1094413,"line_start":302,"line_end":302,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1094414,"byte_end":1094459,"line_start":303,"line_end":303,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":41444},"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1095085,"byte_end":1095096,"line_start":10,"line_end":10,"column_start":12,"column_end":23},"name":"DecodeUtf16","qualname":"::char::decode::DecodeUtf16","value":"DecodeUtf16 {  }","parent":null,"children":[{"krate":0,"index":22075},{"krate":0,"index":22077}],"decl_id":null,"docs":" An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1094997,"byte_end":1095049,"line_start":8,"line_end":8,"column_start":1,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":41454},"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1095345,"byte_end":1095361,"line_start":20,"line_end":20,"column_start":12,"column_end":28},"name":"DecodeUtf16Error","qualname":"::char::decode::DecodeUtf16Error","value":"DecodeUtf16Error {  }","parent":null,"children":[{"krate":0,"index":22083}],"decl_id":null,"docs":" An error that can be returned when decoding UTF-16 code points.\n","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1095242,"byte_end":1095294,"line_start":18,"line_end":18,"column_start":1,"column_end":53}},{"value":"structural_match","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1095334,"byte_end":1095380,"line_start":20,"line_end":22,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":3428},"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1096815,"byte_end":1096827,"line_start":70,"line_end":70,"column_start":8,"column_end":20},"name":"decode_utf16","qualname":"::char::decode::decode_utf16","value":"fn <I> (iter: I) -> DecodeUtf16<I::IntoIter>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator over the UTF-16 encoded code points in `iter`,\n returning unpaired surrogates as `Err`s.","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1096745,"byte_end":1096797,"line_start":68,"line_end":68,"column_start":1,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1096798,"byte_end":1096807,"line_start":69,"line_end":69,"column_start":1,"column_end":10}}]},{"kind":"Method","id":{"krate":0,"index":3440},"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1098709,"byte_end":1098727,"line_start":124,"line_end":124,"column_start":12,"column_end":30},"name":"unpaired_surrogate","qualname":"<DecodeUtf16Error>::unpaired_surrogate","value":"fn (&self) -> u16","parent":null,"children":[],"decl_id":null,"docs":" Returns the unpaired surrogate which caused this error.\n","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1098645,"byte_end":1098697,"line_start":123,"line_end":123,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3468},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1100595,"byte_end":1100603,"line_start":60,"line_end":60,"column_start":12,"column_end":20},"name":"is_digit","qualname":"<char>::is_digit","value":"fn (self, radix: u32) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if a `char` is a digit in the given radix.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1100524,"byte_end":1100569,"line_start":58,"line_end":58,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1100574,"byte_end":1100583,"line_start":59,"line_end":59,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3470},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1102001,"byte_end":1102009,"line_start":114,"line_end":114,"column_start":12,"column_end":20},"name":"to_digit","qualname":"<char>::to_digit","value":"fn (self, radix: u32) -> Option<u32>","parent":null,"children":[],"decl_id":null,"docs":" Converts a `char` to a digit in the given radix.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1101930,"byte_end":1101975,"line_start":112,"line_end":112,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1101980,"byte_end":1101989,"line_start":113,"line_end":113,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3472},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1103645,"byte_end":1103659,"line_start":173,"line_end":173,"column_start":12,"column_end":26},"name":"escape_unicode","qualname":"<char>::escape_unicode","value":"fn (self) -> EscapeUnicode","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the hexadecimal Unicode escape of a\n character as `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1103574,"byte_end":1103619,"line_start":171,"line_end":171,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1103624,"byte_end":1103633,"line_start":172,"line_end":172,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3476},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1106005,"byte_end":1106017,"line_start":245,"line_end":245,"column_start":12,"column_end":24},"name":"escape_debug","qualname":"<char>::escape_debug","value":"fn (self) -> EscapeDebug","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the literal escape code of a character\n as `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"char_escape_debug\", since = \"1.20.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1105921,"byte_end":1105979,"line_start":243,"line_end":243,"column_start":5,"column_end":63}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1105984,"byte_end":1105993,"line_start":244,"line_end":244,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3478},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1107546,"byte_end":1107560,"line_start":300,"line_end":300,"column_start":12,"column_end":26},"name":"escape_default","qualname":"<char>::escape_default","value":"fn (self) -> EscapeDefault","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the literal escape code of a character\n as `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1107475,"byte_end":1107520,"line_start":298,"line_end":298,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1107525,"byte_end":1107534,"line_start":299,"line_end":299,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3480},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1109444,"byte_end":1109452,"line_start":359,"line_end":359,"column_start":12,"column_end":20},"name":"len_utf8","qualname":"<char>::len_utf8","value":"fn (self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of bytes this `char` would need if encoded in UTF-8.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1109373,"byte_end":1109418,"line_start":357,"line_end":357,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1109423,"byte_end":1109432,"line_start":358,"line_end":358,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3482},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1110304,"byte_end":1110313,"line_start":393,"line_end":393,"column_start":12,"column_end":21},"name":"len_utf16","qualname":"<char>::len_utf16","value":"fn (self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of 16-bit code units this `char` would need if\n encoded in UTF-16.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1110233,"byte_end":1110278,"line_start":391,"line_end":391,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1110283,"byte_end":1110292,"line_start":392,"line_end":392,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3484},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1111436,"byte_end":1111447,"line_start":436,"line_end":436,"column_start":12,"column_end":23},"name":"encode_utf8","qualname":"<char>::encode_utf8","value":"fn (self, dst: &mut [u8]) -> &mut str","parent":null,"children":[],"decl_id":null,"docs":" Encodes this character as UTF-8 into the provided byte buffer,\n and then returns the subslice of the buffer that contains the encoded character.","sig":null,"attributes":[{"value":"stable(feature = \"unicode_encode_char\", since = \"1.15.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1111350,"byte_end":1111410,"line_start":434,"line_end":434,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1111415,"byte_end":1111424,"line_start":435,"line_end":435,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3486},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1113934,"byte_end":1113946,"line_start":504,"line_end":504,"column_start":12,"column_end":24},"name":"encode_utf16","qualname":"<char>::encode_utf16","value":"fn (self, dst: &mut [u16]) -> &mut [u16]","parent":null,"children":[],"decl_id":null,"docs":" Encodes this character as UTF-16 into the provided `u16` buffer,\n and then returns the subslice of the buffer that contains the encoded character.","sig":null,"attributes":[{"value":"stable(feature = \"unicode_encode_char\", since = \"1.15.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1113848,"byte_end":1113908,"line_start":502,"line_end":502,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1113913,"byte_end":1113922,"line_start":503,"line_end":503,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3488},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1115365,"byte_end":1115378,"line_start":542,"line_end":542,"column_start":12,"column_end":25},"name":"is_alphabetic","qualname":"<char>::is_alphabetic","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is an alphabetic code point, and false if not.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1115294,"byte_end":1115339,"line_start":540,"line_end":540,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1115344,"byte_end":1115353,"line_start":541,"line_end":541,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3490},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1116058,"byte_end":1116070,"line_start":560,"line_end":560,"column_start":12,"column_end":24},"name":"is_xid_start","qualname":"<char>::is_xid_start","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` satisfies the 'XID_Start' Unicode property, and false\n otherwise.","sig":null,"attributes":[{"value":"unstable(feature = \"rustc_private\",\n           reason = \"mainly needed for compiler internals\",\n           issue = \"27812\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1115898,"byte_end":1116032,"line_start":556,"line_end":558,"column_start":5,"column_end":33}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1116037,"byte_end":1116046,"line_start":559,"line_end":559,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3492},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1116637,"byte_end":1116652,"line_start":574,"line_end":574,"column_start":12,"column_end":27},"name":"is_xid_continue","qualname":"<char>::is_xid_continue","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` satisfies the 'XID_Continue' Unicode property, and false\n otherwise.","sig":null,"attributes":[{"value":"unstable(feature = \"rustc_private\",\n           reason = \"mainly needed for compiler internals\",\n           issue = \"27812\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1116477,"byte_end":1116611,"line_start":570,"line_end":572,"column_start":5,"column_end":33}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1116616,"byte_end":1116625,"line_start":573,"line_end":573,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3494},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1117321,"byte_end":1117333,"line_start":598,"line_end":598,"column_start":12,"column_end":24},"name":"is_lowercase","qualname":"<char>::is_lowercase","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is lowercase.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1117250,"byte_end":1117295,"line_start":596,"line_end":596,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1117300,"byte_end":1117309,"line_start":597,"line_end":597,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3496},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118106,"byte_end":1118118,"line_start":626,"line_end":626,"column_start":12,"column_end":24},"name":"is_uppercase","qualname":"<char>::is_uppercase","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is uppercase.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118035,"byte_end":1118080,"line_start":624,"line_end":624,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118085,"byte_end":1118094,"line_start":625,"line_end":625,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3498},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118800,"byte_end":1118813,"line_start":653,"line_end":653,"column_start":12,"column_end":25},"name":"is_whitespace","qualname":"<char>::is_whitespace","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118729,"byte_end":1118774,"line_start":651,"line_end":651,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1118779,"byte_end":1118788,"line_start":652,"line_end":652,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3500},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1119698,"byte_end":1119713,"line_start":682,"line_end":682,"column_start":12,"column_end":27},"name":"is_alphanumeric","qualname":"<char>::is_alphanumeric","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is alphanumeric.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1119627,"byte_end":1119672,"line_start":680,"line_end":680,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1119677,"byte_end":1119686,"line_start":681,"line_end":681,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3502},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1120225,"byte_end":1120235,"line_start":702,"line_end":702,"column_start":12,"column_end":22},"name":"is_control","qualname":"<char>::is_control","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is a control code point.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1120154,"byte_end":1120199,"line_start":700,"line_end":700,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1120204,"byte_end":1120213,"line_start":701,"line_end":701,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3506},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1121246,"byte_end":1121256,"line_start":736,"line_end":736,"column_start":12,"column_end":22},"name":"is_numeric","qualname":"<char>::is_numeric","value":"fn (self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `char` is numeric.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1121175,"byte_end":1121220,"line_start":734,"line_end":734,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1121225,"byte_end":1121234,"line_start":735,"line_end":735,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3508},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1123257,"byte_end":1123269,"line_start":801,"line_end":801,"column_start":12,"column_end":24},"name":"to_lowercase","qualname":"<char>::to_lowercase","value":"fn (self) -> ToLowercase","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the lowercase equivalent of a `char`\n as one or more `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1123186,"byte_end":1123231,"line_start":799,"line_end":799,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1123236,"byte_end":1123245,"line_start":800,"line_end":800,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3510},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1125987,"byte_end":1125999,"line_start":887,"line_end":887,"column_start":12,"column_end":24},"name":"to_uppercase","qualname":"<char>::to_uppercase","value":"fn (self) -> ToUppercase","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the uppercase equivalent of a `char`\n as one or more `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1125916,"byte_end":1125961,"line_start":885,"line_end":885,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1125966,"byte_end":1125975,"line_start":886,"line_end":886,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3512},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1126458,"byte_end":1126466,"line_start":904,"line_end":904,"column_start":18,"column_end":26},"name":"is_ascii","qualname":"<char>::is_ascii","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is within the ASCII range.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1126358,"byte_end":1126426,"line_start":902,"line_end":902,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1126431,"byte_end":1126440,"line_start":903,"line_end":903,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3514},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1127345,"byte_end":1127363,"line_start":932,"line_end":932,"column_start":12,"column_end":30},"name":"to_ascii_uppercase","qualname":"<char>::to_ascii_uppercase","value":"fn (&self) -> char","parent":null,"children":[],"decl_id":null,"docs":" Makes a copy of the value in its ASCII upper case equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1127251,"byte_end":1127319,"line_start":930,"line_end":930,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1127324,"byte_end":1127333,"line_start":931,"line_end":931,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3516},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1128342,"byte_end":1128360,"line_start":964,"line_end":964,"column_start":12,"column_end":30},"name":"to_ascii_lowercase","qualname":"<char>::to_ascii_lowercase","value":"fn (&self) -> char","parent":null,"children":[],"decl_id":null,"docs":" Makes a copy of the value in its ASCII lower case equivalent.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1128248,"byte_end":1128316,"line_start":962,"line_end":962,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1128321,"byte_end":1128330,"line_start":963,"line_end":963,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3518},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1129080,"byte_end":1129100,"line_start":989,"line_end":989,"column_start":12,"column_end":32},"name":"eq_ignore_ascii_case","qualname":"<char>::eq_ignore_ascii_case","value":"fn (&self, other: &char) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that two values are an ASCII case-insensitive match.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1128986,"byte_end":1129054,"line_start":987,"line_end":987,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1129059,"byte_end":1129068,"line_start":988,"line_end":988,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3520},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1129847,"byte_end":1129867,"line_start":1014,"line_end":1014,"column_start":12,"column_end":32},"name":"make_ascii_uppercase","qualname":"<char>::make_ascii_uppercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this type to its ASCII upper case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1129753,"byte_end":1129821,"line_start":1012,"line_end":1012,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1129826,"byte_end":1129835,"line_start":1013,"line_end":1013,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3522},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1130575,"byte_end":1130595,"line_start":1039,"line_end":1039,"column_start":12,"column_end":32},"name":"make_ascii_lowercase","qualname":"<char>::make_ascii_lowercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this type to its ASCII lower case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1130481,"byte_end":1130549,"line_start":1037,"line_end":1037,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1130554,"byte_end":1130563,"line_start":1038,"line_end":1038,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3524},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1131631,"byte_end":1131650,"line_start":1073,"line_end":1073,"column_start":12,"column_end":31},"name":"is_ascii_alphabetic","qualname":"<char>::is_ascii_alphabetic","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII alphabetic character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1131539,"byte_end":1131605,"line_start":1071,"line_end":1071,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1131610,"byte_end":1131619,"line_start":1072,"line_end":1072,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3526},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1132652,"byte_end":1132670,"line_start":1105,"line_end":1105,"column_start":12,"column_end":30},"name":"is_ascii_uppercase","qualname":"<char>::is_ascii_uppercase","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII uppercase character:\n U+0041 'A' ... U+005A 'Z'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1132560,"byte_end":1132626,"line_start":1103,"line_end":1103,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1132631,"byte_end":1132640,"line_start":1104,"line_end":1104,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3528},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1133671,"byte_end":1133689,"line_start":1137,"line_end":1137,"column_start":12,"column_end":30},"name":"is_ascii_lowercase","qualname":"<char>::is_ascii_lowercase","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII lowercase character:\n U+0061 'a' ... U+007A 'z'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1133579,"byte_end":1133645,"line_start":1135,"line_end":1135,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1133650,"byte_end":1133659,"line_start":1136,"line_end":1136,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3530},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1134807,"byte_end":1134828,"line_start":1172,"line_end":1172,"column_start":12,"column_end":33},"name":"is_ascii_alphanumeric","qualname":"<char>::is_ascii_alphanumeric","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII alphanumeric character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1134715,"byte_end":1134781,"line_start":1170,"line_end":1170,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1134786,"byte_end":1134795,"line_start":1171,"line_end":1171,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3532},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1135791,"byte_end":1135805,"line_start":1204,"line_end":1204,"column_start":12,"column_end":26},"name":"is_ascii_digit","qualname":"<char>::is_ascii_digit","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII decimal digit:\n U+0030 '0' ... U+0039 '9'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1135699,"byte_end":1135765,"line_start":1202,"line_end":1202,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1135770,"byte_end":1135779,"line_start":1203,"line_end":1203,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3534},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136880,"byte_end":1136897,"line_start":1239,"line_end":1239,"column_start":12,"column_end":29},"name":"is_ascii_hexdigit","qualname":"<char>::is_ascii_hexdigit","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII hexadecimal digit:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136788,"byte_end":1136854,"line_start":1237,"line_end":1237,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1136859,"byte_end":1136868,"line_start":1238,"line_end":1238,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3536},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1138090,"byte_end":1138110,"line_start":1275,"line_end":1275,"column_start":12,"column_end":32},"name":"is_ascii_punctuation","qualname":"<char>::is_ascii_punctuation","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII punctuation character:","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1137998,"byte_end":1138064,"line_start":1273,"line_end":1273,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1138069,"byte_end":1138078,"line_start":1274,"line_end":1274,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3538},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1139089,"byte_end":1139105,"line_start":1307,"line_end":1307,"column_start":12,"column_end":28},"name":"is_ascii_graphic","qualname":"<char>::is_ascii_graphic","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII graphic character:\n U+0021 '!' ... U+007E '~'.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1138997,"byte_end":1139063,"line_start":1305,"line_end":1305,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1139068,"byte_end":1139077,"line_start":1306,"line_end":1306,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3540},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1141132,"byte_end":1141151,"line_start":1356,"line_end":1356,"column_start":12,"column_end":31},"name":"is_ascii_whitespace","qualname":"<char>::is_ascii_whitespace","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII whitespace character:\n U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n U+000C FORM FEED, or U+000D CARRIAGE RETURN.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1141040,"byte_end":1141106,"line_start":1354,"line_end":1354,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1141111,"byte_end":1141120,"line_start":1355,"line_end":1355,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3542},"span":{"file_name":"src/libcore/char/methods.rs","byte_start":1142263,"byte_end":1142279,"line_start":1390,"line_end":1390,"column_start":12,"column_end":28},"name":"is_ascii_control","qualname":"<char>::is_ascii_control","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the value is an ASCII control character:\n U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n Note that most ASCII whitespace characters are control\n characters, but SPACE is not.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1142171,"byte_end":1142237,"line_start":1388,"line_end":1388,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/char/methods.rs","byte_start":1142242,"byte_end":1142251,"line_start":1389,"line_end":1389,"column_start":5,"column_end":14}}]},{"kind":"Const","id":{"krate":0,"index":3590},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1074255,"byte_end":1074258,"line_start":99,"line_end":99,"column_start":11,"column_end":14},"name":"MAX","qualname":"::char::MAX","value":"char","parent":null,"children":[],"decl_id":null,"docs":" The highest valid code point a `char` can have.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1074199,"byte_end":1074244,"line_start":98,"line_end":98,"column_start":1,"column_end":46}}]},{"kind":"Const","id":{"krate":0,"index":3592},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1074606,"byte_end":1074627,"line_start":107,"line_end":107,"column_start":11,"column_end":32},"name":"REPLACEMENT_CHARACTER","qualname":"::char::REPLACEMENT_CHARACTER","value":"char","parent":null,"children":[],"decl_id":null,"docs":" `U+FFFD REPLACEMENT CHARACTER` () is used in Unicode to represent a\n decoding error.","sig":null,"attributes":[{"value":"stable(feature = \"decode_utf16\", since = \"1.9.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1074543,"byte_end":1074595,"line_start":106,"line_end":106,"column_start":1,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":41474},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1075068,"byte_end":1075081,"line_start":119,"line_end":119,"column_start":12,"column_end":25},"name":"EscapeUnicode","qualname":"::char::EscapeUnicode","value":"EscapeUnicode {  }","parent":null,"children":[{"krate":0,"index":22085},{"krate":0,"index":22087},{"krate":0,"index":22089}],"decl_id":null,"docs":" Returns an iterator that yields the hexadecimal Unicode escape of a\n character, as `char`s.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1075011,"byte_end":1075056,"line_start":118,"line_end":118,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":41494},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1078742,"byte_end":1078755,"line_start":240,"line_end":240,"column_start":12,"column_end":25},"name":"EscapeDefault","qualname":"::char::EscapeDefault","value":"EscapeDefault {  }","parent":null,"children":[{"krate":0,"index":22115}],"decl_id":null,"docs":" An iterator that yields the literal escape code of a `char`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1078685,"byte_end":1078730,"line_start":239,"line_end":239,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":41514},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1081998,"byte_end":1082009,"line_start":353,"line_end":353,"column_start":12,"column_end":23},"name":"EscapeDebug","qualname":"::char::EscapeDebug","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator that yields the literal escape code of a `char`.","sig":null,"attributes":[{"value":"stable(feature = \"char_escape_debug\", since = \"1.20.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1081904,"byte_end":1081962,"line_start":351,"line_end":351,"column_start":1,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":41524},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083055,"byte_end":1083066,"line_start":384,"line_end":384,"column_start":12,"column_end":23},"name":"ToLowercase","qualname":"::char::ToLowercase","value":"","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the lowercase equivalent of a `char`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082974,"byte_end":1083019,"line_start":382,"line_end":382,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":41534},"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083930,"byte_end":1083941,"line_start":412,"line_end":412,"column_start":12,"column_end":23},"name":"ToUppercase","qualname":"::char::ToUppercase","value":"","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that yields the uppercase equivalent of a `char`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083849,"byte_end":1083894,"line_start":410,"line_end":410,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":3704},"span":{"file_name":"src/libcore/panic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"panic","qualname":"::panic","value":"src/libcore/panic.rs","parent":null,"children":[{"krate":0,"index":3706},{"krate":0,"index":3708},{"krate":0,"index":41554},{"krate":0,"index":41556},{"krate":0,"index":3710},{"krate":0,"index":3724},{"krate":0,"index":41560},{"krate":0,"index":41562},{"krate":0,"index":3728},{"krate":0,"index":3738},{"krate":0,"index":3742}],"decl_id":null,"docs":" Panic support in the standard library.\n","sig":null,"attributes":[{"value":"unstable(feature = \"core_panic_info\",\n           reason = \"newly available in libcore\",\n           issue = \"44489\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1142410,"byte_end":1142531,"line_start":3,"line_end":5,"column_start":1,"column_end":30}}]},{"kind":"Struct","id":{"krate":0,"index":41554},"span":{"file_name":"src/libcore/panic.rs","byte_start":1143221,"byte_end":1143230,"line_start":35,"line_end":35,"column_start":12,"column_end":21},"name":"PanicInfo","qualname":"::panic::PanicInfo","value":"PanicInfo {  }","parent":null,"children":[{"krate":0,"index":22181},{"krate":0,"index":22183},{"krate":0,"index":22185}],"decl_id":null,"docs":" A struct providing information about a panic.","sig":null,"attributes":[{"value":"lang = \"panic_info\"","span":{"file_name":"src/libcore/panic.rs","byte_start":1143117,"byte_end":1143139,"line_start":32,"line_end":32,"column_start":1,"column_end":23}},{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1143140,"byte_end":1143192,"line_start":33,"line_end":33,"column_start":1,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":3712},"span":{"file_name":"src/libcore/panic.rs","byte_start":1143622,"byte_end":1143642,"line_start":48,"line_end":48,"column_start":12,"column_end":32},"name":"internal_constructor","qualname":"<PanicInfo>::internal_constructor","value":"fn (message: Option<&'a fmt::Arguments<'a>>, location: Location<'a>) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/panic.rs","byte_start":1143601,"byte_end":1143610,"line_start":47,"line_end":47,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3716},"span":{"file_name":"src/libcore/panic.rs","byte_start":1143920,"byte_end":1143931,"line_start":57,"line_end":57,"column_start":12,"column_end":23},"name":"set_payload","qualname":"<PanicInfo>::set_payload","value":"fn (&mut self, info: &'a (dyn Any + Send)) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/panic.rs","byte_start":1143899,"byte_end":1143908,"line_start":56,"line_end":56,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":3718},"span":{"file_name":"src/libcore/panic.rs","byte_start":1144587,"byte_end":1144594,"line_start":79,"line_end":79,"column_start":12,"column_end":19},"name":"payload","qualname":"<PanicInfo>::payload","value":"fn (&self) -> &(dyn Any + Send)","parent":null,"children":[],"decl_id":null,"docs":" Returns the payload associated with the panic.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1144523,"byte_end":1144575,"line_start":78,"line_end":78,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3720},"span":{"file_name":"src/libcore/panic.rs","byte_start":1145002,"byte_end":1145009,"line_start":89,"line_end":89,"column_start":12,"column_end":19},"name":"message","qualname":"<PanicInfo>::message","value":"fn (&self) -> Option<&fmt::Arguments<'_>>","parent":null,"children":[],"decl_id":null,"docs":" If the `panic!` macro from the `core` crate (not from `std`)\n was used with a formatting string and some additional arguments,\n returns that message ready to be used for example with [`fmt::write`]","sig":null,"attributes":[{"value":"unstable(feature = \"panic_info_message\", issue = \"44489\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1144930,"byte_end":1144990,"line_start":88,"line_end":88,"column_start":5,"column_end":65}}]},{"kind":"Method","id":{"krate":0,"index":3722},"span":{"file_name":"src/libcore/panic.rs","byte_start":1145939,"byte_end":1145947,"line_start":118,"line_end":118,"column_start":12,"column_end":20},"name":"location","qualname":"<PanicInfo>::location","value":"fn (&self) -> Option<&Location<'_>>","parent":null,"children":[],"decl_id":null,"docs":" Returns information about the location from which the panic originated,\n if available.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1145875,"byte_end":1145927,"line_start":117,"line_end":117,"column_start":5,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":41560},"span":{"file_name":"src/libcore/panic.rs","byte_start":1147725,"byte_end":1147733,"line_start":167,"line_end":167,"column_start":12,"column_end":20},"name":"Location","qualname":"::panic::Location","value":"Location {  }","parent":null,"children":[{"krate":0,"index":22191},{"krate":0,"index":22193},{"krate":0,"index":22195}],"decl_id":null,"docs":" A struct containing information about the location of a panic.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1147661,"byte_end":1147713,"line_start":166,"line_end":166,"column_start":1,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":3730},"span":{"file_name":"src/libcore/panic.rs","byte_start":1148050,"byte_end":1148070,"line_start":179,"line_end":179,"column_start":12,"column_end":32},"name":"internal_constructor","qualname":"<Location>::internal_constructor","value":"fn (file: &'a str, line: u32, col: u32) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3732},"span":{"file_name":"src/libcore/panic.rs","byte_start":1148761,"byte_end":1148765,"line_start":201,"line_end":201,"column_start":12,"column_end":16},"name":"file","qualname":"<Location>::file","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns the name of the source file from which the panic originated.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1148697,"byte_end":1148749,"line_start":200,"line_end":200,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3734},"span":{"file_name":"src/libcore/panic.rs","byte_start":1149394,"byte_end":1149398,"line_start":223,"line_end":223,"column_start":12,"column_end":16},"name":"line","qualname":"<Location>::line","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the line number from which the panic originated.","sig":null,"attributes":[{"value":"stable(feature = \"panic_hooks\", since = \"1.10.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1149330,"byte_end":1149382,"line_start":222,"line_end":222,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":3736},"span":{"file_name":"src/libcore/panic.rs","byte_start":1150023,"byte_end":1150029,"line_start":245,"line_end":245,"column_start":12,"column_end":18},"name":"column","qualname":"<Location>::column","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the column from which the panic originated.","sig":null,"attributes":[{"value":"stable(feature = \"panic_col\", since = \"1.25.0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1149961,"byte_end":1150011,"line_start":244,"line_end":244,"column_start":5,"column_end":55}}]},{"kind":"Trait","id":{"krate":0,"index":3742},"span":{"file_name":"src/libcore/panic.rs","byte_start":1150574,"byte_end":1150581,"line_start":262,"line_end":262,"column_start":18,"column_end":25},"name":"BoxMeUp","qualname":"::panic::BoxMeUp","value":"BoxMeUp","parent":null,"children":[{"krate":0,"index":3744},{"krate":0,"index":3746}],"decl_id":null,"docs":" An internal trait used by libstd to pass data from libstd to `panic_unwind`\n and other panic runtimes. Not intended to be stabilized any time soon, do\n not use.\n","sig":null,"attributes":[{"value":"unstable(feature = \"std_internals\", issue = \"0\")","span":{"file_name":"src/libcore/panic.rs","byte_start":1150490,"byte_end":1150541,"line_start":260,"line_end":260,"column_start":1,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":3744},"span":{"file_name":"src/libcore/panic.rs","byte_start":1150591,"byte_end":1150600,"line_start":263,"line_end":263,"column_start":8,"column_end":17},"name":"box_me_up","qualname":"::panic::BoxMeUp::box_me_up","value":"fn (&mut self) -> *mut (dyn Any + Send)","parent":{"krate":0,"index":3742},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3746},"span":{"file_name":"src/libcore/panic.rs","byte_start":1150645,"byte_end":1150648,"line_start":264,"line_end":264,"column_start":8,"column_end":11},"name":"get","qualname":"::panic::BoxMeUp::get","value":"fn (&mut self) -> &(dyn Any + Send)","parent":{"krate":0,"index":3742},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3748},"span":{"file_name":"src/libcore/panicking.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"panicking","qualname":"::panicking","value":"src/libcore/panicking.rs","parent":null,"children":[{"krate":0,"index":3750},{"krate":0,"index":3752},{"krate":0,"index":3758},{"krate":0,"index":3760},{"krate":0,"index":3762}],"decl_id":null,"docs":" Panic support for libcore","sig":null,"attributes":[{"value":"allow(dead_code, missing_docs)","span":{"file_name":"src/libcore/panicking.rs","byte_start":1151644,"byte_end":1151678,"line_start":23,"line_end":23,"column_start":1,"column_end":35}},{"value":"unstable(feature = \"core_panic\",\n           reason =\n               \"internal details of the implementation of the `panic!` and related macros\",\n           issue = \"0\")","span":{"file_name":"src/libcore/panicking.rs","byte_start":1151679,"byte_end":1151862,"line_start":24,"line_end":27,"column_start":1,"column_end":26}}]},{"kind":"Function","id":{"krate":0,"index":3758},"span":{"file_name":"src/libcore/panicking.rs","byte_start":1152125,"byte_end":1152130,"line_start":37,"line_end":37,"column_start":8,"column_end":13},"name":"panic","qualname":"::panicking::panic","value":"fn (expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> !","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"cold","span":{"file_name":"src/libcore/panicking.rs","byte_start":1151922,"byte_end":1151929,"line_start":32,"line_end":32,"column_start":1,"column_end":8}},{"value":"inline(never)","span":{"file_name":"src/libcore/panicking.rs","byte_start":1152084,"byte_end":1152097,"line_start":35,"line_end":35,"column_start":49,"column_end":62}},{"value":"lang = \"panic\"","span":{"file_name":"src/libcore/panicking.rs","byte_start":1152100,"byte_end":1152117,"line_start":36,"line_end":36,"column_start":1,"column_end":18}}]},{"kind":"Function","id":{"krate":0,"index":3762},"span":{"file_name":"src/libcore/panicking.rs","byte_start":1153471,"byte_end":1153480,"line_start":68,"line_end":68,"column_start":8,"column_end":17},"name":"panic_fmt","qualname":"::panicking::panic_fmt","value":"fn (fmt: fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u32)) -> !","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"cold","span":{"file_name":"src/libcore/panicking.rs","byte_start":1153335,"byte_end":1153342,"line_start":65,"line_end":65,"column_start":1,"column_end":8}},{"value":"inline(never)","span":{"file_name":"src/libcore/panicking.rs","byte_start":1153391,"byte_end":1153404,"line_start":66,"line_end":66,"column_start":49,"column_end":62}}]},{"kind":"Mod","id":{"krate":0,"index":3766},"span":{"file_name":"src/libcore/pin.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"pin","qualname":"::pin","value":"src/libcore/pin.rs","parent":null,"children":[{"krate":0,"index":3768},{"krate":0,"index":3770},{"krate":0,"index":3776},{"krate":0,"index":3784},{"krate":0,"index":41566},{"krate":0,"index":41584},{"krate":0,"index":41580},{"krate":0,"index":41576},{"krate":0,"index":41572},{"krate":0,"index":41568},{"krate":0,"index":3796},{"krate":0,"index":3802},{"krate":0,"index":3814},{"krate":0,"index":3818},{"krate":0,"index":3824},{"krate":0,"index":3830},{"krate":0,"index":3836},{"krate":0,"index":3846},{"krate":0,"index":3852},{"krate":0,"index":3856},{"krate":0,"index":3858},{"krate":0,"index":3862},{"krate":0,"index":3866},{"krate":0,"index":3870},{"krate":0,"index":3872}],"decl_id":null,"docs":" Types that pin data to its location in memory.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1168908,"byte_end":1168953,"line_start":264,"line_end":264,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":41566},"span":{"file_name":"src/libcore/pin.rs","byte_start":1169877,"byte_end":1169880,"line_start":290,"line_end":290,"column_start":12,"column_end":15},"name":"Pin","qualname":"::pin::Pin","value":"Pin {  }","parent":null,"children":[{"krate":0,"index":22201}],"decl_id":null,"docs":" A pinned pointer.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1169731,"byte_end":1169775,"line_start":285,"line_end":285,"column_start":1,"column_end":45}},{"value":"lang = \"pin\"","span":{"file_name":"src/libcore/pin.rs","byte_start":1169776,"byte_end":1169791,"line_start":286,"line_end":286,"column_start":1,"column_end":16}},{"value":"fundamental","span":{"file_name":"src/libcore/pin.rs","byte_start":1169792,"byte_end":1169806,"line_start":287,"line_end":287,"column_start":1,"column_end":15}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/pin.rs","byte_start":1169807,"byte_end":1169827,"line_start":288,"line_end":288,"column_start":1,"column_end":21}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/pin.rs","byte_start":1169866,"byte_end":1169903,"line_start":290,"line_end":292,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":3816},"span":{"file_name":"src/libcore/pin.rs","byte_start":1171343,"byte_end":1171346,"line_start":347,"line_end":347,"column_start":12,"column_end":15},"name":"new","qualname":"<Pin<P>>::new","value":"fn (pointer: P) -> Pin<P>","parent":null,"children":[],"decl_id":null,"docs":" Construct a new `Pin<P>` around a pointer to some data of a type that\n implements [`Unpin`].","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1171265,"byte_end":1171309,"line_start":345,"line_end":345,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1171314,"byte_end":1171331,"line_start":346,"line_end":346,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3820},"span":{"file_name":"src/libcore/pin.rs","byte_start":1174819,"byte_end":1174832,"line_start":421,"line_end":421,"column_start":19,"column_end":32},"name":"new_unchecked","qualname":"<Pin<P>>::new_unchecked","value":"fn (pointer: P) -> Pin<P>","parent":null,"children":[],"decl_id":null,"docs":" Construct a new `Pin<P>` around a reference to some data of a type that\n may or may not implement `Unpin`.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1174734,"byte_end":1174778,"line_start":419,"line_end":419,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1174783,"byte_end":1174800,"line_start":420,"line_end":420,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3822},"span":{"file_name":"src/libcore/pin.rs","byte_start":1175394,"byte_end":1175400,"line_start":434,"line_end":434,"column_start":12,"column_end":18},"name":"as_ref","qualname":"<Pin<P>>::as_ref","value":"fn (self: &Pin<P>) -> Pin<&P::Target>","parent":null,"children":[],"decl_id":null,"docs":" Gets a pinned shared reference from this pinned pointer.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1175316,"byte_end":1175360,"line_start":432,"line_end":432,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1175365,"byte_end":1175382,"line_start":433,"line_end":433,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3826},"span":{"file_name":"src/libcore/pin.rs","byte_start":1176045,"byte_end":1176051,"line_start":449,"line_end":449,"column_start":12,"column_end":18},"name":"as_mut","qualname":"<Pin<P>>::as_mut","value":"fn (self: &mut Pin<P>) -> Pin<&mut P::Target>","parent":null,"children":[],"decl_id":null,"docs":" Gets a pinned mutable reference from this pinned pointer.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1175967,"byte_end":1176011,"line_start":447,"line_end":447,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1176016,"byte_end":1176033,"line_start":448,"line_end":448,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3828},"span":{"file_name":"src/libcore/pin.rs","byte_start":1176472,"byte_end":1176475,"line_start":459,"line_end":459,"column_start":12,"column_end":15},"name":"set","qualname":"<Pin<P>>::set","value":"fn (self: &mut Pin<P>, value: P::Target) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Assigns a new value to the memory behind the pinned reference.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1176394,"byte_end":1176438,"line_start":457,"line_end":457,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1176443,"byte_end":1176460,"line_start":458,"line_end":458,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3832},"span":{"file_name":"src/libcore/pin.rs","byte_start":1177508,"byte_end":1177521,"line_start":484,"line_end":484,"column_start":19,"column_end":32},"name":"map_unchecked","qualname":"<Pin<&'a T>>::map_unchecked","value":"fn <U, F> (self: Pin<&'a T>, func: F) -> Pin<&'a U>","parent":null,"children":[],"decl_id":null,"docs":" Constructs a new pin by mapping the interior value.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1177445,"byte_end":1177489,"line_start":483,"line_end":483,"column_start":5,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":3834},"span":{"file_name":"src/libcore/pin.rs","byte_start":1178861,"byte_end":1178868,"line_start":511,"line_end":511,"column_start":12,"column_end":19},"name":"get_ref","qualname":"<Pin<&'a T>>::get_ref","value":"fn (self: Pin<&'a T>) -> &'a T","parent":null,"children":[],"decl_id":null,"docs":" Gets a shared reference out of a pin.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1178783,"byte_end":1178827,"line_start":509,"line_end":509,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1178832,"byte_end":1178849,"line_start":510,"line_end":510,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3838},"span":{"file_name":"src/libcore/pin.rs","byte_start":1179124,"byte_end":1179132,"line_start":520,"line_end":520,"column_start":12,"column_end":20},"name":"into_ref","qualname":"<Pin<&'a mut T>>::into_ref","value":"fn (self: Pin<&'a mut T>) -> Pin<&'a T>","parent":null,"children":[],"decl_id":null,"docs":" Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1179046,"byte_end":1179090,"line_start":518,"line_end":518,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1179095,"byte_end":1179112,"line_start":519,"line_end":519,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3840},"span":{"file_name":"src/libcore/pin.rs","byte_start":1179819,"byte_end":1179826,"line_start":535,"line_end":535,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<Pin<&'a mut T>>::get_mut","value":"fn (self: Pin<&'a mut T>) -> &'a mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable reference to the data inside of this `Pin`.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1179741,"byte_end":1179785,"line_start":533,"line_end":533,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1179790,"byte_end":1179807,"line_start":534,"line_end":534,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3842},"span":{"file_name":"src/libcore/pin.rs","byte_start":1180435,"byte_end":1180452,"line_start":553,"line_end":553,"column_start":19,"column_end":36},"name":"get_unchecked_mut","qualname":"<Pin<&'a mut T>>::get_unchecked_mut","value":"fn (self: Pin<&'a mut T>) -> &'a mut T","parent":null,"children":[],"decl_id":null,"docs":" Gets a mutable reference to the data inside of this `Pin`.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1180350,"byte_end":1180394,"line_start":551,"line_end":551,"column_start":5,"column_end":49}},{"value":"inline(always)","span":{"file_name":"src/libcore/pin.rs","byte_start":1180399,"byte_end":1180416,"line_start":552,"line_end":552,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":3844},"span":{"file_name":"src/libcore/pin.rs","byte_start":1181395,"byte_end":1181412,"line_start":573,"line_end":573,"column_start":19,"column_end":36},"name":"map_unchecked_mut","qualname":"<Pin<&'a mut T>>::map_unchecked_mut","value":"fn <U, F> (self: Pin<&'a mut T>, func: F) -> Pin<&'a mut U>","parent":null,"children":[],"decl_id":null,"docs":" Construct a new pin by mapping the interior value.","sig":null,"attributes":[{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/pin.rs","byte_start":1181332,"byte_end":1181376,"line_start":572,"line_end":572,"column_start":5,"column_end":49}}]},{"kind":"Mod","id":{"krate":0,"index":3874},"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"iter","qualname":"::iter","value":"src/libcore/iter/mod.rs","parent":null,"children":[{"krate":0,"index":3876},{"krate":0,"index":3878},{"krate":0,"index":3880},{"krate":0,"index":3882},{"krate":0,"index":3888},{"krate":0,"index":3894},{"krate":0,"index":3900},{"krate":0,"index":3906},{"krate":0,"index":3912},{"krate":0,"index":3918},{"krate":0,"index":3924},{"krate":0,"index":3934},{"krate":0,"index":3942},{"krate":0,"index":3944},{"krate":0,"index":3946},{"krate":0,"index":3964},{"krate":0,"index":3980},{"krate":0,"index":3986},{"krate":0,"index":3988},{"krate":0,"index":3990},{"krate":0,"index":3992},{"krate":0,"index":3994},{"krate":0,"index":3996},{"krate":0,"index":4112},{"krate":0,"index":4266},{"krate":0,"index":4620},{"krate":0,"index":42480},{"krate":0,"index":42482},{"krate":0,"index":5484},{"krate":0,"index":5496},{"krate":0,"index":5500}],"decl_id":null,"docs":" Composable external iteration.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1193385,"byte_end":1193431,"line_start":307,"line_end":307,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":4020},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197223,"byte_end":1197227,"line_start":15,"line_end":15,"column_start":11,"column_end":15},"name":"Step","qualname":"::iter::range::Step","value":"Step: Clone + PartialOrd + Sized","parent":null,"children":[{"krate":0,"index":4022},{"krate":0,"index":4024},{"krate":0,"index":4026},{"krate":0,"index":4028},{"krate":0,"index":4030},{"krate":0,"index":4032}],"decl_id":null,"docs":" Objects that can be stepped over in both directions.","sig":null,"attributes":[{"value":"unstable(feature = \"step_trait\",\n           reason = \"likely to be replaced by finer-grained traits\",\n           issue = \"42168\")","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197080,"byte_end":1197212,"line_start":12,"line_end":14,"column_start":1,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":4022},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197501,"byte_end":1197514,"line_start":21,"line_end":21,"column_start":8,"column_end":21},"name":"steps_between","qualname":"::iter::range::Step::steps_between","value":"fn (start: &Self, end: &Self) -> Option<usize>","parent":{"krate":0,"index":4020},"children":[],"decl_id":null,"docs":" Returns the number of steps between two step objects. The count is\n inclusive of `start` and exclusive of `end`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4024},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197622,"byte_end":1197633,"line_start":24,"line_end":24,"column_start":8,"column_end":19},"name":"replace_one","qualname":"::iter::range::Step::replace_one","value":"fn (&mut self) -> Self","parent":{"krate":0,"index":4020},"children":[],"decl_id":null,"docs":" Replaces this step with `1`, returning itself.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4026},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197717,"byte_end":1197729,"line_start":27,"line_end":27,"column_start":8,"column_end":20},"name":"replace_zero","qualname":"::iter::range::Step::replace_zero","value":"fn (&mut self) -> Self","parent":{"krate":0,"index":4020},"children":[],"decl_id":null,"docs":" Replaces this step with `0`, returning itself.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4028},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197811,"byte_end":1197818,"line_start":30,"line_end":30,"column_start":8,"column_end":15},"name":"add_one","qualname":"::iter::range::Step::add_one","value":"fn (&self) -> Self","parent":{"krate":0,"index":4020},"children":[],"decl_id":null,"docs":" Adds one to this step, returning the result.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4030},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197901,"byte_end":1197908,"line_start":33,"line_end":33,"column_start":8,"column_end":15},"name":"sub_one","qualname":"::iter::range::Step::sub_one","value":"fn (&self) -> Self","parent":{"krate":0,"index":4020},"children":[],"decl_id":null,"docs":" Subtracts one to this step, returning the result.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4032},"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197987,"byte_end":1197996,"line_start":36,"line_end":36,"column_start":8,"column_end":17},"name":"add_usize","qualname":"::iter::range::Step::add_usize","value":"fn (&self, n: usize) -> Option<Self>","parent":{"krate":0,"index":4020},"children":[],"decl_id":null,"docs":" Adds a `usize`, returning `None` on overflow.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":41826},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1209652,"byte_end":1209658,"line_start":14,"line_end":14,"column_start":12,"column_end":18},"name":"Repeat","qualname":"::iter::sources::Repeat","value":"Repeat {  }","parent":null,"children":[{"krate":0,"index":22217}],"decl_id":null,"docs":" An iterator that repeats an element endlessly.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1209595,"byte_end":1209640,"line_start":13,"line_end":13,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":4142},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1211840,"byte_end":1211846,"line_start":93,"line_end":93,"column_start":8,"column_end":14},"name":"repeat","qualname":"::iter::sources::repeat","value":"fn <T> (elt: T) -> Repeat<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new iterator that endlessly repeats a single element.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1211777,"byte_end":1211786,"line_start":91,"line_end":91,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1211787,"byte_end":1211832,"line_start":92,"line_end":92,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":41836},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212274,"byte_end":1212284,"line_start":106,"line_end":106,"column_start":12,"column_end":22},"name":"RepeatWith","qualname":"::iter::sources::RepeatWith","value":"RepeatWith {  }","parent":null,"children":[{"krate":0,"index":22225}],"decl_id":null,"docs":" An iterator that repeats elements of type `A` endlessly by\n applying the provided closure `F: FnMut() -> A`.","sig":null,"attributes":[{"value":"stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212201,"byte_end":1212262,"line_start":105,"line_end":105,"column_start":1,"column_end":62}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212263,"byte_end":1212307,"line_start":106,"line_end":108,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":4156},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1214866,"byte_end":1214877,"line_start":189,"line_end":189,"column_start":8,"column_end":19},"name":"repeat_with","qualname":"::iter::sources::repeat_with","value":"fn <A, F> (repeater: F) -> RepeatWith<F>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new iterator that repeats elements of type `A` endlessly by\n applying the provided closure, the repeater, `F: FnMut() -> A`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1214787,"byte_end":1214796,"line_start":187,"line_end":187,"column_start":1,"column_end":10}},{"value":"stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1214797,"byte_end":1214858,"line_start":188,"line_end":188,"column_start":1,"column_end":62}}]},{"kind":"Struct","id":{"krate":0,"index":4158},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215185,"byte_end":1215190,"line_start":199,"line_end":199,"column_start":12,"column_end":17},"name":"Empty","qualname":"::iter::sources::Empty","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator that yields nothing.","sig":null,"attributes":[{"value":"stable(feature = \"iter_empty\", since = \"1.2.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215123,"byte_end":1215173,"line_start":198,"line_end":198,"column_start":1,"column_end":51}}]},{"kind":"Function","id":{"krate":0,"index":4192},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216955,"byte_end":1216960,"line_start":274,"line_end":274,"column_start":14,"column_end":19},"name":"empty","qualname":"::iter::sources::empty","value":"fn <T> () -> Empty<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator that yields nothing.","sig":null,"attributes":[{"value":"stable(feature = \"iter_empty\", since = \"1.2.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216891,"byte_end":1216941,"line_start":273,"line_end":273,"column_start":1,"column_end":51}}]},{"kind":"Struct","id":{"krate":0,"index":41848},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1217274,"byte_end":1217278,"line_start":285,"line_end":285,"column_start":12,"column_end":16},"name":"Once","qualname":"::iter::sources::Once","value":"Once {  }","parent":null,"children":[{"krate":0,"index":22235}],"decl_id":null,"docs":" An iterator that yields an element exactly once.","sig":null,"attributes":[{"value":"stable(feature = \"iter_once\", since = \"1.2.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1217213,"byte_end":1217262,"line_start":284,"line_end":284,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":4214},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1219645,"byte_end":1219649,"line_start":374,"line_end":374,"column_start":8,"column_end":12},"name":"once","qualname":"::iter::sources::once","value":"fn <T> (value: T) -> Once<T>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator that yields an element exactly once.","sig":null,"attributes":[{"value":"stable(feature = \"iter_once\", since = \"1.2.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1219588,"byte_end":1219637,"line_start":373,"line_end":373,"column_start":1,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":41858},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220076,"byte_end":1220084,"line_start":387,"line_end":387,"column_start":12,"column_end":20},"name":"OnceWith","qualname":"::iter::sources::OnceWith","value":"OnceWith {  }","parent":null,"children":[{"krate":0,"index":22243}],"decl_id":null,"docs":" An iterator that yields a single element of type `A` by\n applying the provided closure `F: FnOnce() -> A`.","sig":null,"attributes":[{"value":"unstable(feature = \"iter_once_with\", issue = \"57581\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220008,"byte_end":1220064,"line_start":386,"line_end":386,"column_start":1,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220065,"byte_end":1220111,"line_start":387,"line_end":389,"column_start":1,"column_end":2}}]},{"kind":"Function","id":{"krate":0,"index":4236},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1222883,"byte_end":1222892,"line_start":487,"line_end":487,"column_start":8,"column_end":17},"name":"once_with","qualname":"::iter::sources::once_with","value":"fn <A, F> (gen: F) -> OnceWith<F>","parent":null,"children":[],"decl_id":null,"docs":" Creates an iterator that lazily generates a value exactly once by invoking\n the provided closure.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1222809,"byte_end":1222818,"line_start":485,"line_end":485,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"iter_once_with\", issue = \"57581\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1222819,"byte_end":1222875,"line_start":486,"line_end":486,"column_start":1,"column_end":57}}]},{"kind":"Function","id":{"krate":0,"index":4238},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1224447,"byte_end":1224454,"line_start":531,"line_end":531,"column_start":8,"column_end":15},"name":"from_fn","qualname":"::iter::sources::from_fn","value":"fn <T, F> (f: F) -> FromFn<F>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new iterator where each iteration calls the provided closure\n `F: FnMut() -> Option<T>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1224376,"byte_end":1224385,"line_start":529,"line_end":529,"column_start":1,"column_end":10}},{"value":"stable(feature = \"iter_from_fn\", since = \"1.34.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1224386,"byte_end":1224439,"line_start":530,"line_end":530,"column_start":1,"column_end":54}}]},{"kind":"Struct","id":{"krate":0,"index":41870},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1224853,"byte_end":1224859,"line_start":545,"line_end":545,"column_start":12,"column_end":18},"name":"FromFn","qualname":"::iter::sources::FromFn","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.","sig":null,"attributes":[{"value":"stable(feature = \"iter_from_fn\", since = \"1.34.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1224788,"byte_end":1224841,"line_start":544,"line_end":544,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":4250},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1225824,"byte_end":1225834,"line_start":578,"line_end":578,"column_start":8,"column_end":18},"name":"successors","qualname":"::iter::sources::successors","value":"fn <T, F> (first: Option<T>, succ: F) -> Successors<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new iterator where each successive item is computed based on the preceding one.","sig":null,"attributes":[{"value":"stable(feature = \"iter_successors\", since = \"1.34.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1225760,"byte_end":1225816,"line_start":577,"line_end":577,"column_start":1,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":41876},"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1226528,"byte_end":1226538,"line_start":598,"line_end":598,"column_start":12,"column_end":22},"name":"Successors","qualname":"::iter::sources::Successors","value":"Successors {  }","parent":null,"children":[{"krate":0,"index":22263},{"krate":0,"index":22265}],"decl_id":null,"docs":" An new iterator where each successive item is computed based on the preceding one.","sig":null,"attributes":[{"value":"stable(feature = \"iter_successors\", since = \"1.34.0\")","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1226460,"byte_end":1226516,"line_start":597,"line_end":597,"column_start":1,"column_end":57}}]},{"kind":"Trait","id":{"krate":0,"index":4334},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1232066,"byte_end":1232074,"line_start":91,"line_end":91,"column_start":11,"column_end":19},"name":"Iterator","qualname":"::iter::traits::iterator::Iterator","value":"Iterator","parent":null,"children":[{"krate":0,"index":4336},{"krate":0,"index":4338},{"krate":0,"index":4340},{"krate":0,"index":4342},{"krate":0,"index":4344},{"krate":0,"index":4346},{"krate":0,"index":4348},{"krate":0,"index":4350},{"krate":0,"index":4352},{"krate":0,"index":4354},{"krate":0,"index":4356},{"krate":0,"index":4358},{"krate":0,"index":4360},{"krate":0,"index":4362},{"krate":0,"index":4364},{"krate":0,"index":4366},{"krate":0,"index":4368},{"krate":0,"index":4370},{"krate":0,"index":4372},{"krate":0,"index":4374},{"krate":0,"index":4376},{"krate":0,"index":4378},{"krate":0,"index":4380},{"krate":0,"index":4382},{"krate":0,"index":4384},{"krate":0,"index":4386},{"krate":0,"index":4388},{"krate":0,"index":4390},{"krate":0,"index":4392},{"krate":0,"index":4394},{"krate":0,"index":4396},{"krate":0,"index":4398},{"krate":0,"index":4400},{"krate":0,"index":4402},{"krate":0,"index":4404},{"krate":0,"index":4406},{"krate":0,"index":4408},{"krate":0,"index":4410},{"krate":0,"index":4412},{"krate":0,"index":4414},{"krate":0,"index":4416},{"krate":0,"index":4418},{"krate":0,"index":4420},{"krate":0,"index":4422},{"krate":0,"index":4424},{"krate":0,"index":4426},{"krate":0,"index":4428},{"krate":0,"index":4430},{"krate":0,"index":4432},{"krate":0,"index":4434},{"krate":0,"index":4436},{"krate":0,"index":4438},{"krate":0,"index":4440},{"krate":0,"index":4442},{"krate":0,"index":4444},{"krate":0,"index":4446},{"krate":0,"index":4448},{"krate":0,"index":4450},{"krate":0,"index":4452},{"krate":0,"index":4454}],"decl_id":null,"docs":" An interface for dealing with iterators.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1228748,"byte_end":1228793,"line_start":20,"line_end":20,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(on(_Self = \"[std::ops::Range<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate between two values, remove the square brackets\",\n                            note =\n                                \"`[start..end]` is an array of one `Range`; you might have meant to have a `Range` without the brackets: `start..end`\"),\n                         on(_Self = \"[std::ops::RangeFrom<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate from a value onwards, remove the square brackets\",\n                            note =\n                                \"`[start..]` is an array of one `RangeFrom`; you might have meant to have a `RangeFrom` without the brackets: `start..`, keeping in mind that iterating over an unbounded iterator will run forever unless you `break` or `return` from within the loop\"),\n                         on(_Self = \"[std::ops::RangeTo<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate until a value, remove the square brackets and add a starting value\",\n                            note =\n                                \"`[..end]` is an array of one `RangeTo`; you might have meant to have a bounded `Range` without the brackets: `0..end`\"),\n                         on(_Self = \"[std::ops::RangeInclusive<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate between two values, remove the square brackets\",\n                            note =\n                                \"`[start..=end]` is an array of one `RangeInclusive`; you might have meant to have a `RangeInclusive` without the brackets: `start..=end`\"),\n                         on(_Self = \"[std::ops::RangeToInclusive<Idx>; 1]\",\n                            label =\n                                \"if you meant to iterate until a value (including it), remove the square brackets and add a starting value\",\n                            note =\n                                \"`[..=end]` is an array of one `RangeToInclusive`; you might have meant to have a bounded `RangeInclusive` without the brackets: `0..=end`\"),\n                         on(_Self = \"std::ops::RangeTo<Idx>\",\n                            label =\n                                \"if you meant to iterate until a value, add a starting value\",\n                            note =\n                                \"`..end` is a `RangeTo`, which cannot be iterated on; you might have meant to have a bounded `Range`: `0..end`\"),\n                         on(_Self = \"std::ops::RangeToInclusive<Idx>\",\n                            label =\n                                \"if you meant to iterate until a value (including it), add a starting value\",\n                            note =\n                                \"`..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant to have a bounded `RangeInclusive`: `0..=end`\"),\n                         on(_Self = \"&str\",\n                            label =\n                                \"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"),\n                         on(_Self = \"std::string::String\",\n                            label =\n                                \"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"),\n                         on(_Self = \"[]\",\n                            label =\n                                \"borrow the array with `&` or call `.iter()` on it to iterate over it\",\n                            note =\n                                \"arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\"),\n                         on(_Self = \"{integral}\",\n                            note =\n                                \"if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\"),\n                         label = \"`{Self}` is not an iterator\",\n                         message = \"`{Self}` is not an iterator\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1228794,"byte_end":1231971,"line_start":21,"line_end":88,"column_start":1,"column_end":3}},{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1231990,"byte_end":1232055,"line_start":90,"line_end":90,"column_start":1,"column_end":66}}]},{"kind":"Type","id":{"krate":0,"index":4336},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1232190,"byte_end":1232194,"line_start":94,"line_end":94,"column_start":10,"column_end":14},"name":"Item","qualname":"::iter::traits::iterator::Iterator::Item","value":"type Item;","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" The type of the elements being iterated over.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1232135,"byte_end":1232180,"line_start":93,"line_end":93,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4338},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1233318,"byte_end":1233322,"line_start":128,"line_end":128,"column_start":8,"column_end":12},"name":"next","qualname":"::iter::traits::iterator::Iterator::next","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Advances the iterator and returns the next value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1233265,"byte_end":1233310,"line_start":127,"line_end":127,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4340},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1236000,"byte_end":1236009,"line_start":200,"line_end":200,"column_start":8,"column_end":17},"name":"size_hint","qualname":"::iter::traits::iterator::Iterator::size_hint","value":"fn (&self) -> (usize, Option<usize>)","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Returns the bounds on the remaining length of the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1235933,"byte_end":1235942,"line_start":198,"line_end":198,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1235947,"byte_end":1235992,"line_start":199,"line_end":199,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4342},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1237283,"byte_end":1237288,"line_start":239,"line_end":239,"column_start":8,"column_end":13},"name":"count","qualname":"::iter::traits::iterator::Iterator::count","value":"fn (self) -> usize","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Consumes the iterator, counting the number of iterations and returning it.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1237179,"byte_end":1237188,"line_start":236,"line_end":236,"column_start":5,"column_end":14}},{"value":"rustc_inherit_overflow_checks","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1237193,"byte_end":1237225,"line_start":237,"line_end":237,"column_start":5,"column_end":37}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1237230,"byte_end":1237275,"line_start":238,"line_end":238,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4344},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1238082,"byte_end":1238086,"line_start":265,"line_end":265,"column_start":8,"column_end":12},"name":"last","qualname":"::iter::traits::iterator::Iterator::last","value":"fn (self) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Consumes the iterator, returning the last element.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1238015,"byte_end":1238024,"line_start":263,"line_end":263,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1238029,"byte_end":1238074,"line_start":264,"line_end":264,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4346},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1239594,"byte_end":1239597,"line_start":314,"line_end":314,"column_start":8,"column_end":11},"name":"nth","qualname":"::iter::traits::iterator::Iterator::nth","value":"fn (&mut self, mut n: usize) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Returns the `n`th element of the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1239527,"byte_end":1239536,"line_start":312,"line_end":312,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1239541,"byte_end":1239586,"line_start":313,"line_end":313,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4348},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1241371,"byte_end":1241378,"line_start":368,"line_end":368,"column_start":8,"column_end":15},"name":"step_by","qualname":"::iter::traits::iterator::Iterator::step_by","value":"fn (self, step: usize) -> StepBy<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator starting at the same point, but stepping by\n the given amount at each iteration.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1241292,"byte_end":1241301,"line_start":366,"line_end":366,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_step_by\", since = \"1.28.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1241306,"byte_end":1241363,"line_start":367,"line_end":367,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":4350},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1243230,"byte_end":1243235,"line_start":423,"line_end":423,"column_start":8,"column_end":13},"name":"chain","qualname":"::iter::traits::iterator::Iterator::chain","value":"fn <U> (self, other: U) -> Chain<Self, U::IntoIter>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Takes two iterators and creates a new iterator over both in sequence.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1243163,"byte_end":1243172,"line_start":421,"line_end":421,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1243177,"byte_end":1243222,"line_start":422,"line_end":422,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4352},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1246117,"byte_end":1246120,"line_start":501,"line_end":501,"column_start":8,"column_end":11},"name":"zip","qualname":"::iter::traits::iterator::Iterator::zip","value":"fn <U> (self, other: U) -> Zip<Self, U::IntoIter>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" 'Zips up' two iterators into a single iterator of pairs.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1246050,"byte_end":1246059,"line_start":499,"line_end":499,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1246064,"byte_end":1246109,"line_start":500,"line_end":500,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4354},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1248187,"byte_end":1248190,"line_start":558,"line_end":558,"column_start":8,"column_end":11},"name":"map","qualname":"::iter::traits::iterator::Iterator::map","value":"fn <B, F> (self, f: F) -> Map<Self, F>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Takes a closure and creates an iterator which calls that closure on each\n element.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1248120,"byte_end":1248129,"line_start":556,"line_end":556,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1248134,"byte_end":1248179,"line_start":557,"line_end":557,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4356},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1249742,"byte_end":1249750,"line_start":601,"line_end":601,"column_start":8,"column_end":16},"name":"for_each","qualname":"::iter::traits::iterator::Iterator::for_each","value":"fn <F> (self, mut f: F) -> ()","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Calls a closure on each element of an iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1249662,"byte_end":1249671,"line_start":599,"line_end":599,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_for_each\", since = \"1.21.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1249676,"byte_end":1249734,"line_start":600,"line_end":600,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":4358},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1251807,"byte_end":1251813,"line_start":669,"line_end":669,"column_start":8,"column_end":14},"name":"filter","qualname":"::iter::traits::iterator::Iterator::filter","value":"fn <P> (self, predicate: P) -> Filter<Self, P>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator which uses a closure to determine if an element\n should be yielded.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1251740,"byte_end":1251749,"line_start":667,"line_end":667,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1251754,"byte_end":1251799,"line_start":668,"line_end":668,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4360},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1253962,"byte_end":1253972,"line_start":726,"line_end":726,"column_start":8,"column_end":18},"name":"filter_map","qualname":"::iter::traits::iterator::Iterator::filter_map","value":"fn <B, F> (self, f: F) -> FilterMap<Self, F>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator that both filters and maps.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1253895,"byte_end":1253904,"line_start":724,"line_end":724,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1253909,"byte_end":1253954,"line_start":725,"line_end":725,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4362},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1255538,"byte_end":1255547,"line_start":772,"line_end":772,"column_start":8,"column_end":17},"name":"enumerate","qualname":"::iter::traits::iterator::Iterator::enumerate","value":"fn (self) -> Enumerate<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator which gives the current iteration count as well as\n the next value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1255471,"byte_end":1255480,"line_start":770,"line_end":770,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1255485,"byte_end":1255530,"line_start":771,"line_end":771,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4364},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1257113,"byte_end":1257121,"line_start":818,"line_end":818,"column_start":8,"column_end":16},"name":"peekable","qualname":"::iter::traits::iterator::Iterator::peekable","value":"fn (self) -> Peekable<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator which can use `peek` to look at the next element of\n the iterator without consuming it.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1257046,"byte_end":1257055,"line_start":816,"line_end":816,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1257060,"byte_end":1257105,"line_start":817,"line_end":817,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4366},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1259037,"byte_end":1259047,"line_start":879,"line_end":879,"column_start":8,"column_end":18},"name":"skip_while","qualname":"::iter::traits::iterator::Iterator::skip_while","value":"fn <P> (self, predicate: P) -> SkipWhile<Self, P>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator that [`skip`]s elements based on a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1258970,"byte_end":1258979,"line_start":877,"line_end":877,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1258984,"byte_end":1259029,"line_start":878,"line_end":878,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4368},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1261636,"byte_end":1261646,"line_start":958,"line_end":958,"column_start":8,"column_end":18},"name":"take_while","qualname":"::iter::traits::iterator::Iterator::take_while","value":"fn <P> (self, predicate: P) -> TakeWhile<Self, P>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator that yields elements based on a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1261569,"byte_end":1261578,"line_start":956,"line_end":956,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1261583,"byte_end":1261628,"line_start":957,"line_end":957,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4370},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1262276,"byte_end":1262280,"line_start":982,"line_end":982,"column_start":8,"column_end":12},"name":"skip","qualname":"::iter::traits::iterator::Iterator::skip","value":"fn (self, n: usize) -> Skip<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator that skips the first `n` elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1262209,"byte_end":1262218,"line_start":980,"line_end":980,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1262223,"byte_end":1262268,"line_start":981,"line_end":981,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4372},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1263125,"byte_end":1263129,"line_start":1014,"line_end":1014,"column_start":8,"column_end":12},"name":"take","qualname":"::iter::traits::iterator::Iterator::take","value":"fn (self, n: usize) -> Take<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator that yields its first `n` elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1263058,"byte_end":1263067,"line_start":1012,"line_end":1012,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1263072,"byte_end":1263117,"line_start":1013,"line_end":1013,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4374},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1264583,"byte_end":1264587,"line_start":1057,"line_end":1057,"column_start":8,"column_end":12},"name":"scan","qualname":"::iter::traits::iterator::Iterator::scan","value":"fn <St, B, F> (self, initial_state: St, f: F) -> Scan<Self, St, F>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" An iterator adaptor similar to [`fold`] that holds internal state and\n produces a new iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1264516,"byte_end":1264525,"line_start":1055,"line_end":1055,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1264530,"byte_end":1264575,"line_start":1056,"line_end":1056,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4376},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1265976,"byte_end":1265984,"line_start":1095,"line_end":1095,"column_start":8,"column_end":16},"name":"flat_map","qualname":"::iter::traits::iterator::Iterator::flat_map","value":"fn <U, F> (self, f: F) -> FlatMap<Self, U, F>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator that works like map, but flattens nested structure.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1265909,"byte_end":1265918,"line_start":1093,"line_end":1093,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1265923,"byte_end":1265968,"line_start":1094,"line_end":1094,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4378},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1268424,"byte_end":1268431,"line_start":1164,"line_end":1164,"column_start":8,"column_end":15},"name":"flatten","qualname":"::iter::traits::iterator::Iterator::flatten","value":"fn (self) -> Flatten<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator that flattens nested structure.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1268345,"byte_end":1268354,"line_start":1162,"line_end":1162,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_flatten\", since = \"1.29.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1268359,"byte_end":1268416,"line_start":1163,"line_end":1163,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":4380},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1270330,"byte_end":1270334,"line_start":1225,"line_end":1225,"column_start":8,"column_end":12},"name":"fuse","qualname":"::iter::traits::iterator::Iterator::fuse","value":"fn (self) -> Fuse<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator which ends after the first [`None`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1270263,"byte_end":1270272,"line_start":1223,"line_end":1223,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1270277,"byte_end":1270322,"line_start":1224,"line_end":1224,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4382},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1272644,"byte_end":1272651,"line_start":1306,"line_end":1306,"column_start":8,"column_end":15},"name":"inspect","qualname":"::iter::traits::iterator::Iterator::inspect","value":"fn <F> (self, f: F) -> Inspect<Self, F>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Do something with each element of an iterator, passing the value on.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1272577,"byte_end":1272586,"line_start":1304,"line_end":1304,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1272591,"byte_end":1272636,"line_start":1305,"line_end":1305,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4384},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1273862,"byte_end":1273868,"line_start":1349,"line_end":1349,"column_start":8,"column_end":14},"name":"by_ref","qualname":"::iter::traits::iterator::Iterator::by_ref","value":"fn (&mut self) -> &mut Self","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Borrows an iterator, rather than consuming it.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1273809,"byte_end":1273854,"line_start":1348,"line_end":1348,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4386},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1277911,"byte_end":1277918,"line_start":1464,"line_end":1464,"column_start":8,"column_end":15},"name":"collect","qualname":"::iter::traits::iterator::Iterator::collect","value":"fn <B> (self) -> B","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Transforms an iterator into a collection.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1277745,"byte_end":1277754,"line_start":1461,"line_end":1461,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1277759,"byte_end":1277804,"line_start":1462,"line_end":1462,"column_start":5,"column_end":50}},{"value":"must_use =\n      \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1277809,"byte_end":1277903,"line_start":1463,"line_end":1463,"column_start":5,"column_end":99}}]},{"kind":"Method","id":{"krate":0,"index":4388},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1278700,"byte_end":1278709,"line_start":1489,"line_end":1489,"column_start":8,"column_end":17},"name":"partition","qualname":"::iter::traits::iterator::Iterator::partition","value":"fn <B, F> (self, mut f: F) -> (B, B)","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Consumes an iterator, creating two collections from it.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1278647,"byte_end":1278692,"line_start":1488,"line_end":1488,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4390},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1281631,"byte_end":1281639,"line_start":1567,"line_end":1567,"column_start":8,"column_end":16},"name":"try_fold","qualname":"::iter::traits::iterator::Iterator::try_fold","value":"fn <B, F, R> (&mut self, init: B, mut f: F) -> R","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" An iterator method that applies a function as long as it returns\n successfully, producing a single, final value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1281551,"byte_end":1281560,"line_start":1565,"line_end":1565,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_try_fold\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1281565,"byte_end":1281623,"line_start":1566,"line_end":1566,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":4392},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1283037,"byte_end":1283049,"line_start":1606,"line_end":1606,"column_start":8,"column_end":20},"name":"try_for_each","qualname":"::iter::traits::iterator::Iterator::try_for_each","value":"fn <F, R> (&mut self, mut f: F) -> R","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" An iterator method that applies a fallible function to each item in the\n iterator, stopping at the first error and returning that error.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1282957,"byte_end":1282966,"line_start":1604,"line_end":1604,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_try_fold\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1282971,"byte_end":1283029,"line_start":1605,"line_end":1605,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":4394},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1285517,"byte_end":1285521,"line_start":1681,"line_end":1681,"column_start":8,"column_end":12},"name":"fold","qualname":"::iter::traits::iterator::Iterator::fold","value":"fn <B, F> (mut self, init: B, mut f: F) -> B","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" An iterator method that applies a function, producing a single, final value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1285450,"byte_end":1285459,"line_start":1679,"line_end":1679,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1285464,"byte_end":1285509,"line_start":1680,"line_end":1680,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4396},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1286886,"byte_end":1286889,"line_start":1726,"line_end":1726,"column_start":8,"column_end":11},"name":"all","qualname":"::iter::traits::iterator::Iterator::all","value":"fn <F> (&mut self, mut f: F) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Tests if every element of the iterator matches a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1286819,"byte_end":1286828,"line_start":1724,"line_end":1724,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1286833,"byte_end":1286878,"line_start":1725,"line_end":1725,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4398},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1288331,"byte_end":1288334,"line_start":1774,"line_end":1774,"column_start":8,"column_end":11},"name":"any","qualname":"::iter::traits::iterator::Iterator::any","value":"fn <F> (&mut self, mut f: F) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Tests if any element of the iterator matches a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1288264,"byte_end":1288273,"line_start":1772,"line_end":1772,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1288278,"byte_end":1288323,"line_start":1773,"line_end":1773,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4400},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290145,"byte_end":1290149,"line_start":1828,"line_end":1828,"column_start":8,"column_end":12},"name":"find","qualname":"::iter::traits::iterator::Iterator::find","value":"fn <P> (&mut self, mut predicate: P) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Searches for an element of an iterator that satisfies a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290078,"byte_end":1290087,"line_start":1826,"line_end":1826,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290092,"byte_end":1290137,"line_start":1827,"line_end":1827,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4402},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290942,"byte_end":1290950,"line_start":1855,"line_end":1855,"column_start":8,"column_end":16},"name":"find_map","qualname":"::iter::traits::iterator::Iterator::find_map","value":"fn <B, F> (&mut self, mut f: F) -> Option<B>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Applies function to the elements of iterator and returns\n the first non-none result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290862,"byte_end":1290871,"line_start":1853,"line_end":1853,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_find_map\", since = \"1.30.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1290876,"byte_end":1290934,"line_start":1854,"line_end":1854,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":4404},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1293207,"byte_end":1293215,"line_start":1924,"line_end":1924,"column_start":8,"column_end":16},"name":"position","qualname":"::iter::traits::iterator::Iterator::position","value":"fn <P> (&mut self, mut predicate: P) -> Option<usize>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Searches for an element in an iterator, returning its index.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1293103,"byte_end":1293112,"line_start":1921,"line_end":1921,"column_start":5,"column_end":14}},{"value":"rustc_inherit_overflow_checks","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1293117,"byte_end":1293149,"line_start":1922,"line_end":1922,"column_start":5,"column_end":37}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1293154,"byte_end":1293199,"line_start":1923,"line_end":1923,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4406},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1294884,"byte_end":1294893,"line_start":1975,"line_end":1975,"column_start":8,"column_end":17},"name":"rposition","qualname":"::iter::traits::iterator::Iterator::rposition","value":"fn <P> (&mut self, mut predicate: P) -> Option<usize>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Searches for an element in an iterator from the right, returning its\n index.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1294817,"byte_end":1294826,"line_start":1973,"line_end":1973,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1294831,"byte_end":1294876,"line_start":1974,"line_end":1974,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4408},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1296009,"byte_end":1296012,"line_start":2009,"line_end":2009,"column_start":8,"column_end":11},"name":"max","qualname":"::iter::traits::iterator::Iterator::max","value":"fn (self) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Returns the maximum element of an iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1295942,"byte_end":1295951,"line_start":2007,"line_end":2007,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1295956,"byte_end":1296001,"line_start":2008,"line_end":2008,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4410},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1296708,"byte_end":1296711,"line_start":2034,"line_end":2034,"column_start":8,"column_end":11},"name":"min","qualname":"::iter::traits::iterator::Iterator::min","value":"fn (self) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Returns the minimum element of an iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1296641,"byte_end":1296650,"line_start":2032,"line_end":2032,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1296655,"byte_end":1296700,"line_start":2033,"line_end":2033,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4412},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1297377,"byte_end":1297387,"line_start":2055,"line_end":2055,"column_start":8,"column_end":18},"name":"max_by_key","qualname":"::iter::traits::iterator::Iterator::max_by_key","value":"fn <B, F> (self, mut f: F) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Returns the element that gives the maximum value from the\n specified function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1297300,"byte_end":1297309,"line_start":2053,"line_end":2053,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1297314,"byte_end":1297369,"line_start":2054,"line_end":2054,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":4414},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1298249,"byte_end":1298255,"line_start":2078,"line_end":2078,"column_start":8,"column_end":14},"name":"max_by","qualname":"::iter::traits::iterator::Iterator::max_by","value":"fn <F> (self, mut compare: F) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Returns the element that gives the maximum value with respect to the\n specified comparison function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1298175,"byte_end":1298184,"line_start":2076,"line_end":2076,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_max_by\", since = \"1.15.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1298189,"byte_end":1298241,"line_start":2077,"line_end":2077,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":4416},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1299077,"byte_end":1299087,"line_start":2100,"line_end":2100,"column_start":8,"column_end":18},"name":"min_by_key","qualname":"::iter::traits::iterator::Iterator::min_by_key","value":"fn <B, F> (self, mut f: F) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Returns the element that gives the minimum value from the\n specified function.","sig":null,"attributes":[{"value":"stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1299014,"byte_end":1299069,"line_start":2099,"line_end":2099,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":4418},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1299957,"byte_end":1299963,"line_start":2123,"line_end":2123,"column_start":8,"column_end":14},"name":"min_by","qualname":"::iter::traits::iterator::Iterator::min_by","value":"fn <F> (self, mut compare: F) -> Option<Self::Item>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Returns the element that gives the minimum value with respect to the\n specified comparison function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1299883,"byte_end":1299892,"line_start":2121,"line_end":2121,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_min_by\", since = \"1.15.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1299897,"byte_end":1299949,"line_start":2122,"line_end":2122,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":4420},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1301020,"byte_end":1301023,"line_start":2156,"line_end":2156,"column_start":8,"column_end":11},"name":"rev","qualname":"::iter::traits::iterator::Iterator::rev","value":"fn (self) -> Rev<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Reverses an iterator's direction.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1300953,"byte_end":1300962,"line_start":2154,"line_end":2154,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1300967,"byte_end":1301012,"line_start":2155,"line_end":2155,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4422},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1301809,"byte_end":1301814,"line_start":2183,"line_end":2183,"column_start":8,"column_end":13},"name":"unzip","qualname":"::iter::traits::iterator::Iterator::unzip","value":"fn <A, B, FromA, FromB> (self) -> (FromA, FromB)","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Converts an iterator of pairs into a pair of containers.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1301756,"byte_end":1301801,"line_start":2182,"line_end":2182,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4424},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1302890,"byte_end":1302896,"line_start":2222,"line_end":2222,"column_start":8,"column_end":14},"name":"copied","qualname":"::iter::traits::iterator::Iterator::copied","value":"fn <'a, T> (self) -> Copied<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator which copies all of its elements.","sig":null,"attributes":[{"value":"unstable(feature = \"iter_copied\", issue = \"57127\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1302829,"byte_end":1302882,"line_start":2221,"line_end":2221,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":4426},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1303742,"byte_end":1303748,"line_start":2251,"line_end":2251,"column_start":8,"column_end":14},"name":"cloned","qualname":"::iter::traits::iterator::Iterator::cloned","value":"fn <'a, T> (self) -> Cloned<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Creates an iterator which [`clone`]s all of its elements.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1303689,"byte_end":1303734,"line_start":2250,"line_end":2250,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4428},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1304736,"byte_end":1304741,"line_start":2284,"line_end":2284,"column_start":8,"column_end":13},"name":"cycle","qualname":"::iter::traits::iterator::Iterator::cycle","value":"fn (self) -> Cycle<Self>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Repeats an iterator endlessly.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1304669,"byte_end":1304714,"line_start":2282,"line_end":2282,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1304719,"byte_end":1304728,"line_start":2283,"line_end":2283,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":4430},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1305480,"byte_end":1305483,"line_start":2311,"line_end":2311,"column_start":8,"column_end":11},"name":"sum","qualname":"::iter::traits::iterator::Iterator::sum","value":"fn <S> (self) -> S","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Sums the elements of an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith\", since = \"1.11.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1305421,"byte_end":1305472,"line_start":2310,"line_end":2310,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":4432},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1306260,"byte_end":1306267,"line_start":2339,"line_end":2339,"column_start":8,"column_end":15},"name":"product","qualname":"::iter::traits::iterator::Iterator::product","value":"fn <P> (self) -> P","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Iterates over the entire iterator, multiplying all the elements","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith\", since = \"1.11.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1306201,"byte_end":1306252,"line_start":2338,"line_end":2338,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":4434},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1306551,"byte_end":1306554,"line_start":2349,"line_end":2349,"column_start":8,"column_end":11},"name":"cmp","qualname":"::iter::traits::iterator::Iterator::cmp","value":"fn <I> (mut self, other: I) -> Ordering","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Lexicographically compares the elements of this `Iterator` with those\n of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1306493,"byte_end":1306543,"line_start":2348,"line_end":2348,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":4436},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1307464,"byte_end":1307475,"line_start":2381,"line_end":2381,"column_start":8,"column_end":19},"name":"partial_cmp","qualname":"::iter::traits::iterator::Iterator::partial_cmp","value":"fn <I> (mut self, other: I) -> Option<Ordering>","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Lexicographically compares the elements of this `Iterator` with those\n of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1307406,"byte_end":1307456,"line_start":2380,"line_end":2380,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":4438},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1308417,"byte_end":1308419,"line_start":2413,"line_end":2413,"column_start":8,"column_end":10},"name":"eq","qualname":"::iter::traits::iterator::Iterator::eq","value":"fn <I> (mut self, other: I) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are equal to those of\n another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1308359,"byte_end":1308409,"line_start":2412,"line_end":2412,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":4440},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309095,"byte_end":1309097,"line_start":2438,"line_end":2438,"column_start":8,"column_end":10},"name":"ne","qualname":"::iter::traits::iterator::Iterator::ne","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are unequal to those of\n another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309037,"byte_end":1309087,"line_start":2437,"line_end":2437,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":4442},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309428,"byte_end":1309430,"line_start":2449,"line_end":2449,"column_start":8,"column_end":10},"name":"lt","qualname":"::iter::traits::iterator::Iterator::lt","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are lexicographically\n less than those of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309370,"byte_end":1309420,"line_start":2448,"line_end":2448,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":4444},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309801,"byte_end":1309803,"line_start":2460,"line_end":2460,"column_start":8,"column_end":10},"name":"le","qualname":"::iter::traits::iterator::Iterator::le","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are lexicographically\n less or equal to those of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1309743,"byte_end":1309793,"line_start":2459,"line_end":2459,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":4446},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1310254,"byte_end":1310256,"line_start":2474,"line_end":2474,"column_start":8,"column_end":10},"name":"gt","qualname":"::iter::traits::iterator::Iterator::gt","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are lexicographically\n greater than those of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1310196,"byte_end":1310246,"line_start":2473,"line_end":2473,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":4448},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1310638,"byte_end":1310640,"line_start":2485,"line_end":2485,"column_start":8,"column_end":10},"name":"ge","qualname":"::iter::traits::iterator::Iterator::ge","value":"fn <I> (self, other: I) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Determines if the elements of this `Iterator` are lexicographically\n greater than or equal to those of another.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_order\", since = \"1.5.0\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1310580,"byte_end":1310630,"line_start":2484,"line_end":2484,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":4450},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1311819,"byte_end":1311828,"line_start":2518,"line_end":2518,"column_start":8,"column_end":17},"name":"is_sorted","qualname":"::iter::traits::iterator::Iterator::is_sorted","value":"fn (self) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Checks if the elements of this iterator are sorted.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1311726,"byte_end":1311735,"line_start":2516,"line_end":2516,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1311740,"byte_end":1311811,"line_start":2517,"line_end":2517,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":4452},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1312479,"byte_end":1312491,"line_start":2534,"line_end":2534,"column_start":8,"column_end":20},"name":"is_sorted_by","qualname":"::iter::traits::iterator::Iterator::is_sorted_by","value":"fn <F> (mut self, mut compare: F) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Checks if the elements of this iterator are sorted using the given comparator function.","sig":null,"attributes":[{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1312400,"byte_end":1312471,"line_start":2533,"line_end":2533,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":4454},"span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1313793,"byte_end":1313809,"line_start":2576,"line_end":2576,"column_start":8,"column_end":24},"name":"is_sorted_by_key","qualname":"::iter::traits::iterator::Iterator::is_sorted_by_key","value":"fn <F, K> (self, mut f: F) -> bool","parent":{"krate":0,"index":4334},"children":[],"decl_id":null,"docs":" Checks if the elements of this iterator are sorted using the given key extraction\n function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1313700,"byte_end":1313709,"line_start":2574,"line_end":2574,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/iter/traits/iterator.rs","byte_start":1313714,"byte_end":1313785,"line_start":2575,"line_end":2575,"column_start":5,"column_end":76}}]},{"kind":"Trait","id":{"krate":0,"index":4474},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1316336,"byte_end":1316355,"line_start":39,"line_end":39,"column_start":11,"column_end":30},"name":"DoubleEndedIterator","qualname":"::iter::traits::double_ended::DoubleEndedIterator","value":"DoubleEndedIterator: Iterator","parent":null,"children":[{"krate":0,"index":4476},{"krate":0,"index":4478},{"krate":0,"index":4480},{"krate":0,"index":4482},{"krate":0,"index":4484}],"decl_id":null,"docs":" An iterator able to yield elements from both ends.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1316280,"byte_end":1316325,"line_start":38,"line_end":38,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":4476},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1317221,"byte_end":1317230,"line_start":67,"line_end":67,"column_start":8,"column_end":17},"name":"next_back","qualname":"::iter::traits::double_ended::DoubleEndedIterator::next_back","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":4474},"children":[],"decl_id":null,"docs":" Removes and returns an element from the end of the iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1317168,"byte_end":1317213,"line_start":66,"line_end":66,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4478},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1318912,"byte_end":1318920,"line_start":117,"line_end":117,"column_start":8,"column_end":16},"name":"nth_back","qualname":"::iter::traits::double_ended::DoubleEndedIterator::nth_back","value":"fn (&mut self, mut n: usize) -> Option<Self::Item>","parent":{"krate":0,"index":4474},"children":[],"decl_id":null,"docs":" Returns the `n`th element from the end of the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1318835,"byte_end":1318844,"line_start":115,"line_end":115,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"iter_nth_back\", issue = \"56995\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1318849,"byte_end":1318904,"line_start":116,"line_end":116,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":4480},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1320132,"byte_end":1320141,"line_start":159,"line_end":159,"column_start":8,"column_end":17},"name":"try_rfold","qualname":"::iter::traits::double_ended::DoubleEndedIterator::try_rfold","value":"fn <B, F, R> (&mut self, init: B, mut f: F) -> R","parent":{"krate":0,"index":4474},"children":[],"decl_id":null,"docs":" This is the reverse version of [`try_fold()`]: it takes elements\n starting from the back of the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1320052,"byte_end":1320061,"line_start":157,"line_end":157,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iterator_try_fold\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1320066,"byte_end":1320124,"line_start":158,"line_end":158,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":4482},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1322221,"byte_end":1322226,"line_start":225,"line_end":225,"column_start":8,"column_end":13},"name":"rfold","qualname":"::iter::traits::double_ended::DoubleEndedIterator::rfold","value":"fn <B, F> (mut self, accum: B, mut f: F) -> B","parent":{"krate":0,"index":4474},"children":[],"decl_id":null,"docs":" An iterator method that reduces the iterator's elements to a single,\n final value, starting from the back.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1322148,"byte_end":1322157,"line_start":223,"line_end":223,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_rfold\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1322162,"byte_end":1322213,"line_start":224,"line_end":224,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":4484},"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1324018,"byte_end":1324023,"line_start":277,"line_end":277,"column_start":8,"column_end":13},"name":"rfind","qualname":"::iter::traits::double_ended::DoubleEndedIterator::rfind","value":"fn <P> (&mut self, mut predicate: P) -> Option<Self::Item>","parent":{"krate":0,"index":4474},"children":[],"decl_id":null,"docs":" Searches for an element of an iterator from the back that satisfies a predicate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1323945,"byte_end":1323954,"line_start":275,"line_end":275,"column_start":5,"column_end":14}},{"value":"stable(feature = \"iter_rfind\", since = \"1.27.0\")","span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1323959,"byte_end":1324010,"line_start":276,"line_end":276,"column_start":5,"column_end":56}}]},{"kind":"Trait","id":{"krate":0,"index":4494},"span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1326712,"byte_end":1326729,"line_start":71,"line_end":71,"column_start":11,"column_end":28},"name":"ExactSizeIterator","qualname":"::iter::traits::exact_size::ExactSizeIterator","value":"ExactSizeIterator: Iterator","parent":null,"children":[{"krate":0,"index":4496},{"krate":0,"index":4498}],"decl_id":null,"docs":" An iterator that knows its exact length.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1326656,"byte_end":1326701,"line_start":70,"line_end":70,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":4496},"span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1327579,"byte_end":1327582,"line_start":97,"line_end":97,"column_start":8,"column_end":11},"name":"len","qualname":"::iter::traits::exact_size::ExactSizeIterator::len","value":"fn (&self) -> usize","parent":{"krate":0,"index":4494},"children":[],"decl_id":null,"docs":" Returns the exact number of times the iterator will iterate.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1327512,"byte_end":1327521,"line_start":95,"line_end":95,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1327526,"byte_end":1327571,"line_start":96,"line_end":96,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4498},"span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1328613,"byte_end":1328621,"line_start":129,"line_end":129,"column_start":8,"column_end":16},"name":"is_empty","qualname":"::iter::traits::exact_size::ExactSizeIterator::is_empty","value":"fn (&self) -> bool","parent":{"krate":0,"index":4494},"children":[],"decl_id":null,"docs":" Returns `true` if the iterator is empty.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1328530,"byte_end":1328539,"line_start":127,"line_end":127,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"exact_size_is_empty\", issue = \"35428\")","span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1328544,"byte_end":1328605,"line_start":128,"line_end":128,"column_start":5,"column_end":66}}]},{"kind":"Trait","id":{"krate":0,"index":4508},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1331490,"byte_end":1331502,"line_start":98,"line_end":98,"column_start":11,"column_end":23},"name":"FromIterator","qualname":"::iter::traits::collect::FromIterator","value":"FromIterator<A>: Sized","parent":null,"children":[{"krate":0,"index":4510}],"decl_id":null,"docs":" Conversion from an `Iterator`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1331188,"byte_end":1331233,"line_start":92,"line_end":92,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(message =\n                             \"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\",\n                         label =\n                             \"a collection of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1331234,"byte_end":1331479,"line_start":93,"line_end":97,"column_start":1,"column_end":3}}]},{"kind":"Method","id":{"krate":0,"index":4510},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1332026,"byte_end":1332035,"line_start":119,"line_end":119,"column_start":8,"column_end":17},"name":"from_iter","qualname":"::iter::traits::collect::FromIterator::from_iter","value":"fn <T> (iter: T) -> Self","parent":{"krate":0,"index":4508},"children":[],"decl_id":null,"docs":" Creates a value from an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1331973,"byte_end":1332018,"line_start":118,"line_end":118,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":4512},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1334402,"byte_end":1334414,"line_start":208,"line_end":208,"column_start":11,"column_end":23},"name":"IntoIterator","qualname":"::iter::traits::collect::IntoIterator","value":"IntoIterator","parent":null,"children":[{"krate":0,"index":4514},{"krate":0,"index":4516},{"krate":0,"index":4518}],"decl_id":null,"docs":" Conversion into an `Iterator`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1334346,"byte_end":1334391,"line_start":207,"line_end":207,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":4514},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1334530,"byte_end":1334534,"line_start":211,"line_end":211,"column_start":10,"column_end":14},"name":"Item","qualname":"::iter::traits::collect::IntoIterator::Item","value":"type Item;","parent":{"krate":0,"index":4512},"children":[],"decl_id":null,"docs":" The type of the elements being iterated over.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1334475,"byte_end":1334520,"line_start":210,"line_end":210,"column_start":5,"column_end":50}}]},{"kind":"Type","id":{"krate":0,"index":4516},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1334653,"byte_end":1334661,"line_start":215,"line_end":215,"column_start":10,"column_end":18},"name":"IntoIter","qualname":"::iter::traits::collect::IntoIterator::IntoIter","value":"type IntoIter: Iterator<Item=Self::Item>;","parent":{"krate":0,"index":4512},"children":[],"decl_id":null,"docs":" Which kind of iterator are we turning this into?\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1334598,"byte_end":1334643,"line_start":214,"line_end":214,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":4518},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1335240,"byte_end":1335249,"line_start":237,"line_end":237,"column_start":8,"column_end":17},"name":"into_iter","qualname":"::iter::traits::collect::IntoIterator::into_iter","value":"fn (self) -> Self::IntoIter","parent":{"krate":0,"index":4512},"children":[],"decl_id":null,"docs":" Creates an iterator from a value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1335187,"byte_end":1335232,"line_start":236,"line_end":236,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":4528},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1337672,"byte_end":1337678,"line_start":320,"line_end":320,"column_start":11,"column_end":17},"name":"Extend","qualname":"::iter::traits::collect::Extend","value":"Extend<A>","parent":null,"children":[{"krate":0,"index":4530}],"decl_id":null,"docs":" Extend a collection with the contents of an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1337616,"byte_end":1337661,"line_start":319,"line_end":319,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":4530},"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1338256,"byte_end":1338262,"line_start":341,"line_end":341,"column_start":8,"column_end":14},"name":"extend","qualname":"::iter::traits::collect::Extend::extend","value":"fn <T> (&mut self, iter: T) -> ()","parent":{"krate":0,"index":4528},"children":[],"decl_id":null,"docs":" Extends a collection with the contents of an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1338203,"byte_end":1338248,"line_start":340,"line_end":340,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":4546},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1339175,"byte_end":1339178,"line_start":15,"line_end":15,"column_start":11,"column_end":14},"name":"Sum","qualname":"::iter::traits::accum::Sum","value":"Sum<A = Self>: Sized","parent":null,"children":[{"krate":0,"index":4548}],"decl_id":null,"docs":" Trait to represent types that can be created by summing up an iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith_traits\", since = \"1.12.0\")","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1339106,"byte_end":1339164,"line_start":14,"line_end":14,"column_start":1,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":4548},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1339381,"byte_end":1339384,"line_start":19,"line_end":19,"column_start":8,"column_end":11},"name":"sum","qualname":"::iter::traits::accum::Sum::sum","value":"fn <I> (iter: I) -> Self","parent":{"krate":0,"index":4546},"children":[],"decl_id":null,"docs":" Method which takes an iterator and generates `Self` from the elements by\n \"summing up\" the items.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith_traits\", since = \"1.12.0\")","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1339315,"byte_end":1339373,"line_start":18,"line_end":18,"column_start":5,"column_end":63}}]},{"kind":"Trait","id":{"krate":0,"index":4550},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1340089,"byte_end":1340096,"line_start":34,"line_end":34,"column_start":11,"column_end":18},"name":"Product","qualname":"::iter::traits::accum::Product","value":"Product<A = Self>: Sized","parent":null,"children":[{"krate":0,"index":4552}],"decl_id":null,"docs":" Trait to represent types that can be created by multiplying elements of an\n iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith_traits\", since = \"1.12.0\")","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1340020,"byte_end":1340078,"line_start":33,"line_end":33,"column_start":1,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":4552},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1340298,"byte_end":1340305,"line_start":38,"line_end":38,"column_start":8,"column_end":15},"name":"product","qualname":"::iter::traits::accum::Product::product","value":"fn <I> (iter: I) -> Self","parent":{"krate":0,"index":4550},"children":[],"decl_id":null,"docs":" Method which takes an iterator and generates `Self` from the elements by\n multiplying the items.\n","sig":null,"attributes":[{"value":"stable(feature = \"iter_arith_traits\", since = \"1.12.0\")","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1340232,"byte_end":1340290,"line_start":37,"line_end":37,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":4562},"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1343297,"byte_end":1343304,"line_start":133,"line_end":133,"column_start":12,"column_end":19},"name":"process","qualname":"<ResultShunt<I, E>>::process","value":"fn <F, U> (iter: I, mut f: F) -> Result<U, E>","parent":null,"children":[],"decl_id":null,"docs":" Process the given iterator as if it yielded a `T` instead of a\n `Result<T, _>`. Any errors will stop the inner iterator and\n the overall result will be an error.\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":4586},"span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1346778,"byte_end":1346791,"line_start":16,"line_end":16,"column_start":11,"column_end":24},"name":"FusedIterator","qualname":"::iter::traits::marker::FusedIterator","value":"FusedIterator: Iterator","parent":null,"children":[],"decl_id":null,"docs":" An iterator that always continues to yield `None` when exhausted.","sig":null,"attributes":[{"value":"stable(feature = \"fused\", since = \"1.26.0\")","span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1346721,"byte_end":1346767,"line_start":15,"line_end":15,"column_start":1,"column_end":47}}]},{"kind":"Trait","id":{"krate":0,"index":4590},"span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1347882,"byte_end":1347892,"line_start":41,"line_end":41,"column_start":18,"column_end":28},"name":"TrustedLen","qualname":"::iter::traits::marker::TrustedLen","value":"TrustedLen: Iterator","parent":null,"children":[],"decl_id":null,"docs":" An iterator that reports an accurate length using size_hint.","sig":null,"attributes":[{"value":"unstable(feature = \"trusted_len\", issue = \"37572\")","span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1347811,"byte_end":1347864,"line_start":40,"line_end":40,"column_start":1,"column_end":54}}]},{"kind":"Struct","id":{"krate":0,"index":42298},"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1406709,"byte_end":1406714,"line_start":16,"line_end":16,"column_start":12,"column_end":17},"name":"Chain","qualname":"::iter::adapters::chain::Chain","value":"Chain {  }","parent":null,"children":[{"krate":0,"index":22603},{"krate":0,"index":22605},{"krate":0,"index":22607}],"decl_id":null,"docs":" An iterator that strings two iterators together.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1406586,"byte_end":1406651,"line_start":14,"line_end":14,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1406652,"byte_end":1406697,"line_start":15,"line_end":15,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":4714},"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1414341,"byte_end":1414348,"line_start":17,"line_end":17,"column_start":12,"column_end":19},"name":"FlatMap","qualname":"::iter::adapters::flatten::FlatMap","value":"FlatMap {  }","parent":null,"children":[{"krate":0,"index":2245}],"decl_id":null,"docs":" An iterator that maps each element to an iterator, and yields the elements\n of the produced iterators.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1414218,"byte_end":1414283,"line_start":15,"line_end":15,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1414284,"byte_end":1414329,"line_start":16,"line_end":16,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":4750},"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1417278,"byte_end":1417285,"line_start":107,"line_end":107,"column_start":12,"column_end":19},"name":"Flatten","qualname":"::iter::adapters::flatten::Flatten","value":"Flatten {  }","parent":null,"children":[{"krate":0,"index":2305}],"decl_id":null,"docs":" An iterator that flattens one level of nesting in an iterator of things\n that can be turned into iterators.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1417143,"byte_end":1417208,"line_start":105,"line_end":105,"column_start":1,"column_end":66}},{"value":"stable(feature = \"iterator_flatten\", since = \"1.29.0\")","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1417209,"byte_end":1417266,"line_start":106,"line_end":106,"column_start":1,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":42328},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1424899,"byte_end":1424902,"line_start":15,"line_end":15,"column_start":12,"column_end":15},"name":"Zip","qualname":"::iter::adapters::zip::Zip","value":"Zip {  }","parent":null,"children":[{"krate":0,"index":22651},{"krate":0,"index":22653},{"krate":0,"index":22655},{"krate":0,"index":22657}],"decl_id":null,"docs":" An iterator that iterates two other iterators simultaneously.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1424776,"byte_end":1424841,"line_start":13,"line_end":13,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1424842,"byte_end":1424887,"line_start":14,"line_end":14,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":4848},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1426235,"byte_end":1426239,"line_start":70,"line_end":70,"column_start":10,"column_end":14},"name":"Item","qualname":"::iter::adapters::zip::ZipImpl::Item","value":"type Item;","parent":{"krate":0,"index":4846},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4850},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1426248,"byte_end":1426251,"line_start":71,"line_end":71,"column_start":8,"column_end":11},"name":"new","qualname":"::iter::adapters::zip::ZipImpl::new","value":"fn (a: A, b: B) -> Self","parent":{"krate":0,"index":4846},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4852},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1426280,"byte_end":1426284,"line_start":72,"line_end":72,"column_start":8,"column_end":12},"name":"next","qualname":"::iter::adapters::zip::ZipImpl::next","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":4846},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4854},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1426326,"byte_end":1426335,"line_start":73,"line_end":73,"column_start":8,"column_end":17},"name":"size_hint","qualname":"::iter::adapters::zip::ZipImpl::size_hint","value":"fn (&self) -> (usize, Option<usize>)","parent":{"krate":0,"index":4846},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4856},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1426377,"byte_end":1426380,"line_start":74,"line_end":74,"column_start":8,"column_end":11},"name":"nth","qualname":"::iter::adapters::zip::ZipImpl::nth","value":"fn (&mut self, n: usize) -> Option<Self::Item>","parent":{"krate":0,"index":4846},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4858},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1426432,"byte_end":1426441,"line_start":75,"line_end":75,"column_start":8,"column_end":17},"name":"next_back","qualname":"::iter::adapters::zip::ZipImpl::next_back","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":4846},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4900},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1432219,"byte_end":1432232,"line_start":279,"line_end":279,"column_start":15,"column_end":28},"name":"get_unchecked","qualname":"::iter::adapters::zip::TrustedRandomAccess::get_unchecked","value":"fn (&mut self, i: usize) -> Self::Item","parent":{"krate":0,"index":4898},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4902},"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1432408,"byte_end":1432428,"line_start":282,"line_end":282,"column_start":8,"column_end":28},"name":"may_have_side_effect","qualname":"::iter::adapters::zip::TrustedRandomAccess::may_have_side_effect","value":"fn () -> bool","parent":{"krate":0,"index":4898},"children":[],"decl_id":null,"docs":" Returns `true` if getting an iterator element may have\n side effects. Remember to take inner iterators into account.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":42338},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348853,"byte_end":1348856,"line_start":30,"line_end":30,"column_start":12,"column_end":15},"name":"Rev","qualname":"::iter::adapters::Rev","value":"Rev {  }","parent":null,"children":[{"krate":0,"index":22669}],"decl_id":null,"docs":" A double-ended iterator with the direction inverted.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348730,"byte_end":1348795,"line_start":28,"line_end":28,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348796,"byte_end":1348841,"line_start":29,"line_end":29,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42348},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351828,"byte_end":1351834,"line_start":136,"line_end":136,"column_start":12,"column_end":18},"name":"Copied","qualname":"::iter::adapters::Copied","value":"Copied {  }","parent":null,"children":[{"krate":0,"index":22677}],"decl_id":null,"docs":" An iterator that copies the elements of an underlying iterator.","sig":null,"attributes":[{"value":"unstable(feature = \"iter_copied\", issue = \"57127\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351673,"byte_end":1351726,"line_start":133,"line_end":133,"column_start":1,"column_end":54}},{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351727,"byte_end":1351792,"line_start":134,"line_end":134,"column_start":1,"column_end":66}}]},{"kind":"Struct","id":{"krate":0,"index":42358},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354644,"byte_end":1354650,"line_start":241,"line_end":241,"column_start":12,"column_end":18},"name":"Cloned","qualname":"::iter::adapters::Cloned","value":"Cloned {  }","parent":null,"children":[{"krate":0,"index":22685}],"decl_id":null,"docs":" An iterator that clones the elements of an underlying iterator.","sig":null,"attributes":[{"value":"stable(feature = \"iter_cloned\", since = \"1.1.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354491,"byte_end":1354542,"line_start":238,"line_end":238,"column_start":1,"column_end":52}},{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354543,"byte_end":1354608,"line_start":239,"line_end":239,"column_start":1,"column_end":66}}]},{"kind":"Struct","id":{"krate":0,"index":42368},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357768,"byte_end":1357773,"line_start":358,"line_end":358,"column_start":12,"column_end":17},"name":"Cycle","qualname":"::iter::adapters::Cycle","value":"Cycle {  }","parent":null,"children":[{"krate":0,"index":22693},{"krate":0,"index":22695}],"decl_id":null,"docs":" An iterator that repeats endlessly.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357645,"byte_end":1357710,"line_start":356,"line_end":356,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357711,"byte_end":1357756,"line_start":357,"line_end":357,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42378},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1359110,"byte_end":1359116,"line_start":404,"line_end":404,"column_start":12,"column_end":18},"name":"StepBy","qualname":"::iter::adapters::StepBy","value":"StepBy {  }","parent":null,"children":[{"krate":0,"index":22703},{"krate":0,"index":22705},{"krate":0,"index":22707}],"decl_id":null,"docs":" An iterator for stepping iterators by a custom amount.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1358951,"byte_end":1359016,"line_start":401,"line_end":401,"column_start":1,"column_end":66}},{"value":"stable(feature = \"iterator_step_by\", since = \"1.28.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1359017,"byte_end":1359074,"line_start":402,"line_end":402,"column_start":1,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":42388},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1363545,"byte_end":1363548,"line_start":544,"line_end":544,"column_start":12,"column_end":15},"name":"Map","qualname":"::iter::adapters::Map","value":"Map {  }","parent":null,"children":[{"krate":0,"index":22717},{"krate":0,"index":22719}],"decl_id":null,"docs":" An iterator that maps the values of `iter` with `f`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1363405,"byte_end":1363470,"line_start":541,"line_end":541,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1363471,"byte_end":1363516,"line_start":542,"line_end":542,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42394},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1366788,"byte_end":1366794,"line_start":660,"line_end":660,"column_start":12,"column_end":18},"name":"Filter","qualname":"::iter::adapters::Filter","value":"Filter {  }","parent":null,"children":[{"krate":0,"index":22729},{"krate":0,"index":22731}],"decl_id":null,"docs":" An iterator that filters the elements of `iter` with `predicate`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1366648,"byte_end":1366713,"line_start":657,"line_end":657,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1366714,"byte_end":1366759,"line_start":658,"line_end":658,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42400},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1370798,"byte_end":1370807,"line_start":784,"line_end":784,"column_start":12,"column_end":21},"name":"FilterMap","qualname":"::iter::adapters::FilterMap","value":"FilterMap {  }","parent":null,"children":[{"krate":0,"index":22741},{"krate":0,"index":22743}],"decl_id":null,"docs":" An iterator that uses `f` to both filter and map elements from `iter`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1370658,"byte_end":1370723,"line_start":781,"line_end":781,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1370724,"byte_end":1370769,"line_start":782,"line_end":782,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42406},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1373902,"byte_end":1373911,"line_start":889,"line_end":889,"column_start":12,"column_end":21},"name":"Enumerate","qualname":"::iter::adapters::Enumerate","value":"Enumerate {  }","parent":null,"children":[{"krate":0,"index":22751},{"krate":0,"index":22753}],"decl_id":null,"docs":" An iterator that yields the current count and the element during iteration.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1373779,"byte_end":1373844,"line_start":887,"line_end":887,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1373845,"byte_end":1373890,"line_start":888,"line_end":888,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42416},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1379122,"byte_end":1379130,"line_start":1065,"line_end":1065,"column_start":12,"column_end":20},"name":"Peekable","qualname":"::iter::adapters::Peekable","value":"Peekable {  }","parent":null,"children":[{"krate":0,"index":22761},{"krate":0,"index":22763}],"decl_id":null,"docs":" An iterator with a `peek()` that returns an optional reference to the next\n element.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378999,"byte_end":1379064,"line_start":1063,"line_end":1063,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1379065,"byte_end":1379110,"line_start":1064,"line_end":1064,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":5256},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383401,"byte_end":1383405,"line_start":1206,"line_end":1206,"column_start":12,"column_end":16},"name":"peek","qualname":"<Peekable<I>>::peek","value":"fn (&mut self) -> Option<&I::Item>","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to the next() value without advancing the iterator.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383330,"byte_end":1383339,"line_start":1204,"line_end":1204,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383344,"byte_end":1383389,"line_start":1205,"line_end":1205,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":42426},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383974,"byte_end":1383983,"line_start":1222,"line_end":1222,"column_start":12,"column_end":21},"name":"SkipWhile","qualname":"::iter::adapters::SkipWhile","value":"SkipWhile {  }","parent":null,"children":[{"krate":0,"index":22773},{"krate":0,"index":22775},{"krate":0,"index":22777}],"decl_id":null,"docs":" An iterator that rejects elements while `predicate` returns `true`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383834,"byte_end":1383899,"line_start":1219,"line_end":1219,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1383900,"byte_end":1383945,"line_start":1220,"line_end":1220,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42432},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386531,"byte_end":1386540,"line_start":1310,"line_end":1310,"column_start":12,"column_end":21},"name":"TakeWhile","qualname":"::iter::adapters::TakeWhile","value":"TakeWhile {  }","parent":null,"children":[{"krate":0,"index":22787},{"krate":0,"index":22789},{"krate":0,"index":22791}],"decl_id":null,"docs":" An iterator that only accepts elements while `predicate` returns `true`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386391,"byte_end":1386456,"line_start":1307,"line_end":1307,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386457,"byte_end":1386502,"line_start":1308,"line_end":1308,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42438},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1389057,"byte_end":1389061,"line_start":1398,"line_end":1398,"column_start":12,"column_end":16},"name":"Skip","qualname":"::iter::adapters::Skip","value":"Skip {  }","parent":null,"children":[{"krate":0,"index":22799},{"krate":0,"index":22801}],"decl_id":null,"docs":" An iterator that skips over `n` elements of `iter`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388934,"byte_end":1388999,"line_start":1396,"line_end":1396,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1389000,"byte_end":1389045,"line_start":1397,"line_end":1397,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42448},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392948,"byte_end":1392952,"line_start":1541,"line_end":1541,"column_start":12,"column_end":16},"name":"Take","qualname":"::iter::adapters::Take","value":"Take {  }","parent":null,"children":[{"krate":0,"index":22809},{"krate":0,"index":22811}],"decl_id":null,"docs":" An iterator that only iterates over the first `n` iterations of `iter`.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392825,"byte_end":1392890,"line_start":1539,"line_end":1539,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392891,"byte_end":1392936,"line_start":1540,"line_end":1540,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42458},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395421,"byte_end":1395425,"line_start":1634,"line_end":1634,"column_start":12,"column_end":16},"name":"Scan","qualname":"::iter::adapters::Scan","value":"Scan {  }","parent":null,"children":[{"krate":0,"index":22823},{"krate":0,"index":22825},{"krate":0,"index":22827}],"decl_id":null,"docs":" An iterator to maintain state while iterating another iterator.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395281,"byte_end":1395346,"line_start":1631,"line_end":1631,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395347,"byte_end":1395392,"line_start":1632,"line_end":1632,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42464},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397380,"byte_end":1397384,"line_start":1699,"line_end":1699,"column_start":12,"column_end":16},"name":"Fuse","qualname":"::iter::adapters::Fuse","value":"Fuse {  }","parent":null,"children":[{"krate":0,"index":22837},{"krate":0,"index":22839}],"decl_id":null,"docs":" An iterator that yields `None` forever after the underlying iterator\n yields `None` once.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397257,"byte_end":1397322,"line_start":1697,"line_end":1697,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397323,"byte_end":1397368,"line_start":1698,"line_end":1698,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42474},"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403354,"byte_end":1403361,"line_start":1945,"line_end":1945,"column_start":12,"column_end":19},"name":"Inspect","qualname":"::iter::adapters::Inspect","value":"Inspect {  }","parent":null,"children":[{"krate":0,"index":22849},{"krate":0,"index":22851}],"decl_id":null,"docs":" An iterator that calls a function with a reference to each element before\n yielding it.","sig":null,"attributes":[{"value":"must_use = \"iterators are lazy and do nothing unless consumed\"","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403214,"byte_end":1403279,"line_start":1942,"line_end":1942,"column_start":1,"column_end":66}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403280,"byte_end":1403325,"line_start":1943,"line_end":1943,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":5506},"span":{"file_name":"src/libcore/option.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"option","qualname":"::option","value":"src/libcore/option.rs","parent":null,"children":[{"krate":0,"index":5508},{"krate":0,"index":5516},{"krate":0,"index":5528},{"krate":0,"index":42488},{"krate":0,"index":42526},{"krate":0,"index":42524},{"krate":0,"index":42518},{"krate":0,"index":42506},{"krate":0,"index":42502},{"krate":0,"index":42498},{"krate":0,"index":42494},{"krate":0,"index":42490},{"krate":0,"index":5530},{"krate":0,"index":5586},{"krate":0,"index":5590},{"krate":0,"index":5594},{"krate":0,"index":5598},{"krate":0,"index":5602},{"krate":0,"index":5606},{"krate":0,"index":5610},{"krate":0,"index":5614},{"krate":0,"index":5616},{"krate":0,"index":5620},{"krate":0,"index":5628},{"krate":0,"index":5636},{"krate":0,"index":5644},{"krate":0,"index":5648},{"krate":0,"index":5652},{"krate":0,"index":42530},{"krate":0,"index":42536},{"krate":0,"index":42532},{"krate":0,"index":5656},{"krate":0,"index":5664},{"krate":0,"index":5668},{"krate":0,"index":5670},{"krate":0,"index":5672},{"krate":0,"index":42540},{"krate":0,"index":42542},{"krate":0,"index":5674},{"krate":0,"index":5682},{"krate":0,"index":5686},{"krate":0,"index":5688},{"krate":0,"index":5690},{"krate":0,"index":5692},{"krate":0,"index":42546},{"krate":0,"index":42548},{"krate":0,"index":5696},{"krate":0,"index":5704},{"krate":0,"index":5708},{"krate":0,"index":5710},{"krate":0,"index":5712},{"krate":0,"index":42552},{"krate":0,"index":42558},{"krate":0,"index":42554},{"krate":0,"index":5714},{"krate":0,"index":5722},{"krate":0,"index":5726},{"krate":0,"index":5728},{"krate":0,"index":5730},{"krate":0,"index":5732},{"krate":0,"index":42562},{"krate":0,"index":42590},{"krate":0,"index":42588},{"krate":0,"index":42584},{"krate":0,"index":42580},{"krate":0,"index":42576},{"krate":0,"index":42572},{"krate":0,"index":42568},{"krate":0,"index":42564},{"krate":0,"index":5746}],"decl_id":null,"docs":" Optional values.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1436918,"byte_end":1436964,"line_start":136,"line_end":136,"column_start":1,"column_end":47}}]},{"kind":"TupleVariant","id":{"krate":0,"index":22879},"span":{"file_name":"src/libcore/option.rs","byte_start":1437656,"byte_end":1437660,"line_start":153,"line_end":153,"column_start":5,"column_end":9},"name":"None","qualname":"::option::Option::None","value":"Option::None","parent":{"krate":0,"index":42488},"children":[],"decl_id":null,"docs":" No value\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1437606,"byte_end":1437651,"line_start":152,"line_end":152,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":22883},"span":{"file_name":"src/libcore/option.rs","byte_start":1437739,"byte_end":1437743,"line_start":156,"line_end":156,"column_start":5,"column_end":9},"name":"Some","qualname":"::option::Option::Some","value":"Option::Some(T)","parent":{"krate":0,"index":42488},"children":[],"decl_id":null,"docs":" Some value `T`\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1437689,"byte_end":1437734,"line_start":155,"line_end":155,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":42488},"span":{"file_name":"src/libcore/option.rs","byte_start":1437573,"byte_end":1437579,"line_start":150,"line_end":150,"column_start":10,"column_end":16},"name":"Option","qualname":"::option::Option","value":"Option::{None, Some}","parent":null,"children":[{"krate":0,"index":22879},{"krate":0,"index":22883}],"decl_id":null,"docs":" The `Option` type. See [the module level documentation](index.html) for more.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1437518,"byte_end":1437563,"line_start":149,"line_end":149,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/option.rs","byte_start":1437564,"byte_end":1437795,"line_start":150,"line_end":157,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/option.rs","byte_start":1437564,"byte_end":1437795,"line_start":150,"line_end":157,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":5532},"span":{"file_name":"src/libcore/option.rs","byte_start":1438599,"byte_end":1438606,"line_start":184,"line_end":184,"column_start":12,"column_end":19},"name":"is_some","qualname":"<Option<T>>::is_some","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the option is a [`Some`] value.","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/option.rs","byte_start":1438512,"byte_end":1438523,"line_start":181,"line_end":181,"column_start":5,"column_end":16}},{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1438528,"byte_end":1438537,"line_start":182,"line_end":182,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1438542,"byte_end":1438587,"line_start":183,"line_end":183,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5534},"span":{"file_name":"src/libcore/option.rs","byte_start":1439127,"byte_end":1439134,"line_start":207,"line_end":207,"column_start":12,"column_end":19},"name":"is_none","qualname":"<Option<T>>::is_none","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the option is a [`None`] value.","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/option.rs","byte_start":1439040,"byte_end":1439051,"line_start":204,"line_end":204,"column_start":5,"column_end":16}},{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1439056,"byte_end":1439065,"line_start":205,"line_end":205,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1439070,"byte_end":1439115,"line_start":206,"line_end":206,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5536},"span":{"file_name":"src/libcore/option.rs","byte_start":1440390,"byte_end":1440396,"line_start":237,"line_end":237,"column_start":12,"column_end":18},"name":"as_ref","qualname":"<Option<T>>::as_ref","value":"fn (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Option<T>` to `Option<&T>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1440319,"byte_end":1440328,"line_start":235,"line_end":235,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1440333,"byte_end":1440378,"line_start":236,"line_end":236,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5538},"span":{"file_name":"src/libcore/option.rs","byte_start":1440870,"byte_end":1440876,"line_start":258,"line_end":258,"column_start":12,"column_end":18},"name":"as_mut","qualname":"<Option<T>>::as_mut","value":"fn (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&mut Option<T>` to `Option<&mut T>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1440799,"byte_end":1440808,"line_start":256,"line_end":256,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1440813,"byte_end":1440858,"line_start":257,"line_end":257,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5540},"span":{"file_name":"src/libcore/option.rs","byte_start":1441149,"byte_end":1441159,"line_start":269,"line_end":269,"column_start":12,"column_end":22},"name":"as_pin_ref","qualname":"<Option<T>>::as_pin_ref","value":"fn <'a> (self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Pin<&Option<T>>` to `Option<Pin<&T>>`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1441079,"byte_end":1441088,"line_start":267,"line_end":267,"column_start":5,"column_end":14}},{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1441093,"byte_end":1441137,"line_start":268,"line_end":268,"column_start":5,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":5542},"span":{"file_name":"src/libcore/option.rs","byte_start":1441462,"byte_end":1441472,"line_start":278,"line_end":278,"column_start":12,"column_end":22},"name":"as_pin_mut","qualname":"<Option<T>>::as_pin_mut","value":"fn <'a> (self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Pin<&mut Option<T>>` to `Option<Pin<&mut T>>`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1441392,"byte_end":1441401,"line_start":276,"line_end":276,"column_start":5,"column_end":14}},{"value":"stable(feature = \"pin\", since = \"1.33.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1441406,"byte_end":1441450,"line_start":277,"line_end":277,"column_start":5,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":5544},"span":{"file_name":"src/libcore/option.rs","byte_start":1442495,"byte_end":1442501,"line_start":311,"line_end":311,"column_start":12,"column_end":18},"name":"expect","qualname":"<Option<T>>::expect","value":"fn (self, msg: &str) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps an option, yielding the content of a [`Some`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1442424,"byte_end":1442433,"line_start":309,"line_end":309,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1442438,"byte_end":1442483,"line_start":310,"line_end":310,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5546},"span":{"file_name":"src/libcore/option.rs","byte_start":1443380,"byte_end":1443386,"line_start":344,"line_end":344,"column_start":12,"column_end":18},"name":"unwrap","qualname":"<Option<T>>::unwrap","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1443309,"byte_end":1443318,"line_start":342,"line_end":342,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1443323,"byte_end":1443368,"line_start":343,"line_end":343,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5548},"span":{"file_name":"src/libcore/option.rs","byte_start":1444105,"byte_end":1444114,"line_start":367,"line_end":367,"column_start":12,"column_end":21},"name":"unwrap_or","qualname":"<Option<T>>::unwrap_or","value":"fn (self, def: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the contained value or a default.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1444034,"byte_end":1444043,"line_start":365,"line_end":365,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1444048,"byte_end":1444093,"line_start":366,"line_end":366,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5550},"span":{"file_name":"src/libcore/option.rs","byte_start":1444558,"byte_end":1444572,"line_start":385,"line_end":385,"column_start":12,"column_end":26},"name":"unwrap_or_else","qualname":"<Option<T>>::unwrap_or_else","value":"fn <F> (self, f: F) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the contained value or computes it from a closure.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1444487,"byte_end":1444496,"line_start":383,"line_end":383,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1444501,"byte_end":1444546,"line_start":384,"line_end":384,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5552},"span":{"file_name":"src/libcore/option.rs","byte_start":1445601,"byte_end":1445604,"line_start":414,"line_end":414,"column_start":12,"column_end":15},"name":"map","qualname":"<Option<T>>::map","value":"fn <U, F> (self, f: F) -> Option<U>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1445530,"byte_end":1445539,"line_start":412,"line_end":412,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1445544,"byte_end":1445589,"line_start":413,"line_end":413,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5554},"span":{"file_name":"src/libcore/option.rs","byte_start":1446171,"byte_end":1446177,"line_start":435,"line_end":435,"column_start":12,"column_end":18},"name":"map_or","qualname":"<Option<T>>::map_or","value":"fn <U, F> (self, default: U, f: F) -> U","parent":null,"children":[],"decl_id":null,"docs":" Applies a function to the contained value (if any),\n or returns the provided default (if not).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1446100,"byte_end":1446109,"line_start":433,"line_end":433,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1446114,"byte_end":1446159,"line_start":434,"line_end":434,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5556},"span":{"file_name":"src/libcore/option.rs","byte_start":1446785,"byte_end":1446796,"line_start":458,"line_end":458,"column_start":12,"column_end":23},"name":"map_or_else","qualname":"<Option<T>>::map_or_else","value":"fn <U, D, F> (self, default: D, f: F) -> U","parent":null,"children":[],"decl_id":null,"docs":" Applies a function to the contained value (if any),\n or computes a default (if not).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1446714,"byte_end":1446723,"line_start":456,"line_end":456,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1446728,"byte_end":1446773,"line_start":457,"line_end":457,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5558},"span":{"file_name":"src/libcore/option.rs","byte_start":1447898,"byte_end":1447903,"line_start":490,"line_end":490,"column_start":12,"column_end":17},"name":"ok_or","qualname":"<Option<T>>::ok_or","value":"fn <E> (self, err: E) -> Result<T, E>","parent":null,"children":[],"decl_id":null,"docs":" Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n [`Ok(v)`] and [`None`] to [`Err(err)`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1447827,"byte_end":1447836,"line_start":488,"line_end":488,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1447841,"byte_end":1447886,"line_start":489,"line_end":489,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5560},"span":{"file_name":"src/libcore/option.rs","byte_start":1448745,"byte_end":1448755,"line_start":517,"line_end":517,"column_start":12,"column_end":22},"name":"ok_or_else","qualname":"<Option<T>>::ok_or_else","value":"fn <E, F> (self, err: F) -> Result<T, E>","parent":null,"children":[],"decl_id":null,"docs":" Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n [`Ok(v)`] and [`None`] to [`Err(err())`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1448674,"byte_end":1448683,"line_start":515,"line_end":515,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1448688,"byte_end":1448733,"line_start":516,"line_end":516,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5562},"span":{"file_name":"src/libcore/option.rs","byte_start":1449450,"byte_end":1449454,"line_start":541,"line_end":541,"column_start":12,"column_end":16},"name":"iter","qualname":"<Option<T>>::iter","value":"fn (&self) -> Iter<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the possibly contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1449379,"byte_end":1449388,"line_start":539,"line_end":539,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1449393,"byte_end":1449438,"line_start":540,"line_end":540,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5564},"span":{"file_name":"src/libcore/option.rs","byte_start":1450000,"byte_end":1450008,"line_start":562,"line_end":562,"column_start":12,"column_end":20},"name":"iter_mut","qualname":"<Option<T>>::iter_mut","value":"fn (&mut self) -> IterMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable iterator over the possibly contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1449929,"byte_end":1449938,"line_start":560,"line_end":560,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1449943,"byte_end":1449988,"line_start":561,"line_end":561,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5566},"span":{"file_name":"src/libcore/option.rs","byte_start":1450992,"byte_end":1450995,"line_start":595,"line_end":595,"column_start":12,"column_end":15},"name":"and","qualname":"<Option<T>>::and","value":"fn <U> (self, optb: Option<U>) -> Option<U>","parent":null,"children":[],"decl_id":null,"docs":" Returns [`None`] if the option is [`None`], otherwise returns `optb`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1450921,"byte_end":1450930,"line_start":593,"line_end":593,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1450935,"byte_end":1450980,"line_start":594,"line_end":594,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5568},"span":{"file_name":"src/libcore/option.rs","byte_start":1451849,"byte_end":1451857,"line_start":622,"line_end":622,"column_start":12,"column_end":20},"name":"and_then","qualname":"<Option<T>>::and_then","value":"fn <U, F> (self, f: F) -> Option<U>","parent":null,"children":[],"decl_id":null,"docs":" Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n wrapped value and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1451778,"byte_end":1451787,"line_start":620,"line_end":620,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1451792,"byte_end":1451837,"line_start":621,"line_end":621,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5570},"span":{"file_name":"src/libcore/option.rs","byte_start":1452875,"byte_end":1452881,"line_start":653,"line_end":653,"column_start":12,"column_end":18},"name":"filter","qualname":"<Option<T>>::filter","value":"fn <P> (self, predicate: P) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Returns `None` if the option is `None`, otherwise calls `predicate`\n with the wrapped value and returns:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1452795,"byte_end":1452804,"line_start":651,"line_end":651,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_filter\", since = \"1.27.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1452809,"byte_end":1452863,"line_start":652,"line_end":652,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":5572},"span":{"file_name":"src/libcore/option.rs","byte_start":1453904,"byte_end":1453906,"line_start":691,"line_end":691,"column_start":12,"column_end":14},"name":"or","qualname":"<Option<T>>::or","value":"fn (self, optb: Option<T>) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the option if it contains a value, otherwise returns `optb`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1453833,"byte_end":1453842,"line_start":689,"line_end":689,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1453847,"byte_end":1453892,"line_start":690,"line_end":690,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5574},"span":{"file_name":"src/libcore/option.rs","byte_start":1454586,"byte_end":1454593,"line_start":713,"line_end":713,"column_start":12,"column_end":19},"name":"or_else","qualname":"<Option<T>>::or_else","value":"fn <F> (self, f: F) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the option if it contains a value, otherwise calls `f` and\n returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1454515,"byte_end":1454524,"line_start":711,"line_end":711,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1454529,"byte_end":1454574,"line_start":712,"line_end":712,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5576},"span":{"file_name":"src/libcore/option.rs","byte_start":1455503,"byte_end":1455506,"line_start":748,"line_end":748,"column_start":12,"column_end":15},"name":"xor","qualname":"<Option<T>>::xor","value":"fn (self, optb: Option<T>) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns `None`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1455425,"byte_end":1455434,"line_start":746,"line_end":746,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"option_xor\", issue = \"50512\")","span":{"file_name":"src/libcore/option.rs","byte_start":1455439,"byte_end":1455491,"line_start":747,"line_end":747,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":5578},"span":{"file_name":"src/libcore/option.rs","byte_start":1456426,"byte_end":1456439,"line_start":781,"line_end":781,"column_start":12,"column_end":25},"name":"get_or_insert","qualname":"<Option<T>>::get_or_insert","value":"fn (&mut self, v: T) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Inserts `v` into the option if it is [`None`], then\n returns a mutable reference to the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1456347,"byte_end":1456356,"line_start":779,"line_end":779,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_entry\", since = \"1.20.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1456361,"byte_end":1456414,"line_start":780,"line_end":780,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":5580},"span":{"file_name":"src/libcore/option.rs","byte_start":1457230,"byte_end":1457248,"line_start":814,"line_end":814,"column_start":12,"column_end":30},"name":"get_or_insert_with","qualname":"<Option<T>>::get_or_insert_with","value":"fn <F> (&mut self, f: F) -> &mut T","parent":null,"children":[],"decl_id":null,"docs":" Inserts a value computed from `f` into the option if it is [`None`], then\n returns a mutable reference to the contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1457151,"byte_end":1457160,"line_start":812,"line_end":812,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_entry\", since = \"1.20.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1457165,"byte_end":1457218,"line_start":813,"line_end":813,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":5582},"span":{"file_name":"src/libcore/option.rs","byte_start":1458190,"byte_end":1458194,"line_start":849,"line_end":849,"column_start":12,"column_end":16},"name":"take","qualname":"<Option<T>>::take","value":"fn (&mut self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Takes the value out of the option, leaving a [`None`] in its place.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1458119,"byte_end":1458128,"line_start":847,"line_end":847,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1458133,"byte_end":1458178,"line_start":848,"line_end":848,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5584},"span":{"file_name":"src/libcore/option.rs","byte_start":1458901,"byte_end":1458908,"line_start":874,"line_end":874,"column_start":12,"column_end":19},"name":"replace","qualname":"<Option<T>>::replace","value":"fn (&mut self, value: T) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Replaces the actual value in the option by the value given in parameter,\n returning the old value if present,\n leaving a [`Some`] in its place without deinitializing either one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1458820,"byte_end":1458829,"line_start":872,"line_end":872,"column_start":5,"column_end":14}},{"value":"stable(feature = \"option_replace\", since = \"1.31.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1458834,"byte_end":1458889,"line_start":873,"line_end":873,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":5588},"span":{"file_name":"src/libcore/option.rs","byte_start":1459400,"byte_end":1459406,"line_start":893,"line_end":893,"column_start":12,"column_end":18},"name":"copied","qualname":"<Option<&'_ T>>::copied","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n option.","sig":null,"attributes":[{"value":"stable(feature = \"copied\", since = \"1.35.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1459341,"byte_end":1459388,"line_start":892,"line_end":892,"column_start":5,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":5592},"span":{"file_name":"src/libcore/option.rs","byte_start":1459888,"byte_end":1459894,"line_start":912,"line_end":912,"column_start":12,"column_end":18},"name":"copied","qualname":"<Option<&'_ mut T>>::copied","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n option.","sig":null,"attributes":[{"value":"stable(feature = \"copied\", since = \"1.35.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1459829,"byte_end":1459876,"line_start":911,"line_end":911,"column_start":5,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":5596},"span":{"file_name":"src/libcore/option.rs","byte_start":1460359,"byte_end":1460365,"line_start":931,"line_end":931,"column_start":12,"column_end":18},"name":"cloned","qualname":"<Option<&'_ T>>::cloned","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n option.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1460302,"byte_end":1460347,"line_start":930,"line_end":930,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5600},"span":{"file_name":"src/libcore/option.rs","byte_start":1460870,"byte_end":1460876,"line_start":950,"line_end":950,"column_start":12,"column_end":18},"name":"cloned","qualname":"<Option<&'_ mut T>>::cloned","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n option.","sig":null,"attributes":[{"value":"stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")","span":{"file_name":"src/libcore/option.rs","byte_start":1460796,"byte_end":1460858,"line_start":949,"line_end":949,"column_start":5,"column_end":67}}]},{"kind":"Method","id":{"krate":0,"index":5604},"span":{"file_name":"src/libcore/option.rs","byte_start":1462156,"byte_end":1462173,"line_start":986,"line_end":986,"column_start":12,"column_end":29},"name":"unwrap_or_default","qualname":"<Option<T>>::unwrap_or_default","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the contained value or a default","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1462085,"byte_end":1462094,"line_start":984,"line_end":984,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1462099,"byte_end":1462144,"line_start":985,"line_end":985,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5608},"span":{"file_name":"src/libcore/option.rs","byte_start":1462635,"byte_end":1462640,"line_start":1000,"line_end":1000,"column_start":12,"column_end":17},"name":"deref","qualname":"<Option<T>>::deref","value":"fn (&self) -> Option<&T::Target>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Option<T>` to `Option<&T::Target>`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5612},"span":{"file_name":"src/libcore/option.rs","byte_start":1463347,"byte_end":1463356,"line_start":1023,"line_end":1023,"column_start":12,"column_end":21},"name":"transpose","qualname":"<Option<Result<T, E>>>::transpose","value":"fn (self) -> Result<Option<T>, E>","parent":null,"children":[],"decl_id":null,"docs":" Transposes an `Option` of a `Result` into a `Result` of an `Option`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/option.rs","byte_start":1463264,"byte_end":1463273,"line_start":1021,"line_end":1021,"column_start":5,"column_end":14}},{"value":"stable(feature = \"transpose_result\", since = \"1.33.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1463278,"byte_end":1463335,"line_start":1022,"line_end":1022,"column_start":5,"column_end":62}}]},{"kind":"Struct","id":{"krate":0,"index":42540},"span":{"file_name":"src/libcore/option.rs","byte_start":1466928,"byte_end":1466932,"line_start":1163,"line_end":1163,"column_start":12,"column_end":16},"name":"Iter","qualname":"::option::Iter","value":"Iter {  }","parent":null,"children":[{"krate":0,"index":22919}],"decl_id":null,"docs":" An iterator over a reference to the [`Some`] variant of an [`Option`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1466854,"byte_end":1466899,"line_start":1161,"line_end":1161,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42546},"span":{"file_name":"src/libcore/option.rs","byte_start":1468342,"byte_end":1468349,"line_start":1209,"line_end":1209,"column_start":12,"column_end":19},"name":"IterMut","qualname":"::option::IterMut","value":"IterMut {  }","parent":null,"children":[{"krate":0,"index":22929}],"decl_id":null,"docs":" An iterator over a mutable reference to the [`Some`] variant of an [`Option`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1468268,"byte_end":1468313,"line_start":1207,"line_end":1207,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42552},"span":{"file_name":"src/libcore/option.rs","byte_start":1469611,"byte_end":1469619,"line_start":1246,"line_end":1246,"column_start":12,"column_end":20},"name":"IntoIter","qualname":"::option::IntoIter","value":"IntoIter {  }","parent":null,"children":[{"krate":0,"index":22937}],"decl_id":null,"docs":" An iterator over the value in [`Some`] variant of an [`Option`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/option.rs","byte_start":1469554,"byte_end":1469599,"line_start":1245,"line_end":1245,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42562},"span":{"file_name":"src/libcore/option.rs","byte_start":1474540,"byte_end":1474549,"line_start":1394,"line_end":1394,"column_start":12,"column_end":21},"name":"NoneError","qualname":"::option::NoneError","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type that results from applying the try operator (`?`) to a `None` value. If you wish\n to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can\n implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that\n returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.\n","sig":null,"attributes":[{"value":"unstable(feature = \"try_trait\", issue = \"42327\")","span":{"file_name":"src/libcore/option.rs","byte_start":1474409,"byte_end":1474460,"line_start":1392,"line_end":1392,"column_start":1,"column_end":52}},{"value":"structural_match","span":{"file_name":"src/libcore/option.rs","byte_start":1474529,"byte_end":1474550,"line_start":1394,"line_end":1394,"column_start":1,"column_end":22}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/option.rs","byte_start":1474529,"byte_end":1474550,"line_start":1394,"line_end":1394,"column_start":1,"column_end":22}}]},{"kind":"Mod","id":{"krate":0,"index":5758},"span":{"file_name":"src/libcore/raw.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"raw","qualname":"::raw","value":"src/libcore/raw.rs","parent":null,"children":[{"krate":0,"index":42594},{"krate":0,"index":42600},{"krate":0,"index":42596}],"decl_id":null,"docs":" Contains struct definitions for the layout of compiler built-in types.","sig":null,"attributes":[{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/raw.rs","byte_start":1474931,"byte_end":1474954,"line_start":1,"line_end":1,"column_start":1,"column_end":24}},{"value":"unstable(feature = \"raw\", issue = \"27751\")","span":{"file_name":"src/libcore/raw.rs","byte_start":1474955,"byte_end":1475001,"line_start":2,"line_end":2,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":42594},"span":{"file_name":"src/libcore/raw.rs","byte_start":1477581,"byte_end":1477592,"line_start":82,"line_end":82,"column_start":12,"column_end":23},"name":"TraitObject","qualname":"::raw::TraitObject","value":"TraitObject { data, vtable }","parent":null,"children":[{"krate":0,"index":22947},{"krate":0,"index":22949}],"decl_id":null,"docs":" The representation of a trait object like `&SomeTrait`.","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"src/libcore/raw.rs","byte_start":1477496,"byte_end":1477506,"line_start":79,"line_end":79,"column_start":1,"column_end":11}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/raw.rs","byte_start":1477530,"byte_end":1477569,"line_start":81,"line_end":81,"column_start":1,"column_end":40}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/raw.rs","byte_start":1477570,"byte_end":1477644,"line_start":82,"line_end":85,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":22947},"span":{"file_name":"src/libcore/raw.rs","byte_start":1477603,"byte_end":1477607,"line_start":83,"line_end":83,"column_start":9,"column_end":13},"name":"data","qualname":"::raw::TraitObject::data","value":"*mut ()","parent":{"krate":0,"index":42594},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":22949},"span":{"file_name":"src/libcore/raw.rs","byte_start":1477626,"byte_end":1477632,"line_start":84,"line_end":84,"column_start":9,"column_end":15},"name":"vtable","qualname":"::raw::TraitObject::vtable","value":"*mut ()","parent":{"krate":0,"index":42594},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5760},"span":{"file_name":"src/libcore/result.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"result","qualname":"::result","value":"src/libcore/result.rs","parent":null,"children":[{"krate":0,"index":5762},{"krate":0,"index":5764},{"krate":0,"index":5772},{"krate":0,"index":42602},{"krate":0,"index":42640},{"krate":0,"index":42638},{"krate":0,"index":42632},{"krate":0,"index":42620},{"krate":0,"index":42616},{"krate":0,"index":42612},{"krate":0,"index":42608},{"krate":0,"index":42604},{"krate":0,"index":5778},{"krate":0,"index":5814},{"krate":0,"index":5820},{"krate":0,"index":5826},{"krate":0,"index":5830},{"krate":0,"index":5834},{"krate":0,"index":5838},{"krate":0,"index":5842},{"krate":0,"index":5846},{"krate":0,"index":5848},{"krate":0,"index":5856},{"krate":0,"index":5864},{"krate":0,"index":42644},{"krate":0,"index":42646},{"krate":0,"index":5872},{"krate":0,"index":5880},{"krate":0,"index":5884},{"krate":0,"index":5886},{"krate":0,"index":5888},{"krate":0,"index":5890},{"krate":0,"index":42650},{"krate":0,"index":42652},{"krate":0,"index":5894},{"krate":0,"index":5902},{"krate":0,"index":5906},{"krate":0,"index":5908},{"krate":0,"index":5910},{"krate":0,"index":42656},{"krate":0,"index":42662},{"krate":0,"index":42658},{"krate":0,"index":5912},{"krate":0,"index":5920},{"krate":0,"index":5924},{"krate":0,"index":5926},{"krate":0,"index":5928},{"krate":0,"index":5930},{"krate":0,"index":5944}],"decl_id":null,"docs":" Error handling with the `Result` type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1485045,"byte_end":1485091,"line_start":231,"line_end":231,"column_start":1,"column_end":47}}]},{"kind":"TupleVariant","id":{"krate":0,"index":22955},"span":{"file_name":"src/libcore/result.rs","byte_start":1485756,"byte_end":1485758,"line_start":249,"line_end":249,"column_start":5,"column_end":7},"name":"Ok","qualname":"::result::Result::Ok","value":"Result::Ok(T)","parent":{"krate":0,"index":42602},"children":[],"decl_id":null,"docs":" Contains the success value\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1485706,"byte_end":1485751,"line_start":248,"line_end":248,"column_start":5,"column_end":50}}]},{"kind":"TupleVariant","id":{"krate":0,"index":22961},"span":{"file_name":"src/libcore/result.rs","byte_start":1485897,"byte_end":1485900,"line_start":253,"line_end":253,"column_start":5,"column_end":8},"name":"Err","qualname":"::result::Result::Err","value":"Result::Err(E)","parent":{"krate":0,"index":42602},"children":[],"decl_id":null,"docs":" Contains the error value\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1485847,"byte_end":1485892,"line_start":252,"line_end":252,"column_start":5,"column_end":50}}]},{"kind":"Enum","id":{"krate":0,"index":42602},"span":{"file_name":"src/libcore/result.rs","byte_start":1485652,"byte_end":1485658,"line_start":246,"line_end":246,"column_start":10,"column_end":16},"name":"Result","qualname":"::result::Result","value":"Result::{Ok, Err}","parent":null,"children":[{"krate":0,"index":22955},{"krate":0,"index":22961}],"decl_id":null,"docs":" `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).","sig":null,"attributes":[{"value":"must_use = \"this `Result` may be an `Err` variant, which should be handled\"","span":{"file_name":"src/libcore/result.rs","byte_start":1485518,"byte_end":1485596,"line_start":244,"line_end":244,"column_start":1,"column_end":79}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1485597,"byte_end":1485642,"line_start":245,"line_end":245,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/result.rs","byte_start":1485643,"byte_end":1485952,"line_start":246,"line_end":254,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/result.rs","byte_start":1485643,"byte_end":1485952,"line_start":246,"line_end":254,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":5780},"span":{"file_name":"src/libcore/result.rs","byte_start":1486821,"byte_end":1486826,"line_start":283,"line_end":283,"column_start":12,"column_end":17},"name":"is_ok","qualname":"<Result<T, E>>::is_ok","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the result is [`Ok`].","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/result.rs","byte_start":1486734,"byte_end":1486745,"line_start":280,"line_end":280,"column_start":5,"column_end":16}},{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1486750,"byte_end":1486759,"line_start":281,"line_end":281,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1486764,"byte_end":1486809,"line_start":282,"line_end":282,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5782},"span":{"file_name":"src/libcore/result.rs","byte_start":1487410,"byte_end":1487416,"line_start":308,"line_end":308,"column_start":12,"column_end":18},"name":"is_err","qualname":"<Result<T, E>>::is_err","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the result is [`Err`].","sig":null,"attributes":[{"value":"must_use","span":{"file_name":"src/libcore/result.rs","byte_start":1487323,"byte_end":1487334,"line_start":305,"line_end":305,"column_start":5,"column_end":16}},{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1487339,"byte_end":1487348,"line_start":306,"line_end":306,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1487353,"byte_end":1487398,"line_start":307,"line_end":307,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5784},"span":{"file_name":"src/libcore/result.rs","byte_start":1488227,"byte_end":1488229,"line_start":336,"line_end":336,"column_start":12,"column_end":14},"name":"ok","qualname":"<Result<T, E>>::ok","value":"fn (self) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Result<T, E>` to [`Option<T>`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1488156,"byte_end":1488165,"line_start":334,"line_end":334,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1488170,"byte_end":1488215,"line_start":335,"line_end":335,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5786},"span":{"file_name":"src/libcore/result.rs","byte_start":1488946,"byte_end":1488949,"line_start":363,"line_end":363,"column_start":12,"column_end":15},"name":"err","qualname":"<Result<T, E>>::err","value":"fn (self) -> Option<E>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `Result<T, E>` to [`Option<E>`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1488875,"byte_end":1488884,"line_start":361,"line_end":361,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1488889,"byte_end":1488934,"line_start":362,"line_end":362,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5788},"span":{"file_name":"src/libcore/result.rs","byte_start":1489798,"byte_end":1489804,"line_start":392,"line_end":392,"column_start":12,"column_end":18},"name":"as_ref","qualname":"<Result<T, E>>::as_ref","value":"fn (&self) -> Result<&T, &E>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Result<T, E>` to `Result<&T, &E>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1489727,"byte_end":1489736,"line_start":390,"line_end":390,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1489741,"byte_end":1489786,"line_start":391,"line_end":391,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5790},"span":{"file_name":"src/libcore/result.rs","byte_start":1490571,"byte_end":1490577,"line_start":423,"line_end":423,"column_start":12,"column_end":18},"name":"as_mut","qualname":"<Result<T, E>>::as_mut","value":"fn (&mut self) -> Result<&mut T, &mut E>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1490500,"byte_end":1490509,"line_start":421,"line_end":421,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1490514,"byte_end":1490559,"line_start":422,"line_end":422,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5792},"span":{"file_name":"src/libcore/result.rs","byte_start":1491690,"byte_end":1491693,"line_start":458,"line_end":458,"column_start":12,"column_end":15},"name":"map","qualname":"<Result<T, E>>::map","value":"fn <U, F> (self, op: F) -> Result<U, E>","parent":null,"children":[],"decl_id":null,"docs":" Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1491619,"byte_end":1491628,"line_start":456,"line_end":456,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1491633,"byte_end":1491678,"line_start":457,"line_end":457,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5794},"span":{"file_name":"src/libcore/result.rs","byte_start":1492676,"byte_end":1492687,"line_start":491,"line_end":491,"column_start":12,"column_end":23},"name":"map_or_else","qualname":"<Result<T, E>>::map_or_else","value":"fn <U, M, F> (self, fallback: F, map: M) -> U","parent":null,"children":[],"decl_id":null,"docs":" Maps a `Result<T, E>` to `U` by applying a function to a\n contained [`Ok`] value, or a fallback function to a\n contained [`Err`] value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1492590,"byte_end":1492599,"line_start":489,"line_end":489,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"result_map_or_else\", issue = \"53268\")","span":{"file_name":"src/libcore/result.rs","byte_start":1492604,"byte_end":1492664,"line_start":490,"line_end":490,"column_start":5,"column_end":65}}]},{"kind":"Method","id":{"krate":0,"index":5796},"span":{"file_name":"src/libcore/result.rs","byte_start":1493631,"byte_end":1493638,"line_start":519,"line_end":519,"column_start":12,"column_end":19},"name":"map_err","qualname":"<Result<T, E>>::map_err","value":"fn <F, O> (self, op: O) -> Result<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1493560,"byte_end":1493569,"line_start":517,"line_end":517,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1493574,"byte_end":1493619,"line_start":518,"line_end":518,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5798},"span":{"file_name":"src/libcore/result.rs","byte_start":1494489,"byte_end":1494493,"line_start":547,"line_end":547,"column_start":12,"column_end":16},"name":"iter","qualname":"<Result<T, E>>::iter","value":"fn (&self) -> Iter<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the possibly contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1494418,"byte_end":1494427,"line_start":545,"line_end":545,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1494432,"byte_end":1494477,"line_start":546,"line_end":546,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5800},"span":{"file_name":"src/libcore/result.rs","byte_start":1495186,"byte_end":1495194,"line_start":572,"line_end":572,"column_start":12,"column_end":20},"name":"iter_mut","qualname":"<Result<T, E>>::iter_mut","value":"fn (&mut self) -> IterMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable iterator over the possibly contained value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1495115,"byte_end":1495124,"line_start":570,"line_end":570,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1495129,"byte_end":1495174,"line_start":571,"line_end":571,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5802},"span":{"file_name":"src/libcore/result.rs","byte_start":1496486,"byte_end":1496489,"line_start":608,"line_end":608,"column_start":12,"column_end":15},"name":"and","qualname":"<Result<T, E>>::and","value":"fn <U> (self, res: Result<U, E>) -> Result<U, E>","parent":null,"children":[],"decl_id":null,"docs":" Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1496415,"byte_end":1496424,"line_start":606,"line_end":606,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1496429,"byte_end":1496474,"line_start":607,"line_end":607,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5804},"span":{"file_name":"src/libcore/result.rs","byte_start":1497432,"byte_end":1497440,"line_start":637,"line_end":637,"column_start":12,"column_end":20},"name":"and_then","qualname":"<Result<T, E>>::and_then","value":"fn <U, F> (self, op: F) -> Result<U, E>","parent":null,"children":[],"decl_id":null,"docs":" Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1497361,"byte_end":1497370,"line_start":635,"line_end":635,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1497375,"byte_end":1497420,"line_start":636,"line_end":636,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5806},"span":{"file_name":"src/libcore/result.rs","byte_start":1498752,"byte_end":1498754,"line_start":677,"line_end":677,"column_start":12,"column_end":14},"name":"or","qualname":"<Result<T, E>>::or","value":"fn <F> (self, res: Result<T, F>) -> Result<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1498681,"byte_end":1498690,"line_start":675,"line_end":675,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1498695,"byte_end":1498740,"line_start":676,"line_end":676,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5808},"span":{"file_name":"src/libcore/result.rs","byte_start":1499686,"byte_end":1499693,"line_start":706,"line_end":706,"column_start":12,"column_end":19},"name":"or_else","qualname":"<Result<T, E>>::or_else","value":"fn <F, O> (self, op: O) -> Result<T, F>","parent":null,"children":[],"decl_id":null,"docs":" Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1499615,"byte_end":1499624,"line_start":704,"line_end":704,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1499629,"byte_end":1499674,"line_start":705,"line_end":705,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5810},"span":{"file_name":"src/libcore/result.rs","byte_start":1500676,"byte_end":1500685,"line_start":738,"line_end":738,"column_start":12,"column_end":21},"name":"unwrap_or","qualname":"<Result<T, E>>::unwrap_or","value":"fn (self, optb: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Ok`].\n Else, it returns `optb`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1500605,"byte_end":1500614,"line_start":736,"line_end":736,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1500619,"byte_end":1500664,"line_start":737,"line_end":737,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5812},"span":{"file_name":"src/libcore/result.rs","byte_start":1501353,"byte_end":1501367,"line_start":763,"line_end":763,"column_start":12,"column_end":26},"name":"unwrap_or_else","qualname":"<Result<T, E>>::unwrap_or_else","value":"fn <F> (self, op: F) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Ok`].\n If the value is an [`Err`] then it calls `op` with its value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1501282,"byte_end":1501291,"line_start":761,"line_end":761,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1501296,"byte_end":1501341,"line_start":762,"line_end":762,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5816},"span":{"file_name":"src/libcore/result.rs","byte_start":1502237,"byte_end":1502243,"line_start":797,"line_end":797,"column_start":12,"column_end":18},"name":"unwrap","qualname":"<Result<T, E>>::unwrap","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Ok`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1502166,"byte_end":1502175,"line_start":795,"line_end":795,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1502180,"byte_end":1502225,"line_start":796,"line_end":796,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5818},"span":{"file_name":"src/libcore/result.rs","byte_start":1503066,"byte_end":1503072,"line_start":824,"line_end":824,"column_start":12,"column_end":18},"name":"expect","qualname":"<Result<T, E>>::expect","value":"fn (self, msg: &str) -> T","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Ok`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1502987,"byte_end":1502996,"line_start":822,"line_end":822,"column_start":5,"column_end":14}},{"value":"stable(feature = \"result_expect\", since = \"1.4.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1503001,"byte_end":1503054,"line_start":823,"line_end":823,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":5822},"span":{"file_name":"src/libcore/result.rs","byte_start":1503939,"byte_end":1503949,"line_start":857,"line_end":857,"column_start":12,"column_end":22},"name":"unwrap_err","qualname":"<Result<T, E>>::unwrap_err","value":"fn (self) -> E","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Err`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1503868,"byte_end":1503877,"line_start":855,"line_end":855,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1503882,"byte_end":1503927,"line_start":856,"line_end":856,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":5824},"span":{"file_name":"src/libcore/result.rs","byte_start":1504758,"byte_end":1504768,"line_start":884,"line_end":884,"column_start":12,"column_end":22},"name":"expect_err","qualname":"<Result<T, E>>::expect_err","value":"fn (self, msg: &str) -> E","parent":null,"children":[],"decl_id":null,"docs":" Unwraps a result, yielding the content of an [`Err`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1504674,"byte_end":1504683,"line_start":882,"line_end":882,"column_start":5,"column_end":14}},{"value":"stable(feature = \"result_expect_err\", since = \"1.17.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1504688,"byte_end":1504746,"line_start":883,"line_end":883,"column_start":5,"column_end":63}}]},{"kind":"Method","id":{"krate":0,"index":5828},"span":{"file_name":"src/libcore/result.rs","byte_start":1506086,"byte_end":1506103,"line_start":922,"line_end":922,"column_start":12,"column_end":29},"name":"unwrap_or_default","qualname":"<Result<T, E>>::unwrap_or_default","value":"fn (self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the contained value or a default","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1505995,"byte_end":1506004,"line_start":920,"line_end":920,"column_start":5,"column_end":14}},{"value":"stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1506009,"byte_end":1506074,"line_start":921,"line_end":921,"column_start":5,"column_end":70}}]},{"kind":"Method","id":{"krate":0,"index":5832},"span":{"file_name":"src/libcore/result.rs","byte_start":1506600,"byte_end":1506608,"line_start":937,"line_end":937,"column_start":12,"column_end":20},"name":"deref_ok","qualname":"<Result<T, E>>::deref_ok","value":"fn (&self) -> Result<&T::Target, &E>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Result<T, E>` to `Result<&T::Target, &E>`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5836},"span":{"file_name":"src/libcore/result.rs","byte_start":1507072,"byte_end":1507081,"line_start":949,"line_end":949,"column_start":12,"column_end":21},"name":"deref_err","qualname":"<Result<T, E>>::deref_err","value":"fn (&self) -> Result<&T, &E::Target>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Result<T, E>` to `Result<&T, &E::Target>`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5840},"span":{"file_name":"src/libcore/result.rs","byte_start":1507583,"byte_end":1507588,"line_start":962,"line_end":962,"column_start":12,"column_end":17},"name":"deref","qualname":"<Result<T, E>>::deref","value":"fn (&self) -> Result<&T::Target, &E::Target>","parent":null,"children":[],"decl_id":null,"docs":" Converts from `&Result<T, E>` to `Result<&T::Target, &E::Target>`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5844},"span":{"file_name":"src/libcore/result.rs","byte_start":1508334,"byte_end":1508343,"line_start":986,"line_end":986,"column_start":12,"column_end":21},"name":"transpose","qualname":"<Result<Option<T>, E>>::transpose","value":"fn (self) -> Option<Result<T, E>>","parent":null,"children":[],"decl_id":null,"docs":" Transposes a `Result` of an `Option` into an `Option` of a `Result`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/result.rs","byte_start":1508251,"byte_end":1508260,"line_start":984,"line_end":984,"column_start":5,"column_end":14}},{"value":"stable(feature = \"transpose_result\", since = \"1.33.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1508265,"byte_end":1508322,"line_start":985,"line_end":985,"column_start":5,"column_end":62}}]},{"kind":"Struct","id":{"krate":0,"index":42644},"span":{"file_name":"src/libcore/result.rs","byte_start":1510701,"byte_end":1510705,"line_start":1069,"line_end":1069,"column_start":12,"column_end":16},"name":"Iter","qualname":"::result::Iter","value":"Iter {  }","parent":null,"children":[{"krate":0,"index":23005}],"decl_id":null,"docs":" An iterator over a reference to the [`Ok`] variant of a [`Result`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1510644,"byte_end":1510689,"line_start":1068,"line_end":1068,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42650},"span":{"file_name":"src/libcore/result.rs","byte_start":1512024,"byte_end":1512031,"line_start":1114,"line_end":1114,"column_start":12,"column_end":19},"name":"IterMut","qualname":"::result::IterMut","value":"IterMut {  }","parent":null,"children":[{"krate":0,"index":23015}],"decl_id":null,"docs":" An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1511967,"byte_end":1512012,"line_start":1113,"line_end":1113,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42656},"span":{"file_name":"src/libcore/result.rs","byte_start":1513454,"byte_end":1513462,"line_start":1157,"line_end":1157,"column_start":12,"column_end":20},"name":"IntoIter","qualname":"::result::IntoIter","value":"IntoIter {  }","parent":null,"children":[{"krate":0,"index":23023}],"decl_id":null,"docs":" An iterator over the value in a [`Ok`] variant of a [`Result`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/result.rs","byte_start":1513397,"byte_end":1513442,"line_start":1156,"line_end":1156,"column_start":1,"column_end":46}}]},{"kind":"Mod","id":{"krate":0,"index":5956},"span":{"file_name":"src/libcore/ffi.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ffi","qualname":"::ffi","value":"src/libcore/ffi.rs","parent":null,"children":[{"krate":0,"index":5958},{"krate":0,"index":5960},{"krate":0,"index":5962},{"krate":0,"index":42666},{"krate":0,"index":42668},{"krate":0,"index":42672},{"krate":0,"index":42674},{"krate":0,"index":5966},{"krate":0,"index":5970},{"krate":0,"index":42678},{"krate":0,"index":42680},{"krate":0,"index":42682},{"krate":0,"index":42684},{"krate":0,"index":42686},{"krate":0,"index":42688},{"krate":0,"index":42690},{"krate":0,"index":42692},{"krate":0,"index":42694},{"krate":0,"index":42696},{"krate":0,"index":42698},{"krate":0,"index":5972},{"krate":0,"index":5974},{"krate":0,"index":5976},{"krate":0,"index":5982}],"decl_id":null,"docs":" Utilities related to FFI bindings.\n","sig":null,"attributes":[{"value":"stable(feature = \"\", since = \"1.30.0\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1517708,"byte_end":1517750,"line_start":1,"line_end":1,"column_start":1,"column_end":43}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/ffi.rs","byte_start":1517752,"byte_end":1517783,"line_start":3,"line_end":3,"column_start":1,"column_end":32}}]},{"kind":"TupleVariant","id":{"krate":0,"index":3453},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1519182,"byte_end":1519192,"line_start":34,"line_end":34,"column_start":20,"column_end":30},"name":"__variant1","qualname":"::ffi::c_void::__variant1","value":"c_void::__variant1","parent":{"krate":0,"index":5960},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"c_void_variant\",\n           reason = \"temporary implementation detail\",\n           issue = \"0\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1519051,"byte_end":1519162,"line_start":32,"line_end":33,"column_start":5,"column_end":29}}]},{"kind":"TupleVariant","id":{"krate":0,"index":3457},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1519329,"byte_end":1519339,"line_start":37,"line_end":37,"column_start":20,"column_end":30},"name":"__variant2","qualname":"::ffi::c_void::__variant2","value":"c_void::__variant2","parent":{"krate":0,"index":5960},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"c_void_variant\",\n           reason = \"temporary implementation detail\",\n           issue = \"0\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1519198,"byte_end":1519309,"line_start":35,"line_end":36,"column_start":5,"column_end":29}}]},{"kind":"Enum","id":{"krate":0,"index":5960},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1519038,"byte_end":1519044,"line_start":31,"line_end":31,"column_start":10,"column_end":16},"name":"c_void","qualname":"::ffi::c_void","value":"c_void::{__variant1, __variant2}","parent":null,"children":[{"krate":0,"index":3453},{"krate":0,"index":3457}],"decl_id":null,"docs":" Equivalent to C's `void` type when used as a [pointer].","sig":null,"attributes":[{"value":"repr(u8)","span":{"file_name":"src/libcore/ffi.rs","byte_start":1518970,"byte_end":1518981,"line_start":29,"line_end":29,"column_start":1,"column_end":12}},{"value":"stable(feature = \"raw_os\", since = \"1.1.0\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1518982,"byte_end":1519028,"line_start":30,"line_end":30,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":42672},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1522180,"byte_end":1522186,"line_start":129,"line_end":129,"column_start":12,"column_end":18},"name":"VaList","qualname":"::ffi::VaList","value":"","parent":null,"children":[],"decl_id":null,"docs":" A wrapper for a `va_list`\n","sig":null,"attributes":[{"value":"lang = \"va_list\"","span":{"file_name":"src/libcore/ffi.rs","byte_start":1521920,"byte_end":1521939,"line_start":122,"line_end":122,"column_start":1,"column_end":20}},{"value":"unstable(feature = \"c_variadic\",\n           reason =\n               \"the `c_variadic` feature has not been properly tested on all supported platforms\",\n           issue = \"44930\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1521957,"byte_end":1522147,"line_start":124,"line_end":127,"column_start":1,"column_end":29}},{"value":"repr(transparent)","span":{"file_name":"src/libcore/ffi.rs","byte_start":1522148,"byte_end":1522168,"line_start":128,"line_end":128,"column_start":1,"column_end":21}}]},{"kind":"Trait","id":{"krate":0,"index":5968},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1523155,"byte_end":1523164,"line_start":148,"line_end":148,"column_start":15,"column_end":24},"name":"VaArgSafe","qualname":"::ffi::sealed_trait::VaArgSafe","value":"VaArgSafe","parent":null,"children":[],"decl_id":null,"docs":" Trait which whitelists the allowed types to be used with [VaList::arg]","sig":null,"attributes":[{"value":"unstable(feature = \"c_variadic\",\n           reason =\n               \"the `c_variadic` feature has not been properly tested on all supported platforms\",\n           issue = \"44930\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1522938,"byte_end":1523140,"line_start":144,"line_end":147,"column_start":5,"column_end":33}}]},{"kind":"Method","id":{"krate":0,"index":5978},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1524415,"byte_end":1524418,"line_start":184,"line_end":184,"column_start":19,"column_end":22},"name":"arg","qualname":"<VaList>::arg","value":"fn <T> (&mut self) -> T","parent":null,"children":[],"decl_id":null,"docs":" Advance to the next arg.\n","sig":null,"attributes":[{"value":"unstable(feature = \"c_variadic\",\n           reason =\n               \"the `c_variadic` feature has not been properly tested on all supported platforms\",\n           issue = \"44930\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1524194,"byte_end":1524396,"line_start":180,"line_end":183,"column_start":5,"column_end":33}}]},{"kind":"Method","id":{"krate":0,"index":5980},"span":{"file_name":"src/libcore/ffi.rs","byte_start":1524772,"byte_end":1524781,"line_start":193,"line_end":193,"column_start":19,"column_end":28},"name":"with_copy","qualname":"<VaList>::with_copy","value":"fn <F, R> (&self, f: F) -> R","parent":null,"children":[],"decl_id":null,"docs":" Copies the `va_list` at the current location.\n","sig":null,"attributes":[{"value":"unstable(feature = \"c_variadic\",\n           reason =\n               \"the `c_variadic` feature has not been properly tested on all supported platforms\",\n           issue = \"44930\")","span":{"file_name":"src/libcore/ffi.rs","byte_start":1524551,"byte_end":1524753,"line_start":189,"line_end":192,"column_start":5,"column_end":33}}]},{"kind":"Mod","id":{"krate":0,"index":5984},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"slice","qualname":"::slice","value":"src/libcore/slice/mod.rs","parent":null,"children":[{"krate":0,"index":5986},{"krate":0,"index":5996},{"krate":0,"index":5998},{"krate":0,"index":6000},{"krate":0,"index":6002},{"krate":0,"index":6004},{"krate":0,"index":6006},{"krate":0,"index":6014},{"krate":0,"index":6016},{"krate":0,"index":6022},{"krate":0,"index":6024},{"krate":0,"index":6030},{"krate":0,"index":6032},{"krate":0,"index":6034},{"krate":0,"index":6046},{"krate":0,"index":6070},{"krate":0,"index":6090},{"krate":0,"index":6160},{"krate":0,"index":6162},{"krate":0,"index":6164},{"krate":0,"index":6302},{"krate":0,"index":6312},{"krate":0,"index":6318},{"krate":0,"index":6322},{"krate":0,"index":6324},{"krate":0,"index":6326},{"krate":0,"index":6328},{"krate":0,"index":6348},{"krate":0,"index":6364},{"krate":0,"index":6380},{"krate":0,"index":6396},{"krate":0,"index":6412},{"krate":0,"index":6428},{"krate":0,"index":6444},{"krate":0,"index":6460},{"krate":0,"index":6476},{"krate":0,"index":6480},{"krate":0,"index":6484},{"krate":0,"index":6492},{"krate":0,"index":6500},{"krate":0,"index":6502},{"krate":0,"index":6504},{"krate":0,"index":6506},{"krate":0,"index":6508},{"krate":0,"index":6510},{"krate":0,"index":6514},{"krate":0,"index":6516},{"krate":0,"index":6518},{"krate":0,"index":42700},{"krate":0,"index":42708},{"krate":0,"index":42714},{"krate":0,"index":42738},{"krate":0,"index":42746},{"krate":0,"index":42748},{"krate":0,"index":6522},{"krate":0,"index":6526},{"krate":0,"index":6530},{"krate":0,"index":6532},{"krate":0,"index":6536},{"krate":0,"index":6538},{"krate":0,"index":6540},{"krate":0,"index":42750},{"krate":0,"index":42758},{"krate":0,"index":42764},{"krate":0,"index":42786},{"krate":0,"index":42794},{"krate":0,"index":42796},{"krate":0,"index":6546},{"krate":0,"index":6550},{"krate":0,"index":6552},{"krate":0,"index":6556},{"krate":0,"index":6560},{"krate":0,"index":6568},{"krate":0,"index":6572},{"krate":0,"index":6576},{"krate":0,"index":6578},{"krate":0,"index":6580},{"krate":0,"index":6584},{"krate":0,"index":6588},{"krate":0,"index":6596},{"krate":0,"index":6600},{"krate":0,"index":42798},{"krate":0,"index":42800},{"krate":0,"index":6602},{"krate":0,"index":6606},{"krate":0,"index":6614},{"krate":0,"index":6618},{"krate":0,"index":6622},{"krate":0,"index":6624},{"krate":0,"index":6626},{"krate":0,"index":6630},{"krate":0,"index":6634},{"krate":0,"index":6642},{"krate":0,"index":6646},{"krate":0,"index":42804},{"krate":0,"index":42806},{"krate":0,"index":6648},{"krate":0,"index":6656},{"krate":0,"index":6658},{"krate":0,"index":6662},{"krate":0,"index":6664},{"krate":0,"index":6668},{"krate":0,"index":6670},{"krate":0,"index":6674},{"krate":0,"index":6676},{"krate":0,"index":6680},{"krate":0,"index":42810},{"krate":0,"index":42818},{"krate":0,"index":42820},{"krate":0,"index":42828},{"krate":0,"index":42830},{"krate":0,"index":42838},{"krate":0,"index":42840},{"krate":0,"index":42848},{"krate":0,"index":42850},{"krate":0,"index":42852},{"krate":0,"index":6682},{"krate":0,"index":6686},{"krate":0,"index":6700},{"krate":0,"index":6706},{"krate":0,"index":6708},{"krate":0,"index":6710},{"krate":0,"index":6712},{"krate":0,"index":42856},{"krate":0,"index":42858},{"krate":0,"index":6718},{"krate":0,"index":6722},{"krate":0,"index":6736},{"krate":0,"index":6740},{"krate":0,"index":6742},{"krate":0,"index":6744},{"krate":0,"index":6746},{"krate":0,"index":42862},{"krate":0,"index":42864},{"krate":0,"index":6752},{"krate":0,"index":6766},{"krate":0,"index":6770},{"krate":0,"index":6772},{"krate":0,"index":6774},{"krate":0,"index":6776},{"krate":0,"index":42868},{"krate":0,"index":42870},{"krate":0,"index":6782},{"krate":0,"index":6786},{"krate":0,"index":6790},{"krate":0,"index":6804},{"krate":0,"index":6808},{"krate":0,"index":6812},{"krate":0,"index":6814},{"krate":0,"index":6816},{"krate":0,"index":42874},{"krate":0,"index":42876},{"krate":0,"index":6822},{"krate":0,"index":6826},{"krate":0,"index":6840},{"krate":0,"index":6844},{"krate":0,"index":6848},{"krate":0,"index":6850},{"krate":0,"index":6852},{"krate":0,"index":42880},{"krate":0,"index":42882},{"krate":0,"index":6858},{"krate":0,"index":6862},{"krate":0,"index":6876},{"krate":0,"index":6880},{"krate":0,"index":6882},{"krate":0,"index":6884},{"krate":0,"index":6886},{"krate":0,"index":42886},{"krate":0,"index":42888},{"krate":0,"index":6892},{"krate":0,"index":6906},{"krate":0,"index":6910},{"krate":0,"index":6912},{"krate":0,"index":6914},{"krate":0,"index":6916},{"krate":0,"index":42892},{"krate":0,"index":42894},{"krate":0,"index":6922},{"krate":0,"index":6926},{"krate":0,"index":6930},{"krate":0,"index":6944},{"krate":0,"index":6948},{"krate":0,"index":6952},{"krate":0,"index":6954},{"krate":0,"index":6956},{"krate":0,"index":42898},{"krate":0,"index":42900},{"krate":0,"index":6962},{"krate":0,"index":6966},{"krate":0,"index":6980},{"krate":0,"index":6984},{"krate":0,"index":6988},{"krate":0,"index":6990},{"krate":0,"index":6992},{"krate":0,"index":6998},{"krate":0,"index":7000},{"krate":0,"index":7002},{"krate":0,"index":7004},{"krate":0,"index":7006},{"krate":0,"index":7008},{"krate":0,"index":7010},{"krate":0,"index":7016},{"krate":0,"index":7018},{"krate":0,"index":7022},{"krate":0,"index":7026},{"krate":0,"index":7032},{"krate":0,"index":7036},{"krate":0,"index":7040},{"krate":0,"index":7044},{"krate":0,"index":7048},{"krate":0,"index":7052},{"krate":0,"index":7056},{"krate":0,"index":7060},{"krate":0,"index":7064},{"krate":0,"index":7066},{"krate":0,"index":42904},{"krate":0,"index":42906},{"krate":0,"index":42908},{"krate":0,"index":42910},{"krate":0,"index":42912},{"krate":0,"index":42914},{"krate":0,"index":42916},{"krate":0,"index":42918},{"krate":0,"index":42920},{"krate":0,"index":42922},{"krate":0,"index":42924},{"krate":0,"index":42926},{"krate":0,"index":7068},{"krate":0,"index":7074},{"krate":0,"index":7080},{"krate":0,"index":7084},{"krate":0,"index":7088},{"krate":0,"index":7092}],"decl_id":null,"docs":" Slice management and manipulation.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1526713,"byte_end":1526759,"line_start":7,"line_end":7,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":6046},"span":{"file_name":"src/libcore/slice/memchr.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"memchr","qualname":"::slice::memchr","value":"src/libcore/slice/memchr.rs","parent":null,"children":[{"krate":0,"index":6048},{"krate":0,"index":6050},{"krate":0,"index":6052},{"krate":0,"index":6054},{"krate":0,"index":6056},{"krate":0,"index":6058},{"krate":0,"index":6060},{"krate":0,"index":6062},{"krate":0,"index":6064},{"krate":0,"index":6066}],"decl_id":null,"docs":" Pure rust memchr implementation, taken from rust-memchr\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_internals\",\n           issue = \"0\",\n           reason =\n               \"exposed from core to be reused in std; use the memchr crate\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1527650,"byte_end":1527786,"line_start":38,"line_end":39,"column_start":1,"column_end":84}}]},{"kind":"Function","id":{"krate":0,"index":6064},"span":{"file_name":"src/libcore/slice/memchr.rs","byte_start":1702133,"byte_end":1702139,"line_start":39,"line_end":39,"column_start":8,"column_end":14},"name":"memchr","qualname":"::slice::memchr::memchr","value":"fn (x: u8, text: &[u8]) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Returns the first index matching the byte `x` in `text`.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6066},"span":{"file_name":"src/libcore/slice/memchr.rs","byte_start":1703679,"byte_end":1703686,"line_start":84,"line_end":84,"column_start":8,"column_end":15},"name":"memrchr","qualname":"::slice::memchr::memrchr","value":"fn (x: u8, text: &[u8]) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Returns the last index matching the byte `x` in `text`.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6088},"span":{"file_name":"src/libcore/slice/rotate.rs","byte_start":1707452,"byte_end":1707462,"line_start":55,"line_end":55,"column_start":15,"column_end":25},"name":"ptr_rotate","qualname":"::slice::rotate::ptr_rotate","value":"fn <T> (mut left: usize, mid: *mut T, mut right: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Rotates the range `[mid-left, mid+right)` such that the element at `mid`\n becomes the first element. Equivalently, rotates the range `left`\n elements to the left or `right` elements to the right.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6120},"span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1713609,"byte_end":1713617,"line_start":146,"line_end":146,"column_start":8,"column_end":16},"name":"heapsort","qualname":"::slice::sort::heapsort","value":"fn <T, F> (v: &mut [T], is_less: &mut F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n","sig":null,"attributes":[{"value":"cold","span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1713594,"byte_end":1713601,"line_start":145,"line_end":145,"column_start":1,"column_end":8}}]},{"kind":"Function","id":{"krate":0,"index":6148},"span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1733163,"byte_end":1733172,"line_start":681,"line_end":681,"column_start":8,"column_end":17},"name":"quicksort","qualname":"::slice::sort::quicksort","value":"fn <T, F> (v: &mut [T], mut is_less: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6154},"span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1735511,"byte_end":1735529,"line_start":750,"line_end":750,"column_start":8,"column_end":26},"name":"partition_at_index","qualname":"::slice::sort::partition_at_index","value":"fn <T, F> (v: &mut [T], index: usize, mut is_less: F) -> (&mut [T], &mut T, &mut [T])","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6166},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1528446,"byte_end":1528449,"line_start":77,"line_end":77,"column_start":18,"column_end":21},"name":"len","qualname":"<[T]>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of elements in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1528312,"byte_end":1528357,"line_start":74,"line_end":74,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1528362,"byte_end":1528371,"line_start":75,"line_end":75,"column_start":5,"column_end":14}},{"value":"rustc_const_unstable(feature = \"const_slice_len\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1528376,"byte_end":1528428,"line_start":76,"line_end":76,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6168},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1528853,"byte_end":1528861,"line_start":94,"line_end":94,"column_start":18,"column_end":26},"name":"is_empty","qualname":"<[T]>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the slice has a length of 0.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1528719,"byte_end":1528764,"line_start":91,"line_end":91,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1528769,"byte_end":1528778,"line_start":92,"line_end":92,"column_start":5,"column_end":14}},{"value":"rustc_const_unstable(feature = \"const_slice_len\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1528783,"byte_end":1528835,"line_start":93,"line_end":93,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":6170},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1529264,"byte_end":1529269,"line_start":111,"line_end":111,"column_start":12,"column_end":17},"name":"first","qualname":"<[T]>::first","value":"fn (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the first element of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1529193,"byte_end":1529238,"line_start":109,"line_end":109,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1529243,"byte_end":1529252,"line_start":110,"line_end":110,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6172},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1529703,"byte_end":1529712,"line_start":129,"line_end":129,"column_start":12,"column_end":21},"name":"first_mut","qualname":"<[T]>::first_mut","value":"fn (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable pointer to the first element of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1529632,"byte_end":1529677,"line_start":127,"line_end":127,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1529682,"byte_end":1529691,"line_start":128,"line_end":128,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6174},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1530198,"byte_end":1530209,"line_start":147,"line_end":147,"column_start":12,"column_end":23},"name":"split_first","qualname":"<[T]>::split_first","value":"fn (&self) -> Option<(&T, &[T])>","parent":null,"children":[],"decl_id":null,"docs":" Returns the first and all the rest of the elements of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"slice_splits\", since = \"1.5.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1530120,"byte_end":1530172,"line_start":145,"line_end":145,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1530177,"byte_end":1530186,"line_start":146,"line_end":146,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6176},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1530792,"byte_end":1530807,"line_start":167,"line_end":167,"column_start":12,"column_end":27},"name":"split_first_mut","qualname":"<[T]>::split_first_mut","value":"fn (&mut self) -> Option<(&mut T, &mut [T])>","parent":null,"children":[],"decl_id":null,"docs":" Returns the first and all the rest of the elements of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"slice_splits\", since = \"1.5.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1530714,"byte_end":1530766,"line_start":165,"line_end":165,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1530771,"byte_end":1530780,"line_start":166,"line_end":166,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6178},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1531421,"byte_end":1531431,"line_start":188,"line_end":188,"column_start":12,"column_end":22},"name":"split_last","qualname":"<[T]>::split_last","value":"fn (&self) -> Option<(&T, &[T])>","parent":null,"children":[],"decl_id":null,"docs":" Returns the last and all the rest of the elements of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"slice_splits\", since = \"1.5.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1531343,"byte_end":1531395,"line_start":186,"line_end":186,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1531400,"byte_end":1531409,"line_start":187,"line_end":187,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6180},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1532047,"byte_end":1532061,"line_start":209,"line_end":209,"column_start":12,"column_end":26},"name":"split_last_mut","qualname":"<[T]>::split_last_mut","value":"fn (&mut self) -> Option<(&mut T, &mut [T])>","parent":null,"children":[],"decl_id":null,"docs":" Returns the last and all the rest of the elements of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"slice_splits\", since = \"1.5.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1531969,"byte_end":1532021,"line_start":207,"line_end":207,"column_start":5,"column_end":57}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1532026,"byte_end":1532035,"line_start":208,"line_end":208,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6182},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1532637,"byte_end":1532641,"line_start":231,"line_end":231,"column_start":12,"column_end":16},"name":"last","qualname":"<[T]>::last","value":"fn (&self) -> Option<&T>","parent":null,"children":[],"decl_id":null,"docs":" Returns the last element of the slice, or `None` if it is empty.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1532566,"byte_end":1532611,"line_start":229,"line_end":229,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1532616,"byte_end":1532625,"line_start":230,"line_end":230,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6184},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1533102,"byte_end":1533110,"line_start":250,"line_end":250,"column_start":12,"column_end":20},"name":"last_mut","qualname":"<[T]>::last_mut","value":"fn (&mut self) -> Option<&mut T>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable pointer to the last item in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1533031,"byte_end":1533076,"line_start":248,"line_end":248,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1533081,"byte_end":1533090,"line_start":249,"line_end":249,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6186},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1533904,"byte_end":1533907,"line_start":274,"line_end":274,"column_start":12,"column_end":15},"name":"get","qualname":"<[T]>::get","value":"fn <I> (&self, index: I) -> Option<&I::Output>","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to an element or subslice depending on the type of\n index.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1533833,"byte_end":1533878,"line_start":272,"line_end":272,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1533883,"byte_end":1533892,"line_start":273,"line_end":273,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6188},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1534501,"byte_end":1534508,"line_start":297,"line_end":297,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<[T]>::get_mut","value":"fn <I> (&mut self, index: I) -> Option<&mut I::Output>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to an element or subslice depending on the\n type of index (see [`get`]) or `None` if the index is out of bounds.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1534430,"byte_end":1534475,"line_start":295,"line_end":295,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1534480,"byte_end":1534489,"line_start":296,"line_end":296,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6190},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1535130,"byte_end":1535143,"line_start":322,"line_end":322,"column_start":19,"column_end":32},"name":"get_unchecked","qualname":"<[T]>::get_unchecked","value":"fn <I> (&self, index: I) -> &I::Output","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to an element or subslice, without doing bounds\n checking.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1535052,"byte_end":1535097,"line_start":320,"line_end":320,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1535102,"byte_end":1535111,"line_start":321,"line_end":321,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6192},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1535838,"byte_end":1535855,"line_start":349,"line_end":349,"column_start":19,"column_end":36},"name":"get_unchecked_mut","qualname":"<[T]>::get_unchecked_mut","value":"fn <I> (&mut self, index: I) -> &mut I::Output","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable reference to an element or subslice, without doing\n bounds checking.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1535760,"byte_end":1535805,"line_start":347,"line_end":347,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1535810,"byte_end":1535819,"line_start":348,"line_end":348,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6194},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1536696,"byte_end":1536702,"line_start":377,"line_end":377,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<[T]>::as_ptr","value":"fn (&self) -> *const T","parent":null,"children":[],"decl_id":null,"docs":" Returns a raw pointer to the slice's buffer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1536619,"byte_end":1536664,"line_start":375,"line_end":375,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1536669,"byte_end":1536678,"line_start":376,"line_end":376,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6196},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1537504,"byte_end":1537514,"line_start":404,"line_end":404,"column_start":12,"column_end":22},"name":"as_mut_ptr","qualname":"<[T]>::as_mut_ptr","value":"fn (&mut self) -> *mut T","parent":null,"children":[],"decl_id":null,"docs":" Returns an unsafe mutable pointer to the slice's buffer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1537433,"byte_end":1537478,"line_start":402,"line_end":402,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1537483,"byte_end":1537492,"line_start":403,"line_end":403,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6198},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1538071,"byte_end":1538075,"line_start":428,"line_end":428,"column_start":12,"column_end":16},"name":"swap","qualname":"<[T]>::swap","value":"fn (&mut self, a: usize, b: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps two elements in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1538000,"byte_end":1538045,"line_start":426,"line_end":426,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1538050,"byte_end":1538059,"line_start":427,"line_end":427,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6200},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1538681,"byte_end":1538688,"line_start":449,"line_end":449,"column_start":12,"column_end":19},"name":"reverse","qualname":"<[T]>::reverse","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Reverses the order of elements in the slice, in place.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1538610,"byte_end":1538655,"line_start":447,"line_end":447,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1538660,"byte_end":1538669,"line_start":448,"line_end":448,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6202},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1541934,"byte_end":1541938,"line_start":527,"line_end":527,"column_start":12,"column_end":16},"name":"iter","qualname":"<[T]>::iter","value":"fn (&self) -> Iter<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1541863,"byte_end":1541908,"line_start":525,"line_end":525,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1541913,"byte_end":1541922,"line_start":526,"line_end":526,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6204},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1542720,"byte_end":1542728,"line_start":559,"line_end":559,"column_start":12,"column_end":20},"name":"iter_mut","qualname":"<[T]>::iter_mut","value":"fn (&mut self) -> IterMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator that allows modifying each value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1542649,"byte_end":1542694,"line_start":557,"line_end":557,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1542699,"byte_end":1542708,"line_start":558,"line_end":558,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6206},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1544057,"byte_end":1544064,"line_start":606,"line_end":606,"column_start":12,"column_end":19},"name":"windows","qualname":"<[T]>::windows","value":"fn (&self, size: usize) -> Windows<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over all contiguous windows of length\n `size`. The windows overlap. If the slice is shorter than\n `size`, the iterator returns no values.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1543986,"byte_end":1544031,"line_start":604,"line_end":604,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1544036,"byte_end":1544045,"line_start":605,"line_end":605,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6208},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1545296,"byte_end":1545302,"line_start":640,"line_end":640,"column_start":12,"column_end":18},"name":"chunks","qualname":"<[T]>::chunks","value":"fn (&self, chunk_size: usize) -> Chunks<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1545225,"byte_end":1545270,"line_start":638,"line_end":638,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1545275,"byte_end":1545284,"line_start":639,"line_end":639,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6210},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1546572,"byte_end":1546582,"line_start":678,"line_end":678,"column_start":12,"column_end":22},"name":"chunks_mut","qualname":"<[T]>::chunks_mut","value":"fn (&mut self, chunk_size: usize) -> ChunksMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1546501,"byte_end":1546546,"line_start":676,"line_end":676,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1546551,"byte_end":1546560,"line_start":677,"line_end":677,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6212},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1548071,"byte_end":1548083,"line_start":715,"line_end":715,"column_start":12,"column_end":24},"name":"chunks_exact","qualname":"<[T]>::chunks_exact","value":"fn (&self, chunk_size: usize) -> ChunksExact<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1547992,"byte_end":1548045,"line_start":713,"line_end":713,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1548050,"byte_end":1548059,"line_start":714,"line_end":714,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6214},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1549761,"byte_end":1549777,"line_start":760,"line_end":760,"column_start":12,"column_end":28},"name":"chunks_exact_mut","qualname":"<[T]>::chunks_exact_mut","value":"fn (&mut self, chunk_size: usize) -> ChunksExactMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1549682,"byte_end":1549735,"line_start":758,"line_end":758,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1549740,"byte_end":1549749,"line_start":759,"line_end":759,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6216},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1551173,"byte_end":1551180,"line_start":797,"line_end":797,"column_start":12,"column_end":19},"name":"rchunks","qualname":"<[T]>::rchunks","value":"fn (&self, chunk_size: usize) -> RChunks<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1551099,"byte_end":1551147,"line_start":795,"line_end":795,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1551152,"byte_end":1551161,"line_start":796,"line_end":796,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6218},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1552443,"byte_end":1552454,"line_start":835,"line_end":835,"column_start":12,"column_end":23},"name":"rchunks_mut","qualname":"<[T]>::rchunks_mut","value":"fn (&mut self, chunk_size: usize) -> RChunksMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1552369,"byte_end":1552417,"line_start":833,"line_end":833,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1552422,"byte_end":1552431,"line_start":834,"line_end":834,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6220},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1553984,"byte_end":1553997,"line_start":874,"line_end":874,"column_start":12,"column_end":25},"name":"rchunks_exact","qualname":"<[T]>::rchunks_exact","value":"fn (&self, chunk_size: usize) -> RChunksExact<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1553910,"byte_end":1553958,"line_start":872,"line_end":872,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1553963,"byte_end":1553972,"line_start":873,"line_end":873,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6222},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1555667,"byte_end":1555684,"line_start":919,"line_end":919,"column_start":12,"column_end":29},"name":"rchunks_exact_mut","qualname":"<[T]>::rchunks_exact_mut","value":"fn (&mut self, chunk_size: usize) -> RChunksExactMut<'_, T>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1555593,"byte_end":1555641,"line_start":917,"line_end":917,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1555646,"byte_end":1555655,"line_start":918,"line_end":918,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6224},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1556896,"byte_end":1556904,"line_start":961,"line_end":961,"column_start":12,"column_end":20},"name":"split_at","qualname":"<[T]>::split_at","value":"fn (&self, mid: usize) -> (&[T], &[T])","parent":null,"children":[],"decl_id":null,"docs":" Divides one slice into two at an index.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1556825,"byte_end":1556870,"line_start":959,"line_end":959,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1556875,"byte_end":1556884,"line_start":960,"line_end":960,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6226},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1557795,"byte_end":1557807,"line_start":991,"line_end":991,"column_start":12,"column_end":24},"name":"split_at_mut","qualname":"<[T]>::split_at_mut","value":"fn (&mut self, mid: usize) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Divides one mutable slice into two at an index.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1557724,"byte_end":1557769,"line_start":989,"line_end":989,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1557774,"byte_end":1557783,"line_start":990,"line_end":990,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6228},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1559579,"byte_end":1559584,"line_start":1045,"line_end":1045,"column_start":12,"column_end":17},"name":"split","qualname":"<[T]>::split","value":"fn <F> (&self, pred: F) -> Split<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred`. The matched element is not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1559508,"byte_end":1559553,"line_start":1043,"line_end":1043,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1559558,"byte_end":1559567,"line_start":1044,"line_end":1044,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6230},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1560245,"byte_end":1560254,"line_start":1070,"line_end":1070,"column_start":12,"column_end":21},"name":"split_mut","qualname":"<[T]>::split_mut","value":"fn <F> (&mut self, pred: F) -> SplitMut<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over mutable subslices separated by elements that\n match `pred`. The matched element is not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1560174,"byte_end":1560219,"line_start":1068,"line_end":1068,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1560224,"byte_end":1560233,"line_start":1069,"line_end":1069,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6232},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1561512,"byte_end":1561518,"line_start":1105,"line_end":1105,"column_start":12,"column_end":18},"name":"rsplit","qualname":"<[T]>::rsplit","value":"fn <F> (&self, pred: F) -> RSplit<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred`, starting at the end of the slice and working backwards.\n The matched element is not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rsplit\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1561433,"byte_end":1561486,"line_start":1103,"line_end":1103,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1561491,"byte_end":1561500,"line_start":1104,"line_end":1104,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6234},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1562275,"byte_end":1562285,"line_start":1130,"line_end":1130,"column_start":12,"column_end":22},"name":"rsplit_mut","qualname":"<[T]>::rsplit_mut","value":"fn <F> (&mut self, pred: F) -> RSplitMut<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over mutable subslices separated by elements that\n match `pred`, starting at the end of the slice and working\n backwards. The matched element is not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rsplit\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1562196,"byte_end":1562249,"line_start":1128,"line_end":1128,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1562254,"byte_end":1562263,"line_start":1129,"line_end":1129,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6236},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1563125,"byte_end":1563131,"line_start":1157,"line_end":1157,"column_start":12,"column_end":18},"name":"splitn","qualname":"<[T]>::splitn","value":"fn <F> (&self, n: usize, pred: F) -> SplitN<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred`, limited to returning at most `n` items. The matched element is\n not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1563054,"byte_end":1563099,"line_start":1155,"line_end":1155,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1563104,"byte_end":1563113,"line_start":1156,"line_end":1156,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6238},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1563996,"byte_end":1564006,"line_start":1187,"line_end":1187,"column_start":12,"column_end":22},"name":"splitn_mut","qualname":"<[T]>::splitn_mut","value":"fn <F> (&mut self, n: usize, pred: F) -> SplitNMut<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred`, limited to returning at most `n` items. The matched element is\n not contained in the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1563925,"byte_end":1563970,"line_start":1185,"line_end":1185,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1563975,"byte_end":1563984,"line_start":1186,"line_end":1186,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6240},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565043,"byte_end":1565050,"line_start":1220,"line_end":1220,"column_start":12,"column_end":19},"name":"rsplitn","qualname":"<[T]>::rsplitn","value":"fn <F> (&self, n: usize, pred: F) -> RSplitN<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred` limited to returning at most `n` items. This starts at the end of\n the slice and works backwards. The matched element is not contained in\n the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1564972,"byte_end":1565017,"line_start":1218,"line_end":1218,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565022,"byte_end":1565031,"line_start":1219,"line_end":1219,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6242},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565983,"byte_end":1565994,"line_start":1251,"line_end":1251,"column_start":12,"column_end":23},"name":"rsplitn_mut","qualname":"<[T]>::rsplitn_mut","value":"fn <F> (&mut self, n: usize, pred: F) -> RSplitNMut<'_, T, F>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over subslices separated by elements that match\n `pred` limited to returning at most `n` items. This starts at the end of\n the slice and works backwards. The matched element is not contained in\n the subslices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565912,"byte_end":1565957,"line_start":1249,"line_end":1249,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1565962,"byte_end":1565971,"line_start":1250,"line_end":1250,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6244},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1566547,"byte_end":1566555,"line_start":1272,"line_end":1272,"column_start":12,"column_end":20},"name":"contains","qualname":"<[T]>::contains","value":"fn (&self, x: &T) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the slice contains an element with the given value.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1566490,"byte_end":1566535,"line_start":1271,"line_end":1271,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6246},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1567260,"byte_end":1567271,"line_start":1299,"line_end":1299,"column_start":12,"column_end":23},"name":"starts_with","qualname":"<[T]>::starts_with","value":"fn (&self, needle: &[T]) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `needle` is a prefix of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1567203,"byte_end":1567248,"line_start":1298,"line_end":1298,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6248},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1568018,"byte_end":1568027,"line_start":1327,"line_end":1327,"column_start":12,"column_end":21},"name":"ends_with","qualname":"<[T]>::ends_with","value":"fn (&self, needle: &[T]) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `needle` is a suffix of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1567961,"byte_end":1568006,"line_start":1326,"line_end":1326,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6250},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1569283,"byte_end":1569296,"line_start":1358,"line_end":1358,"column_start":12,"column_end":25},"name":"binary_search","qualname":"<[T]>::binary_search","value":"fn (&self, x: &T) -> Result<usize, usize>","parent":null,"children":[],"decl_id":null,"docs":" Binary searches this sorted slice for a given element.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1569226,"byte_end":1569271,"line_start":1357,"line_end":1357,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":6252},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570973,"byte_end":1570989,"line_start":1398,"line_end":1398,"column_start":12,"column_end":28},"name":"binary_search_by","qualname":"<[T]>::binary_search_by","value":"fn <'a, F> (&'a self, mut f: F) -> Result<usize, usize>","parent":null,"children":[],"decl_id":null,"docs":" Binary searches this sorted slice with a comparator function.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570902,"byte_end":1570947,"line_start":1396,"line_end":1396,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1570952,"byte_end":1570961,"line_start":1397,"line_end":1397,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6254},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1573444,"byte_end":1573464,"line_start":1456,"line_end":1456,"column_start":12,"column_end":32},"name":"binary_search_by_key","qualname":"<[T]>::binary_search_by_key","value":"fn <'a, B, F> (&'a self, b: &B, mut f: F) -> Result<usize, usize>","parent":null,"children":[],"decl_id":null,"docs":" Binary searches this sorted slice with a key extraction function.","sig":null,"attributes":[{"value":"stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1573351,"byte_end":1573418,"line_start":1454,"line_end":1454,"column_start":5,"column_end":72}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1573423,"byte_end":1573432,"line_start":1455,"line_end":1455,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6256},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1574810,"byte_end":1574823,"line_start":1491,"line_end":1491,"column_start":12,"column_end":25},"name":"sort_unstable","qualname":"<[T]>::sort_unstable","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts the slice, but may not preserve the order of equal elements.","sig":null,"attributes":[{"value":"stable(feature = \"sort_unstable\", since = \"1.20.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1574730,"byte_end":1574784,"line_start":1489,"line_end":1489,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1574789,"byte_end":1574798,"line_start":1490,"line_end":1490,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6258},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1577064,"byte_end":1577080,"line_start":1545,"line_end":1545,"column_start":12,"column_end":28},"name":"sort_unstable_by","qualname":"<[T]>::sort_unstable_by","value":"fn <F> (&mut self, mut compare: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts the slice with a comparator function, but may not preserve the order of equal\n elements.","sig":null,"attributes":[{"value":"stable(feature = \"sort_unstable\", since = \"1.20.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1576984,"byte_end":1577038,"line_start":1543,"line_end":1543,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1577043,"byte_end":1577052,"line_start":1544,"line_end":1544,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6260},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1578586,"byte_end":1578606,"line_start":1582,"line_end":1582,"column_start":12,"column_end":32},"name":"sort_unstable_by_key","qualname":"<[T]>::sort_unstable_by_key","value":"fn <K, F> (&mut self, mut f: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sorts the slice with a key extraction function, but may not preserve the order of equal\n elements.","sig":null,"attributes":[{"value":"stable(feature = \"sort_unstable\", since = \"1.20.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1578506,"byte_end":1578560,"line_start":1580,"line_end":1580,"column_start":5,"column_end":59}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1578565,"byte_end":1578574,"line_start":1581,"line_end":1581,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6262},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1580450,"byte_end":1580468,"line_start":1628,"line_end":1628,"column_start":12,"column_end":30},"name":"partition_at_index","qualname":"<[T]>::partition_at_index","value":"fn (&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Reorder the slice such that the element at `index` is at its final sorted position.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_at_index\", issue = \"55300\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1580358,"byte_end":1580424,"line_start":1626,"line_end":1626,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1580429,"byte_end":1580438,"line_start":1627,"line_end":1627,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6264},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1582548,"byte_end":1582569,"line_start":1677,"line_end":1677,"column_start":12,"column_end":33},"name":"partition_at_index_by","qualname":"<[T]>::partition_at_index_by","value":"fn <F> (&mut self, index: usize, mut compare: F) -> (&mut [T], &mut T, &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Reorder the slice with a comparator function such that the element at `index` is at its\n final sorted position.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_at_index\", issue = \"55300\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1582456,"byte_end":1582522,"line_start":1675,"line_end":1675,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1582527,"byte_end":1582536,"line_start":1676,"line_end":1676,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6266},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1584762,"byte_end":1584787,"line_start":1727,"line_end":1727,"column_start":12,"column_end":37},"name":"partition_at_index_by_key","qualname":"<[T]>::partition_at_index_by_key","value":"fn <K, F> (&mut self, index: usize, mut f: F) -> (&mut [T], &mut T, &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Reorder the slice with a key extraction function such that the element at `index` is at its\n final sorted position.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_at_index\", issue = \"55300\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1584670,"byte_end":1584736,"line_start":1725,"line_end":1725,"column_start":5,"column_end":71}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1584741,"byte_end":1584750,"line_start":1726,"line_end":1726,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6268},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1585858,"byte_end":1585873,"line_start":1757,"line_end":1757,"column_start":12,"column_end":27},"name":"partition_dedup","qualname":"<[T]>::partition_dedup","value":"fn (&mut self) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Moves all consecutive repeated elements to the end of the slice according to the\n [`PartialEq`] trait implementation.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_dedup\", issue = \"54279\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1585769,"byte_end":1585832,"line_start":1755,"line_end":1755,"column_start":5,"column_end":68}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1585837,"byte_end":1585846,"line_start":1756,"line_end":1756,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6270},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1587192,"byte_end":1587210,"line_start":1790,"line_end":1790,"column_start":12,"column_end":30},"name":"partition_dedup_by","qualname":"<[T]>::partition_dedup_by","value":"fn <F> (&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Moves all but the first of consecutive elements to the end of the slice satisfying\n a given equality relation.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_dedup\", issue = \"54279\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1587103,"byte_end":1587166,"line_start":1788,"line_end":1788,"column_start":5,"column_end":68}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1587171,"byte_end":1587180,"line_start":1789,"line_end":1789,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6272},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1591287,"byte_end":1591309,"line_start":1900,"line_end":1900,"column_start":12,"column_end":34},"name":"partition_dedup_by_key","qualname":"<[T]>::partition_dedup_by_key","value":"fn <K, F> (&mut self, mut key: F) -> (&mut [T], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Moves all but the first of consecutive elements to the end of the slice that resolve\n to the same key.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_partition_dedup\", issue = \"54279\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1591198,"byte_end":1591261,"line_start":1898,"line_end":1898,"column_start":5,"column_end":68}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1591266,"byte_end":1591275,"line_start":1899,"line_end":1899,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6274},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1592549,"byte_end":1592560,"line_start":1938,"line_end":1938,"column_start":12,"column_end":23},"name":"rotate_left","qualname":"<[T]>::rotate_left","value":"fn (&mut self, mid: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Rotates the slice in-place such that the first `mid` elements of the\n slice move to the end while the last `self.len() - mid` elements move to\n the front. After calling `rotate_left`, the element previously at index\n `mid` will become the first element in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rotate\", since = \"1.26.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1592484,"byte_end":1592537,"line_start":1937,"line_end":1937,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":6276},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1593837,"byte_end":1593849,"line_start":1979,"line_end":1979,"column_start":12,"column_end":24},"name":"rotate_right","qualname":"<[T]>::rotate_right","value":"fn (&mut self, k: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Rotates the slice in-place such that the first `self.len() - k`\n elements of the slice move to the end while the last `k` elements move\n to the front. After calling `rotate_right`, the element previously at\n index `self.len() - k` will become the first element in the slice.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rotate\", since = \"1.26.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1593772,"byte_end":1593825,"line_start":1978,"line_end":1978,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":6278},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1595883,"byte_end":1595899,"line_start":2045,"line_end":2045,"column_start":12,"column_end":28},"name":"clone_from_slice","qualname":"<[T]>::clone_from_slice","value":"fn (&mut self, src: &[T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies the elements from `src` into `self`.","sig":null,"attributes":[{"value":"stable(feature = \"clone_from_slice\", since = \"1.7.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1595815,"byte_end":1595871,"line_start":2044,"line_end":2044,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":6280},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1598203,"byte_end":1598218,"line_start":2114,"line_end":2114,"column_start":12,"column_end":27},"name":"copy_from_slice","qualname":"<[T]>::copy_from_slice","value":"fn (&mut self, src: &[T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies all elements from `src` into `self`, using a memcpy.","sig":null,"attributes":[{"value":"stable(feature = \"copy_from_slice\", since = \"1.9.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1598136,"byte_end":1598191,"line_start":2113,"line_end":2113,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":6282},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1599427,"byte_end":1599438,"line_start":2149,"line_end":2149,"column_start":12,"column_end":23},"name":"copy_within","qualname":"<[T]>::copy_within","value":"fn <R> (&mut self, src: R, dest: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies elements from one part of the slice to another part of itself,\n using a memmove.","sig":null,"attributes":[{"value":"unstable(feature = \"copy_within\", issue = \"54236\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1599362,"byte_end":1599415,"line_start":2148,"line_end":2148,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":6284},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1602024,"byte_end":1602039,"line_start":2228,"line_end":2228,"column_start":12,"column_end":27},"name":"swap_with_slice","qualname":"<[T]>::swap_with_slice","value":"fn (&mut self, other: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Swaps all elements in `self` with those in `other`.","sig":null,"attributes":[{"value":"stable(feature = \"swap_with_slice\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1601956,"byte_end":1602012,"line_start":2227,"line_end":2227,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":6292},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1606321,"byte_end":1606329,"line_start":2328,"line_end":2328,"column_start":19,"column_end":27},"name":"align_to","qualname":"<[T]>::align_to","value":"fn <U> (&self) -> (&[T], &[U], &[T])","parent":null,"children":[],"decl_id":null,"docs":" Transmute the slice to a slice of another type, ensuring alignment of the types is\n maintained.","sig":null,"attributes":[{"value":"stable(feature = \"slice_align_to\", since = \"1.30.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1606247,"byte_end":1606302,"line_start":2327,"line_end":2327,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":6294},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1608717,"byte_end":1608729,"line_start":2381,"line_end":2381,"column_start":19,"column_end":31},"name":"align_to_mut","qualname":"<[T]>::align_to_mut","value":"fn <U> (&mut self) -> (&mut [T], &mut [U], &mut [T])","parent":null,"children":[],"decl_id":null,"docs":" Transmute the slice to a slice of another type, ensuring alignment of the types is\n maintained.","sig":null,"attributes":[{"value":"stable(feature = \"slice_align_to\", since = \"1.30.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1608643,"byte_end":1608698,"line_start":2380,"line_end":2380,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":6296},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1610677,"byte_end":1610686,"line_start":2428,"line_end":2428,"column_start":12,"column_end":21},"name":"is_sorted","qualname":"<[T]>::is_sorted","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the elements of this slice are sorted.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1610580,"byte_end":1610589,"line_start":2426,"line_end":2426,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1610594,"byte_end":1610665,"line_start":2427,"line_end":2427,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":6298},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1611290,"byte_end":1611302,"line_start":2443,"line_end":2443,"column_start":12,"column_end":24},"name":"is_sorted_by","qualname":"<[T]>::is_sorted_by","value":"fn <F> (&self, mut compare: F) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the elements of this slice are sorted using the given comparator function.","sig":null,"attributes":[{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1611207,"byte_end":1611278,"line_start":2442,"line_end":2442,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":6300},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612191,"byte_end":1612207,"line_start":2468,"line_end":2468,"column_start":12,"column_end":28},"name":"is_sorted_by_key","qualname":"<[T]>::is_sorted_by_key","value":"fn <F, K> (&self, mut f: F) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if the elements of this slice are sorted using the given key extraction function.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612094,"byte_end":1612103,"line_start":2466,"line_end":2466,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612108,"byte_end":1612179,"line_start":2467,"line_end":2467,"column_start":5,"column_end":76}}]},{"kind":"Method","id":{"krate":0,"index":6304},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612590,"byte_end":1612598,"line_start":2483,"line_end":2483,"column_start":12,"column_end":20},"name":"is_ascii","qualname":"<[u8]>::is_ascii","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if all bytes in this slice are within the ASCII range.\n","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612496,"byte_end":1612564,"line_start":2481,"line_end":2481,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612569,"byte_end":1612578,"line_start":2482,"line_end":2482,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6306},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612961,"byte_end":1612981,"line_start":2493,"line_end":2493,"column_start":12,"column_end":32},"name":"eq_ignore_ascii_case","qualname":"<[u8]>::eq_ignore_ascii_case","value":"fn (&self, other: &[u8]) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that two slices are an ASCII case-insensitive match.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612867,"byte_end":1612935,"line_start":2491,"line_end":2491,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1612940,"byte_end":1612949,"line_start":2492,"line_end":2492,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6308},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1613635,"byte_end":1613655,"line_start":2511,"line_end":2511,"column_start":12,"column_end":32},"name":"make_ascii_uppercase","qualname":"<[u8]>::make_ascii_uppercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this slice to its ASCII upper case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1613541,"byte_end":1613609,"line_start":2509,"line_end":2509,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1613614,"byte_end":1613623,"line_start":2510,"line_end":2510,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":6310},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1614225,"byte_end":1614245,"line_start":2528,"line_end":2528,"column_start":12,"column_end":32},"name":"make_ascii_lowercase","qualname":"<[u8]>::make_ascii_lowercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this slice to its ASCII lower case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1614131,"byte_end":1614199,"line_start":2526,"line_end":2526,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1614204,"byte_end":1614213,"line_start":2527,"line_end":2527,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":6332},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615364,"byte_end":1615370,"line_start":2579,"line_end":2579,"column_start":15,"column_end":21},"name":"Sealed","qualname":"::slice::private_slice_index::Sealed","value":"Sealed","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"stable(feature = \"slice_get_slice\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615293,"byte_end":1615349,"line_start":2578,"line_end":2578,"column_start":5,"column_end":61}}]},{"kind":"Trait","id":{"krate":0,"index":6348},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616736,"byte_end":1616746,"line_start":2612,"line_end":2612,"column_start":11,"column_end":21},"name":"SliceIndex","qualname":"::slice::SliceIndex","value":"SliceIndex<T: ?Sized>: private_slice_index::Sealed","parent":null,"children":[{"krate":0,"index":6350},{"krate":0,"index":6352},{"krate":0,"index":6354},{"krate":0,"index":6356},{"krate":0,"index":6358},{"krate":0,"index":6360},{"krate":0,"index":6362}],"decl_id":null,"docs":" A helper trait used for indexing operations.\n","sig":null,"attributes":[{"value":"stable(feature = \"slice_get_slice\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616152,"byte_end":1616208,"line_start":2598,"line_end":2598,"column_start":1,"column_end":57}},{"value":"rustc_on_unimplemented(on(T = \"str\",\n                            label = \"string indices are ranges of `usize`\"),\n                         on(all(any(T = \"str\",\n                                    T = \"&str\",\n                                    T = \"std::string::String\"),\n                                _Self = \"{integer}\"),\n                            note =\n                                \"you can use `.chars().nth()` or `.bytes().nth()`\\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"),\n                         message =\n                             \"the type `{T}` cannot be indexed by `{Self}`\",\n                         label =\n                             \"slice indices are of type `usize` or ranges of `usize`\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616209,"byte_end":1616725,"line_start":2599,"line_end":2611,"column_start":1,"column_end":3}}]},{"kind":"Type","id":{"krate":0,"index":6350},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616904,"byte_end":1616910,"line_start":2615,"line_end":2615,"column_start":10,"column_end":16},"name":"Output","qualname":"::slice::SliceIndex::Output","value":"type Output: ?Sized;","parent":{"krate":0,"index":6348},"children":[],"decl_id":null,"docs":" The output type returned by methods.\n","sig":null,"attributes":[{"value":"stable(feature = \"slice_get_slice\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616838,"byte_end":1616894,"line_start":2614,"line_end":2614,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":6352},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617079,"byte_end":1617082,"line_start":2620,"line_end":2620,"column_start":8,"column_end":11},"name":"get","qualname":"::slice::SliceIndex::get","value":"fn (self, slice: &T) -> Option<&Self::Output>","parent":{"krate":0,"index":6348},"children":[],"decl_id":null,"docs":" Returns a shared reference to the output at this location, if in\n bounds.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617014,"byte_end":1617071,"line_start":2619,"line_end":2619,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":6354},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617286,"byte_end":1617293,"line_start":2625,"line_end":2625,"column_start":8,"column_end":15},"name":"get_mut","qualname":"::slice::SliceIndex::get_mut","value":"fn (self, slice: &mut T) -> Option<&mut Self::Output>","parent":{"krate":0,"index":6348},"children":[],"decl_id":null,"docs":" Returns a mutable reference to the output at this location, if in\n bounds.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617221,"byte_end":1617278,"line_start":2624,"line_end":2624,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":6356},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617537,"byte_end":1617550,"line_start":2630,"line_end":2630,"column_start":15,"column_end":28},"name":"get_unchecked","qualname":"::slice::SliceIndex::get_unchecked","value":"fn (self, slice: &T) -> &Self::Output","parent":{"krate":0,"index":6348},"children":[],"decl_id":null,"docs":" Returns a shared reference to the output at this location, without\n performing any bounds checking.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617465,"byte_end":1617522,"line_start":2629,"line_end":2629,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":6358},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617779,"byte_end":1617796,"line_start":2635,"line_end":2635,"column_start":15,"column_end":32},"name":"get_unchecked_mut","qualname":"::slice::SliceIndex::get_unchecked_mut","value":"fn (self, slice: &mut T) -> &mut Self::Output","parent":{"krate":0,"index":6348},"children":[],"decl_id":null,"docs":" Returns a mutable reference to the output at this location, without\n performing any bounds checking.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617707,"byte_end":1617764,"line_start":2634,"line_end":2634,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":6360},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1618013,"byte_end":1618018,"line_start":2640,"line_end":2640,"column_start":8,"column_end":13},"name":"index","qualname":"::slice::SliceIndex::index","value":"fn (self, slice: &T) -> &Self::Output","parent":{"krate":0,"index":6348},"children":[],"decl_id":null,"docs":" Returns a shared reference to the output at this location, panicking\n if out of bounds.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1617948,"byte_end":1618005,"line_start":2639,"line_end":2639,"column_start":5,"column_end":62}}]},{"kind":"Method","id":{"krate":0,"index":6362},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1618228,"byte_end":1618237,"line_start":2645,"line_end":2645,"column_start":8,"column_end":17},"name":"index_mut","qualname":"::slice::SliceIndex::index_mut","value":"fn (self, slice: &mut T) -> &mut Self::Output","parent":{"krate":0,"index":6348},"children":[],"decl_id":null,"docs":" Returns a mutable reference to the output at this location, panicking\n if out of bounds.\n","sig":null,"attributes":[{"value":"unstable(feature = \"slice_index_methods\", issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1618163,"byte_end":1618220,"line_start":2644,"line_end":2644,"column_start":5,"column_end":62}}]},{"kind":"Struct","id":{"krate":0,"index":6508},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1637395,"byte_end":1637399,"line_start":3277,"line_end":3277,"column_start":12,"column_end":16},"name":"Iter","qualname":"::slice::Iter","value":"Iter {  }","parent":null,"children":[{"krate":0,"index":3757},{"krate":0,"index":3759},{"krate":0,"index":3761}],"decl_id":null,"docs":" Immutable slice iterator","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1637338,"byte_end":1637383,"line_start":3276,"line_end":3276,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6520},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1639085,"byte_end":1639093,"line_start":3325,"line_end":3325,"column_start":12,"column_end":20},"name":"as_slice","qualname":"<Iter>::as_slice","value":"fn (&self) -> &'a [T]","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"stable(feature = \"iter_to_slice\", since = \"1.4.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1639020,"byte_end":1639073,"line_start":3324,"line_end":3324,"column_start":5,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":6530},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1640535,"byte_end":1640542,"line_start":3379,"line_end":3379,"column_start":12,"column_end":19},"name":"IterMut","qualname":"::slice::IterMut","value":"IterMut {  }","parent":null,"children":[{"krate":0,"index":3781},{"krate":0,"index":3783},{"krate":0,"index":3785}],"decl_id":null,"docs":" Mutable slice iterator.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1640478,"byte_end":1640523,"line_start":3378,"line_end":3378,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":6542},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1642536,"byte_end":1642546,"line_start":3436,"line_end":3436,"column_start":12,"column_end":22},"name":"into_slice","qualname":"<IterMut>::into_slice","value":"fn (self) -> &'a mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"stable(feature = \"iter_to_slice\", since = \"1.4.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1642471,"byte_end":1642524,"line_start":3435,"line_end":3435,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":6544},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1643569,"byte_end":1643577,"line_start":3464,"line_end":3464,"column_start":12,"column_end":20},"name":"as_slice","qualname":"<IterMut>::as_slice","value":"fn (&self) -> &[T]","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"unstable(feature = \"slice_iter_mut_as_slice\",\n           reason = \"recently added\",\n           issue = \"58957\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1643465,"byte_end":1643557,"line_start":3463,"line_end":3463,"column_start":5,"column_end":97}}]},{"kind":"Method","id":{"krate":0,"index":6548},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1643979,"byte_end":1643985,"line_start":3477,"line_end":3477,"column_start":8,"column_end":14},"name":"finish","qualname":"::slice::SplitIter::finish","value":"fn (&mut self) -> Option<Self::Item>","parent":{"krate":0,"index":6546},"children":[],"decl_id":null,"docs":" Marks the underlying iterator as complete, extracting the remaining\n portion of the slice.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":6550},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1644346,"byte_end":1644351,"line_start":3488,"line_end":3488,"column_start":12,"column_end":17},"name":"Split","qualname":"::slice::Split","value":"Split {  }","parent":null,"children":[{"krate":0,"index":3803},{"krate":0,"index":3805},{"krate":0,"index":3807}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a predicate\n function.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1644289,"byte_end":1644334,"line_start":3487,"line_end":3487,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":6578},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647029,"byte_end":1647037,"line_start":3579,"line_end":3579,"column_start":12,"column_end":20},"name":"SplitMut","qualname":"::slice::SplitMut","value":"SplitMut {  }","parent":null,"children":[{"krate":0,"index":3849},{"krate":0,"index":3851},{"krate":0,"index":3853}],"decl_id":null,"docs":" An iterator over the subslices of the vector which are separated\n by elements that match `pred`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1646972,"byte_end":1647017,"line_start":3578,"line_end":3578,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42798},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650152,"byte_end":1650158,"line_start":3678,"line_end":3678,"column_start":12,"column_end":18},"name":"RSplit","qualname":"::slice::RSplit","value":"RSplit {  }","parent":null,"children":[{"krate":0,"index":23161}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a predicate\n function, starting from the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rsplit\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650007,"byte_end":1650060,"line_start":3676,"line_end":3676,"column_start":1,"column_end":54}}]},{"kind":"Struct","id":{"krate":0,"index":6624},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651934,"byte_end":1651943,"line_start":3734,"line_end":3734,"column_start":12,"column_end":21},"name":"RSplitMut","qualname":"::slice::RSplitMut","value":"RSplitMut {  }","parent":null,"children":[{"krate":0,"index":3917}],"decl_id":null,"docs":" An iterator over the subslices of the vector which are separated\n by elements that match `pred`, starting from the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"slice_rsplit\", since = \"1.27.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651869,"byte_end":1651922,"line_start":3733,"line_end":3733,"column_start":1,"column_end":54}}]},{"kind":"Struct","id":{"krate":0,"index":6656},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654462,"byte_end":1654468,"line_start":3820,"line_end":3820,"column_start":12,"column_end":18},"name":"SplitN","qualname":"::slice::SplitN","value":"SplitN {  }","parent":null,"children":[{"krate":0,"index":3957}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a predicate\n function, limited to a given number of splits.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654405,"byte_end":1654450,"line_start":3819,"line_end":3819,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":6662},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1655271,"byte_end":1655278,"line_start":3842,"line_end":3842,"column_start":12,"column_end":19},"name":"RSplitN","qualname":"::slice::RSplitN","value":"RSplitN {  }","parent":null,"children":[{"krate":0,"index":3969}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a\n predicate function, limited to a given number of splits, starting\n from the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1655214,"byte_end":1655259,"line_start":3841,"line_end":3841,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":6668},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1656053,"byte_end":1656062,"line_start":3863,"line_end":3863,"column_start":12,"column_end":21},"name":"SplitNMut","qualname":"::slice::SplitNMut","value":"SplitNMut {  }","parent":null,"children":[{"krate":0,"index":3981}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a predicate\n function, limited to a given number of splits.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1655996,"byte_end":1656041,"line_start":3862,"line_end":3862,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":6674},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1656886,"byte_end":1656896,"line_start":3885,"line_end":3885,"column_start":12,"column_end":22},"name":"RSplitNMut","qualname":"::slice::RSplitNMut","value":"RSplitNMut {  }","parent":null,"children":[{"krate":0,"index":3993}],"decl_id":null,"docs":" An iterator over subslices separated by elements that match a\n predicate function, limited to a given number of splits, starting\n from the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1656829,"byte_end":1656874,"line_start":3884,"line_end":3884,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42850},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1658523,"byte_end":1658530,"line_start":3936,"line_end":3936,"column_start":12,"column_end":19},"name":"Windows","qualname":"::slice::Windows","value":"Windows {  }","parent":null,"children":[{"krate":0,"index":23229},{"krate":0,"index":23231}],"decl_id":null,"docs":" An iterator over overlapping subslices of length `size`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1658466,"byte_end":1658511,"line_start":3935,"line_end":3935,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42856},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661899,"byte_end":1661905,"line_start":4062,"line_end":4062,"column_start":12,"column_end":18},"name":"Chunks","qualname":"::slice::Chunks","value":"Chunks {  }","parent":null,"children":[{"krate":0,"index":23241},{"krate":0,"index":23243}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n time), starting at the beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661842,"byte_end":1661887,"line_start":4061,"line_end":4061,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42862},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1665638,"byte_end":1665647,"line_start":4189,"line_end":4189,"column_start":12,"column_end":21},"name":"ChunksMut","qualname":"::slice::ChunksMut","value":"ChunksMut {  }","parent":null,"children":[{"krate":0,"index":23253},{"krate":0,"index":23255}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1665581,"byte_end":1665626,"line_start":4188,"line_end":4188,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":42868},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1669581,"byte_end":1669592,"line_start":4312,"line_end":4312,"column_start":12,"column_end":23},"name":"ChunksExact","qualname":"::slice::ChunksExact","value":"ChunksExact {  }","parent":null,"children":[{"krate":0,"index":23265},{"krate":0,"index":23267},{"krate":0,"index":23269}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n time), starting at the beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1669516,"byte_end":1669569,"line_start":4311,"line_end":4311,"column_start":1,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6784},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1669940,"byte_end":1669949,"line_start":4323,"line_end":4323,"column_start":12,"column_end":21},"name":"remainder","qualname":"<ChunksExact>::remainder","value":"fn (&self) -> &'a [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1669875,"byte_end":1669928,"line_start":4322,"line_end":4322,"column_start":5,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":42874},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1673238,"byte_end":1673252,"line_start":4436,"line_end":4436,"column_start":12,"column_end":26},"name":"ChunksExactMut","qualname":"::slice::ChunksExactMut","value":"ChunksExactMut {  }","parent":null,"children":[{"krate":0,"index":23279},{"krate":0,"index":23281},{"krate":0,"index":23283}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the beginning of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1673173,"byte_end":1673226,"line_start":4435,"line_end":4435,"column_start":1,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":6824},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1673611,"byte_end":1673625,"line_start":4447,"line_end":4447,"column_start":12,"column_end":26},"name":"into_remainder","qualname":"<ChunksExactMut>::into_remainder","value":"fn (self) -> &'a mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n","sig":null,"attributes":[{"value":"stable(feature = \"chunks_exact\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1673546,"byte_end":1673599,"line_start":4446,"line_end":4446,"column_start":5,"column_end":58}}]},{"kind":"Struct","id":{"krate":0,"index":42880},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676655,"byte_end":1676662,"line_start":4550,"line_end":4550,"column_start":12,"column_end":19},"name":"RChunks","qualname":"::slice::RChunks","value":"RChunks {  }","parent":null,"children":[{"krate":0,"index":23293},{"krate":0,"index":23295}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n time), starting at the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676595,"byte_end":1676643,"line_start":4549,"line_end":4549,"column_start":1,"column_end":49}}]},{"kind":"Struct","id":{"krate":0,"index":42886},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1680553,"byte_end":1680563,"line_start":4681,"line_end":4681,"column_start":12,"column_end":22},"name":"RChunksMut","qualname":"::slice::RChunksMut","value":"RChunksMut {  }","parent":null,"children":[{"krate":0,"index":23305},{"krate":0,"index":23307}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1680493,"byte_end":1680541,"line_start":4680,"line_end":4680,"column_start":1,"column_end":49}}]},{"kind":"Struct","id":{"krate":0,"index":42892},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684646,"byte_end":1684658,"line_start":4808,"line_end":4808,"column_start":12,"column_end":24},"name":"RChunksExact","qualname":"::slice::RChunksExact","value":"RChunksExact {  }","parent":null,"children":[{"krate":0,"index":23317},{"krate":0,"index":23319},{"krate":0,"index":23321}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n time), starting at the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684586,"byte_end":1684634,"line_start":4807,"line_end":4807,"column_start":1,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":6924},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685002,"byte_end":1685011,"line_start":4819,"line_end":4819,"column_start":12,"column_end":21},"name":"remainder","qualname":"<RChunksExact>::remainder","value":"fn (&self) -> &'a [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684942,"byte_end":1684990,"line_start":4818,"line_end":4818,"column_start":5,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":42898},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688358,"byte_end":1688373,"line_start":4933,"line_end":4933,"column_start":12,"column_end":27},"name":"RChunksExactMut","qualname":"::slice::RChunksExactMut","value":"RChunksExactMut {  }","parent":null,"children":[{"krate":0,"index":23331},{"krate":0,"index":23333},{"krate":0,"index":23335}],"decl_id":null,"docs":" An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the end of the slice.","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688298,"byte_end":1688346,"line_start":4932,"line_end":4932,"column_start":1,"column_end":49}}]},{"kind":"Method","id":{"krate":0,"index":6964},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688728,"byte_end":1688742,"line_start":4944,"line_end":4944,"column_start":12,"column_end":26},"name":"into_remainder","qualname":"<RChunksExactMut>::into_remainder","value":"fn (self) -> &'a mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n","sig":null,"attributes":[{"value":"stable(feature = \"rchunks\", since = \"1.31.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688668,"byte_end":1688716,"line_start":4943,"line_end":4943,"column_start":5,"column_end":53}}]},{"kind":"Function","id":{"krate":0,"index":6998},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1693029,"byte_end":1693043,"line_start":5084,"line_end":5084,"column_start":15,"column_end":29},"name":"from_raw_parts","qualname":"::slice::from_raw_parts","value":"fn <'a, T> (data: *const T, len: usize) -> &'a [T]","parent":null,"children":[],"decl_id":null,"docs":" Forms a slice from a pointer and a length.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1692959,"byte_end":1692968,"line_start":5082,"line_end":5082,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1692969,"byte_end":1693014,"line_start":5083,"line_end":5083,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":7000},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694071,"byte_end":1694089,"line_start":5105,"line_end":5105,"column_start":15,"column_end":33},"name":"from_raw_parts_mut","qualname":"::slice::from_raw_parts_mut","value":"fn <'a, T> (data: *mut T, len: usize) -> &'a mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694001,"byte_end":1694010,"line_start":5103,"line_end":5103,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694011,"byte_end":1694056,"line_start":5104,"line_end":5104,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":7002},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694581,"byte_end":1694589,"line_start":5114,"line_end":5114,"column_start":8,"column_end":16},"name":"from_ref","qualname":"::slice::from_ref","value":"fn <T> (s: &T) -> &[T]","parent":null,"children":[],"decl_id":null,"docs":" Converts a reference to T into a slice of length 1 (without copying).\n","sig":null,"attributes":[{"value":"stable(feature = \"from_ref\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694524,"byte_end":1694573,"line_start":5113,"line_end":5113,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7004},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694792,"byte_end":1694800,"line_start":5122,"line_end":5122,"column_start":8,"column_end":16},"name":"from_mut","qualname":"::slice::from_mut","value":"fn <T> (s: &mut T) -> &mut [T]","parent":null,"children":[],"decl_id":null,"docs":" Converts a reference to T into a slice of length 1 (without copying).\n","sig":null,"attributes":[{"value":"stable(feature = \"from_ref\", since = \"1.28.0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694735,"byte_end":1694784,"line_start":5121,"line_end":5121,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":7006},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1695080,"byte_end":1695088,"line_start":5131,"line_end":5131,"column_start":8,"column_end":16},"name":"heapsort","qualname":"::slice::heapsort","value":"fn <T, F> (v: &mut [T], mut is_less: F) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"sort_internals\",\n           reason = \"internal to sort module\",\n           issue = \"0\")","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1694969,"byte_end":1695057,"line_start":5129,"line_end":5129,"column_start":1,"column_end":89}}]},{"kind":"Method","id":{"krate":0,"index":7028},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1696493,"byte_end":1696498,"line_start":5185,"line_end":5185,"column_start":8,"column_end":13},"name":"equal","qualname":"::slice::SlicePartialEq::equal","value":"fn (&self, other: &[B]) -> bool","parent":{"krate":0,"index":7026},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7030},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1696536,"byte_end":1696545,"line_start":5187,"line_end":5187,"column_start":8,"column_end":17},"name":"not_equal","qualname":"::slice::SlicePartialEq::not_equal","value":"fn (&self, other: &[B]) -> bool","parent":{"krate":0,"index":7026},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7042},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1697605,"byte_end":1697620,"line_start":5231,"line_end":5231,"column_start":8,"column_end":23},"name":"partial_compare","qualname":"::slice::SlicePartialOrd::partial_compare","value":"fn (&self, other: &[B]) -> Option<Ordering>","parent":{"krate":0,"index":7040},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7054},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1698535,"byte_end":1698542,"line_start":5267,"line_end":5267,"column_start":8,"column_end":15},"name":"compare","qualname":"::slice::SliceOrd::compare","value":"fn (&self, other: &[B]) -> Ordering","parent":{"krate":0,"index":7052},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7082},"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700540,"byte_end":1700554,"line_start":5344,"line_end":5344,"column_start":8,"column_end":22},"name":"slice_contains","qualname":"::slice::SliceContains::slice_contains","value":"fn (&self, x: &[Self]) -> bool","parent":{"krate":0,"index":7080},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7096},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"str","qualname":"::str","value":"src/libcore/str/mod.rs","parent":null,"children":[{"krate":0,"index":7098},{"krate":0,"index":7100},{"krate":0,"index":7108},{"krate":0,"index":7110},{"krate":0,"index":7116},{"krate":0,"index":7130},{"krate":0,"index":7138},{"krate":0,"index":7146},{"krate":0,"index":7148},{"krate":0,"index":7150},{"krate":0,"index":7152},{"krate":0,"index":7358},{"krate":0,"index":7404},{"krate":0,"index":7410},{"krate":0,"index":43100},{"krate":0,"index":43116},{"krate":0,"index":43112},{"krate":0,"index":43106},{"krate":0,"index":43102},{"krate":0,"index":7416},{"krate":0,"index":43120},{"krate":0,"index":43140},{"krate":0,"index":43136},{"krate":0,"index":43130},{"krate":0,"index":43126},{"krate":0,"index":43122},{"krate":0,"index":7420},{"krate":0,"index":7426},{"krate":0,"index":7428},{"krate":0,"index":7430},{"krate":0,"index":7432},{"krate":0,"index":7434},{"krate":0,"index":43142},{"krate":0,"index":43148},{"krate":0,"index":43144},{"krate":0,"index":7438},{"krate":0,"index":7440},{"krate":0,"index":7442},{"krate":0,"index":7444},{"krate":0,"index":7446},{"krate":0,"index":7448},{"krate":0,"index":7450},{"krate":0,"index":7462},{"krate":0,"index":7466},{"krate":0,"index":7468},{"krate":0,"index":43152},{"krate":0,"index":43158},{"krate":0,"index":43154},{"krate":0,"index":7472},{"krate":0,"index":7484},{"krate":0,"index":7488},{"krate":0,"index":7490},{"krate":0,"index":43162},{"krate":0,"index":43168},{"krate":0,"index":43164},{"krate":0,"index":7494},{"krate":0,"index":7518},{"krate":0,"index":7526},{"krate":0,"index":7532},{"krate":0,"index":7534},{"krate":0,"index":7536},{"krate":0,"index":7542},{"krate":0,"index":7544},{"krate":0,"index":43172},{"krate":0,"index":7546},{"krate":0,"index":7548},{"krate":0,"index":7552},{"krate":0,"index":43176},{"krate":0,"index":43178},{"krate":0,"index":43182},{"krate":0,"index":43188},{"krate":0,"index":43192},{"krate":0,"index":43194},{"krate":0,"index":43198},{"krate":0,"index":43204},{"krate":0,"index":43208},{"krate":0,"index":43210},{"krate":0,"index":43212},{"krate":0,"index":43216},{"krate":0,"index":43220},{"krate":0,"index":43222},{"krate":0,"index":43226},{"krate":0,"index":43232},{"krate":0,"index":43236},{"krate":0,"index":43238},{"krate":0,"index":43242},{"krate":0,"index":43248},{"krate":0,"index":43252},{"krate":0,"index":43254},{"krate":0,"index":43256},{"krate":0,"index":43260},{"krate":0,"index":43264},{"krate":0,"index":7560},{"krate":0,"index":7562},{"krate":0,"index":7566},{"krate":0,"index":43268},{"krate":0,"index":43270},{"krate":0,"index":43274},{"krate":0,"index":43280},{"krate":0,"index":43284},{"krate":0,"index":43286},{"krate":0,"index":43290},{"krate":0,"index":43296},{"krate":0,"index":43300},{"krate":0,"index":43302},{"krate":0,"index":43304},{"krate":0,"index":7572},{"krate":0,"index":7574},{"krate":0,"index":7578},{"krate":0,"index":43308},{"krate":0,"index":43310},{"krate":0,"index":43314},{"krate":0,"index":43320},{"krate":0,"index":43324},{"krate":0,"index":43326},{"krate":0,"index":43330},{"krate":0,"index":43336},{"krate":0,"index":43340},{"krate":0,"index":43342},{"krate":0,"index":43344},{"krate":0,"index":43348},{"krate":0,"index":43352},{"krate":0,"index":7584},{"krate":0,"index":7586},{"krate":0,"index":7590},{"krate":0,"index":43356},{"krate":0,"index":43358},{"krate":0,"index":43362},{"krate":0,"index":43368},{"krate":0,"index":43372},{"krate":0,"index":43374},{"krate":0,"index":43378},{"krate":0,"index":43384},{"krate":0,"index":43388},{"krate":0,"index":43390},{"krate":0,"index":43392},{"krate":0,"index":43396},{"krate":0,"index":43400},{"krate":0,"index":43406},{"krate":0,"index":43402},{"krate":0,"index":7596},{"krate":0,"index":7604},{"krate":0,"index":7608},{"krate":0,"index":43410},{"krate":0,"index":43416},{"krate":0,"index":43412},{"krate":0,"index":43434},{"krate":0,"index":43436},{"krate":0,"index":43420},{"krate":0,"index":43424},{"krate":0,"index":43428},{"krate":0,"index":7610},{"krate":0,"index":7618},{"krate":0,"index":7622},{"krate":0,"index":7624},{"krate":0,"index":7626},{"krate":0,"index":7628},{"krate":0,"index":7634},{"krate":0,"index":7636},{"krate":0,"index":7638},{"krate":0,"index":7640},{"krate":0,"index":7642},{"krate":0,"index":7778},{"krate":0,"index":7780},{"krate":0,"index":7784},{"krate":0,"index":43482},{"krate":0,"index":43484},{"krate":0,"index":43440},{"krate":0,"index":43444},{"krate":0,"index":43448},{"krate":0,"index":43488},{"krate":0,"index":43490},{"krate":0,"index":43454},{"krate":0,"index":43458},{"krate":0,"index":43462},{"krate":0,"index":43494},{"krate":0,"index":43496},{"krate":0,"index":43468},{"krate":0,"index":43472},{"krate":0,"index":43476},{"krate":0,"index":7900},{"krate":0,"index":7904},{"krate":0,"index":7908},{"krate":0,"index":43500},{"krate":0,"index":43506},{"krate":0,"index":43502},{"krate":0,"index":43510},{"krate":0,"index":43516},{"krate":0,"index":43512},{"krate":0,"index":43590},{"krate":0,"index":43592},{"krate":0,"index":43520},{"krate":0,"index":43524},{"krate":0,"index":43528},{"krate":0,"index":43596},{"krate":0,"index":43598},{"krate":0,"index":43534},{"krate":0,"index":43538},{"krate":0,"index":43542},{"krate":0,"index":43602},{"krate":0,"index":43604},{"krate":0,"index":43548},{"krate":0,"index":43552},{"krate":0,"index":43556},{"krate":0,"index":43608},{"krate":0,"index":43610},{"krate":0,"index":43562},{"krate":0,"index":43566},{"krate":0,"index":43570},{"krate":0,"index":43614},{"krate":0,"index":43616},{"krate":0,"index":43576},{"krate":0,"index":43580},{"krate":0,"index":43584},{"krate":0,"index":7912},{"krate":0,"index":7920},{"krate":0,"index":7924},{"krate":0,"index":7926},{"krate":0,"index":7934},{"krate":0,"index":7938},{"krate":0,"index":43620},{"krate":0,"index":43622},{"krate":0,"index":7940},{"krate":0,"index":7944},{"krate":0,"index":7952},{"krate":0,"index":43626},{"krate":0,"index":43632},{"krate":0,"index":43628},{"krate":0,"index":43636},{"krate":0,"index":43642},{"krate":0,"index":43638},{"krate":0,"index":43646},{"krate":0,"index":43652},{"krate":0,"index":43648},{"krate":0,"index":7954},{"krate":0,"index":43656},{"krate":0,"index":43660},{"krate":0,"index":43672},{"krate":0,"index":43674},{"krate":0,"index":43678},{"krate":0,"index":43690},{"krate":0,"index":43692},{"krate":0,"index":43696},{"krate":0,"index":43708}],"decl_id":null,"docs":" String manipulation.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1737030,"byte_end":1737076,"line_start":5,"line_end":5,"column_start":1,"column_end":47}}]},{"kind":"Mod","id":{"krate":0,"index":7152},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"pattern","qualname":"::str::pattern","value":"src/libcore/str/pattern.rs","parent":null,"children":[{"krate":0,"index":7154},{"krate":0,"index":7156},{"krate":0,"index":7158},{"krate":0,"index":7160},{"krate":0,"index":7162},{"krate":0,"index":42928},{"krate":0,"index":42948},{"krate":0,"index":42944},{"krate":0,"index":42940},{"krate":0,"index":42934},{"krate":0,"index":42930},{"krate":0,"index":7174},{"krate":0,"index":7184},{"krate":0,"index":7192},{"krate":0,"index":42950},{"krate":0,"index":42956},{"krate":0,"index":42952},{"krate":0,"index":7194},{"krate":0,"index":7202},{"krate":0,"index":7208},{"krate":0,"index":7210},{"krate":0,"index":7222},{"krate":0,"index":7226},{"krate":0,"index":7230},{"krate":0,"index":7234},{"krate":0,"index":42960},{"krate":0,"index":42966},{"krate":0,"index":42962},{"krate":0,"index":7236},{"krate":0,"index":7242},{"krate":0,"index":7248},{"krate":0,"index":7252},{"krate":0,"index":7254},{"krate":0,"index":7256},{"krate":0,"index":42970},{"krate":0,"index":42976},{"krate":0,"index":42972},{"krate":0,"index":7258},{"krate":0,"index":7260},{"krate":0,"index":7262},{"krate":0,"index":7264},{"krate":0,"index":43004},{"krate":0,"index":43006},{"krate":0,"index":7266},{"krate":0,"index":7270},{"krate":0,"index":7272},{"krate":0,"index":7274},{"krate":0,"index":7276},{"krate":0,"index":7278},{"krate":0,"index":7280},{"krate":0,"index":43044},{"krate":0,"index":43050},{"krate":0,"index":43046},{"krate":0,"index":43054},{"krate":0,"index":43060},{"krate":0,"index":43056},{"krate":0,"index":43064},{"krate":0,"index":43070},{"krate":0,"index":43066},{"krate":0,"index":7290},{"krate":0,"index":7294},{"krate":0,"index":7302},{"krate":0,"index":43074},{"krate":0,"index":43080},{"krate":0,"index":43076},{"krate":0,"index":7308},{"krate":0,"index":7324},{"krate":0,"index":7334},{"krate":0,"index":7336},{"krate":0,"index":7346},{"krate":0,"index":7348}],"decl_id":null,"docs":" The string Pattern API.","sig":null,"attributes":[{"value":"unstable(feature = \"pattern\",\n           reason = \"API not fully fleshed out and ready to be stabilized\",\n           issue = \"27721\")","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1877518,"byte_end":1877657,"line_start":6,"line_end":8,"column_start":1,"column_end":30}}]},{"kind":"Trait","id":{"krate":0,"index":7162},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1878187,"byte_end":1878194,"line_start":28,"line_end":28,"column_start":11,"column_end":18},"name":"Pattern","qualname":"::str::pattern::Pattern","value":"Pattern<'a>: Sized","parent":null,"children":[{"krate":0,"index":7164},{"krate":0,"index":7166},{"krate":0,"index":7168},{"krate":0,"index":7170},{"krate":0,"index":7172}],"decl_id":null,"docs":" A string pattern.","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":7164},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1878262,"byte_end":1878270,"line_start":30,"line_end":30,"column_start":10,"column_end":18},"name":"Searcher","qualname":"::str::pattern::Pattern::Searcher","value":"type Searcher: Searcher<'a>;","parent":{"krate":0,"index":7162},"children":[],"decl_id":null,"docs":" Associated searcher for this pattern\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7166},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1878390,"byte_end":1878403,"line_start":34,"line_end":34,"column_start":8,"column_end":21},"name":"into_searcher","qualname":"::str::pattern::Pattern::into_searcher","value":"fn (self, haystack: &'a str) -> Self::Searcher","parent":{"krate":0,"index":7162},"children":[],"decl_id":null,"docs":" Constructs the associated searcher from\n `self` and the `haystack` to search in.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7168},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1878538,"byte_end":1878553,"line_start":38,"line_end":38,"column_start":8,"column_end":23},"name":"is_contained_in","qualname":"::str::pattern::Pattern::is_contained_in","value":"fn (self, haystack: &'a str) -> bool","parent":{"krate":0,"index":7162},"children":[],"decl_id":null,"docs":" Checks whether the pattern matches anywhere in the haystack\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1878521,"byte_end":1878530,"line_start":37,"line_end":37,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7170},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1878749,"byte_end":1878761,"line_start":44,"line_end":44,"column_start":8,"column_end":20},"name":"is_prefix_of","qualname":"::str::pattern::Pattern::is_prefix_of","value":"fn (self, haystack: &'a str) -> bool","parent":{"krate":0,"index":7162},"children":[],"decl_id":null,"docs":" Checks whether the pattern matches at the front of the haystack\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1878732,"byte_end":1878741,"line_start":43,"line_end":43,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7172},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1879027,"byte_end":1879039,"line_start":53,"line_end":53,"column_start":8,"column_end":20},"name":"is_suffix_of","qualname":"::str::pattern::Pattern::is_suffix_of","value":"fn (self, haystack: &'a str) -> bool","parent":{"krate":0,"index":7162},"children":[],"decl_id":null,"docs":" Checks whether the pattern matches at the back of the haystack\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1879010,"byte_end":1879019,"line_start":52,"line_end":52,"column_start":5,"column_end":14}}]},{"kind":"TupleVariant","id":{"krate":0,"index":23341},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1879547,"byte_end":1879552,"line_start":70,"line_end":70,"column_start":5,"column_end":10},"name":"Match","qualname":"::str::pattern::SearchStep::Match","value":"SearchStep::Match(usize, usize)","parent":{"krate":0,"index":42928},"children":[],"decl_id":null,"docs":" Expresses that a match of the pattern has been found at\n `haystack[a..b]`.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":23349},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1879827,"byte_end":1879833,"line_start":76,"line_end":76,"column_start":5,"column_end":11},"name":"Reject","qualname":"::str::pattern::SearchStep::Reject","value":"SearchStep::Reject(usize, usize)","parent":{"krate":0,"index":42928},"children":[],"decl_id":null,"docs":" Expresses that `haystack[a..b]` has been rejected as a possible match\n of the pattern.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":23357},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1879951,"byte_end":1879955,"line_start":79,"line_end":79,"column_start":5,"column_end":9},"name":"Done","qualname":"::str::pattern::SearchStep::Done","value":"SearchStep::Done","parent":{"krate":0,"index":42928},"children":[],"decl_id":null,"docs":" Expresses that every byte of the haystack has been visited, ending\n the iteration.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":42928},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1879440,"byte_end":1879450,"line_start":67,"line_end":67,"column_start":10,"column_end":20},"name":"SearchStep","qualname":"::str::pattern::SearchStep","value":"SearchStep::{Match, Reject, Done}","parent":null,"children":[{"krate":0,"index":23341},{"krate":0,"index":23349},{"krate":0,"index":23357}],"decl_id":null,"docs":" Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1879431,"byte_end":1879957,"line_start":67,"line_end":80,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1879431,"byte_end":1879957,"line_start":67,"line_end":80,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":7174},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1880498,"byte_end":1880506,"line_start":94,"line_end":94,"column_start":18,"column_end":26},"name":"Searcher","qualname":"::str::pattern::Searcher","value":"Searcher<'a>","parent":null,"children":[{"krate":0,"index":7176},{"krate":0,"index":7178},{"krate":0,"index":7180},{"krate":0,"index":7182}],"decl_id":null,"docs":" A searcher for a string pattern.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7176},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1880630,"byte_end":1880638,"line_start":98,"line_end":98,"column_start":8,"column_end":16},"name":"haystack","qualname":"::str::pattern::Searcher::haystack","value":"fn (&self) -> &'a str","parent":{"krate":0,"index":7174},"children":[],"decl_id":null,"docs":" Getter for the underlying string to be searched in","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7178},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1881587,"byte_end":1881591,"line_start":118,"line_end":118,"column_start":8,"column_end":12},"name":"next","qualname":"::str::pattern::Searcher::next","value":"fn (&mut self) -> SearchStep","parent":{"krate":0,"index":7174},"children":[],"decl_id":null,"docs":" Performs the next search step starting from the front.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7180},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1881988,"byte_end":1881998,"line_start":127,"line_end":127,"column_start":8,"column_end":18},"name":"next_match","qualname":"::str::pattern::Searcher::next_match","value":"fn (&mut self) -> Option<(usize, usize)>","parent":{"krate":0,"index":7174},"children":[],"decl_id":null,"docs":" Finds the next `Match` result. See `next()`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1881971,"byte_end":1881980,"line_start":126,"line_end":126,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7182},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1882476,"byte_end":1882487,"line_start":142,"line_end":142,"column_start":8,"column_end":19},"name":"next_reject","qualname":"::str::pattern::Searcher::next_reject","value":"fn (&mut self) -> Option<(usize, usize)>","parent":{"krate":0,"index":7174},"children":[],"decl_id":null,"docs":" Finds the next `Reject` result. See `next()` and `next_match()`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1882459,"byte_end":1882468,"line_start":141,"line_end":141,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":7184},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1883322,"byte_end":1883337,"line_start":167,"line_end":167,"column_start":18,"column_end":33},"name":"ReverseSearcher","qualname":"::str::pattern::ReverseSearcher","value":"ReverseSearcher<'a>: Searcher<'a>","parent":null,"children":[{"krate":0,"index":7186},{"krate":0,"index":7188},{"krate":0,"index":7190}],"decl_id":null,"docs":" A reverse searcher for a string pattern.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7186},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1884285,"byte_end":1884294,"line_start":186,"line_end":186,"column_start":8,"column_end":17},"name":"next_back","qualname":"::str::pattern::ReverseSearcher::next_back","value":"fn (&mut self) -> SearchStep","parent":{"krate":0,"index":7184},"children":[],"decl_id":null,"docs":" Performs the next search step starting from the back.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7188},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1884400,"byte_end":1884415,"line_start":190,"line_end":190,"column_start":8,"column_end":23},"name":"next_match_back","qualname":"::str::pattern::ReverseSearcher::next_match_back","value":"fn (&mut self) -> Option<(usize, usize)>","parent":{"krate":0,"index":7184},"children":[],"decl_id":null,"docs":" Finds the next `Match` result. See `next_back()`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1884383,"byte_end":1884392,"line_start":189,"line_end":189,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7190},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1884760,"byte_end":1884776,"line_start":202,"line_end":202,"column_start":8,"column_end":24},"name":"next_reject_back","qualname":"::str::pattern::ReverseSearcher::next_reject_back","value":"fn (&mut self) -> Option<(usize, usize)>","parent":{"krate":0,"index":7184},"children":[],"decl_id":null,"docs":" Finds the next `Reject` result. See `next_back()`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1884743,"byte_end":1884752,"line_start":201,"line_end":201,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":7192},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1885914,"byte_end":1885933,"line_start":234,"line_end":234,"column_start":11,"column_end":30},"name":"DoubleEndedSearcher","qualname":"::str::pattern::DoubleEndedSearcher","value":"DoubleEndedSearcher<'a>: ReverseSearcher<'a>","parent":null,"children":[],"decl_id":null,"docs":" A marker trait to express that a `ReverseSearcher`\n can be used for a `DoubleEndedIterator` implementation.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":42950},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1886232,"byte_end":1886244,"line_start":243,"line_end":243,"column_start":12,"column_end":24},"name":"CharSearcher","qualname":"::str::pattern::CharSearcher","value":"CharSearcher {  }","parent":null,"children":[{"krate":0,"index":23363},{"krate":0,"index":23365},{"krate":0,"index":23367},{"krate":0,"index":23369},{"krate":0,"index":23371},{"krate":0,"index":23373}],"decl_id":null,"docs":" Associated type for `<char as Pattern<'a>>::Searcher`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7224},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1895982,"byte_end":1895989,"line_start":475,"line_end":475,"column_start":8,"column_end":15},"name":"matches","qualname":"::str::pattern::MultiCharEq::matches","value":"fn (&mut self, c: char) -> bool","parent":{"krate":0,"index":7222},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":42970},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1900421,"byte_end":1900438,"line_start":632,"line_end":632,"column_start":12,"column_end":29},"name":"CharSliceSearcher","qualname":"::str::pattern::CharSliceSearcher","value":"","parent":null,"children":[],"decl_id":null,"docs":" Associated type for `<&[char] as Pattern<'a>>::Searcher`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":43004},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1901266,"byte_end":1901287,"line_start":655,"line_end":655,"column_start":12,"column_end":33},"name":"CharPredicateSearcher","qualname":"::str::pattern::CharPredicateSearcher","value":"","parent":null,"children":[],"decl_id":null,"docs":" Associated type for `<F as Pattern<'a>>::Searcher`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":43044},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1903991,"byte_end":1904002,"line_start":736,"line_end":736,"column_start":12,"column_end":23},"name":"StrSearcher","qualname":"::str::pattern::StrSearcher","value":"StrSearcher {  }","parent":null,"children":[{"krate":0,"index":23441},{"krate":0,"index":23443},{"krate":0,"index":23445}],"decl_id":null,"docs":" Associated type for `<&str as Pattern<'a>>::Searcher`.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":7326},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929384,"byte_end":1929390,"line_start":1370,"line_end":1370,"column_start":10,"column_end":16},"name":"Output","qualname":"::str::pattern::TwoWayStrategy::Output","value":"type Output;","parent":{"krate":0,"index":7324},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7328},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929399,"byte_end":1929415,"line_start":1371,"line_end":1371,"column_start":8,"column_end":24},"name":"use_early_reject","qualname":"::str::pattern::TwoWayStrategy::use_early_reject","value":"fn () -> bool","parent":{"krate":0,"index":7324},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7330},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929434,"byte_end":1929443,"line_start":1372,"line_end":1372,"column_start":8,"column_end":17},"name":"rejecting","qualname":"::str::pattern::TwoWayStrategy::rejecting","value":"fn (a: usize, b: usize) -> Self::Output","parent":{"krate":0,"index":7324},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7332},"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929488,"byte_end":1929496,"line_start":1373,"line_end":1373,"column_start":8,"column_end":16},"name":"matching","qualname":"::str::pattern::TwoWayStrategy::matching","value":"fn (a: usize, b: usize) -> Self::Output","parent":{"krate":0,"index":7324},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":7358},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"lossy","qualname":"::str::lossy","value":"src/libcore/str/lossy.rs","parent":null,"children":[{"krate":0,"index":7360},{"krate":0,"index":7362},{"krate":0,"index":7364},{"krate":0,"index":7370},{"krate":0,"index":7372},{"krate":0,"index":7374},{"krate":0,"index":7382},{"krate":0,"index":43084},{"krate":0,"index":43094},{"krate":0,"index":43090},{"krate":0,"index":43086},{"krate":0,"index":7384},{"krate":0,"index":7396},{"krate":0,"index":7400}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1737490,"byte_end":1737541,"line_start":21,"line_end":21,"column_start":1,"column_end":52}},{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1737542,"byte_end":1737564,"line_start":22,"line_end":22,"column_start":1,"column_end":23}}]},{"kind":"Struct","id":{"krate":0,"index":7372},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930463,"byte_end":1930472,"line_start":8,"line_end":8,"column_start":12,"column_end":21},"name":"Utf8Lossy","qualname":"::str::lossy::Utf8Lossy","value":"Utf8Lossy {  }","parent":null,"children":[{"krate":0,"index":4357}],"decl_id":null,"docs":" Lossy UTF-8 string.\n","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930400,"byte_end":1930451,"line_start":7,"line_end":7,"column_start":1,"column_end":52}}]},{"kind":"Method","id":{"krate":0,"index":7376},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930522,"byte_end":1930530,"line_start":13,"line_end":13,"column_start":12,"column_end":20},"name":"from_str","qualname":"<Utf8Lossy>::from_str","value":"fn (s: &str) -> &Utf8Lossy","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7378},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930618,"byte_end":1930628,"line_start":17,"line_end":17,"column_start":12,"column_end":22},"name":"from_bytes","qualname":"<Utf8Lossy>::from_bytes","value":"fn (bytes: &[u8]) -> &Utf8Lossy","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":7380},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930718,"byte_end":1930724,"line_start":21,"line_end":21,"column_start":12,"column_end":18},"name":"chunks","qualname":"<Utf8Lossy>::chunks","value":"fn (&self) -> Utf8LossyChunksIter<'_>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7382},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930963,"byte_end":1930982,"line_start":30,"line_end":30,"column_start":12,"column_end":31},"name":"Utf8LossyChunksIter","qualname":"::str::lossy::Utf8LossyChunksIter","value":"Utf8LossyChunksIter {  }","parent":null,"children":[{"krate":0,"index":4361}],"decl_id":null,"docs":" Iterator over lossy UTF-8 string\n","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930860,"byte_end":1930911,"line_start":28,"line_end":28,"column_start":1,"column_end":52}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930912,"byte_end":1930951,"line_start":29,"line_end":29,"column_start":1,"column_end":40}}]},{"kind":"Struct","id":{"krate":0,"index":43084},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1931109,"byte_end":1931123,"line_start":36,"line_end":36,"column_start":12,"column_end":26},"name":"Utf8LossyChunk","qualname":"::str::lossy::Utf8LossyChunk","value":"Utf8LossyChunk { valid, broken }","parent":null,"children":[{"krate":0,"index":23493},{"krate":0,"index":23495}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1931014,"byte_end":1931065,"line_start":34,"line_end":34,"column_start":1,"column_end":52}},{"value":"structural_match","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1931098,"byte_end":1931347,"line_start":36,"line_end":43,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":23493},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1931220,"byte_end":1931225,"line_start":39,"line_end":39,"column_start":9,"column_end":14},"name":"valid","qualname":"::str::lossy::Utf8LossyChunk::valid","value":"&'a str","parent":{"krate":0,"index":43084},"children":[],"decl_id":null,"docs":" Sequence of valid chars.\n Can be empty between broken UTF-8 chars.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":23495},"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1931328,"byte_end":1931334,"line_start":42,"line_end":42,"column_start":9,"column_end":15},"name":"broken","qualname":"::str::lossy::Utf8LossyChunk::broken","value":"&'a [u8]","parent":{"krate":0,"index":43084},"children":[],"decl_id":null,"docs":" Single broken char, empty if none.\n Empty iff iterator item is last.\n","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":7404},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1739110,"byte_end":1739117,"line_start":72,"line_end":72,"column_start":11,"column_end":18},"name":"FromStr","qualname":"::str::FromStr","value":"FromStr: Sized","parent":null,"children":[{"krate":0,"index":7406},{"krate":0,"index":7408}],"decl_id":null,"docs":" Parse a value from a string","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1739054,"byte_end":1739099,"line_start":71,"line_end":71,"column_start":1,"column_end":46}}]},{"kind":"Type","id":{"krate":0,"index":7406},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1739251,"byte_end":1739254,"line_start":75,"line_end":75,"column_start":10,"column_end":13},"name":"Err","qualname":"::str::FromStr::Err","value":"type Err;","parent":{"krate":0,"index":7404},"children":[],"decl_id":null,"docs":" The associated error which can be returned from parsing.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1739196,"byte_end":1739241,"line_start":74,"line_end":74,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":7408},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1740084,"byte_end":1740092,"line_start":101,"line_end":101,"column_start":8,"column_end":16},"name":"from_str","qualname":"::str::FromStr::from_str","value":"fn (s: &str) -> Result<Self, Self::Err>","parent":{"krate":0,"index":7404},"children":[],"decl_id":null,"docs":" Parses a string `s` to return a value of this type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1740031,"byte_end":1740076,"line_start":100,"line_end":100,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":43100},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1741421,"byte_end":1741435,"line_start":145,"line_end":145,"column_start":12,"column_end":26},"name":"ParseBoolError","qualname":"::str::ParseBoolError","value":"ParseBoolError {  }","parent":null,"children":[{"krate":0,"index":23503}],"decl_id":null,"docs":" An error returned when parsing a `bool` using [`from_str`] fails","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1741364,"byte_end":1741409,"line_start":144,"line_end":144,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1741410,"byte_end":1741449,"line_start":145,"line_end":145,"column_start":1,"column_end":40}}]},{"kind":"Struct","id":{"krate":0,"index":43120},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1743195,"byte_end":1743204,"line_start":201,"line_end":201,"column_start":12,"column_end":21},"name":"Utf8Error","qualname":"::str::Utf8Error","value":"Utf8Error {  }","parent":null,"children":[{"krate":0,"index":23505},{"krate":0,"index":23507}],"decl_id":null,"docs":" Errors which can occur when attempting to interpret a sequence of [`u8`]\n as a string.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1743138,"byte_end":1743183,"line_start":200,"line_end":200,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1743184,"byte_end":1743259,"line_start":201,"line_end":204,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1743184,"byte_end":1743259,"line_start":201,"line_end":204,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":7422},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1743977,"byte_end":1743988,"line_start":230,"line_end":230,"column_start":12,"column_end":23},"name":"valid_up_to","qualname":"<Utf8Error>::valid_up_to","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the index in the given string up to which valid UTF-8 was\n verified.","sig":null,"attributes":[{"value":"stable(feature = \"utf8_error\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1743915,"byte_end":1743965,"line_start":229,"line_end":229,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":7424},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1744927,"byte_end":1744936,"line_start":248,"line_end":248,"column_start":12,"column_end":21},"name":"error_len","qualname":"<Utf8Error>::error_len","value":"fn (&self) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Provides more information about the failure:","sig":null,"attributes":[{"value":"stable(feature = \"utf8_error_error_len\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1744854,"byte_end":1744915,"line_start":247,"line_end":247,"column_start":5,"column_end":66}}]},{"kind":"Function","id":{"krate":0,"index":7426},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1747561,"byte_end":1747570,"line_start":335,"line_end":335,"column_start":8,"column_end":17},"name":"from_utf8","qualname":"::str::from_utf8","value":"fn (v: &[u8]) -> Result<&str, Utf8Error>","parent":null,"children":[],"decl_id":null,"docs":" Converts a slice of bytes to a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1747508,"byte_end":1747553,"line_start":334,"line_end":334,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":7428},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1748552,"byte_end":1748565,"line_start":373,"line_end":373,"column_start":8,"column_end":21},"name":"from_utf8_mut","qualname":"::str::from_utf8_mut","value":"fn (v: &mut [u8]) -> Result<&mut str, Utf8Error>","parent":null,"children":[],"decl_id":null,"docs":" Converts a mutable slice of bytes to a mutable string slice.","sig":null,"attributes":[{"value":"stable(feature = \"str_mut_extras\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1748489,"byte_end":1748544,"line_start":372,"line_end":372,"column_start":1,"column_end":56}}]},{"kind":"Function","id":{"krate":0,"index":7430},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1749577,"byte_end":1749596,"line_start":411,"line_end":411,"column_start":15,"column_end":34},"name":"from_utf8_unchecked","qualname":"::str::from_utf8_unchecked","value":"fn (v: &[u8]) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1749507,"byte_end":1749516,"line_start":409,"line_end":409,"column_start":1,"column_end":10}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1749517,"byte_end":1749562,"line_start":410,"line_end":410,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":7432},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1750237,"byte_end":1750260,"line_start":436,"line_end":436,"column_start":15,"column_end":38},"name":"from_utf8_unchecked_mut","qualname":"::str::from_utf8_unchecked_mut","value":"fn (v: &mut [u8]) -> &mut str","parent":null,"children":[],"decl_id":null,"docs":" Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8; mutable version.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1750157,"byte_end":1750166,"line_start":434,"line_end":434,"column_start":1,"column_end":10}},{"value":"stable(feature = \"str_mut_extras\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1750167,"byte_end":1750222,"line_start":435,"line_end":435,"column_start":1,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":43142},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1751185,"byte_end":1751190,"line_start":467,"line_end":467,"column_start":12,"column_end":17},"name":"Chars","qualname":"::str::Chars","value":"Chars {  }","parent":null,"children":[{"krate":0,"index":23511}],"decl_id":null,"docs":" An iterator over the [`char`]s of a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1751128,"byte_end":1751173,"line_start":466,"line_end":466,"column_start":1,"column_end":46}}]},{"kind":"Function","id":{"krate":0,"index":7446},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1752146,"byte_end":1752161,"line_start":498,"line_end":498,"column_start":8,"column_end":23},"name":"next_code_point","qualname":"::str::next_code_point","value":"fn <'a, I> (bytes: &mut I) -> Option<u32>","parent":null,"children":[],"decl_id":null,"docs":" Reads the next code point out of a byte iterator (assuming a\n UTF-8-like encoding).\n","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1752077,"byte_end":1752128,"line_start":496,"line_end":496,"column_start":1,"column_end":52}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1752129,"byte_end":1752138,"line_start":497,"line_end":497,"column_start":1,"column_end":10}}]},{"kind":"Method","id":{"krate":0,"index":7470},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1756357,"byte_end":1756363,"line_start":637,"line_end":637,"column_start":12,"column_end":18},"name":"as_str","qualname":"<Chars>::as_str","value":"fn (&self) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"stable(feature = \"iter_to_slice\", since = \"1.4.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1756278,"byte_end":1756331,"line_start":635,"line_end":635,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1756336,"byte_end":1756345,"line_start":636,"line_end":636,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":43152},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1756885,"byte_end":1756896,"line_start":653,"line_end":653,"column_start":12,"column_end":23},"name":"CharIndices","qualname":"::str::CharIndices","value":"CharIndices {  }","parent":null,"children":[{"krate":0,"index":23519},{"krate":0,"index":23521}],"decl_id":null,"docs":" An iterator over the [`char`]s of a string slice, and their positions.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1756828,"byte_end":1756873,"line_start":652,"line_end":652,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":7492},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758528,"byte_end":1758534,"line_start":714,"line_end":714,"column_start":12,"column_end":18},"name":"as_str","qualname":"<CharIndices>::as_str","value":"fn (&self) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Views the underlying data as a subslice of the original data.","sig":null,"attributes":[{"value":"stable(feature = \"iter_to_slice\", since = \"1.4.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758449,"byte_end":1758502,"line_start":712,"line_end":712,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758507,"byte_end":1758516,"line_start":713,"line_end":713,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":43162},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758928,"byte_end":1758933,"line_start":728,"line_end":728,"column_start":12,"column_end":17},"name":"Bytes","qualname":"::str::Bytes","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the bytes of a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758847,"byte_end":1758892,"line_start":726,"line_end":726,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":43176},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1770721,"byte_end":1770726,"line_start":1115,"line_end":1115,"column_start":16,"column_end":21},"name":"Split","qualname":"::str::Split","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`split`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1764231,"byte_end":1764261,"line_start":915,"line_end":915,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43192},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1770883,"byte_end":1770889,"line_start":1120,"line_end":1120,"column_start":16,"column_end":22},"name":"RSplit","qualname":"::str::RSplit","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rsplit`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1765344,"byte_end":1765374,"line_start":949,"line_end":949,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43220},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1771261,"byte_end":1771276,"line_start":1133,"line_end":1133,"column_start":16,"column_end":31},"name":"SplitTerminator","qualname":"::str::SplitTerminator","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`split_terminator`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1764231,"byte_end":1764261,"line_start":915,"line_end":915,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43236},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1771466,"byte_end":1771482,"line_start":1138,"line_end":1138,"column_start":16,"column_end":32},"name":"RSplitTerminator","qualname":"::str::RSplitTerminator","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rsplit_terminator`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1765344,"byte_end":1765374,"line_start":949,"line_end":949,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43268},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1772965,"byte_end":1772971,"line_start":1193,"line_end":1193,"column_start":16,"column_end":22},"name":"SplitN","qualname":"::str::SplitN","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`splitn`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1764231,"byte_end":1764261,"line_start":915,"line_end":915,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43284},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1773131,"byte_end":1773138,"line_start":1198,"line_end":1198,"column_start":16,"column_end":23},"name":"RSplitN","qualname":"::str::RSplitN","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rsplitn`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1765344,"byte_end":1765374,"line_start":949,"line_end":949,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43308},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1774467,"byte_end":1774479,"line_start":1244,"line_end":1244,"column_start":16,"column_end":28},"name":"MatchIndices","qualname":"::str::MatchIndices","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`match_indices`].","sig":null,"attributes":[{"value":"stable(feature = \"str_match_indices\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1764231,"byte_end":1764261,"line_start":915,"line_end":915,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43324},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1774660,"byte_end":1774673,"line_start":1249,"line_end":1249,"column_start":16,"column_end":29},"name":"RMatchIndices","qualname":"::str::RMatchIndices","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rmatch_indices`].","sig":null,"attributes":[{"value":"stable(feature = \"str_match_indices\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1765344,"byte_end":1765374,"line_start":949,"line_end":949,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43356},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1776037,"byte_end":1776044,"line_start":1297,"line_end":1297,"column_start":16,"column_end":23},"name":"Matches","qualname":"::str::Matches","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`matches`].","sig":null,"attributes":[{"value":"stable(feature = \"str_matches\", since = \"1.2.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1764231,"byte_end":1764261,"line_start":915,"line_end":915,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43372},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1776207,"byte_end":1776215,"line_start":1302,"line_end":1302,"column_start":16,"column_end":24},"name":"RMatches","qualname":"::str::RMatches","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`rmatches`].","sig":null,"attributes":[{"value":"stable(feature = \"str_matches\", since = \"1.2.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1765344,"byte_end":1765374,"line_start":949,"line_end":949,"column_start":11,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":43400},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1776731,"byte_end":1776736,"line_start":1319,"line_end":1319,"column_start":12,"column_end":17},"name":"Lines","qualname":"::str::Lines","value":"","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the lines of a string, as string slices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1776650,"byte_end":1776695,"line_start":1317,"line_end":1317,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":43410},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1777650,"byte_end":1777658,"line_start":1354,"line_end":1354,"column_start":12,"column_end":20},"name":"LinesAny","qualname":"::str::LinesAny","value":"","parent":null,"children":[],"decl_id":null,"docs":" Created with the method [`lines_any`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1777469,"byte_end":1777514,"line_start":1350,"line_end":1350,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1777515,"byte_end":1777593,"line_start":1351,"line_end":1351,"column_start":1,"column_end":79}},{"value":"allow(deprecated)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1777618,"byte_end":1777638,"line_start":1353,"line_end":1353,"column_start":1,"column_end":21}}]},{"kind":"Function","id":{"krate":0,"index":7636},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784324,"byte_end":1784339,"line_start":1551,"line_end":1551,"column_start":8,"column_end":23},"name":"utf8_char_width","qualname":"::str::utf8_char_width","value":"fn (b: u8) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Given a first byte, determines how many bytes are in this UTF-8 character.\n","sig":null,"attributes":[{"value":"unstable(feature = \"str_internals\", issue = \"0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784255,"byte_end":1784306,"line_start":1549,"line_end":1549,"column_start":1,"column_end":52}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1784307,"byte_end":1784316,"line_start":1550,"line_end":1550,"column_start":1,"column_end":10}}]},{"kind":"Method","id":{"krate":0,"index":7786},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802675,"byte_end":1802678,"line_start":2058,"line_end":2058,"column_start":18,"column_end":21},"name":"len","qualname":"<str>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the length of `self`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802543,"byte_end":1802588,"line_start":2055,"line_end":2055,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802593,"byte_end":1802602,"line_start":2056,"line_end":2056,"column_start":5,"column_end":14}},{"value":"rustc_const_unstable(feature = \"const_str_len\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1802607,"byte_end":1802657,"line_start":2057,"line_end":2057,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":7788},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1803139,"byte_end":1803147,"line_start":2078,"line_end":2078,"column_start":18,"column_end":26},"name":"is_empty","qualname":"<str>::is_empty","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if `self` has a length of zero bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1803007,"byte_end":1803016,"line_start":2075,"line_end":2075,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1803021,"byte_end":1803066,"line_start":2076,"line_end":2076,"column_start":5,"column_end":50}},{"value":"rustc_const_unstable(feature = \"const_str_len\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1803071,"byte_end":1803121,"line_start":2077,"line_end":2077,"column_start":5,"column_end":55}}]},{"kind":"Method","id":{"krate":0,"index":7790},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1803998,"byte_end":1804014,"line_start":2108,"line_end":2108,"column_start":12,"column_end":28},"name":"is_char_boundary","qualname":"<str>::is_char_boundary","value":"fn (&self, index: usize) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that `index`-th byte lies at the start and/or end of a\n UTF-8 code point sequence.","sig":null,"attributes":[{"value":"stable(feature = \"is_char_boundary\", since = \"1.9.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1803916,"byte_end":1803972,"line_start":2106,"line_end":2106,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1803977,"byte_end":1803986,"line_start":2107,"line_end":2107,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7792},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1804992,"byte_end":1805000,"line_start":2136,"line_end":2136,"column_start":18,"column_end":26},"name":"as_bytes","qualname":"<str>::as_bytes","value":"fn (&self) -> &[u8]","parent":null,"children":[],"decl_id":null,"docs":" Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`str::from_utf8`] function.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1804849,"byte_end":1804894,"line_start":2133,"line_end":2133,"column_start":5,"column_end":50}},{"value":"inline(always)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1804899,"byte_end":1804916,"line_start":2134,"line_end":2134,"column_start":5,"column_end":22}},{"value":"rustc_const_unstable(feature = \"const_str_as_bytes\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1804921,"byte_end":1804974,"line_start":2135,"line_end":2135,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":7796},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806103,"byte_end":1806115,"line_start":2179,"line_end":2179,"column_start":19,"column_end":31},"name":"as_bytes_mut","qualname":"<str>::as_bytes_mut","value":"fn (&mut self) -> &mut [u8]","parent":null,"children":[],"decl_id":null,"docs":" Converts a mutable string slice to a mutable byte slice. To convert the\n mutable byte slice back into a mutable string slice, use the\n [`str::from_utf8_mut`] function.","sig":null,"attributes":[{"value":"stable(feature = \"str_mut_extras\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806007,"byte_end":1806062,"line_start":2177,"line_end":2177,"column_start":5,"column_end":60}},{"value":"inline(always)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806067,"byte_end":1806084,"line_start":2178,"line_end":2178,"column_start":5,"column_end":22}}]},{"kind":"Method","id":{"krate":0,"index":7798},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806687,"byte_end":1806693,"line_start":2201,"line_end":2201,"column_start":18,"column_end":24},"name":"as_ptr","qualname":"<str>::as_ptr","value":"fn (&self) -> *const u8","parent":null,"children":[],"decl_id":null,"docs":" Converts a string slice to a raw pointer.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806610,"byte_end":1806655,"line_start":2199,"line_end":2199,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1806660,"byte_end":1806669,"line_start":2200,"line_end":2200,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7800},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1807267,"byte_end":1807277,"line_start":2217,"line_end":2217,"column_start":12,"column_end":22},"name":"as_mut_ptr","qualname":"<str>::as_mut_ptr","value":"fn (&mut self) -> *mut u8","parent":null,"children":[],"decl_id":null,"docs":" Converts a mutable string slice to a raw pointer.","sig":null,"attributes":[{"value":"unstable(feature = \"str_as_mut_ptr\", issue = \"58215\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1807185,"byte_end":1807241,"line_start":2215,"line_end":2215,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1807246,"byte_end":1807255,"line_start":2216,"line_end":2216,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7802},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1808059,"byte_end":1808062,"line_start":2244,"line_end":2244,"column_start":12,"column_end":15},"name":"get","qualname":"<str>::get","value":"fn <I> (&self, i: I) -> Option<&I::Output>","parent":null,"children":[],"decl_id":null,"docs":" Returns a subslice of `str`.","sig":null,"attributes":[{"value":"stable(feature = \"str_checked_slicing\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1807973,"byte_end":1808033,"line_start":2242,"line_end":2242,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1808038,"byte_end":1808047,"line_start":2243,"line_end":2243,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7804},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1809080,"byte_end":1809087,"line_start":2278,"line_end":2278,"column_start":12,"column_end":19},"name":"get_mut","qualname":"<str>::get_mut","value":"fn <I> (&mut self, i: I) -> Option<&mut I::Output>","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable subslice of `str`.","sig":null,"attributes":[{"value":"stable(feature = \"str_checked_slicing\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1808994,"byte_end":1809054,"line_start":2276,"line_end":2276,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1809059,"byte_end":1809068,"line_start":2277,"line_end":2277,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7806},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1810156,"byte_end":1810169,"line_start":2310,"line_end":2310,"column_start":19,"column_end":32},"name":"get_unchecked","qualname":"<str>::get_unchecked","value":"fn <I> (&self, i: I) -> &I::Output","parent":null,"children":[],"decl_id":null,"docs":" Returns a unchecked subslice of `str`.","sig":null,"attributes":[{"value":"stable(feature = \"str_checked_slicing\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1810063,"byte_end":1810123,"line_start":2308,"line_end":2308,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1810128,"byte_end":1810137,"line_start":2309,"line_end":2309,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7808},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1811267,"byte_end":1811284,"line_start":2342,"line_end":2342,"column_start":19,"column_end":36},"name":"get_unchecked_mut","qualname":"<str>::get_unchecked_mut","value":"fn <I> (&mut self, i: I) -> &mut I::Output","parent":null,"children":[],"decl_id":null,"docs":" Returns a mutable, unchecked subslice of `str`.","sig":null,"attributes":[{"value":"stable(feature = \"str_checked_slicing\", since = \"1.20.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1811174,"byte_end":1811234,"line_start":2340,"line_end":2340,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1811239,"byte_end":1811248,"line_start":2341,"line_end":2341,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7810},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1812836,"byte_end":1812851,"line_start":2392,"line_end":2392,"column_start":19,"column_end":34},"name":"slice_unchecked","qualname":"<str>::slice_unchecked","value":"fn (&self, begin: usize, end: usize) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Creates a string slice from another string slice, bypassing safety\n checks.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1812664,"byte_end":1812709,"line_start":2389,"line_end":2389,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.29.0\",\n                   reason = \"use `get_unchecked(begin..end)` instead\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1812714,"byte_end":1812803,"line_start":2390,"line_end":2390,"column_start":5,"column_end":94}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1812808,"byte_end":1812817,"line_start":2391,"line_end":2391,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7812},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1814026,"byte_end":1814045,"line_start":2423,"line_end":2423,"column_start":19,"column_end":38},"name":"slice_mut_unchecked","qualname":"<str>::slice_mut_unchecked","value":"fn (&mut self, begin: usize, end: usize) -> &mut str","parent":null,"children":[],"decl_id":null,"docs":" Creates a string slice from another string slice, bypassing safety\n checks.\n This is generally not recommended, use with caution! For a safe\n alternative see [`str`] and [`IndexMut`].","sig":null,"attributes":[{"value":"stable(feature = \"str_slice_mut\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1813842,"byte_end":1813895,"line_start":2420,"line_end":2420,"column_start":5,"column_end":58}},{"value":"rustc_deprecated(since = \"1.29.0\",\n                   reason = \"use `get_unchecked_mut(begin..end)` instead\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1813900,"byte_end":1813993,"line_start":2421,"line_end":2421,"column_start":5,"column_end":98}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1813998,"byte_end":1814007,"line_start":2422,"line_end":2422,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7814},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1815154,"byte_end":1815162,"line_start":2459,"line_end":2459,"column_start":12,"column_end":20},"name":"split_at","qualname":"<str>::split_at","value":"fn (&self, mid: usize) -> (&str, &str)","parent":null,"children":[],"decl_id":null,"docs":" Divide one string slice into two at an index.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1815076,"byte_end":1815085,"line_start":2457,"line_end":2457,"column_start":5,"column_end":14}},{"value":"stable(feature = \"str_split_at\", since = \"1.4.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1815090,"byte_end":1815142,"line_start":2458,"line_end":2458,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7816},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816634,"byte_end":1816646,"line_start":2504,"line_end":2504,"column_start":12,"column_end":24},"name":"split_at_mut","qualname":"<str>::split_at_mut","value":"fn (&mut self, mid: usize) -> (&mut str, &mut str)","parent":null,"children":[],"decl_id":null,"docs":" Divide one mutable string slice into two at an index.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816556,"byte_end":1816565,"line_start":2502,"line_end":2502,"column_start":5,"column_end":14}},{"value":"stable(feature = \"str_split_at\", since = \"1.4.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1816570,"byte_end":1816622,"line_start":2503,"line_end":2503,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7818},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818714,"byte_end":1818719,"line_start":2567,"line_end":2567,"column_start":12,"column_end":17},"name":"chars","qualname":"<str>::chars","value":"fn (&self) -> Chars<'_>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the [`char`]s of a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818643,"byte_end":1818688,"line_start":2565,"line_end":2565,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1818693,"byte_end":1818702,"line_start":2566,"line_end":2566,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7820},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1820602,"byte_end":1820614,"line_start":2622,"line_end":2622,"column_start":12,"column_end":24},"name":"char_indices","qualname":"<str>::char_indices","value":"fn (&self) -> CharIndices<'_>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator over the [`char`]s of a string slice, and their\n positions.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1820531,"byte_end":1820576,"line_start":2620,"line_end":2620,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1820581,"byte_end":1820590,"line_start":2621,"line_end":2621,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7822},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1821367,"byte_end":1821372,"line_start":2647,"line_end":2647,"column_start":12,"column_end":17},"name":"bytes","qualname":"<str>::bytes","value":"fn (&self) -> Bytes<'_>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the bytes of a string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1821296,"byte_end":1821341,"line_start":2645,"line_end":2645,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1821346,"byte_end":1821355,"line_start":2646,"line_end":2646,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7824},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1822825,"byte_end":1822841,"line_start":2690,"line_end":2690,"column_start":12,"column_end":28},"name":"split_whitespace","qualname":"<str>::split_whitespace","value":"fn (&self) -> SplitWhitespace<'_>","parent":null,"children":[],"decl_id":null,"docs":" Splits a string slice by whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"split_whitespace\", since = \"1.1.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1822743,"byte_end":1822799,"line_start":2688,"line_end":2688,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1822804,"byte_end":1822813,"line_start":2689,"line_end":2689,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7826},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1824220,"byte_end":1824242,"line_start":2731,"line_end":2731,"column_start":12,"column_end":34},"name":"split_ascii_whitespace","qualname":"<str>::split_ascii_whitespace","value":"fn (&self) -> SplitAsciiWhitespace<'_>","parent":null,"children":[],"decl_id":null,"docs":" Splits a string slice by ASCII whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1824131,"byte_end":1824194,"line_start":2729,"line_end":2729,"column_start":5,"column_end":68}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1824199,"byte_end":1824208,"line_start":2730,"line_end":2730,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7828},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825609,"byte_end":1825614,"line_start":2778,"line_end":2778,"column_start":12,"column_end":17},"name":"lines","qualname":"<str>::lines","value":"fn (&self) -> Lines<'_>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the lines of a string, as string slices.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825538,"byte_end":1825583,"line_start":2776,"line_end":2776,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825588,"byte_end":1825597,"line_start":2777,"line_end":2777,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7830},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825929,"byte_end":1825938,"line_start":2787,"line_end":2787,"column_start":12,"column_end":21},"name":"lines_any","qualname":"<str>::lines_any","value":"fn (&self) -> LinesAny<'_>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the lines of a string.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825756,"byte_end":1825801,"line_start":2783,"line_end":2783,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825806,"byte_end":1825878,"line_start":2784,"line_end":2784,"column_start":5,"column_end":77}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825883,"byte_end":1825892,"line_start":2785,"line_end":2785,"column_start":5,"column_end":14}},{"value":"allow(deprecated)","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1825897,"byte_end":1825917,"line_start":2786,"line_end":2786,"column_start":5,"column_end":25}}]},{"kind":"Method","id":{"krate":0,"index":7832},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1826423,"byte_end":1826435,"line_start":2806,"line_end":2806,"column_start":12,"column_end":24},"name":"encode_utf16","qualname":"<str>::encode_utf16","value":"fn (&self) -> EncodeUtf16<'_>","parent":null,"children":[],"decl_id":null,"docs":" Returns an iterator of `u16` over the string encoded as UTF-16.","sig":null,"attributes":[{"value":"stable(feature = \"encode_utf16\", since = \"1.8.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1826359,"byte_end":1826411,"line_start":2805,"line_end":2805,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":7834},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1826960,"byte_end":1826968,"line_start":2827,"line_end":2827,"column_start":12,"column_end":20},"name":"contains","qualname":"<str>::contains","value":"fn <'a, P> (&'a self, pat: P) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the given pattern matches a sub-slice of\n this string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1826889,"byte_end":1826934,"line_start":2825,"line_end":2825,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1826939,"byte_end":1826948,"line_start":2826,"line_end":2826,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7836},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1827480,"byte_end":1827491,"line_start":2847,"line_end":2847,"column_start":12,"column_end":23},"name":"starts_with","qualname":"<str>::starts_with","value":"fn <'a, P> (&'a self, pat: P) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the given pattern matches a prefix of this\n string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1827423,"byte_end":1827468,"line_start":2846,"line_end":2846,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":7838},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1827996,"byte_end":1828005,"line_start":2867,"line_end":2867,"column_start":12,"column_end":21},"name":"ends_with","qualname":"<str>::ends_with","value":"fn <'a, P> (&'a self, pat: P) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if the given pattern matches a suffix of this\n string slice.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1827939,"byte_end":1827984,"line_start":2866,"line_end":2866,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":7840},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1829468,"byte_end":1829472,"line_start":2916,"line_end":2916,"column_start":12,"column_end":16},"name":"find","qualname":"<str>::find","value":"fn <'a, P> (&'a self, pat: P) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Returns the byte index of the first character of this string slice that\n matches the pattern.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1829397,"byte_end":1829442,"line_start":2914,"line_end":2914,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1829447,"byte_end":1829456,"line_start":2915,"line_end":2915,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7842},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1830701,"byte_end":1830706,"line_start":2960,"line_end":2960,"column_start":12,"column_end":17},"name":"rfind","qualname":"<str>::rfind","value":"fn <'a, P> (&'a self, pat: P) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Returns the byte index of the last character of this string slice that\n matches the pattern.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1830630,"byte_end":1830675,"line_start":2958,"line_end":2958,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1830680,"byte_end":1830689,"line_start":2959,"line_end":2959,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7844},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1834540,"byte_end":1834545,"line_start":3073,"line_end":3073,"column_start":12,"column_end":17},"name":"split","qualname":"<str>::split","value":"fn <'a, P> (&'a self, pat: P) -> Split<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of this string slice, separated by\n characters matched by a pattern.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1834469,"byte_end":1834514,"line_start":3071,"line_end":3071,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1834519,"byte_end":1834528,"line_start":3072,"line_end":3072,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7846},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1836451,"byte_end":1836457,"line_start":3127,"line_end":3127,"column_start":12,"column_end":18},"name":"rsplit","qualname":"<str>::rsplit","value":"fn <'a, P> (&'a self, pat: P) -> RSplit<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of the given string slice, separated by\n characters matched by a pattern and yielded in reverse order.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1836380,"byte_end":1836425,"line_start":3125,"line_end":3125,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1836430,"byte_end":1836439,"line_start":3126,"line_end":3126,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7848},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1838118,"byte_end":1838134,"line_start":3173,"line_end":3173,"column_start":12,"column_end":28},"name":"split_terminator","qualname":"<str>::split_terminator","value":"fn <'a, P> (&'a self, pat: P) -> SplitTerminator<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of the given string slice, separated by\n characters matched by a pattern.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1838047,"byte_end":1838092,"line_start":3171,"line_end":3171,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1838097,"byte_end":1838106,"line_start":3172,"line_end":3172,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7850},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1839742,"byte_end":1839759,"line_start":3218,"line_end":3218,"column_start":12,"column_end":29},"name":"rsplit_terminator","qualname":"<str>::rsplit_terminator","value":"fn <'a, P> (&'a self, pat: P) -> RSplitTerminator<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of `self`, separated by characters\n matched by a pattern and yielded in reverse order.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1839671,"byte_end":1839716,"line_start":3216,"line_end":3216,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1839721,"byte_end":1839730,"line_start":3217,"line_end":3217,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7852},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1841539,"byte_end":1841545,"line_start":3269,"line_end":3269,"column_start":12,"column_end":18},"name":"splitn","qualname":"<str>::splitn","value":"fn <'a, P> (&'a self, n: usize, pat: P) -> SplitN<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of the given string slice, separated by a\n pattern, restricted to returning at most `n` items.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1841468,"byte_end":1841513,"line_start":3267,"line_end":3267,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1841518,"byte_end":1841527,"line_start":3268,"line_end":3268,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7854},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1843276,"byte_end":1843283,"line_start":3318,"line_end":3318,"column_start":12,"column_end":19},"name":"rsplitn","qualname":"<str>::rsplitn","value":"fn <'a, P> (&'a self, n: usize, pat: P) -> RSplitN<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over substrings of this string slice, separated by a\n pattern, starting from the end of the string, restricted to returning\n at most `n` items.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1843205,"byte_end":1843250,"line_start":3316,"line_end":3316,"column_start":5,"column_end":50}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1843255,"byte_end":1843264,"line_start":3317,"line_end":3317,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7856},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844669,"byte_end":1844676,"line_start":3356,"line_end":3356,"column_start":12,"column_end":19},"name":"matches","qualname":"<str>::matches","value":"fn <'a, P> (&'a self, pat: P) -> Matches<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the disjoint matches of a pattern within the given string\n slice.","sig":null,"attributes":[{"value":"stable(feature = \"str_matches\", since = \"1.2.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844592,"byte_end":1844643,"line_start":3354,"line_end":3354,"column_start":5,"column_end":56}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1844648,"byte_end":1844657,"line_start":3355,"line_end":3355,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7858},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1845889,"byte_end":1845897,"line_start":3391,"line_end":3391,"column_start":12,"column_end":20},"name":"rmatches","qualname":"<str>::rmatches","value":"fn <'a, P> (&'a self, pat: P) -> RMatches<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the disjoint matches of a pattern within this string slice,\n yielded in reverse order.","sig":null,"attributes":[{"value":"stable(feature = \"str_matches\", since = \"1.2.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1845812,"byte_end":1845863,"line_start":3389,"line_end":3389,"column_start":5,"column_end":56}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1845868,"byte_end":1845877,"line_start":3390,"line_end":3390,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7860},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1847577,"byte_end":1847590,"line_start":3435,"line_end":3435,"column_start":12,"column_end":25},"name":"match_indices","qualname":"<str>::match_indices","value":"fn <'a, P> (&'a self, pat: P) -> MatchIndices<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the disjoint matches of a pattern within this string\n slice as well as the index that the match starts at.","sig":null,"attributes":[{"value":"stable(feature = \"str_match_indices\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1847494,"byte_end":1847551,"line_start":3433,"line_end":3433,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1847556,"byte_end":1847565,"line_start":3434,"line_end":3434,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7862},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849153,"byte_end":1849167,"line_start":3476,"line_end":3476,"column_start":12,"column_end":26},"name":"rmatch_indices","qualname":"<str>::rmatch_indices","value":"fn <'a, P> (&'a self, pat: P) -> RMatchIndices<'a, P>","parent":null,"children":[],"decl_id":null,"docs":" An iterator over the disjoint matches of a pattern within `self`,\n yielded in reverse order along with the index of the match.","sig":null,"attributes":[{"value":"stable(feature = \"str_match_indices\", since = \"1.5.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849070,"byte_end":1849127,"line_start":3474,"line_end":3474,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849132,"byte_end":1849141,"line_start":3475,"line_end":3475,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7864},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849892,"byte_end":1849896,"line_start":3499,"line_end":3499,"column_start":12,"column_end":16},"name":"trim","qualname":"<str>::trim","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with leading and trailing whitespace removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a slice, without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849720,"byte_end":1849830,"line_start":3496,"line_end":3497,"column_start":5,"column_end":51}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1849835,"byte_end":1849880,"line_start":3498,"line_end":3498,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":7866},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1851138,"byte_end":1851148,"line_start":3536,"line_end":3536,"column_start":12,"column_end":22},"name":"trim_start","qualname":"<str>::trim_start","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with leading whitespace removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1850952,"byte_end":1851066,"line_start":3533,"line_end":3534,"column_start":5,"column_end":51}},{"value":"stable(feature = \"trim_direction\", since = \"1.30.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1851071,"byte_end":1851126,"line_start":3535,"line_end":3535,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":7868},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1852399,"byte_end":1852407,"line_start":3573,"line_end":3573,"column_start":12,"column_end":20},"name":"trim_end","qualname":"<str>::trim_end","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with trailing whitespace removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1852213,"byte_end":1852327,"line_start":3570,"line_end":3571,"column_start":5,"column_end":51}},{"value":"stable(feature = \"trim_direction\", since = \"1.30.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1852332,"byte_end":1852387,"line_start":3572,"line_end":3572,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":7870},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1853633,"byte_end":1853642,"line_start":3614,"line_end":3614,"column_start":12,"column_end":21},"name":"trim_left","qualname":"<str>::trim_left","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with leading whitespace removed.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1853437,"byte_end":1853482,"line_start":3608,"line_end":3608,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.33.0\",\n                   reason = \"superseded by `trim_start`\",\n                   suggestion = \"trim_start\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1853487,"byte_end":1853621,"line_start":3609,"line_end":3613,"column_start":5,"column_end":7}}]},{"kind":"Method","id":{"krate":0,"index":7872},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1854846,"byte_end":1854856,"line_start":3655,"line_end":3655,"column_start":12,"column_end":22},"name":"trim_right","qualname":"<str>::trim_right","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with trailing whitespace removed.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1854654,"byte_end":1854699,"line_start":3649,"line_end":3649,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.33.0\",\n                   reason = \"superseded by `trim_end`\",\n                   suggestion = \"trim_end\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1854704,"byte_end":1854834,"line_start":3650,"line_end":3654,"column_start":5,"column_end":7}}]},{"kind":"Method","id":{"krate":0,"index":7874},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1855816,"byte_end":1855828,"line_start":3685,"line_end":3685,"column_start":12,"column_end":24},"name":"trim_matches","qualname":"<str>::trim_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all prefixes and suffixes that match a\n pattern repeatedly removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1855640,"byte_end":1855754,"line_start":3682,"line_end":3683,"column_start":5,"column_end":51}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1855759,"byte_end":1855804,"line_start":3684,"line_end":3684,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":7876},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1857532,"byte_end":1857550,"line_start":3732,"line_end":3732,"column_start":12,"column_end":30},"name":"trim_start_matches","qualname":"<str>::trim_start_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all prefixes that match a pattern\n repeatedly removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1857346,"byte_end":1857460,"line_start":3729,"line_end":3730,"column_start":5,"column_end":51}},{"value":"stable(feature = \"trim_direction\", since = \"1.30.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1857465,"byte_end":1857520,"line_start":3731,"line_end":3731,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":7878},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1859154,"byte_end":1859170,"line_start":3777,"line_end":3777,"column_start":12,"column_end":28},"name":"trim_end_matches","qualname":"<str>::trim_end_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all suffixes that match a pattern\n repeatedly removed.","sig":null,"attributes":[{"value":"must_use =\n      \"this returns the trimmed string as a new slice, without modifying the original\"","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1858968,"byte_end":1859082,"line_start":3774,"line_end":3775,"column_start":5,"column_end":51}},{"value":"stable(feature = \"trim_direction\", since = \"1.30.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1859087,"byte_end":1859142,"line_start":3776,"line_end":3776,"column_start":5,"column_end":60}}]},{"kind":"Method","id":{"krate":0,"index":7880},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1860745,"byte_end":1860762,"line_start":3823,"line_end":3823,"column_start":12,"column_end":29},"name":"trim_left_matches","qualname":"<str>::trim_left_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all prefixes that match a pattern\n repeatedly removed.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1860533,"byte_end":1860578,"line_start":3817,"line_end":3817,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.33.0\",\n                   reason = \"superseded by `trim_start_matches`\",\n                   suggestion = \"trim_start_matches\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1860583,"byte_end":1860733,"line_start":3818,"line_end":3822,"column_start":5,"column_end":7}}]},{"kind":"Method","id":{"krate":0,"index":7882},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1862211,"byte_end":1862229,"line_start":3865,"line_end":3865,"column_start":12,"column_end":30},"name":"trim_right_matches","qualname":"<str>::trim_right_matches","value":"fn <'a, P> (&'a self, pat: P) -> &'a str","parent":null,"children":[],"decl_id":null,"docs":" Returns a string slice with all suffixes that match a pattern\n repeatedly removed.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1862003,"byte_end":1862048,"line_start":3859,"line_end":3859,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.33.0\",\n                   reason = \"superseded by `trim_end_matches`\",\n                   suggestion = \"trim_end_matches\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1862053,"byte_end":1862199,"line_start":3860,"line_end":3864,"column_start":5,"column_end":7}}]},{"kind":"Method","id":{"krate":0,"index":7884},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1863670,"byte_end":1863675,"line_start":3917,"line_end":3917,"column_start":12,"column_end":17},"name":"parse","qualname":"<str>::parse","value":"fn <F> (&self) -> Result<F, F::Err>","parent":null,"children":[],"decl_id":null,"docs":" Parses this string slice into another type.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1863599,"byte_end":1863608,"line_start":3915,"line_end":3915,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1863613,"byte_end":1863658,"line_start":3916,"line_end":3916,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":7886},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864153,"byte_end":1864161,"line_start":3934,"line_end":3934,"column_start":12,"column_end":20},"name":"is_ascii","qualname":"<str>::is_ascii","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks if all characters in this string are within the ASCII range.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864059,"byte_end":1864127,"line_start":3932,"line_end":3932,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864132,"byte_end":1864141,"line_start":3933,"line_end":3933,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7888},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864945,"byte_end":1864965,"line_start":3955,"line_end":3955,"column_start":12,"column_end":32},"name":"eq_ignore_ascii_case","qualname":"<str>::eq_ignore_ascii_case","value":"fn (&self, other: &str) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Checks that two strings are an ASCII case-insensitive match.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864851,"byte_end":1864919,"line_start":3953,"line_end":3953,"column_start":5,"column_end":73}},{"value":"inline","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1864924,"byte_end":1864933,"line_start":3954,"line_end":3954,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":7890},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1865524,"byte_end":1865544,"line_start":3969,"line_end":3969,"column_start":12,"column_end":32},"name":"make_ascii_uppercase","qualname":"<str>::make_ascii_uppercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this string to its ASCII upper case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1865444,"byte_end":1865512,"line_start":3968,"line_end":3968,"column_start":5,"column_end":73}}]},{"kind":"Method","id":{"krate":0,"index":7892},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1866106,"byte_end":1866126,"line_start":3984,"line_end":3984,"column_start":12,"column_end":32},"name":"make_ascii_lowercase","qualname":"<str>::make_ascii_lowercase","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Converts this string to its ASCII lower case equivalent in-place.","sig":null,"attributes":[{"value":"stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1866026,"byte_end":1866094,"line_start":3983,"line_end":3983,"column_start":5,"column_end":73}}]},{"kind":"Method","id":{"krate":0,"index":7894},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867137,"byte_end":1867149,"line_start":4026,"line_end":4026,"column_start":12,"column_end":24},"name":"escape_debug","qualname":"<str>::escape_debug","value":"fn (&self) -> EscapeDebug<'_>","parent":null,"children":[],"decl_id":null,"docs":" Return an iterator that escapes each char in `self` with [`char::escape_debug`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1867074,"byte_end":1867125,"line_start":4025,"line_end":4025,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":7896},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1868295,"byte_end":1868309,"line_start":4071,"line_end":4071,"column_start":12,"column_end":26},"name":"escape_default","qualname":"<str>::escape_default","value":"fn (&self) -> EscapeDefault<'_>","parent":null,"children":[],"decl_id":null,"docs":" Return an iterator that escapes each char in `self` with [`char::escape_default`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1868232,"byte_end":1868283,"line_start":4070,"line_end":4070,"column_start":5,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":7898},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1869273,"byte_end":1869287,"line_start":4109,"line_end":4109,"column_start":12,"column_end":26},"name":"escape_unicode","qualname":"<str>::escape_unicode","value":"fn (&self) -> EscapeUnicode<'_>","parent":null,"children":[],"decl_id":null,"docs":" Return an iterator that escapes each char in `self` with [`char::escape_unicode`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1869210,"byte_end":1869261,"line_start":4108,"line_end":4108,"column_start":5,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":43500},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1870744,"byte_end":1870759,"line_start":4160,"line_end":4160,"column_start":12,"column_end":27},"name":"SplitWhitespace","qualname":"::str::SplitWhitespace","value":"SplitWhitespace {  }","parent":null,"children":[{"krate":0,"index":23861}],"decl_id":null,"docs":" An iterator over the non-whitespace substrings of a string,\n separated by any amount of whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"split_whitespace\", since = \"1.1.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1870652,"byte_end":1870708,"line_start":4158,"line_end":4158,"column_start":1,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":43510},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1871300,"byte_end":1871320,"line_start":4174,"line_end":4174,"column_start":12,"column_end":32},"name":"SplitAsciiWhitespace","qualname":"::str::SplitAsciiWhitespace","value":"SplitAsciiWhitespace {  }","parent":null,"children":[{"krate":0,"index":23869}],"decl_id":null,"docs":" An iterator over the non-ASCII-whitespace substrings of a string,\n separated by any amount of ASCII whitespace.","sig":null,"attributes":[{"value":"stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1871201,"byte_end":1871264,"line_start":4172,"line_end":4172,"column_start":1,"column_end":64}}]},{"kind":"Struct","id":{"krate":0,"index":43620},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1873801,"byte_end":1873812,"line_start":4268,"line_end":4268,"column_start":12,"column_end":23},"name":"EncodeUtf16","qualname":"::str::EncodeUtf16","value":"EncodeUtf16 {  }","parent":null,"children":[{"krate":0,"index":23917},{"krate":0,"index":23919}],"decl_id":null,"docs":" An iterator of [`u16`] over the string encoded as UTF-16.","sig":null,"attributes":[{"value":"stable(feature = \"encode_utf16\", since = \"1.8.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1873737,"byte_end":1873789,"line_start":4267,"line_end":4267,"column_start":1,"column_end":53}}]},{"kind":"Struct","id":{"krate":0,"index":43626},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1875229,"byte_end":1875240,"line_start":4320,"line_end":4320,"column_start":12,"column_end":23},"name":"EscapeDebug","qualname":"::str::EscapeDebug","value":"EscapeDebug {  }","parent":null,"children":[{"krate":0,"index":23925}],"decl_id":null,"docs":" The return type of [`str::escape_debug`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1875142,"byte_end":1875193,"line_start":4318,"line_end":4318,"column_start":1,"column_end":52}}]},{"kind":"Struct","id":{"krate":0,"index":43636},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1875619,"byte_end":1875632,"line_start":4332,"line_end":4332,"column_start":12,"column_end":25},"name":"EscapeDefault","qualname":"::str::EscapeDefault","value":"EscapeDefault {  }","parent":null,"children":[{"krate":0,"index":23933}],"decl_id":null,"docs":" The return type of [`str::escape_default`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1875532,"byte_end":1875583,"line_start":4330,"line_end":4330,"column_start":1,"column_end":52}}]},{"kind":"Struct","id":{"krate":0,"index":43646},"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1875932,"byte_end":1875945,"line_start":4341,"line_end":4341,"column_start":12,"column_end":25},"name":"EscapeUnicode","qualname":"::str::EscapeUnicode","value":"EscapeUnicode {  }","parent":null,"children":[{"krate":0,"index":23941}],"decl_id":null,"docs":" The return type of [`str::escape_unicode`].","sig":null,"attributes":[{"value":"stable(feature = \"str_escape\", since = \"1.34.0\")","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1875845,"byte_end":1875896,"line_start":4339,"line_end":4339,"column_start":1,"column_end":52}}]},{"kind":"Mod","id":{"krate":0,"index":7956},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"hash","qualname":"::hash","value":"src/libcore/hash/mod.rs","parent":null,"children":[{"krate":0,"index":7958},{"krate":0,"index":7960},{"krate":0,"index":7962},{"krate":0,"index":7964},{"krate":0,"index":7966},{"krate":0,"index":8050},{"krate":0,"index":8056},{"krate":0,"index":8086},{"krate":0,"index":8116},{"krate":0,"index":8122},{"krate":0,"index":8124},{"krate":0,"index":8128},{"krate":0,"index":8134},{"krate":0,"index":8138},{"krate":0,"index":8142},{"krate":0,"index":8146},{"krate":0,"index":8148}],"decl_id":null,"docs":" Generic hashing support.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1938292,"byte_end":1938338,"line_start":82,"line_end":82,"column_start":1,"column_end":47}}]},{"kind":"Struct","id":{"krate":0,"index":43710},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1957295,"byte_end":1957306,"line_start":21,"line_end":21,"column_start":12,"column_end":23},"name":"SipHasher13","qualname":"::hash::sip::SipHasher13","value":"SipHasher13 {  }","parent":null,"children":[{"krate":0,"index":24001}],"decl_id":null,"docs":" An implementation of SipHash 1-3.","sig":null,"attributes":[{"value":"unstable(feature = \"hashmap_internals\", issue = \"0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1957055,"byte_end":1957110,"line_start":16,"line_end":16,"column_start":1,"column_end":56}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1957111,"byte_end":1957235,"line_start":17,"line_end":18,"column_start":1,"column_end":88}}]},{"kind":"Struct","id":{"krate":0,"index":43738},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1958510,"byte_end":1958519,"line_start":52,"line_end":52,"column_start":12,"column_end":21},"name":"SipHasher","qualname":"::hash::sip::SipHasher","value":"","parent":null,"children":[],"decl_id":null,"docs":" An implementation of SipHash 2-4.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1958295,"byte_end":1958340,"line_start":48,"line_end":48,"column_start":1,"column_end":46}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1958341,"byte_end":1958465,"line_start":49,"line_end":50,"column_start":1,"column_end":88}}]},{"kind":"Method","id":{"krate":0,"index":7984},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961376,"byte_end":1961379,"line_start":140,"line_end":140,"column_start":12,"column_end":15},"name":"new","qualname":"<SipHasher>::new","value":"fn () -> SipHasher","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `SipHasher` with the two initial keys set to 0.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961172,"byte_end":1961181,"line_start":136,"line_end":136,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961186,"byte_end":1961231,"line_start":137,"line_end":137,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961236,"byte_end":1961364,"line_start":138,"line_end":139,"column_start":5,"column_end":92}}]},{"kind":"Method","id":{"krate":0,"index":7986},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961718,"byte_end":1961731,"line_start":149,"line_end":149,"column_start":12,"column_end":25},"name":"new_with_keys","qualname":"<SipHasher>::new_with_keys","value":"fn (key0: u64, key1: u64) -> SipHasher","parent":null,"children":[],"decl_id":null,"docs":" Creates a `SipHasher` that is keyed off the provided keys.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961514,"byte_end":1961523,"line_start":145,"line_end":145,"column_start":5,"column_end":14}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961528,"byte_end":1961573,"line_start":146,"line_end":146,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961578,"byte_end":1961706,"line_start":147,"line_end":148,"column_start":5,"column_end":92}}]},{"kind":"Method","id":{"krate":0,"index":7990},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1962184,"byte_end":1962187,"line_start":162,"line_end":162,"column_start":12,"column_end":15},"name":"new","qualname":"<SipHasher13>::new","value":"fn () -> SipHasher13","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `SipHasher13` with the two initial keys set to 0.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961970,"byte_end":1961979,"line_start":158,"line_end":158,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"hashmap_internals\", issue = \"0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961984,"byte_end":1962039,"line_start":159,"line_end":159,"column_start":5,"column_end":60}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1962044,"byte_end":1962172,"line_start":160,"line_end":161,"column_start":5,"column_end":92}}]},{"kind":"Method","id":{"krate":0,"index":7992},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1962542,"byte_end":1962555,"line_start":171,"line_end":171,"column_start":12,"column_end":25},"name":"new_with_keys","qualname":"<SipHasher13>::new_with_keys","value":"fn (key0: u64, key1: u64) -> SipHasher13","parent":null,"children":[],"decl_id":null,"docs":" Creates a `SipHasher13` that is keyed off the provided keys.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1962328,"byte_end":1962337,"line_start":167,"line_end":167,"column_start":5,"column_end":14}},{"value":"unstable(feature = \"hashmap_internals\", issue = \"0\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1962342,"byte_end":1962397,"line_start":168,"line_end":168,"column_start":5,"column_end":60}},{"value":"rustc_deprecated(since = \"1.13.0\",\n                   reason =\n                       \"use `std::collections::hash_map::DefaultHasher` instead\")","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1962402,"byte_end":1962530,"line_start":169,"line_end":170,"column_start":5,"column_end":92}}]},{"kind":"Method","id":{"krate":0,"index":8034},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1967712,"byte_end":1967720,"line_start":365,"line_end":365,"column_start":8,"column_end":16},"name":"c_rounds","qualname":"::hash::sip::Sip::c_rounds","value":"fn (_: &mut State) -> ()","parent":{"krate":0,"index":8032},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8036},"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1967744,"byte_end":1967752,"line_start":366,"line_end":366,"column_start":8,"column_end":16},"name":"d_rounds","qualname":"::hash::sip::Sip::d_rounds","value":"fn (_: &mut State) -> ()","parent":{"krate":0,"index":8032},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":8050},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1940259,"byte_end":1940263,"line_start":158,"line_end":158,"column_start":11,"column_end":15},"name":"Hash","qualname":"::hash::Hash","value":"Hash","parent":null,"children":[{"krate":0,"index":8052},{"krate":0,"index":8054}],"decl_id":null,"docs":" A hashable type.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1940203,"byte_end":1940248,"line_start":157,"line_end":157,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8052},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1940713,"byte_end":1940717,"line_start":174,"line_end":174,"column_start":8,"column_end":12},"name":"hash","qualname":"::hash::Hash::hash","value":"fn <H> (&self, state: &mut H) -> ()","parent":{"krate":0,"index":8050},"children":[],"decl_id":null,"docs":" Feeds this value into the given [`Hasher`].","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1940660,"byte_end":1940705,"line_start":173,"line_end":173,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8054},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1941274,"byte_end":1941284,"line_start":192,"line_end":192,"column_start":8,"column_end":18},"name":"hash_slice","qualname":"::hash::Hash::hash_slice","value":"fn <H> (data: &[Self], state: &mut H) -> ()","parent":{"krate":0,"index":8050},"children":[],"decl_id":null,"docs":" Feeds a slice of this type into the given [`Hasher`].","sig":null,"attributes":[{"value":"stable(feature = \"hash_slice\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1941216,"byte_end":1941266,"line_start":191,"line_end":191,"column_start":5,"column_end":55}}]},{"kind":"Trait","id":{"krate":0,"index":8056},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1942404,"byte_end":1942410,"line_start":232,"line_end":232,"column_start":11,"column_end":17},"name":"Hasher","qualname":"::hash::Hasher","value":"Hasher","parent":null,"children":[{"krate":0,"index":8058},{"krate":0,"index":8060},{"krate":0,"index":8062},{"krate":0,"index":8064},{"krate":0,"index":8066},{"krate":0,"index":8068},{"krate":0,"index":8070},{"krate":0,"index":8072},{"krate":0,"index":8074},{"krate":0,"index":8076},{"krate":0,"index":8078},{"krate":0,"index":8080},{"krate":0,"index":8082},{"krate":0,"index":8084}],"decl_id":null,"docs":" A trait for hashing an arbitrary stream of bytes.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1942348,"byte_end":1942393,"line_start":231,"line_end":231,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8058},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943121,"byte_end":1943127,"line_start":254,"line_end":254,"column_start":8,"column_end":14},"name":"finish","qualname":"::hash::Hasher::finish","value":"fn (&self) -> u64","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Returns the hash value for the values written so far.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943068,"byte_end":1943113,"line_start":253,"line_end":253,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8060},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943612,"byte_end":1943617,"line_start":272,"line_end":272,"column_start":8,"column_end":13},"name":"write","qualname":"::hash::Hasher::write","value":"fn (&mut self, bytes: &[u8]) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes some data into this `Hasher`.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943559,"byte_end":1943604,"line_start":271,"line_end":271,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8062},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943770,"byte_end":1943778,"line_start":277,"line_end":277,"column_start":8,"column_end":16},"name":"write_u8","qualname":"::hash::Hasher::write_u8","value":"fn (&mut self, i: u8) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `u8` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943696,"byte_end":1943705,"line_start":275,"line_end":275,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943710,"byte_end":1943762,"line_start":276,"line_end":276,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8064},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943956,"byte_end":1943965,"line_start":283,"line_end":283,"column_start":8,"column_end":17},"name":"write_u16","qualname":"::hash::Hasher::write_u16","value":"fn (&mut self, i: u16) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `u16` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943882,"byte_end":1943891,"line_start":281,"line_end":281,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1943896,"byte_end":1943948,"line_start":282,"line_end":282,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8066},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944156,"byte_end":1944165,"line_start":289,"line_end":289,"column_start":8,"column_end":17},"name":"write_u32","qualname":"::hash::Hasher::write_u32","value":"fn (&mut self, i: u32) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `u32` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944082,"byte_end":1944091,"line_start":287,"line_end":287,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944096,"byte_end":1944148,"line_start":288,"line_end":288,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8068},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944356,"byte_end":1944365,"line_start":295,"line_end":295,"column_start":8,"column_end":17},"name":"write_u64","qualname":"::hash::Hasher::write_u64","value":"fn (&mut self, i: u64) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `u64` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944282,"byte_end":1944291,"line_start":293,"line_end":293,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944296,"byte_end":1944348,"line_start":294,"line_end":294,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8070},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944550,"byte_end":1944560,"line_start":301,"line_end":301,"column_start":8,"column_end":18},"name":"write_u128","qualname":"::hash::Hasher::write_u128","value":"fn (&mut self, i: u128) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `u128` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944483,"byte_end":1944492,"line_start":299,"line_end":299,"column_start":5,"column_end":14}},{"value":"stable(feature = \"i128\", since = \"1.26.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944497,"byte_end":1944542,"line_start":300,"line_end":300,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8072},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944754,"byte_end":1944765,"line_start":307,"line_end":307,"column_start":8,"column_end":19},"name":"write_usize","qualname":"::hash::Hasher::write_usize","value":"fn (&mut self, i: usize) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `usize` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944680,"byte_end":1944689,"line_start":305,"line_end":305,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944694,"byte_end":1944746,"line_start":306,"line_end":306,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8074},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944958,"byte_end":1944966,"line_start":314,"line_end":314,"column_start":8,"column_end":16},"name":"write_i8","qualname":"::hash::Hasher::write_i8","value":"fn (&mut self, i: i8) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `i8` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944884,"byte_end":1944893,"line_start":312,"line_end":312,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1944898,"byte_end":1944950,"line_start":313,"line_end":313,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8076},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945150,"byte_end":1945159,"line_start":320,"line_end":320,"column_start":8,"column_end":17},"name":"write_i16","qualname":"::hash::Hasher::write_i16","value":"fn (&mut self, i: i16) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `i16` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945076,"byte_end":1945085,"line_start":318,"line_end":318,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945090,"byte_end":1945142,"line_start":319,"line_end":319,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8078},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945350,"byte_end":1945359,"line_start":326,"line_end":326,"column_start":8,"column_end":17},"name":"write_i32","qualname":"::hash::Hasher::write_i32","value":"fn (&mut self, i: i32) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `i32` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945276,"byte_end":1945285,"line_start":324,"line_end":324,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945290,"byte_end":1945342,"line_start":325,"line_end":325,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8080},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945550,"byte_end":1945559,"line_start":332,"line_end":332,"column_start":8,"column_end":17},"name":"write_i64","qualname":"::hash::Hasher::write_i64","value":"fn (&mut self, i: i64) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `i64` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945476,"byte_end":1945485,"line_start":330,"line_end":330,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945490,"byte_end":1945542,"line_start":331,"line_end":331,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8082},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945744,"byte_end":1945754,"line_start":338,"line_end":338,"column_start":8,"column_end":18},"name":"write_i128","qualname":"::hash::Hasher::write_i128","value":"fn (&mut self, i: i128) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `i128` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945677,"byte_end":1945686,"line_start":336,"line_end":336,"column_start":5,"column_end":14}},{"value":"stable(feature = \"i128\", since = \"1.26.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945691,"byte_end":1945736,"line_start":337,"line_end":337,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8084},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945948,"byte_end":1945959,"line_start":344,"line_end":344,"column_start":8,"column_end":19},"name":"write_isize","qualname":"::hash::Hasher::write_isize","value":"fn (&mut self, i: isize) -> ()","parent":{"krate":0,"index":8056},"children":[],"decl_id":null,"docs":" Writes a single `isize` into this hasher.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945874,"byte_end":1945883,"line_start":342,"line_end":342,"column_start":5,"column_end":14}},{"value":"stable(feature = \"hasher_write\", since = \"1.3.0\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1945888,"byte_end":1945940,"line_start":343,"line_end":343,"column_start":5,"column_end":57}}]},{"kind":"Trait","id":{"krate":0,"index":8116},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1948218,"byte_end":1948229,"line_start":425,"line_end":425,"column_start":11,"column_end":22},"name":"BuildHasher","qualname":"::hash::BuildHasher","value":"BuildHasher","parent":null,"children":[{"krate":0,"index":8118},{"krate":0,"index":8120}],"decl_id":null,"docs":" A trait for creating instances of [`Hasher`].","sig":null,"attributes":[{"value":"stable(since = \"1.7.0\", feature = \"build_hasher\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1948155,"byte_end":1948207,"line_start":424,"line_end":424,"column_start":1,"column_end":53}}]},{"kind":"Type","id":{"krate":0,"index":8118},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1948347,"byte_end":1948353,"line_start":428,"line_end":428,"column_start":10,"column_end":16},"name":"Hasher","qualname":"::hash::BuildHasher::Hasher","value":"type Hasher: Hasher;","parent":{"krate":0,"index":8116},"children":[],"decl_id":null,"docs":" Type of the hasher that will be created.\n","sig":null,"attributes":[{"value":"stable(since = \"1.7.0\", feature = \"build_hasher\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1948285,"byte_end":1948337,"line_start":427,"line_end":427,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":8120},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1948845,"byte_end":1948857,"line_start":447,"line_end":447,"column_start":8,"column_end":20},"name":"build_hasher","qualname":"::hash::BuildHasher::build_hasher","value":"fn (&self) -> Self::Hasher","parent":{"krate":0,"index":8116},"children":[],"decl_id":null,"docs":" Creates a new hasher.","sig":null,"attributes":[{"value":"stable(since = \"1.7.0\", feature = \"build_hasher\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1948785,"byte_end":1948837,"line_start":446,"line_end":446,"column_start":5,"column_end":57}}]},{"kind":"Struct","id":{"krate":0,"index":8122},"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1950586,"byte_end":1950604,"line_start":499,"line_end":499,"column_start":12,"column_end":30},"name":"BuildHasherDefault","qualname":"::hash::BuildHasherDefault","value":"","parent":null,"children":[],"decl_id":null,"docs":" Used to create a default [`BuildHasher`] instance for types that implement\n [`Hasher`] and [`Default`].","sig":null,"attributes":[{"value":"stable(since = \"1.7.0\", feature = \"build_hasher\")","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1950522,"byte_end":1950574,"line_start":498,"line_end":498,"column_start":1,"column_end":53}}]},{"kind":"Mod","id":{"krate":0,"index":8198},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"fmt","qualname":"::fmt","value":"src/libcore/fmt/mod.rs","parent":null,"children":[{"krate":0,"index":8200},{"krate":0,"index":8212},{"krate":0,"index":8214},{"krate":0,"index":8216},{"krate":0,"index":8218},{"krate":0,"index":8220},{"krate":0,"index":8222},{"krate":0,"index":8224},{"krate":0,"index":8226},{"krate":0,"index":8260},{"krate":0,"index":8324},{"krate":0,"index":44510},{"krate":0,"index":44512},{"krate":0,"index":8408},{"krate":0,"index":8420},{"krate":0,"index":8424},{"krate":0,"index":44564},{"krate":0,"index":44598},{"krate":0,"index":44594},{"krate":0,"index":44590},{"krate":0,"index":44586},{"krate":0,"index":44582},{"krate":0,"index":44578},{"krate":0,"index":44574},{"krate":0,"index":44570},{"krate":0,"index":44566},{"krate":0,"index":8426},{"krate":0,"index":8434},{"krate":0,"index":8442},{"krate":0,"index":8444},{"krate":0,"index":44600},{"krate":0,"index":44606},{"krate":0,"index":44602},{"krate":0,"index":8446},{"krate":0,"index":44608},{"krate":0,"index":44614},{"krate":0,"index":44610},{"krate":0,"index":8456},{"krate":0,"index":44616},{"krate":0,"index":44622},{"krate":0,"index":44618},{"krate":0,"index":8464},{"krate":0,"index":8468},{"krate":0,"index":8472},{"krate":0,"index":8476},{"krate":0,"index":8480},{"krate":0,"index":8484},{"krate":0,"index":8488},{"krate":0,"index":8492},{"krate":0,"index":8496},{"krate":0,"index":8500},{"krate":0,"index":8504},{"krate":0,"index":8508},{"krate":0,"index":8510},{"krate":0,"index":8512},{"krate":0,"index":8518},{"krate":0,"index":8578},{"krate":0,"index":8586},{"krate":0,"index":8590},{"krate":0,"index":44624},{"krate":0,"index":44628},{"krate":0,"index":44632},{"krate":0,"index":44636},{"krate":0,"index":44640},{"krate":0,"index":44644},{"krate":0,"index":44648},{"krate":0,"index":44652},{"krate":0,"index":44656},{"krate":0,"index":44660},{"krate":0,"index":44664},{"krate":0,"index":44668},{"krate":0,"index":44672},{"krate":0,"index":44676},{"krate":0,"index":44680},{"krate":0,"index":44684},{"krate":0,"index":8592},{"krate":0,"index":8596},{"krate":0,"index":8600},{"krate":0,"index":8604},{"krate":0,"index":8608},{"krate":0,"index":8612},{"krate":0,"index":8616},{"krate":0,"index":8620},{"krate":0,"index":8624},{"krate":0,"index":8628},{"krate":0,"index":8632},{"krate":0,"index":8636},{"krate":0,"index":8640},{"krate":0,"index":8644},{"krate":0,"index":8648},{"krate":0,"index":8650},{"krate":0,"index":8652},{"krate":0,"index":44688},{"krate":0,"index":44692},{"krate":0,"index":44696},{"krate":0,"index":44700},{"krate":0,"index":44704},{"krate":0,"index":44708},{"krate":0,"index":44712},{"krate":0,"index":44716},{"krate":0,"index":44720},{"krate":0,"index":44724},{"krate":0,"index":44728},{"krate":0,"index":44732},{"krate":0,"index":8654},{"krate":0,"index":8658},{"krate":0,"index":8662},{"krate":0,"index":8666},{"krate":0,"index":8670},{"krate":0,"index":8680},{"krate":0,"index":8684},{"krate":0,"index":8688}],"decl_id":null,"docs":" Utilities for formatting and printing strings.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1968482,"byte_end":1968528,"line_start":3,"line_end":3,"column_start":1,"column_end":47}}]},{"kind":"Method","id":{"krate":0,"index":8282},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2042990,"byte_end":2042994,"line_start":14,"line_end":14,"column_start":8,"column_end":12},"name":"zero","qualname":"::fmt::num::Int::zero","value":"fn () -> Self","parent":{"krate":0,"index":8280},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8284},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043013,"byte_end":2043020,"line_start":15,"line_end":15,"column_start":8,"column_end":15},"name":"from_u8","qualname":"::fmt::num::Int::from_u8","value":"fn (u: u8) -> Self","parent":{"krate":0,"index":8280},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8286},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043044,"byte_end":2043049,"line_start":16,"line_end":16,"column_start":8,"column_end":13},"name":"to_u8","qualname":"::fmt::num::Int::to_u8","value":"fn (&self) -> u8","parent":{"krate":0,"index":8280},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8288},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043071,"byte_end":2043077,"line_start":17,"line_end":17,"column_start":8,"column_end":14},"name":"to_u16","qualname":"::fmt::num::Int::to_u16","value":"fn (&self) -> u16","parent":{"krate":0,"index":8280},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8290},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043100,"byte_end":2043106,"line_start":18,"line_end":18,"column_start":8,"column_end":14},"name":"to_u32","qualname":"::fmt::num::Int::to_u32","value":"fn (&self) -> u32","parent":{"krate":0,"index":8280},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8292},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043129,"byte_end":2043135,"line_start":19,"line_end":19,"column_start":8,"column_end":14},"name":"to_u64","qualname":"::fmt::num::Int::to_u64","value":"fn (&self) -> u64","parent":{"krate":0,"index":8280},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8294},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043158,"byte_end":2043165,"line_start":20,"line_end":20,"column_start":8,"column_end":15},"name":"to_u128","qualname":"::fmt::num::Int::to_u128","value":"fn (&self) -> u128","parent":{"krate":0,"index":8280},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8300},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043761,"byte_end":2043765,"line_start":40,"line_end":40,"column_start":11,"column_end":15},"name":"BASE","qualname":"::fmt::num::GenericRadix::BASE","value":"u8","parent":{"krate":0,"index":8298},"children":[],"decl_id":null,"docs":" The number of digits.\n","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8302},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043822,"byte_end":2043828,"line_start":43,"line_end":43,"column_start":11,"column_end":17},"name":"PREFIX","qualname":"::fmt::num::GenericRadix::PREFIX","value":"&'static str","parent":{"krate":0,"index":8298},"children":[],"decl_id":null,"docs":" A radix-specific prefix string.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8304},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043910,"byte_end":2043915,"line_start":46,"line_end":46,"column_start":8,"column_end":13},"name":"digit","qualname":"::fmt::num::GenericRadix::digit","value":"fn (x: u8) -> u8","parent":{"krate":0,"index":8298},"children":[],"decl_id":null,"docs":" Converts an integer to corresponding radix digit.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8306},"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2043999,"byte_end":2044006,"line_start":49,"line_end":49,"column_start":8,"column_end":15},"name":"fmt_int","qualname":"::fmt::num::GenericRadix::fmt_int","value":"fn <T> (&self, mut x: T, f: &mut fmt::Formatter<'_>) -> fmt::Result","parent":{"krate":0,"index":8298},"children":[],"decl_id":null,"docs":" Format an integer using the radix using a formatter.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":8338},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2054564,"byte_end":2054575,"line_start":82,"line_end":82,"column_start":12,"column_end":23},"name":"DebugStruct","qualname":"::fmt::builders::DebugStruct","value":"DebugStruct {  }","parent":null,"children":[{"krate":0,"index":4739},{"krate":0,"index":4741},{"krate":0,"index":4743}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2054392,"byte_end":2054457,"line_start":79,"line_end":79,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2054458,"byte_end":2054497,"line_start":80,"line_end":80,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2054498,"byte_end":2054552,"line_start":81,"line_end":81,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":8340},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2054684,"byte_end":2054700,"line_start":88,"line_end":88,"column_start":8,"column_end":24},"name":"debug_struct_new","qualname":"::fmt::builders::debug_struct_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugStruct<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8344},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2056011,"byte_end":2056016,"line_start":129,"line_end":129,"column_start":12,"column_end":17},"name":"field","qualname":"<DebugStruct>::field","value":"fn (&mut self, name: &str, value: &dyn fmt::Debug) -> &mut DebugStruct<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new field to the generated struct output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2055945,"byte_end":2055999,"line_start":128,"line_end":128,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8346},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2057751,"byte_end":2057757,"line_start":182,"line_end":182,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugStruct>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2057685,"byte_end":2057739,"line_start":181,"line_end":181,"column_start":5,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":8350},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2059135,"byte_end":2059145,"line_start":233,"line_end":233,"column_start":12,"column_end":22},"name":"DebugTuple","qualname":"::fmt::builders::DebugTuple","value":"DebugTuple {  }","parent":null,"children":[{"krate":0,"index":4761},{"krate":0,"index":4763},{"krate":0,"index":4765},{"krate":0,"index":4767}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2058963,"byte_end":2059028,"line_start":230,"line_end":230,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2059029,"byte_end":2059068,"line_start":231,"line_end":231,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2059069,"byte_end":2059123,"line_start":232,"line_end":232,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":8352},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2059273,"byte_end":2059288,"line_start":240,"line_end":240,"column_start":8,"column_end":23},"name":"debug_tuple_new","qualname":"::fmt::builders::debug_tuple_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8356},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2060305,"byte_end":2060310,"line_start":275,"line_end":275,"column_start":12,"column_end":17},"name":"field","qualname":"<DebugTuple>::field","value":"fn (&mut self, value: &dyn fmt::Debug) -> &mut DebugTuple<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new field to the generated tuple struct output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2060239,"byte_end":2060293,"line_start":274,"line_end":274,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8358},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2061765,"byte_end":2061771,"line_start":321,"line_end":321,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugTuple>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2061699,"byte_end":2061753,"line_start":320,"line_end":320,"column_start":5,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":8370},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2063950,"byte_end":2063958,"line_start":401,"line_end":401,"column_start":12,"column_end":20},"name":"DebugSet","qualname":"::fmt::builders::DebugSet","value":"DebugSet {  }","parent":null,"children":[{"krate":0,"index":4801}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2063778,"byte_end":2063843,"line_start":398,"line_end":398,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2063844,"byte_end":2063883,"line_start":399,"line_end":399,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2063884,"byte_end":2063938,"line_start":400,"line_end":400,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":8372},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2064014,"byte_end":2064027,"line_start":405,"line_end":405,"column_start":8,"column_end":21},"name":"debug_set_new","qualname":"::fmt::builders::debug_set_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8376},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2065000,"byte_end":2065005,"line_start":441,"line_end":441,"column_start":12,"column_end":17},"name":"entry","qualname":"<DebugSet>::entry","value":"fn (&mut self, entry: &dyn fmt::Debug) -> &mut DebugSet<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new entry to the set output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2064934,"byte_end":2064988,"line_start":440,"line_end":440,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8378},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2065865,"byte_end":2065872,"line_start":470,"line_end":470,"column_start":12,"column_end":19},"name":"entries","qualname":"<DebugSet>::entries","value":"fn <D, I> (&mut self, entries: I) -> &mut DebugSet<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds the contents of an iterator of entries to the set output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2065799,"byte_end":2065853,"line_start":469,"line_end":469,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8380},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2066728,"byte_end":2066734,"line_start":503,"line_end":503,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugSet>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2066662,"byte_end":2066716,"line_start":502,"line_end":502,"column_start":5,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":8382},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2067723,"byte_end":2067732,"line_start":538,"line_end":538,"column_start":12,"column_end":21},"name":"DebugList","qualname":"::fmt::builders::DebugList","value":"DebugList {  }","parent":null,"children":[{"krate":0,"index":4821}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2067551,"byte_end":2067616,"line_start":535,"line_end":535,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2067617,"byte_end":2067656,"line_start":536,"line_end":536,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2067657,"byte_end":2067711,"line_start":537,"line_end":537,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":8384},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2067788,"byte_end":2067802,"line_start":542,"line_end":542,"column_start":8,"column_end":22},"name":"debug_list_new","qualname":"::fmt::builders::debug_list_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8388},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2068784,"byte_end":2068789,"line_start":578,"line_end":578,"column_start":12,"column_end":17},"name":"entry","qualname":"<DebugList>::entry","value":"fn (&mut self, entry: &dyn fmt::Debug) -> &mut DebugList<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new entry to the list output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2068718,"byte_end":2068772,"line_start":577,"line_end":577,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8390},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2069597,"byte_end":2069604,"line_start":607,"line_end":607,"column_start":12,"column_end":19},"name":"entries","qualname":"<DebugList>::entries","value":"fn <D, I> (&mut self, entries: I) -> &mut DebugList<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds the contents of an iterator of entries to the list output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2069531,"byte_end":2069585,"line_start":606,"line_end":606,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8392},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2070462,"byte_end":2070468,"line_start":640,"line_end":640,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugList>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2070396,"byte_end":2070450,"line_start":639,"line_end":639,"column_start":5,"column_end":59}}]},{"kind":"Struct","id":{"krate":0,"index":8394},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2071536,"byte_end":2071544,"line_start":675,"line_end":675,"column_start":12,"column_end":20},"name":"DebugMap","qualname":"::fmt::builders::DebugMap","value":"DebugMap {  }","parent":null,"children":[{"krate":0,"index":4841},{"krate":0,"index":4843},{"krate":0,"index":4845}],"decl_id":null,"docs":" A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.","sig":null,"attributes":[{"value":"must_use = \"must eventually call `finish()` on Debug builders\"","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2071364,"byte_end":2071429,"line_start":672,"line_end":672,"column_start":1,"column_end":66}},{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2071430,"byte_end":2071469,"line_start":673,"line_end":673,"column_start":1,"column_end":40}},{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2071470,"byte_end":2071524,"line_start":674,"line_end":674,"column_start":1,"column_end":55}}]},{"kind":"Function","id":{"krate":0,"index":8396},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2071653,"byte_end":2071666,"line_start":681,"line_end":681,"column_start":8,"column_end":21},"name":"debug_map_new","qualname":"::fmt::builders::debug_map_new","value":"fn <'a, 'b> (fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8400},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2072580,"byte_end":2072585,"line_start":714,"line_end":714,"column_start":12,"column_end":17},"name":"entry","qualname":"<DebugMap>::entry","value":"fn (&mut self, key: &dyn fmt::Debug, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds a new entry to the map output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2072514,"byte_end":2072568,"line_start":713,"line_end":713,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8402},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2074264,"byte_end":2074271,"line_start":765,"line_end":765,"column_start":12,"column_end":19},"name":"entries","qualname":"<DebugMap>::entries","value":"fn <K, V, I> (&mut self, entries: I) -> &mut DebugMap<'a, 'b>","parent":null,"children":[],"decl_id":null,"docs":" Adds the contents of an iterator of entries to the map output.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2074198,"byte_end":2074252,"line_start":764,"line_end":764,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8404},"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2075257,"byte_end":2075263,"line_start":799,"line_end":799,"column_start":12,"column_end":18},"name":"finish","qualname":"<DebugMap>::finish","value":"fn (&mut self) -> fmt::Result","parent":null,"children":[],"decl_id":null,"docs":" Finishes output and returns any error encountered.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2075191,"byte_end":2075245,"line_start":798,"line_end":798,"column_start":5,"column_end":59}}]},{"kind":"TupleVariant","id":{"krate":0,"index":24283},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969046,"byte_end":1969050,"line_start":24,"line_end":24,"column_start":5,"column_end":9},"name":"Left","qualname":"::fmt::Alignment::Left","value":"Alignment::Left","parent":{"krate":0,"index":44510},"children":[],"decl_id":null,"docs":" Indication that contents should be left-aligned.\n","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1968928,"byte_end":1968984,"line_start":22,"line_end":22,"column_start":5,"column_end":61}}]},{"kind":"TupleVariant","id":{"krate":0,"index":24287},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969175,"byte_end":1969180,"line_start":27,"line_end":27,"column_start":5,"column_end":10},"name":"Right","qualname":"::fmt::Alignment::Right","value":"Alignment::Right","parent":{"krate":0,"index":44510},"children":[],"decl_id":null,"docs":" Indication that contents should be right-aligned.\n","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969056,"byte_end":1969112,"line_start":25,"line_end":25,"column_start":5,"column_end":61}}]},{"kind":"TupleVariant","id":{"krate":0,"index":24291},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969306,"byte_end":1969312,"line_start":30,"line_end":30,"column_start":5,"column_end":11},"name":"Center","qualname":"::fmt::Alignment::Center","value":"Alignment::Center","parent":{"krate":0,"index":44510},"children":[],"decl_id":null,"docs":" Indication that contents should be center-aligned.\n","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969186,"byte_end":1969242,"line_start":28,"line_end":28,"column_start":5,"column_end":61}}]},{"kind":"Enum","id":{"krate":0,"index":44510},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1968912,"byte_end":1968921,"line_start":21,"line_end":21,"column_start":10,"column_end":19},"name":"Alignment","qualname":"::fmt::Alignment","value":"Alignment::{Left, Right, Center}","parent":null,"children":[{"krate":0,"index":24283},{"krate":0,"index":24287},{"krate":0,"index":24291}],"decl_id":null,"docs":" Possible alignments returned by `Formatter::align`\n","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1968774,"byte_end":1968830,"line_start":18,"line_end":18,"column_start":1,"column_end":57}}]},{"kind":"Mod","id":{"krate":0,"index":8420},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969578,"byte_end":1969580,"line_start":39,"line_end":39,"column_start":9,"column_end":11},"name":"rt","qualname":"::fmt::rt","value":"src/libcore/fmt/mod.rs","parent":null,"children":[{"krate":0,"index":8422}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969455,"byte_end":1969554,"line_start":36,"line_end":37,"column_start":1,"column_end":25}}]},{"kind":"Mod","id":{"krate":0,"index":8422},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"v1","qualname":"::fmt::rt::v1","value":"src/libcore/fmt/rt/v1.rs","parent":null,"children":[{"krate":0,"index":44516},{"krate":0,"index":44522},{"krate":0,"index":44518},{"krate":0,"index":44524},{"krate":0,"index":44530},{"krate":0,"index":44526},{"krate":0,"index":44532},{"krate":0,"index":44546},{"krate":0,"index":44542},{"krate":0,"index":44538},{"krate":0,"index":44534},{"krate":0,"index":44548},{"krate":0,"index":44554},{"krate":0,"index":44550},{"krate":0,"index":44556},{"krate":0,"index":44562},{"krate":0,"index":44558}],"decl_id":null,"docs":" This is an internal module used by the ifmt! runtime. These structures are\n emitted to static arrays to precompile format strings ahead of time.","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075746,"byte_end":2075786,"line_start":6,"line_end":6,"column_start":1,"column_end":41}}]},{"kind":"Struct","id":{"krate":0,"index":44516},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075822,"byte_end":2075830,"line_start":9,"line_end":9,"column_start":12,"column_end":20},"name":"Argument","qualname":"::fmt::rt::v1::Argument","value":"Argument { position, format }","parent":null,"children":[{"krate":0,"index":24295},{"krate":0,"index":24297}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075811,"byte_end":2075890,"line_start":9,"line_end":12,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":24295},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075841,"byte_end":2075849,"line_start":10,"line_end":10,"column_start":9,"column_end":17},"name":"position","qualname":"::fmt::rt::v1::Argument::position","value":"fmt::rt::v1::Position","parent":{"krate":0,"index":44516},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":24297},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075869,"byte_end":2075875,"line_start":11,"line_end":11,"column_start":9,"column_end":15},"name":"format","qualname":"::fmt::rt::v1::Argument::format","value":"fmt::rt::v1::FormatSpec","parent":{"krate":0,"index":44516},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":44524},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075926,"byte_end":2075936,"line_start":15,"line_end":15,"column_start":12,"column_end":22},"name":"FormatSpec","qualname":"::fmt::rt::v1::FormatSpec","value":"FormatSpec { fill, align, flags, precision, width }","parent":null,"children":[{"krate":0,"index":24299},{"krate":0,"index":24301},{"krate":0,"index":24303},{"krate":0,"index":24305},{"krate":0,"index":24307}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075915,"byte_end":2076054,"line_start":15,"line_end":21,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":24299},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075947,"byte_end":2075951,"line_start":16,"line_end":16,"column_start":9,"column_end":13},"name":"fill","qualname":"::fmt::rt::v1::FormatSpec::fill","value":"char","parent":{"krate":0,"index":44524},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":24301},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075967,"byte_end":2075972,"line_start":17,"line_end":17,"column_start":9,"column_end":14},"name":"align","qualname":"::fmt::rt::v1::FormatSpec::align","value":"fmt::rt::v1::Alignment","parent":{"krate":0,"index":44524},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":24303},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2075993,"byte_end":2075998,"line_start":18,"line_end":18,"column_start":9,"column_end":14},"name":"flags","qualname":"::fmt::rt::v1::FormatSpec::flags","value":"u32","parent":{"krate":0,"index":44524},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":24305},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076013,"byte_end":2076022,"line_start":19,"line_end":19,"column_start":9,"column_end":18},"name":"precision","qualname":"::fmt::rt::v1::FormatSpec::precision","value":"fmt::rt::v1::Count","parent":{"krate":0,"index":44524},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":24307},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076039,"byte_end":2076044,"line_start":20,"line_end":20,"column_start":9,"column_end":14},"name":"width","qualname":"::fmt::rt::v1::FormatSpec::width","value":"fmt::rt::v1::Count","parent":{"krate":0,"index":44524},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24309},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076257,"byte_end":2076261,"line_start":27,"line_end":27,"column_start":5,"column_end":9},"name":"Left","qualname":"::fmt::rt::v1::Alignment::Left","value":"Alignment::Left","parent":{"krate":0,"index":44532},"children":[],"decl_id":null,"docs":" Indication that contents should be left-aligned.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24313},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076325,"byte_end":2076330,"line_start":29,"line_end":29,"column_start":5,"column_end":10},"name":"Right","qualname":"::fmt::rt::v1::Alignment::Right","value":"Alignment::Right","parent":{"krate":0,"index":44532},"children":[],"decl_id":null,"docs":" Indication that contents should be right-aligned.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24317},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076395,"byte_end":2076401,"line_start":31,"line_end":31,"column_start":5,"column_end":11},"name":"Center","qualname":"::fmt::rt::v1::Alignment::Center","value":"Alignment::Center","parent":{"krate":0,"index":44532},"children":[],"decl_id":null,"docs":" Indication that contents should be center-aligned.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24321},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076443,"byte_end":2076450,"line_start":33,"line_end":33,"column_start":5,"column_end":12},"name":"Unknown","qualname":"::fmt::rt::v1::Alignment::Unknown","value":"Alignment::Unknown","parent":{"krate":0,"index":44532},"children":[],"decl_id":null,"docs":" No alignment was requested.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":44532},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076184,"byte_end":2076193,"line_start":25,"line_end":25,"column_start":10,"column_end":19},"name":"Alignment","qualname":"::fmt::rt::v1::Alignment","value":"Alignment::{Left, Right, Center, Unknown}","parent":null,"children":[{"krate":0,"index":24309},{"krate":0,"index":24313},{"krate":0,"index":24317},{"krate":0,"index":24321}],"decl_id":null,"docs":" Possible alignments that can be requested as part of a formatting directive.\n","sig":null,"attributes":[{"value":"structural_match","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076175,"byte_end":2076453,"line_start":25,"line_end":34,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076175,"byte_end":2076453,"line_start":25,"line_end":34,"column_start":1,"column_end":2}}]},{"kind":"TupleVariant","id":{"krate":0,"index":24325},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076499,"byte_end":2076501,"line_start":38,"line_end":38,"column_start":5,"column_end":7},"name":"Is","qualname":"::fmt::rt::v1::Count::Is","value":"Count::Is(usize)","parent":{"krate":0,"index":44548},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24331},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076514,"byte_end":2076519,"line_start":39,"line_end":39,"column_start":5,"column_end":10},"name":"Param","qualname":"::fmt::rt::v1::Count::Param","value":"Count::Param(usize)","parent":{"krate":0,"index":44548},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24337},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076532,"byte_end":2076541,"line_start":40,"line_end":40,"column_start":5,"column_end":14},"name":"NextParam","qualname":"::fmt::rt::v1::Count::NextParam","value":"Count::NextParam","parent":{"krate":0,"index":44548},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24341},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076547,"byte_end":2076554,"line_start":41,"line_end":41,"column_start":5,"column_end":12},"name":"Implied","qualname":"::fmt::rt::v1::Count::Implied","value":"Count::Implied","parent":{"krate":0,"index":44548},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":44548},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076487,"byte_end":2076492,"line_start":37,"line_end":37,"column_start":10,"column_end":15},"name":"Count","qualname":"::fmt::rt::v1::Count","value":"Count::{Is, Param, NextParam, Implied}","parent":null,"children":[{"krate":0,"index":24325},{"krate":0,"index":24331},{"krate":0,"index":24337},{"krate":0,"index":24341}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076478,"byte_end":2076557,"line_start":37,"line_end":42,"column_start":1,"column_end":2}}]},{"kind":"TupleVariant","id":{"krate":0,"index":24345},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076606,"byte_end":2076610,"line_start":46,"line_end":46,"column_start":5,"column_end":9},"name":"Next","qualname":"::fmt::rt::v1::Position::Next","value":"Position::Next","parent":{"krate":0,"index":44556},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24349},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076616,"byte_end":2076618,"line_start":47,"line_end":47,"column_start":5,"column_end":7},"name":"At","qualname":"::fmt::rt::v1::Position::At","value":"Position::At(usize)","parent":{"krate":0,"index":44556},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":44556},"span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076591,"byte_end":2076599,"line_start":45,"line_end":45,"column_start":10,"column_end":18},"name":"Position","qualname":"::fmt::rt::v1::Position","value":"Position::{Next, At}","parent":null,"children":[{"krate":0,"index":24345},{"krate":0,"index":24349}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/rt/v1.rs","byte_start":2076582,"byte_end":2076628,"line_start":45,"line_end":48,"column_start":1,"column_end":2}}]},{"kind":"Type","id":{"krate":0,"index":8424},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1970158,"byte_end":1970164,"line_start":68,"line_end":68,"column_start":10,"column_end":16},"name":"Result","qualname":"::fmt::Result","value":"result::Result<(), Error>","parent":null,"children":[],"decl_id":null,"docs":" The type returned by formatter methods.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1970103,"byte_end":1970148,"line_start":67,"line_end":67,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":44564},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1971141,"byte_end":1971146,"line_start":95,"line_end":95,"column_start":12,"column_end":17},"name":"Error","qualname":"::fmt::Error","value":"","parent":null,"children":[],"decl_id":null,"docs":" The error type which is returned from formatting a message into a stream.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1971007,"byte_end":1971052,"line_start":93,"line_end":93,"column_start":1,"column_end":46}},{"value":"structural_match","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1971130,"byte_end":1971147,"line_start":95,"line_end":95,"column_start":1,"column_end":18}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1971130,"byte_end":1971147,"line_start":95,"line_end":95,"column_start":1,"column_end":18}}]},{"kind":"Trait","id":{"krate":0,"index":8426},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1971814,"byte_end":1971819,"line_start":110,"line_end":110,"column_start":11,"column_end":16},"name":"Write","qualname":"::fmt::Write","value":"Write","parent":null,"children":[{"krate":0,"index":8428},{"krate":0,"index":8430},{"krate":0,"index":8432}],"decl_id":null,"docs":" A collection of methods that are required to format a message into a stream.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1971758,"byte_end":1971803,"line_start":109,"line_end":109,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8428},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1972654,"byte_end":1972663,"line_start":138,"line_end":138,"column_start":8,"column_end":17},"name":"write_str","qualname":"::fmt::Write::write_str","value":"fn (&mut self, s: &str) -> Result","parent":{"krate":0,"index":8426},"children":[],"decl_id":null,"docs":" Writes a slice of bytes into this writer, returning whether the write\n succeeded.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1972601,"byte_end":1972646,"line_start":137,"line_end":137,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8430},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1973674,"byte_end":1973684,"line_start":169,"line_end":169,"column_start":8,"column_end":18},"name":"write_char","qualname":"::fmt::Write::write_char","value":"fn (&mut self, c: char) -> Result","parent":{"krate":0,"index":8426},"children":[],"decl_id":null,"docs":" Writes a [`char`] into this writer, returning whether the write succeeded.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_write_char\", since = \"1.1.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1973612,"byte_end":1973666,"line_start":168,"line_end":168,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8432},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1974450,"byte_end":1974459,"line_start":194,"line_end":194,"column_start":8,"column_end":17},"name":"write_fmt","qualname":"::fmt::Write::write_fmt","value":"fn (mut self: &mut Self, args: Arguments<'_>) -> Result","parent":{"krate":0,"index":8426},"children":[],"decl_id":null,"docs":" Glue for usage of the [`write!`] macro with implementors of this trait.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1974397,"byte_end":1974442,"line_start":193,"line_end":193,"column_start":5,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":8442},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1975598,"byte_end":1975607,"line_start":228,"line_end":228,"column_start":12,"column_end":21},"name":"Formatter","qualname":"::fmt::Formatter","value":"Formatter {  }","parent":null,"children":[{"krate":0,"index":4871},{"krate":0,"index":4873},{"krate":0,"index":4875},{"krate":0,"index":4877},{"krate":0,"index":4879},{"krate":0,"index":4881},{"krate":0,"index":4883},{"krate":0,"index":4885}],"decl_id":null,"docs":" Configuration for formatting.","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1975501,"byte_end":1975540,"line_start":226,"line_end":226,"column_start":1,"column_end":40}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1975541,"byte_end":1975586,"line_start":227,"line_end":227,"column_start":1,"column_end":46}}]},{"kind":"Struct","id":{"krate":0,"index":44600},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1977031,"byte_end":1977041,"line_start":264,"line_end":264,"column_start":12,"column_end":22},"name":"ArgumentV1","qualname":"::fmt::ArgumentV1","value":"ArgumentV1 {  }","parent":null,"children":[{"krate":0,"index":24361},{"krate":0,"index":24363}],"decl_id":null,"docs":" This struct represents the generic \"argument\" which is taken by the Xprintf\n family of functions. It contains a function to format the given value. At\n compile time it is ensured that the function and the value have the correct\n types, and then this struct is used to canonicalize arguments to one type.\n","sig":null,"attributes":[{"value":"allow(missing_debug_implementations)","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1976865,"byte_end":1976904,"line_start":260,"line_end":260,"column_start":1,"column_end":40}},{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1976905,"byte_end":1977004,"line_start":261,"line_end":262,"column_start":1,"column_end":25}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1977020,"byte_end":1977126,"line_start":264,"line_end":267,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":8450},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1977411,"byte_end":1977414,"line_start":278,"line_end":278,"column_start":12,"column_end":15},"name":"new","qualname":"<ArgumentV1>::new","value":"fn <'b, T> (x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1977296,"byte_end":1977399,"line_start":276,"line_end":277,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":8452},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1977813,"byte_end":1977823,"line_start":291,"line_end":291,"column_start":12,"column_end":22},"name":"from_usize","qualname":"<ArgumentV1>::from_usize","value":"fn (x: &usize) -> ArgumentV1<'_>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1977698,"byte_end":1977801,"line_start":289,"line_end":290,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":8458},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1978606,"byte_end":1978612,"line_start":314,"line_end":314,"column_start":12,"column_end":18},"name":"new_v1","qualname":"<Arguments>::new_v1","value":"fn (pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a>","parent":null,"children":[],"decl_id":null,"docs":" When using the format_args!() macro, this function is used to generate the\n Arguments structure.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1978477,"byte_end":1978486,"line_start":311,"line_end":311,"column_start":20,"column_end":29}},{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1978491,"byte_end":1978594,"line_start":312,"line_end":313,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":8460},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1979368,"byte_end":1979384,"line_start":332,"line_end":332,"column_start":12,"column_end":28},"name":"new_v1_formatted","qualname":"<Arguments>::new_v1_formatted","value":"fn (pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>], fmt: &'a [rt::v1::Argument]) -> Arguments<'a>","parent":null,"children":[],"decl_id":null,"docs":" This function is used to specify nonstandard formatting parameters.\n The `pieces` array must be at least as long as `fmt` to construct\n a valid Arguments structure. Also, any `Count` within `fmt` that is\n `CountIsParam` or `CountIsNextParam` has to point to an argument\n created with `argumentusize`. However, failing to do so doesn't cause\n unsafety, but will ignore invalid .\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1979239,"byte_end":1979248,"line_start":329,"line_end":329,"column_start":20,"column_end":29}},{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1979253,"byte_end":1979356,"line_start":330,"line_end":331,"column_start":5,"column_end":29}}]},{"kind":"Method","id":{"krate":0,"index":8462},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1980004,"byte_end":1980022,"line_start":349,"line_end":349,"column_start":12,"column_end":30},"name":"estimated_capacity","qualname":"<Arguments>::estimated_capacity","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Estimates the length of the formatted text.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1979875,"byte_end":1979884,"line_start":346,"line_end":346,"column_start":20,"column_end":29}},{"value":"unstable(feature = \"fmt_internals\",\n           reason = \"internal to format_args!\",\n           issue = \"0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1979889,"byte_end":1979992,"line_start":347,"line_end":348,"column_start":5,"column_end":29}}]},{"kind":"Struct","id":{"krate":0,"index":44616},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1981891,"byte_end":1981900,"line_start":395,"line_end":395,"column_start":12,"column_end":21},"name":"Arguments","qualname":"::fmt::Arguments","value":"Arguments {  }","parent":null,"children":[{"krate":0,"index":24395},{"krate":0,"index":24397},{"krate":0,"index":24399}],"decl_id":null,"docs":" This structure represents a safely precompiled version of a format string\n and its arguments. This cannot be generated at runtime because it cannot\n safely be done, so no constructors are given and the fields are private\n to prevent modification.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1981811,"byte_end":1981856,"line_start":393,"line_end":393,"column_start":1,"column_end":46}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1981880,"byte_end":1982262,"line_start":395,"line_end":405,"column_start":1,"column_end":2}}]},{"kind":"Trait","id":{"krate":0,"index":8472},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1985341,"byte_end":1985346,"line_start":522,"line_end":522,"column_start":11,"column_end":16},"name":"Debug","qualname":"::fmt::Debug","value":"Debug","parent":null,"children":[{"krate":0,"index":8474}],"decl_id":null,"docs":" `?` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1984904,"byte_end":1984949,"line_start":513,"line_end":513,"column_start":1,"column_end":46}},{"value":"rustc_on_unimplemented(on(crate_local,\n                            label =\n                                \"`{Self}` cannot be formatted using `{{:?}}`\",\n                            note =\n                                \"add `#[derive(Debug)]` or manually implement `{Debug}`\"),\n                         message = \"`{Self}` doesn\\'t implement `{Debug}`\",\n                         label =\n                             \"`{Self}` cannot be formatted using `{{:?}}` because it doesn\\'t implement `{Debug}`\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1984950,"byte_end":1985283,"line_start":514,"line_end":519,"column_start":1,"column_end":3}},{"value":"lang = \"debug_trait\"","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1985307,"byte_end":1985330,"line_start":521,"line_end":521,"column_start":1,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":8474},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1985996,"byte_end":1985999,"line_start":545,"line_end":545,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Debug::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8472},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1985943,"byte_end":1985988,"line_start":544,"line_end":544,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":8476},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1987405,"byte_end":1987412,"line_start":594,"line_end":594,"column_start":11,"column_end":18},"name":"Display","qualname":"::fmt::Display","value":"Display","parent":null,"children":[{"krate":0,"index":8478}],"decl_id":null,"docs":" Format trait for an empty format, `{}`.","sig":null,"attributes":[{"value":"rustc_on_unimplemented(on(_Self = \"std::path::Path\",\n                            label =\n                                \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n                            note =\n                                \"call `.display()` or `.to_string_lossy()` to safely print paths, as they may contain non-Unicode data\"),\n                         message = \"`{Self}` doesn\\'t implement `{Display}`\",\n                         label =\n                             \"`{Self}` cannot be formatted with the default formatter\",\n                         note =\n                             \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1986797,"byte_end":1987327,"line_start":581,"line_end":591,"column_start":1,"column_end":3}},{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1987349,"byte_end":1987394,"line_start":593,"line_end":593,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8478},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1988058,"byte_end":1988061,"line_start":617,"line_end":617,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Display::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8476},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1988005,"byte_end":1988050,"line_start":616,"line_end":616,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":8480},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1989263,"byte_end":1989268,"line_start":666,"line_end":666,"column_start":11,"column_end":16},"name":"Octal","qualname":"::fmt::Octal","value":"Octal","parent":null,"children":[{"krate":0,"index":8482}],"decl_id":null,"docs":" `o` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1989207,"byte_end":1989252,"line_start":665,"line_end":665,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8482},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1989381,"byte_end":1989384,"line_start":669,"line_end":669,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Octal::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8480},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1989328,"byte_end":1989373,"line_start":668,"line_end":668,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":8484},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1990806,"byte_end":1990812,"line_start":722,"line_end":722,"column_start":11,"column_end":17},"name":"Binary","qualname":"::fmt::Binary","value":"Binary","parent":null,"children":[{"krate":0,"index":8486}],"decl_id":null,"docs":" `b` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1990750,"byte_end":1990795,"line_start":721,"line_end":721,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8486},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1990925,"byte_end":1990928,"line_start":725,"line_end":725,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Binary::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8484},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1990872,"byte_end":1990917,"line_start":724,"line_end":724,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":8488},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1992177,"byte_end":1992185,"line_start":775,"line_end":775,"column_start":11,"column_end":19},"name":"LowerHex","qualname":"::fmt::LowerHex","value":"LowerHex","parent":null,"children":[{"krate":0,"index":8490}],"decl_id":null,"docs":" `x` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1992121,"byte_end":1992166,"line_start":774,"line_end":774,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8490},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1992298,"byte_end":1992301,"line_start":778,"line_end":778,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::LowerHex::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8488},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1992245,"byte_end":1992290,"line_start":777,"line_end":777,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":8492},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1993550,"byte_end":1993558,"line_start":828,"line_end":828,"column_start":11,"column_end":19},"name":"UpperHex","qualname":"::fmt::UpperHex","value":"UpperHex","parent":null,"children":[{"krate":0,"index":8494}],"decl_id":null,"docs":" `X` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1993494,"byte_end":1993539,"line_start":827,"line_end":827,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8494},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1993671,"byte_end":1993674,"line_start":831,"line_end":831,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::UpperHex::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8492},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1993618,"byte_end":1993663,"line_start":830,"line_end":830,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":8496},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1994690,"byte_end":1994697,"line_start":873,"line_end":873,"column_start":11,"column_end":18},"name":"Pointer","qualname":"::fmt::Pointer","value":"Pointer","parent":null,"children":[{"krate":0,"index":8498}],"decl_id":null,"docs":" `p` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1994634,"byte_end":1994679,"line_start":872,"line_end":872,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8498},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1994810,"byte_end":1994813,"line_start":876,"line_end":876,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::Pointer::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8496},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1994757,"byte_end":1994802,"line_start":875,"line_end":875,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":8500},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1995736,"byte_end":1995744,"line_start":916,"line_end":916,"column_start":11,"column_end":19},"name":"LowerExp","qualname":"::fmt::LowerExp","value":"LowerExp","parent":null,"children":[{"krate":0,"index":8502}],"decl_id":null,"docs":" `e` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1995680,"byte_end":1995725,"line_start":915,"line_end":915,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8502},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1995857,"byte_end":1995860,"line_start":919,"line_end":919,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::LowerExp::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8500},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1995804,"byte_end":1995849,"line_start":918,"line_end":918,"column_start":5,"column_end":50}}]},{"kind":"Trait","id":{"krate":0,"index":8504},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1996784,"byte_end":1996792,"line_start":959,"line_end":959,"column_start":11,"column_end":19},"name":"UpperExp","qualname":"::fmt::UpperExp","value":"UpperExp","parent":null,"children":[{"krate":0,"index":8506}],"decl_id":null,"docs":" `E` formatting.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1996728,"byte_end":1996773,"line_start":958,"line_end":958,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8506},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1996905,"byte_end":1996908,"line_start":962,"line_end":962,"column_start":8,"column_end":11},"name":"fmt","qualname":"::fmt::UpperExp::fmt","value":"fn (&self, f: &mut Formatter<'_>) -> Result","parent":{"krate":0,"index":8504},"children":[],"decl_id":null,"docs":" Formats the value using the given formatter.\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1996852,"byte_end":1996897,"line_start":961,"line_end":961,"column_start":5,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":8508},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1997904,"byte_end":1997909,"line_start":997,"line_end":997,"column_start":8,"column_end":13},"name":"write","qualname":"::fmt::write","value":"fn (output: &mut dyn Write, args: Arguments<'_>) -> Result","parent":null,"children":[],"decl_id":null,"docs":" The `write` function takes an output stream, and an `Arguments` struct\n that can be precompiled with the `format_args!` macro.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1997851,"byte_end":1997896,"line_start":996,"line_end":996,"column_start":1,"column_end":46}}]},{"kind":"Method","id":{"krate":0,"index":8526},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2003246,"byte_end":2003258,"line_start":1163,"line_end":1163,"column_start":12,"column_end":24},"name":"pad_integral","qualname":"<Formatter>::pad_integral","value":"fn (&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result","parent":null,"children":[],"decl_id":null,"docs":" Performs the correct padding for an integer which has already been\n emitted into a str. The str should *not* contain the sign for the\n integer, that will be added by this method.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2003189,"byte_end":2003234,"line_start":1162,"line_end":1162,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8530},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2006742,"byte_end":2006745,"line_start":1260,"line_end":1260,"column_start":12,"column_end":15},"name":"pad","qualname":"<Formatter>::pad","value":"fn (&mut self, s: &str) -> Result","parent":null,"children":[],"decl_id":null,"docs":" This function takes a string slice and emits it to the internal buffer\n after applying the relevant formatting flags specified. The flags\n recognized for generic strings are:","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2006685,"byte_end":2006730,"line_start":1259,"line_end":1259,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8542},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2013531,"byte_end":2013540,"line_start":1433,"line_end":1433,"column_start":12,"column_end":21},"name":"write_str","qualname":"<Formatter>::write_str","value":"fn (&mut self, data: &str) -> Result","parent":null,"children":[],"decl_id":null,"docs":" Writes some data to the underlying buffer contained within this\n formatter.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2013474,"byte_end":2013519,"line_start":1432,"line_end":1432,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8544},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2014184,"byte_end":2014193,"line_start":1456,"line_end":1456,"column_start":12,"column_end":21},"name":"write_fmt","qualname":"<Formatter>::write_fmt","value":"fn (&mut self, fmt: Arguments<'_>) -> Result","parent":null,"children":[],"decl_id":null,"docs":" Writes some formatted information into this instance.","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2014127,"byte_end":2014172,"line_start":1455,"line_end":1455,"column_start":5,"column_end":50}}]},{"kind":"Method","id":{"krate":0,"index":8546},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2014564,"byte_end":2014569,"line_start":1465,"line_end":1465,"column_start":12,"column_end":17},"name":"flags","qualname":"<Formatter>::flags","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Flags for formatting\n","sig":null,"attributes":[{"value":"stable(feature = \"rust1\", since = \"1.0.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2014306,"byte_end":2014351,"line_start":1461,"line_end":1461,"column_start":5,"column_end":50}},{"value":"rustc_deprecated(since = \"1.24.0\",\n                   reason =\n                       \"use the `sign_plus`, `sign_minus`, `alternate`, or `sign_aware_zero_pad` methods instead\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2014356,"byte_end":2014552,"line_start":1462,"line_end":1464,"column_start":5,"column_end":77}}]},{"kind":"Method","id":{"krate":0,"index":8548},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2015475,"byte_end":2015479,"line_start":1495,"line_end":1495,"column_start":12,"column_end":16},"name":"fill","qualname":"<Formatter>::fill","value":"fn (&self) -> char","parent":null,"children":[],"decl_id":null,"docs":" Character used as 'fill' whenever there is alignment.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2015414,"byte_end":2015463,"line_start":1494,"line_end":1494,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":8550},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2016619,"byte_end":2016624,"line_start":1531,"line_end":1531,"column_start":12,"column_end":17},"name":"align","qualname":"<Formatter>::align","value":"fn (&self) -> Option<Alignment>","parent":null,"children":[],"decl_id":null,"docs":" Flag indicating what form of alignment was requested.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags_align\", since = \"1.28.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2016551,"byte_end":2016607,"line_start":1530,"line_end":1530,"column_start":5,"column_end":61}}]},{"kind":"Method","id":{"krate":0,"index":8552},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2017821,"byte_end":2017826,"line_start":1565,"line_end":1565,"column_start":12,"column_end":17},"name":"width","qualname":"<Formatter>::width","value":"fn (&self) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Optionally specified integer width that the output should be.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2017760,"byte_end":2017809,"line_start":1564,"line_end":1564,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":8554},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2018734,"byte_end":2018743,"line_start":1592,"line_end":1592,"column_start":12,"column_end":21},"name":"precision","qualname":"<Formatter>::precision","value":"fn (&self) -> Option<usize>","parent":null,"children":[],"decl_id":null,"docs":" Optionally specified precision for numeric types.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2018673,"byte_end":2018722,"line_start":1591,"line_end":1591,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":8556},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019602,"byte_end":2019611,"line_start":1620,"line_end":1620,"column_start":12,"column_end":21},"name":"sign_plus","qualname":"<Formatter>::sign_plus","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Determines if the `+` flag was specified.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2019541,"byte_end":2019590,"line_start":1619,"line_end":1619,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":8558},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2020434,"byte_end":2020444,"line_start":1646,"line_end":1646,"column_start":12,"column_end":22},"name":"sign_minus","qualname":"<Formatter>::sign_minus","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Determines if the `-` flag was specified.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2020373,"byte_end":2020422,"line_start":1645,"line_end":1645,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":8560},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2021199,"byte_end":2021208,"line_start":1671,"line_end":1671,"column_start":12,"column_end":21},"name":"alternate","qualname":"<Formatter>::alternate","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Determines if the `#` flag was specified.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2021138,"byte_end":2021187,"line_start":1670,"line_end":1670,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":8562},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2021929,"byte_end":2021948,"line_start":1694,"line_end":1694,"column_start":12,"column_end":31},"name":"sign_aware_zero_pad","qualname":"<Formatter>::sign_aware_zero_pad","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Determines if the `0` flag was specified.","sig":null,"attributes":[{"value":"stable(feature = \"fmt_flags\", since = \"1.5.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2021868,"byte_end":2021917,"line_start":1693,"line_end":1693,"column_start":5,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":8568},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2023553,"byte_end":2023565,"line_start":1742,"line_end":1742,"column_start":12,"column_end":24},"name":"debug_struct","qualname":"<Formatter>::debug_struct","value":"fn <'b> (&'b mut self, name: &str) -> DebugStruct<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2023487,"byte_end":2023541,"line_start":1741,"line_end":1741,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8570},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2024541,"byte_end":2024552,"line_start":1773,"line_end":1773,"column_start":12,"column_end":23},"name":"debug_tuple","qualname":"<Formatter>::debug_tuple","value":"fn <'b> (&'b mut self, name: &str) -> DebugTuple<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `DebugTuple` builder designed to assist with creation of\n `fmt::Debug` implementations for tuple structs.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2024475,"byte_end":2024529,"line_start":1772,"line_end":1772,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8572},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2025272,"byte_end":2025282,"line_start":1797,"line_end":1797,"column_start":12,"column_end":22},"name":"debug_list","qualname":"<Formatter>::debug_list","value":"fn <'b> (&'b mut self) -> DebugList<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `DebugList` builder designed to assist with creation of\n `fmt::Debug` implementations for list-like structures.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2025206,"byte_end":2025260,"line_start":1796,"line_end":1796,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8574},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2027096,"byte_end":2027105,"line_start":1856,"line_end":1856,"column_start":12,"column_end":21},"name":"debug_set","qualname":"<Formatter>::debug_set","value":"fn <'b> (&'b mut self) -> DebugSet<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `DebugSet` builder designed to assist with creation of\n `fmt::Debug` implementations for set-like structures.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2027030,"byte_end":2027084,"line_start":1855,"line_end":1855,"column_start":5,"column_end":59}}]},{"kind":"Method","id":{"krate":0,"index":8576},"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2027888,"byte_end":2027897,"line_start":1880,"line_end":1880,"column_start":12,"column_end":21},"name":"debug_map","qualname":"<Formatter>::debug_map","value":"fn <'b> (&'b mut self) -> DebugMap<'b, 'a>","parent":null,"children":[],"decl_id":null,"docs":" Creates a `DebugMap` builder designed to assist with creation of\n `fmt::Debug` implementations for map-like structures.","sig":null,"attributes":[{"value":"stable(feature = \"debug_builders\", since = \"1.2.0\")","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2027822,"byte_end":2027876,"line_start":1879,"line_end":1879,"column_start":5,"column_end":59}}]},{"kind":"Mod","id":{"krate":0,"index":8692},"span":{"file_name":"src/libcore/time.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"time","qualname":"::time","value":"src/libcore/time.rs","parent":null,"children":[{"krate":0,"index":8694},{"krate":0,"index":8700},{"krate":0,"index":8702},{"krate":0,"index":8720},{"krate":0,"index":8722},{"krate":0,"index":8724},{"krate":0,"index":8726},{"krate":0,"index":8728},{"krate":0,"index":44736},{"krate":0,"index":44774},{"krate":0,"index":44772},{"krate":0,"index":44766},{"krate":0,"index":44762},{"krate":0,"index":44750},{"krate":0,"index":44746},{"krate":0,"index":44742},{"krate":0,"index":44738},{"krate":0,"index":8730},{"krate":0,"index":8788},{"krate":0,"index":8794},{"krate":0,"index":8798},{"krate":0,"index":8804},{"krate":0,"index":8808},{"krate":0,"index":8814},{"krate":0,"index":8820},{"krate":0,"index":8824},{"krate":0,"index":8830},{"krate":0,"index":8834},{"krate":0,"index":8836},{"krate":0,"index":8840},{"krate":0,"index":8844}],"decl_id":null,"docs":" Temporal quantification.","sig":null,"attributes":[{"value":"stable(feature = \"duration_core\", since = \"1.25.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2076630,"byte_end":2076685,"line_start":1,"line_end":1,"column_start":1,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":44736},"span":{"file_name":"src/libcore/time.rs","byte_start":2078353,"byte_end":2078361,"line_start":55,"line_end":55,"column_start":12,"column_end":20},"name":"Duration","qualname":"::time::Duration","value":"Duration {  }","parent":null,"children":[{"krate":0,"index":24593},{"krate":0,"index":24595}],"decl_id":null,"docs":" A `Duration` type to represent a span of time, typically used for system\n timeouts.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2078223,"byte_end":2078271,"line_start":53,"line_end":53,"column_start":1,"column_end":49}},{"value":"structural_match","span":{"file_name":"src/libcore/time.rs","byte_start":2078342,"byte_end":2078433,"line_start":55,"line_end":58,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/time.rs","byte_start":2078342,"byte_end":2078433,"line_start":55,"line_end":58,"column_start":1,"column_end":2}}]},{"kind":"Const","id":{"krate":0,"index":8732},"span":{"file_name":"src/libcore/time.rs","byte_start":2078768,"byte_end":2078774,"line_start":72,"line_end":72,"column_start":15,"column_end":21},"name":"SECOND","qualname":"::time::Duration::SECOND","value":"Duration","parent":{"krate":0,"index":8730},"children":[],"decl_id":null,"docs":" The duration of one second.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_constants\", issue = \"57391\")","span":{"file_name":"src/libcore/time.rs","byte_start":2078693,"byte_end":2078753,"line_start":71,"line_end":71,"column_start":5,"column_end":65}}]},{"kind":"Const","id":{"krate":0,"index":8734},"span":{"file_name":"src/libcore/time.rs","byte_start":2079141,"byte_end":2079152,"line_start":85,"line_end":85,"column_start":15,"column_end":26},"name":"MILLISECOND","qualname":"::time::Duration::MILLISECOND","value":"Duration","parent":{"krate":0,"index":8730},"children":[],"decl_id":null,"docs":" The duration of one millisecond.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_constants\", issue = \"57391\")","span":{"file_name":"src/libcore/time.rs","byte_start":2079066,"byte_end":2079126,"line_start":84,"line_end":84,"column_start":5,"column_end":65}}]},{"kind":"Const","id":{"krate":0,"index":8736},"span":{"file_name":"src/libcore/time.rs","byte_start":2079521,"byte_end":2079532,"line_start":98,"line_end":98,"column_start":15,"column_end":26},"name":"MICROSECOND","qualname":"::time::Duration::MICROSECOND","value":"Duration","parent":{"krate":0,"index":8730},"children":[],"decl_id":null,"docs":" The duration of one microsecond.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_constants\", issue = \"57391\")","span":{"file_name":"src/libcore/time.rs","byte_start":2079446,"byte_end":2079506,"line_start":97,"line_end":97,"column_start":5,"column_end":65}}]},{"kind":"Const","id":{"krate":0,"index":8738},"span":{"file_name":"src/libcore/time.rs","byte_start":2079898,"byte_end":2079908,"line_start":111,"line_end":111,"column_start":15,"column_end":25},"name":"NANOSECOND","qualname":"::time::Duration::NANOSECOND","value":"Duration","parent":{"krate":0,"index":8730},"children":[],"decl_id":null,"docs":" The duration of one nanosecond.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_constants\", issue = \"57391\")","span":{"file_name":"src/libcore/time.rs","byte_start":2079823,"byte_end":2079883,"line_start":110,"line_end":110,"column_start":5,"column_end":65}}]},{"kind":"Method","id":{"krate":0,"index":8740},"span":{"file_name":"src/libcore/time.rs","byte_start":2080598,"byte_end":2080601,"line_start":133,"line_end":133,"column_start":12,"column_end":15},"name":"new","qualname":"<Duration>::new","value":"fn (secs: u64, nanos: u32) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of whole seconds and\n additional nanoseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2080524,"byte_end":2080572,"line_start":131,"line_end":131,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2080577,"byte_end":2080586,"line_start":132,"line_end":132,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":47088},"span":{"file_name":"src/libcore/time.rs","byte_start":2081271,"byte_end":2081280,"line_start":155,"line_end":155,"column_start":18,"column_end":27},"name":"from_secs","qualname":"<Duration>::from_secs","value":"fn (secs: u64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of whole seconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2081167,"byte_end":2081215,"line_start":152,"line_end":152,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2081220,"byte_end":2081229,"line_start":153,"line_end":153,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/time.rs","byte_start":2081234,"byte_end":2081253,"line_start":154,"line_end":154,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":47086},"span":{"file_name":"src/libcore/time.rs","byte_start":2081794,"byte_end":2081805,"line_start":174,"line_end":174,"column_start":18,"column_end":29},"name":"from_millis","qualname":"<Duration>::from_millis","value":"fn (millis: u64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of milliseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2081690,"byte_end":2081738,"line_start":171,"line_end":171,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2081743,"byte_end":2081752,"line_start":172,"line_end":172,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/time.rs","byte_start":2081757,"byte_end":2081776,"line_start":173,"line_end":173,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":47084},"span":{"file_name":"src/libcore/time.rs","byte_start":2082441,"byte_end":2082452,"line_start":196,"line_end":196,"column_start":18,"column_end":29},"name":"from_micros","qualname":"<Duration>::from_micros","value":"fn (micros: u64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of microseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration_from_micros\", since = \"1.27.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2082324,"byte_end":2082385,"line_start":193,"line_end":193,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2082390,"byte_end":2082399,"line_start":194,"line_end":194,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/time.rs","byte_start":2082404,"byte_end":2082423,"line_start":195,"line_end":195,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":47082},"span":{"file_name":"src/libcore/time.rs","byte_start":2083084,"byte_end":2083094,"line_start":218,"line_end":218,"column_start":18,"column_end":28},"name":"from_nanos","qualname":"<Duration>::from_nanos","value":"fn (nanos: u64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of nanoseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration_extras\", since = \"1.27.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2082972,"byte_end":2083028,"line_start":215,"line_end":215,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2083033,"byte_end":2083042,"line_start":216,"line_end":216,"column_start":5,"column_end":14}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/time.rs","byte_start":2083047,"byte_end":2083066,"line_start":217,"line_end":217,"column_start":5,"column_end":24}}]},{"kind":"Method","id":{"krate":0,"index":8742},"span":{"file_name":"src/libcore/time.rs","byte_start":2084252,"byte_end":2084259,"line_start":255,"line_end":255,"column_start":18,"column_end":25},"name":"as_secs","qualname":"<Duration>::as_secs","value":"fn (&self) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of _whole_ seconds contained by this `Duration`.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2084172,"byte_end":2084220,"line_start":253,"line_end":253,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2084225,"byte_end":2084234,"line_start":254,"line_end":254,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8744},"span":{"file_name":"src/libcore/time.rs","byte_start":2084940,"byte_end":2084953,"line_start":274,"line_end":274,"column_start":18,"column_end":31},"name":"subsec_millis","qualname":"<Duration>::subsec_millis","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the fractional part of this `Duration`, in whole milliseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration_extras\", since = \"1.27.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2084852,"byte_end":2084908,"line_start":272,"line_end":272,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2084913,"byte_end":2084922,"line_start":273,"line_end":273,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8746},"span":{"file_name":"src/libcore/time.rs","byte_start":2085661,"byte_end":2085674,"line_start":293,"line_end":293,"column_start":18,"column_end":31},"name":"subsec_micros","qualname":"<Duration>::subsec_micros","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the fractional part of this `Duration`, in whole microseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration_extras\", since = \"1.27.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2085573,"byte_end":2085629,"line_start":291,"line_end":291,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2085634,"byte_end":2085643,"line_start":292,"line_end":292,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8748},"span":{"file_name":"src/libcore/time.rs","byte_start":2086363,"byte_end":2086375,"line_start":312,"line_end":312,"column_start":18,"column_end":30},"name":"subsec_nanos","qualname":"<Duration>::subsec_nanos","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Returns the fractional part of this `Duration`, in nanoseconds.","sig":null,"attributes":[{"value":"stable(feature = \"duration\", since = \"1.3.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2086283,"byte_end":2086331,"line_start":310,"line_end":310,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2086336,"byte_end":2086345,"line_start":311,"line_end":311,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8750},"span":{"file_name":"src/libcore/time.rs","byte_start":2086784,"byte_end":2086793,"line_start":326,"line_end":326,"column_start":18,"column_end":27},"name":"as_millis","qualname":"<Duration>::as_millis","value":"fn (&self) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Returns the total number of whole milliseconds contained by this `Duration`.","sig":null,"attributes":[{"value":"stable(feature = \"duration_as_u128\", since = \"1.33.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2086695,"byte_end":2086752,"line_start":324,"line_end":324,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2086757,"byte_end":2086766,"line_start":325,"line_end":325,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8752},"span":{"file_name":"src/libcore/time.rs","byte_start":2087291,"byte_end":2087300,"line_start":342,"line_end":342,"column_start":18,"column_end":27},"name":"as_micros","qualname":"<Duration>::as_micros","value":"fn (&self) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Returns the total number of whole microseconds contained by this `Duration`.","sig":null,"attributes":[{"value":"stable(feature = \"duration_as_u128\", since = \"1.33.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2087202,"byte_end":2087259,"line_start":340,"line_end":340,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2087264,"byte_end":2087273,"line_start":341,"line_end":341,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8754},"span":{"file_name":"src/libcore/time.rs","byte_start":2087793,"byte_end":2087801,"line_start":358,"line_end":358,"column_start":18,"column_end":26},"name":"as_nanos","qualname":"<Duration>::as_nanos","value":"fn (&self) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Returns the total number of nanoseconds contained by this `Duration`.","sig":null,"attributes":[{"value":"stable(feature = \"duration_as_u128\", since = \"1.33.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2087704,"byte_end":2087761,"line_start":356,"line_end":356,"column_start":5,"column_end":62}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2087766,"byte_end":2087775,"line_start":357,"line_end":357,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8756},"span":{"file_name":"src/libcore/time.rs","byte_start":2088494,"byte_end":2088505,"line_start":379,"line_end":379,"column_start":12,"column_end":23},"name":"checked_add","qualname":"<Duration>::checked_add","value":"fn (self, rhs: Duration) -> Option<Duration>","parent":null,"children":[],"decl_id":null,"docs":" Checked `Duration` addition. Computes `self + other`, returning [`None`]\n if overflow occurred.","sig":null,"attributes":[{"value":"stable(feature = \"duration_checked_ops\", since = \"1.16.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2088407,"byte_end":2088468,"line_start":377,"line_end":377,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2088473,"byte_end":2088482,"line_start":378,"line_end":378,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8758},"span":{"file_name":"src/libcore/time.rs","byte_start":2089748,"byte_end":2089759,"line_start":417,"line_end":417,"column_start":12,"column_end":23},"name":"checked_sub","qualname":"<Duration>::checked_sub","value":"fn (self, rhs: Duration) -> Option<Duration>","parent":null,"children":[],"decl_id":null,"docs":" Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n if the result would be negative or if overflow occurred.","sig":null,"attributes":[{"value":"stable(feature = \"duration_checked_ops\", since = \"1.16.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2089661,"byte_end":2089722,"line_start":415,"line_end":415,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2089727,"byte_end":2089736,"line_start":416,"line_end":416,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8760},"span":{"file_name":"src/libcore/time.rs","byte_start":2090956,"byte_end":2090967,"line_start":453,"line_end":453,"column_start":12,"column_end":23},"name":"checked_mul","qualname":"<Duration>::checked_mul","value":"fn (self, rhs: u32) -> Option<Duration>","parent":null,"children":[],"decl_id":null,"docs":" Checked `Duration` multiplication. Computes `self * other`, returning\n [`None`] if overflow occurred.","sig":null,"attributes":[{"value":"stable(feature = \"duration_checked_ops\", since = \"1.16.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2090869,"byte_end":2090930,"line_start":451,"line_end":451,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2090935,"byte_end":2090944,"line_start":452,"line_end":452,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8762},"span":{"file_name":"src/libcore/time.rs","byte_start":2092227,"byte_end":2092238,"line_start":489,"line_end":489,"column_start":12,"column_end":23},"name":"checked_div","qualname":"<Duration>::checked_div","value":"fn (self, rhs: u32) -> Option<Duration>","parent":null,"children":[],"decl_id":null,"docs":" Checked `Duration` division. Computes `self / other`, returning [`None`]\n if `other == 0`.","sig":null,"attributes":[{"value":"stable(feature = \"duration_checked_ops\", since = \"1.16.0\")","span":{"file_name":"src/libcore/time.rs","byte_start":2092140,"byte_end":2092201,"line_start":487,"line_end":487,"column_start":5,"column_end":66}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2092206,"byte_end":2092215,"line_start":488,"line_end":488,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8764},"span":{"file_name":"src/libcore/time.rs","byte_start":2093179,"byte_end":2093190,"line_start":516,"line_end":516,"column_start":18,"column_end":29},"name":"as_secs_f64","qualname":"<Duration>::as_secs_f64","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of seconds contained by this `Duration` as `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2093091,"byte_end":2093147,"line_start":514,"line_end":514,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2093152,"byte_end":2093161,"line_start":515,"line_end":515,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8766},"span":{"file_name":"src/libcore/time.rs","byte_start":2093776,"byte_end":2093787,"line_start":534,"line_end":534,"column_start":18,"column_end":29},"name":"as_secs_f32","qualname":"<Duration>::as_secs_f32","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the number of seconds contained by this `Duration` as `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2093688,"byte_end":2093744,"line_start":532,"line_end":532,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2093749,"byte_end":2093758,"line_start":533,"line_end":533,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8768},"span":{"file_name":"src/libcore/time.rs","byte_start":2094423,"byte_end":2094436,"line_start":554,"line_end":554,"column_start":12,"column_end":25},"name":"from_secs_f64","qualname":"<Duration>::from_secs_f64","value":"fn (secs: f64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of seconds represented\n as `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2094341,"byte_end":2094397,"line_start":552,"line_end":552,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2094402,"byte_end":2094411,"line_start":553,"line_end":553,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8772},"span":{"file_name":"src/libcore/time.rs","byte_start":2095683,"byte_end":2095696,"line_start":590,"line_end":590,"column_start":12,"column_end":25},"name":"from_secs_f32","qualname":"<Duration>::from_secs_f32","value":"fn (secs: f32) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Duration` from the specified number of seconds represented\n as `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2095601,"byte_end":2095657,"line_start":588,"line_end":588,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2095662,"byte_end":2095671,"line_start":589,"line_end":589,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8776},"span":{"file_name":"src/libcore/time.rs","byte_start":2096961,"byte_end":2096968,"line_start":626,"line_end":626,"column_start":12,"column_end":19},"name":"mul_f64","qualname":"<Duration>::mul_f64","value":"fn (self, rhs: f64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Multiplies `Duration` by `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2096879,"byte_end":2096935,"line_start":624,"line_end":624,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2096940,"byte_end":2096949,"line_start":625,"line_end":625,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8778},"span":{"file_name":"src/libcore/time.rs","byte_start":2097737,"byte_end":2097744,"line_start":648,"line_end":648,"column_start":12,"column_end":19},"name":"mul_f32","qualname":"<Duration>::mul_f32","value":"fn (self, rhs: f32) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Multiplies `Duration` by `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2097655,"byte_end":2097711,"line_start":646,"line_end":646,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2097716,"byte_end":2097725,"line_start":647,"line_end":647,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8780},"span":{"file_name":"src/libcore/time.rs","byte_start":2098444,"byte_end":2098451,"line_start":669,"line_end":669,"column_start":12,"column_end":19},"name":"div_f64","qualname":"<Duration>::div_f64","value":"fn (self, rhs: f64) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Divide `Duration` by `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2098362,"byte_end":2098418,"line_start":667,"line_end":667,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2098423,"byte_end":2098432,"line_start":668,"line_end":668,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8782},"span":{"file_name":"src/libcore/time.rs","byte_start":2099254,"byte_end":2099261,"line_start":692,"line_end":692,"column_start":12,"column_end":19},"name":"div_f32","qualname":"<Duration>::div_f32","value":"fn (self, rhs: f32) -> Duration","parent":null,"children":[],"decl_id":null,"docs":" Divide `Duration` by `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2099172,"byte_end":2099228,"line_start":690,"line_end":690,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2099233,"byte_end":2099242,"line_start":691,"line_end":691,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8784},"span":{"file_name":"src/libcore/time.rs","byte_start":2099783,"byte_end":2099799,"line_start":709,"line_end":709,"column_start":12,"column_end":28},"name":"div_duration_f64","qualname":"<Duration>::div_duration_f64","value":"fn (self, rhs: Duration) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Divide `Duration` by `Duration` and return `f64`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2099701,"byte_end":2099757,"line_start":707,"line_end":707,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2099762,"byte_end":2099771,"line_start":708,"line_end":708,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":8786},"span":{"file_name":"src/libcore/time.rs","byte_start":2100310,"byte_end":2100326,"line_start":726,"line_end":726,"column_start":12,"column_end":28},"name":"div_duration_f32","qualname":"<Duration>::div_duration_f32","value":"fn (self, rhs: Duration) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Divide `Duration` by `Duration` and return `f32`.","sig":null,"attributes":[{"value":"unstable(feature = \"duration_float\", issue = \"54361\")","span":{"file_name":"src/libcore/time.rs","byte_start":2100228,"byte_end":2100284,"line_start":724,"line_end":724,"column_start":5,"column_end":61}},{"value":"inline","span":{"file_name":"src/libcore/time.rs","byte_start":2100289,"byte_end":2100298,"line_start":725,"line_end":725,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":8850},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"unicode","qualname":"::unicode","value":"src/libcore/unicode/mod.rs","parent":null,"children":[{"krate":0,"index":8852},{"krate":0,"index":8868},{"krate":0,"index":8886},{"krate":0,"index":8964},{"krate":0,"index":8966},{"krate":0,"index":8974},{"krate":0,"index":8982}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"unstable(feature = \"unicode_internals\", issue = \"0\")","span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2108859,"byte_end":2108915,"line_start":1,"line_end":1,"column_start":1,"column_end":57}},{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2108916,"byte_end":2108939,"line_start":2,"line_end":2,"column_start":1,"column_end":24}}]},{"kind":"Struct","id":{"krate":0,"index":8854},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2110553,"byte_end":2110561,"line_start":20,"line_end":20,"column_start":12,"column_end":20},"name":"BoolTrie","qualname":"::unicode::bool_trie::BoolTrie","value":"BoolTrie { r1, r2, r3, r4, r5, r6 }","parent":null,"children":[{"krate":0,"index":4967},{"krate":0,"index":4971},{"krate":0,"index":4975},{"krate":0,"index":4977},{"krate":0,"index":4981},{"krate":0,"index":4983}],"decl_id":null,"docs":" BoolTrie is a trie for representing a set of Unicode codepoints. It is\n implemented with postfix compression (sharing of identical child nodes),\n which gives both compact size and fast lookup.","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4967},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2110636,"byte_end":2110638,"line_start":22,"line_end":22,"column_start":9,"column_end":11},"name":"r1","qualname":"::unicode::bool_trie::BoolTrie::r1","value":"[u64; _]","parent":{"krate":0,"index":8854},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4971},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2110736,"byte_end":2110738,"line_start":25,"line_end":25,"column_start":9,"column_end":11},"name":"r2","qualname":"::unicode::bool_trie::BoolTrie::r2","value":"[u8; _]","parent":{"krate":0,"index":8854},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4975},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2110779,"byte_end":2110781,"line_start":26,"line_end":26,"column_start":9,"column_end":11},"name":"r3","qualname":"::unicode::bool_trie::BoolTrie::r3","value":"&'static [u64]","parent":{"krate":0,"index":8854},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4977},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2110886,"byte_end":2110888,"line_start":29,"line_end":29,"column_start":9,"column_end":11},"name":"r4","qualname":"::unicode::bool_trie::BoolTrie::r4","value":"[u8; _]","parent":{"krate":0,"index":8854},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4981},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2110930,"byte_end":2110932,"line_start":30,"line_end":30,"column_start":9,"column_end":11},"name":"r5","qualname":"::unicode::bool_trie::BoolTrie::r5","value":"&'static [u8]","parent":{"krate":0,"index":8854},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4983},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2110975,"byte_end":2110977,"line_start":31,"line_end":31,"column_start":9,"column_end":11},"name":"r6","qualname":"::unicode::bool_trie::BoolTrie::r6","value":"&'static [u64]","parent":{"krate":0,"index":8854},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8858},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2111035,"byte_end":2111041,"line_start":34,"line_end":34,"column_start":12,"column_end":18},"name":"lookup","qualname":"<BoolTrie>::lookup","value":"fn (&self, c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":8860},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2111571,"byte_end":2111584,"line_start":49,"line_end":49,"column_start":12,"column_end":25},"name":"SmallBoolTrie","qualname":"::unicode::bool_trie::SmallBoolTrie","value":"SmallBoolTrie {  }","parent":null,"children":[{"krate":0,"index":4985},{"krate":0,"index":4987}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":8864},"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2111718,"byte_end":2111724,"line_start":55,"line_end":55,"column_start":12,"column_end":18},"name":"lookup","qualname":"<SmallBoolTrie>::lookup","value":"fn (&self, c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8896},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2124152,"byte_end":2124167,"line_start":11,"line_end":11,"column_start":11,"column_end":26},"name":"UNICODE_VERSION","qualname":"::unicode::tables::UNICODE_VERSION","value":"UnicodeVersion","parent":null,"children":[],"decl_id":null,"docs":" The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n `char` and `str` methods are based on.\n","sig":null,"attributes":[{"value":"unstable(feature = \"unicode_version\", issue = \"49726\")","span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2124084,"byte_end":2124141,"line_start":10,"line_end":10,"column_start":1,"column_end":58}}]},{"kind":"Mod","id":{"krate":0,"index":8898},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2124272,"byte_end":2124288,"line_start":17,"line_end":17,"column_start":9,"column_end":25},"name":"general_category","qualname":"::unicode::tables::general_category","value":"src/libcore/unicode/tables.rs","parent":null,"children":[{"krate":0,"index":8900},{"krate":0,"index":8902},{"krate":0,"index":8904},{"krate":0,"index":8906}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8900},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2124305,"byte_end":2124313,"line_start":18,"line_end":18,"column_start":15,"column_end":23},"name":"Cc_table","qualname":"::unicode::tables::general_category::Cc_table","value":"&super::SmallBoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8902},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2124505,"byte_end":2124507,"line_start":27,"line_end":27,"column_start":12,"column_end":14},"name":"Cc","qualname":"::unicode::tables::general_category::Cc","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8904},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2124575,"byte_end":2124582,"line_start":31,"line_end":31,"column_start":15,"column_end":22},"name":"N_table","qualname":"::unicode::tables::general_category::N_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8906},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2133394,"byte_end":2133395,"line_start":136,"line_end":136,"column_start":12,"column_end":13},"name":"N","qualname":"::unicode::tables::general_category::N","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":8908},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2133459,"byte_end":2133475,"line_start":142,"line_end":142,"column_start":9,"column_end":25},"name":"derived_property","qualname":"::unicode::tables::derived_property","value":"src/libcore/unicode/tables.rs","parent":null,"children":[{"krate":0,"index":8910},{"krate":0,"index":8912},{"krate":0,"index":8914},{"krate":0,"index":8916},{"krate":0,"index":8918},{"krate":0,"index":8920},{"krate":0,"index":8922},{"krate":0,"index":8924},{"krate":0,"index":8926},{"krate":0,"index":8928},{"krate":0,"index":8930},{"krate":0,"index":8932},{"krate":0,"index":8934},{"krate":0,"index":8936},{"krate":0,"index":8938},{"krate":0,"index":8940}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8910},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2133492,"byte_end":2133508,"line_start":143,"line_end":143,"column_start":15,"column_end":31},"name":"Alphabetic_table","qualname":"::unicode::tables::derived_property::Alphabetic_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8912},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2149417,"byte_end":2149427,"line_start":322,"line_end":322,"column_start":12,"column_end":22},"name":"Alphabetic","qualname":"::unicode::tables::derived_property::Alphabetic","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8914},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2149503,"byte_end":2149523,"line_start":326,"line_end":326,"column_start":15,"column_end":35},"name":"Case_Ignorable_table","qualname":"::unicode::tables::derived_property::Case_Ignorable_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8916},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2160567,"byte_end":2160581,"line_start":456,"line_end":456,"column_start":12,"column_end":26},"name":"Case_Ignorable","qualname":"::unicode::tables::derived_property::Case_Ignorable","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8918},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2160661,"byte_end":2160672,"line_start":460,"line_end":460,"column_start":15,"column_end":26},"name":"Cased_table","qualname":"::unicode::tables::derived_property::Cased_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8920},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2168683,"byte_end":2168688,"line_start":557,"line_end":557,"column_start":12,"column_end":17},"name":"Cased","qualname":"::unicode::tables::derived_property::Cased","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8922},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2168759,"byte_end":2168780,"line_start":561,"line_end":561,"column_start":15,"column_end":36},"name":"Grapheme_Extend_table","qualname":"::unicode::tables::derived_property::Grapheme_Extend_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8924},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2178847,"byte_end":2178862,"line_start":680,"line_end":680,"column_start":12,"column_end":27},"name":"Grapheme_Extend","qualname":"::unicode::tables::derived_property::Grapheme_Extend","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8926},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2178943,"byte_end":2178958,"line_start":684,"line_end":684,"column_start":15,"column_end":30},"name":"Lowercase_table","qualname":"::unicode::tables::derived_property::Lowercase_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8928},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2186808,"byte_end":2186817,"line_start":780,"line_end":780,"column_start":12,"column_end":21},"name":"Lowercase","qualname":"::unicode::tables::derived_property::Lowercase","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8930},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2186892,"byte_end":2186907,"line_start":784,"line_end":784,"column_start":15,"column_end":30},"name":"Uppercase_table","qualname":"::unicode::tables::derived_property::Uppercase_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8932},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2194876,"byte_end":2194885,"line_start":881,"line_end":881,"column_start":12,"column_end":21},"name":"Uppercase","qualname":"::unicode::tables::derived_property::Uppercase","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8934},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2194960,"byte_end":2194978,"line_start":885,"line_end":885,"column_start":15,"column_end":33},"name":"XID_Continue_table","qualname":"::unicode::tables::derived_property::XID_Continue_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8936},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2210235,"byte_end":2210247,"line_start":1058,"line_end":1058,"column_start":12,"column_end":24},"name":"XID_Continue","qualname":"::unicode::tables::derived_property::XID_Continue","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8938},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2210325,"byte_end":2210340,"line_start":1062,"line_end":1062,"column_start":15,"column_end":30},"name":"XID_Start_table","qualname":"::unicode::tables::derived_property::XID_Start_table","value":"&super::BoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8940},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2225692,"byte_end":2225701,"line_start":1236,"line_end":1236,"column_start":12,"column_end":21},"name":"XID_Start","qualname":"::unicode::tables::derived_property::XID_Start","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":8942},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2225773,"byte_end":2225781,"line_start":1242,"line_end":1242,"column_start":9,"column_end":17},"name":"property","qualname":"::unicode::tables::property","value":"src/libcore/unicode/tables.rs","parent":null,"children":[{"krate":0,"index":8944},{"krate":0,"index":8946},{"krate":0,"index":8948},{"krate":0,"index":8950}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8944},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2225798,"byte_end":2225823,"line_start":1243,"line_end":1243,"column_start":15,"column_end":40},"name":"Pattern_White_Space_table","qualname":"::unicode::tables::property::Pattern_White_Space_table","value":"&super::SmallBoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8946},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2226481,"byte_end":2226500,"line_start":1256,"line_end":1256,"column_start":12,"column_end":31},"name":"Pattern_White_Space","qualname":"::unicode::tables::property::Pattern_White_Space","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Const","id":{"krate":0,"index":8948},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2226585,"byte_end":2226602,"line_start":1260,"line_end":1260,"column_start":15,"column_end":32},"name":"White_Space_table","qualname":"::unicode::tables::property::White_Space_table","value":"&super::SmallBoolTrie","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8950},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2227528,"byte_end":2227539,"line_start":1276,"line_end":1276,"column_start":12,"column_end":23},"name":"White_Space","qualname":"::unicode::tables::property::White_Space","value":"fn (c: char) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":8952},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2227613,"byte_end":2227624,"line_start":1282,"line_end":1282,"column_start":9,"column_end":20},"name":"conversions","qualname":"::unicode::tables::conversions","value":"src/libcore/unicode/tables.rs","parent":null,"children":[{"krate":0,"index":8954},{"krate":0,"index":8956},{"krate":0,"index":8958},{"krate":0,"index":8960},{"krate":0,"index":8962}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8954},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2227638,"byte_end":2227646,"line_start":1283,"line_end":1283,"column_start":12,"column_end":20},"name":"to_lower","qualname":"::unicode::tables::conversions::to_lower","value":"fn (c: char) -> [char; 3]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":8956},"span":{"file_name":"src/libcore/unicode/tables.rs","byte_start":2227857,"byte_end":2227865,"line_start":1290,"line_end":1290,"column_start":12,"column_end":20},"name":"to_upper","qualname":"::unicode::tables::conversions::to_upper","value":"fn (c: char) -> [char; 3]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":44778},"span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2352387,"byte_end":2352401,"line_start":6,"line_end":6,"column_start":12,"column_end":26},"name":"UnicodeVersion","qualname":"::unicode::version::UnicodeVersion","value":"UnicodeVersion { major, minor, micro }","parent":null,"children":[{"krate":0,"index":24607},{"krate":0,"index":24609},{"krate":0,"index":24611},{"krate":0,"index":24613}],"decl_id":null,"docs":" Represents a Unicode Version.","sig":null,"attributes":[{"value":"unstable(feature = \"unicode_version\", issue = \"49726\")","span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2352318,"byte_end":2352375,"line_start":5,"line_end":5,"column_start":1,"column_end":58}},{"value":"structural_match","span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2352376,"byte_end":2352623,"line_start":6,"line_end":18,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2352376,"byte_end":2352623,"line_start":6,"line_end":18,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":24607},"span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2352435,"byte_end":2352440,"line_start":8,"line_end":8,"column_start":9,"column_end":14},"name":"major","qualname":"::unicode::version::UnicodeVersion::major","value":"u32","parent":{"krate":0,"index":44778},"children":[],"decl_id":null,"docs":" Major version.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":24609},"span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2352479,"byte_end":2352484,"line_start":11,"line_end":11,"column_start":9,"column_end":14},"name":"minor","qualname":"::unicode::version::UnicodeVersion::minor","value":"u32","parent":{"krate":0,"index":44778},"children":[],"decl_id":null,"docs":" Minor version.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":24611},"span":{"file_name":"src/libcore/unicode/version.rs","byte_start":2352535,"byte_end":2352540,"line_start":14,"line_end":14,"column_start":9,"column_end":14},"name":"micro","qualname":"::unicode::version::UnicodeVersion::micro","value":"u32","parent":{"krate":0,"index":44778},"children":[],"decl_id":null,"docs":" Micro (or Update) version.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":8966},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2109089,"byte_end":2109105,"line_start":10,"line_end":10,"column_start":9,"column_end":25},"name":"derived_property","qualname":"::unicode::derived_property","value":"src/libcore/unicode/mod.rs","parent":null,"children":[{"krate":0,"index":8968}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":8974},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2109197,"byte_end":2109208,"line_start":13,"line_end":13,"column_start":9,"column_end":20},"name":"conversions","qualname":"::unicode::conversions","value":"src/libcore/unicode/mod.rs","parent":null,"children":[{"krate":0,"index":8976}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":8982},"span":{"file_name":"src/libcore/unicode/mod.rs","byte_start":2109317,"byte_end":2109325,"line_start":18,"line_end":18,"column_start":9,"column_end":17},"name":"property","qualname":"::unicode::property","value":"src/libcore/unicode/mod.rs","parent":null,"children":[{"krate":0,"index":8984}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":8986},"span":{"file_name":"src/libcore/future/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"future","qualname":"::future","value":"src/libcore/future/mod.rs","parent":null,"children":[{"krate":0,"index":8988},{"krate":0,"index":9020}],"decl_id":null,"docs":" Asynchronous values.\n","sig":null,"attributes":[{"value":"unstable(feature = \"futures_api\",\n           reason = \"futures in libcore are unstable\",\n           issue = \"50547\")","span":{"file_name":"src/libcore/future/mod.rs","byte_start":2352625,"byte_end":2352747,"line_start":1,"line_end":3,"column_start":1,"column_end":30}}]},{"kind":"Trait","id":{"krate":0,"index":9002},"span":{"file_name":"src/libcore/future/future.rs","byte_start":2353942,"byte_end":2353948,"line_start":29,"line_end":29,"column_start":11,"column_end":17},"name":"Future","qualname":"::future::future::Future","value":"Future","parent":null,"children":[{"krate":0,"index":9004},{"krate":0,"index":9006}],"decl_id":null,"docs":" A future represents an asynchronous computation.","sig":null,"attributes":[{"value":"must_use = \"futures do nothing unless polled\"","span":{"file_name":"src/libcore/future/future.rs","byte_start":2353883,"byte_end":2353931,"line_start":28,"line_end":28,"column_start":1,"column_end":49}}]},{"kind":"Type","id":{"krate":0,"index":9004},"span":{"file_name":"src/libcore/future/future.rs","byte_start":2354010,"byte_end":2354016,"line_start":31,"line_end":31,"column_start":10,"column_end":16},"name":"Output","qualname":"::future::future::Future::Output","value":"type Output;","parent":{"krate":0,"index":9002},"children":[],"decl_id":null,"docs":" The type of value produced on completion.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9006},"span":{"file_name":"src/libcore/future/future.rs","byte_start":2357198,"byte_end":2357202,"line_start":95,"line_end":95,"column_start":8,"column_end":12},"name":"poll","qualname":"::future::future::Future::poll","value":"fn (self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>","parent":{"krate":0,"index":9002},"children":[],"decl_id":null,"docs":" Attempt to resolve the future to a final value, registering\n the current task for wakeup if the value is not yet available.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":9022},"span":{"file_name":"src/libcore/task/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"task","qualname":"::task","value":"src/libcore/task/mod.rs","parent":null,"children":[{"krate":0,"index":9024},{"krate":0,"index":9072},{"krate":0,"index":9074},{"krate":0,"index":9130}],"decl_id":null,"docs":" Types and Traits for working with asynchronous tasks.\n","sig":null,"attributes":[{"value":"unstable(feature = \"futures_api\",\n           reason = \"futures in libcore are unstable\",\n           issue = \"50547\")","span":{"file_name":"src/libcore/task/mod.rs","byte_start":2357779,"byte_end":2357901,"line_start":1,"line_end":3,"column_start":1,"column_end":30}}]},{"kind":"TupleVariant","id":{"krate":0,"index":24641},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358590,"byte_end":2358595,"line_start":14,"line_end":14,"column_start":5,"column_end":10},"name":"Ready","qualname":"::task::poll::Poll::Ready","value":"Poll::Ready(T)","parent":{"krate":0,"index":44816},"children":[],"decl_id":null,"docs":" Represents that a value is immediately ready.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":24647},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358829,"byte_end":2358836,"line_start":21,"line_end":21,"column_start":5,"column_end":12},"name":"Pending","qualname":"::task::poll::Poll::Pending","value":"Poll::Pending","parent":{"krate":0,"index":44816},"children":[],"decl_id":null,"docs":" Represents that a value is not ready yet.","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":44816},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358522,"byte_end":2358526,"line_start":12,"line_end":12,"column_start":10,"column_end":14},"name":"Poll","qualname":"::task::poll::Poll","value":"Poll::{Ready, Pending}","parent":null,"children":[{"krate":0,"index":24641},{"krate":0,"index":24647}],"decl_id":null,"docs":" Indicates whether a value is available or if the current task has been\n scheduled to receive a wakeup instead.\n","sig":null,"attributes":[{"value":"must_use =\n      \"this `Poll` may be a `Pending` variant, which should be handled\"","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358365,"byte_end":2358444,"line_start":10,"line_end":10,"column_start":1,"column_end":80}},{"value":"structural_match","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358513,"byte_end":2358839,"line_start":12,"line_end":22,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358513,"byte_end":2358839,"line_start":12,"line_end":22,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":9032},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358944,"byte_end":2358947,"line_start":26,"line_end":26,"column_start":12,"column_end":15},"name":"map","qualname":"<Poll<T>>::map","value":"fn <U, F> (self, f: F) -> Poll<U>","parent":null,"children":[],"decl_id":null,"docs":" Changes the ready value of this `Poll` with the closure provided.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9034},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2359219,"byte_end":2359227,"line_start":37,"line_end":37,"column_start":12,"column_end":20},"name":"is_ready","qualname":"<Poll<T>>::is_ready","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this is `Poll::Ready`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2359198,"byte_end":2359207,"line_start":36,"line_end":36,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9036},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2359431,"byte_end":2359441,"line_start":46,"line_end":46,"column_start":12,"column_end":22},"name":"is_pending","qualname":"<Poll<T>>::is_pending","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this is `Poll::Pending`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2359410,"byte_end":2359419,"line_start":45,"line_end":45,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9040},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2359612,"byte_end":2359618,"line_start":53,"line_end":53,"column_start":12,"column_end":18},"name":"map_ok","qualname":"<Poll<Result<T, E>>>::map_ok","value":"fn <U, F> (self, f: F) -> Poll<Result<U, E>>","parent":null,"children":[],"decl_id":null,"docs":" Changes the success value of this `Poll` with the closure provided.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9042},"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2359977,"byte_end":2359984,"line_start":64,"line_end":64,"column_start":12,"column_end":19},"name":"map_err","qualname":"<Poll<Result<T, E>>>::map_err","value":"fn <U, F> (self, f: F) -> Poll<Result<T, U>>","parent":null,"children":[],"decl_id":null,"docs":" Changes the error value of this `Poll` with the closure provided.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":44858},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2362050,"byte_end":2362058,"line_start":16,"line_end":16,"column_start":12,"column_end":20},"name":"RawWaker","qualname":"::task::wake::RawWaker","value":"RawWaker {  }","parent":null,"children":[{"krate":0,"index":24669},{"krate":0,"index":24671}],"decl_id":null,"docs":" A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n which provides customized wakeup behavior.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":47080},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2363358,"byte_end":2363361,"line_start":43,"line_end":43,"column_start":18,"column_end":21},"name":"new","qualname":"<RawWaker>::new","value":"fn (data: *const (), vtable: &'static RawWakerVTable) -> RawWaker","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `RawWaker` from the provided `data` pointer and `vtable`.","sig":null,"attributes":[{"value":"unstable(feature = \"futures_api\",\n           reason = \"futures in libcore are unstable\",\n           issue = \"50547\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2363219,"byte_end":2363340,"line_start":40,"line_end":42,"column_start":5,"column_end":30}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2363195,"byte_end":2363214,"line_start":39,"line_end":39,"column_start":5,"column_end":24}}]},{"kind":"Struct","id":{"krate":0,"index":44870},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2364074,"byte_end":2364088,"line_start":62,"line_end":62,"column_start":12,"column_end":26},"name":"RawWakerVTable","qualname":"::task::wake::RawWakerVTable","value":"RawWakerVTable {  }","parent":null,"children":[{"krate":0,"index":24673},{"krate":0,"index":24675},{"krate":0,"index":24677},{"krate":0,"index":24679}],"decl_id":null,"docs":" A virtual function pointer table (vtable) that specifies the behavior\n of a [`RawWaker`].","sig":null,"attributes":[{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2364063,"byte_end":2365575,"line_start":62,"line_end":93,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":47078},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2367357,"byte_end":2367360,"line_start":137,"line_end":137,"column_start":18,"column_end":21},"name":"new","qualname":"<RawWakerVTable>::new","value":"fn (clone: unsafe fn(*const ()) -> RawWaker, wake: unsafe fn(*const ()), wake_by_ref: unsafe fn(*const ()), drop: unsafe fn(*const ())) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `RawWakerVTable` from the provided `clone`, `wake`,\n `wake_by_ref`, and `drop` functions.","sig":null,"attributes":[{"value":"unstable(feature = \"futures_api\",\n           reason = \"futures in libcore are unstable\",\n           issue = \"50547\")","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2367218,"byte_end":2367339,"line_start":134,"line_end":136,"column_start":5,"column_end":30}},{"value":"rustc_promotable","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2367194,"byte_end":2367213,"line_start":133,"line_end":133,"column_start":5,"column_end":24}}]},{"kind":"Struct","id":{"krate":0,"index":9088},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2367831,"byte_end":2367838,"line_start":156,"line_end":156,"column_start":12,"column_end":19},"name":"Context","qualname":"::task::wake::Context","value":"Context {  }","parent":null,"children":[{"krate":0,"index":5037},{"krate":0,"index":5039}],"decl_id":null,"docs":" The `Context` of an asynchronous task.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9092},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368225,"byte_end":2368235,"line_start":168,"line_end":168,"column_start":12,"column_end":22},"name":"from_waker","qualname":"<Context>::from_waker","value":"fn (waker: &'a Waker) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Create a new `Context` from a `&Waker`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368204,"byte_end":2368213,"line_start":167,"line_end":167,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9094},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368442,"byte_end":2368447,"line_start":177,"line_end":177,"column_start":12,"column_end":17},"name":"waker","qualname":"<Context>::waker","value":"fn (&self) -> &'a Waker","parent":null,"children":[],"decl_id":null,"docs":" Returns a reference to the `Waker` for the current task.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368421,"byte_end":2368430,"line_start":176,"line_end":176,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":9100},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369008,"byte_end":2369013,"line_start":198,"line_end":198,"column_start":12,"column_end":17},"name":"Waker","qualname":"::task::wake::Waker","value":"Waker {  }","parent":null,"children":[{"krate":0,"index":5043}],"decl_id":null,"docs":" A `Waker` is a handle for waking up a task by notifying its executor that it\n is ready to be run.","sig":null,"attributes":[{"value":"repr(transparent)","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368976,"byte_end":2368996,"line_start":197,"line_end":197,"column_start":1,"column_end":21}}]},{"kind":"Method","id":{"krate":0,"index":9110},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369218,"byte_end":2369222,"line_start":209,"line_end":209,"column_start":12,"column_end":16},"name":"wake","qualname":"<Waker>::wake","value":"fn (self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Wake up the task associated with this `Waker`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369197,"byte_end":2369206,"line_start":208,"line_end":208,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9112},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2370127,"byte_end":2370138,"line_start":230,"line_end":230,"column_start":12,"column_end":23},"name":"wake_by_ref","qualname":"<Waker>::wake_by_ref","value":"fn (&self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Wake up the task associated with this `Waker` without consuming the `Waker`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2370106,"byte_end":2370115,"line_start":229,"line_end":229,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9114},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2370838,"byte_end":2370847,"line_start":246,"line_end":246,"column_start":12,"column_end":21},"name":"will_wake","qualname":"<Waker>::will_wake","value":"fn (&self, other: &Waker) -> bool","parent":null,"children":[],"decl_id":null,"docs":" Returns `true` if this `Waker` and another `Waker` have awoken the same task.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2370817,"byte_end":2370826,"line_start":245,"line_end":245,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9116},"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2371213,"byte_end":2371221,"line_start":256,"line_end":256,"column_start":19,"column_end":27},"name":"from_raw","qualname":"<Waker>::from_raw","value":"fn (waker: RawWaker) -> Waker","parent":null,"children":[],"decl_id":null,"docs":" Creates a new `Waker` from [`RawWaker`].","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2371185,"byte_end":2371194,"line_start":255,"line_end":255,"column_start":5,"column_end":14}}]},{"kind":"Mod","id":{"krate":0,"index":9140},"span":{"file_name":"src/libcore/alloc.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"alloc","qualname":"::alloc","value":"src/libcore/alloc.rs","parent":null,"children":[{"krate":0,"index":9142},{"krate":0,"index":9144},{"krate":0,"index":9146},{"krate":0,"index":9148},{"krate":0,"index":9150},{"krate":0,"index":9156},{"krate":0,"index":44888},{"krate":0,"index":44890},{"krate":0,"index":9158},{"krate":0,"index":44894},{"krate":0,"index":44914},{"krate":0,"index":44910},{"krate":0,"index":44906},{"krate":0,"index":44900},{"krate":0,"index":44896},{"krate":0,"index":9160},{"krate":0,"index":44916},{"krate":0,"index":44932},{"krate":0,"index":44926},{"krate":0,"index":44922},{"krate":0,"index":44918},{"krate":0,"index":9190},{"krate":0,"index":44936},{"krate":0,"index":44950},{"krate":0,"index":44946},{"krate":0,"index":44942},{"krate":0,"index":44938},{"krate":0,"index":9194},{"krate":0,"index":44954},{"krate":0,"index":44968},{"krate":0,"index":44964},{"krate":0,"index":44960},{"krate":0,"index":44956},{"krate":0,"index":9198},{"krate":0,"index":9202},{"krate":0,"index":9206},{"krate":0,"index":9216}],"decl_id":null,"docs":" Memory allocation APIs\n","sig":null,"attributes":[{"value":"allow(missing_docs)","span":{"file_name":"src/libcore/lib.rs","byte_start":6667,"byte_end":6689,"line_start":220,"line_end":220,"column_start":1,"column_end":23}},{"value":"stable(feature = \"alloc_module\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2372374,"byte_end":2372428,"line_start":3,"line_end":3,"column_start":1,"column_end":55}}]},{"kind":"Struct","id":{"krate":0,"index":44888},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2372745,"byte_end":2372751,"line_start":16,"line_end":16,"column_start":12,"column_end":18},"name":"Excess","qualname":"::alloc::Excess","value":"","parent":null,"children":[],"decl_id":null,"docs":" Represents the combination of a starting address and\n a total capacity of the returned block.\n","sig":null,"attributes":[{"value":"unstable(feature = \"allocator_api\", issue = \"32838\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2372661,"byte_end":2372716,"line_start":14,"line_end":14,"column_start":1,"column_end":56}}]},{"kind":"Struct","id":{"krate":0,"index":44894},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2373589,"byte_end":2373595,"line_start":38,"line_end":38,"column_start":12,"column_end":18},"name":"Layout","qualname":"::alloc::Layout","value":"Layout {  }","parent":null,"children":[{"krate":0,"index":24687},{"krate":0,"index":24689}],"decl_id":null,"docs":" Layout of a block of memory.","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2373454,"byte_end":2373507,"line_start":35,"line_end":35,"column_start":1,"column_end":54}},{"value":"lang = \"alloc_layout\"","span":{"file_name":"src/libcore/alloc.rs","byte_start":2373553,"byte_end":2373577,"line_start":37,"line_end":37,"column_start":1,"column_end":25}},{"value":"structural_match","span":{"file_name":"src/libcore/alloc.rs","byte_start":2373578,"byte_end":2374112,"line_start":38,"line_end":50,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/alloc.rs","byte_start":2373578,"byte_end":2374112,"line_start":38,"line_end":50,"column_start":1,"column_end":2}}]},{"kind":"Method","id":{"krate":0,"index":9162},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2374634,"byte_end":2374649,"line_start":66,"line_end":66,"column_start":12,"column_end":27},"name":"from_size_align","qualname":"<Layout>::from_size_align","value":"fn (size: usize, align: usize) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Constructs a `Layout` from a given `size` and `align`,\n or returns `LayoutErr` if either of the following conditions\n are not met:","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2374555,"byte_end":2374608,"line_start":64,"line_end":64,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2374613,"byte_end":2374622,"line_start":65,"line_end":65,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9164},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2375941,"byte_end":2375966,"line_start":102,"line_end":102,"column_start":19,"column_end":44},"name":"from_size_align_unchecked","qualname":"<Layout>::from_size_align_unchecked","value":"fn (size: usize, align: usize) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout, bypassing all checks.","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2375855,"byte_end":2375908,"line_start":100,"line_end":100,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2375913,"byte_end":2375922,"line_start":101,"line_end":101,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9166},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2376238,"byte_end":2376242,"line_start":109,"line_end":109,"column_start":12,"column_end":16},"name":"size","qualname":"<Layout>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" The minimum size in bytes for a memory block of this layout.\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2376159,"byte_end":2376212,"line_start":107,"line_end":107,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2376217,"byte_end":2376226,"line_start":108,"line_end":108,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9168},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2376428,"byte_end":2376433,"line_start":114,"line_end":114,"column_start":12,"column_end":17},"name":"align","qualname":"<Layout>::align","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" The minimum byte alignment for a memory block of this layout.\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2376349,"byte_end":2376402,"line_start":112,"line_end":112,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2376407,"byte_end":2376416,"line_start":113,"line_end":113,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9170},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2376628,"byte_end":2376631,"line_start":119,"line_end":119,"column_start":12,"column_end":15},"name":"new","qualname":"<Layout>::new","value":"fn <T> () -> Self","parent":null,"children":[],"decl_id":null,"docs":" Constructs a `Layout` suitable for holding a value of type `T`.\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2376549,"byte_end":2376602,"line_start":117,"line_end":117,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2376607,"byte_end":2376616,"line_start":118,"line_end":118,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9172},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2377411,"byte_end":2377420,"line_start":136,"line_end":136,"column_start":12,"column_end":21},"name":"for_value","qualname":"<Layout>::for_value","value":"fn <T> (t: &T) -> Self","parent":null,"children":[],"decl_id":null,"docs":" Produces layout describing a record that could be used to\n allocate backing structure for `T` (which could be a trait\n or other unsized type like a slice).\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2377332,"byte_end":2377385,"line_start":134,"line_end":134,"column_start":5,"column_end":58}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2377390,"byte_end":2377399,"line_start":135,"line_end":135,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9174},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2378583,"byte_end":2378591,"line_start":162,"line_end":162,"column_start":12,"column_end":20},"name":"align_to","qualname":"<Layout>::align_to","value":"fn (&self, align: usize) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record that can hold a value\n of the same layout as `self`, but that also is aligned to\n alignment `align` (measured in bytes).","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2378497,"byte_end":2378557,"line_start":160,"line_end":160,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2378562,"byte_end":2378571,"line_start":161,"line_end":161,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9176},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2379647,"byte_end":2379665,"line_start":184,"line_end":184,"column_start":12,"column_end":30},"name":"padding_needed_for","qualname":"<Layout>::padding_needed_for","value":"fn (&self, align: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the amount of padding we must insert after `self`\n to ensure that the following address will satisfy `align`\n (measured in bytes).","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2379561,"byte_end":2379621,"line_start":182,"line_end":182,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2379626,"byte_end":2379635,"line_start":183,"line_end":183,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9178},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2381159,"byte_end":2381171,"line_start":220,"line_end":220,"column_start":12,"column_end":24},"name":"pad_to_align","qualname":"<Layout>::pad_to_align","value":"fn (&self) -> Result<Layout, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout by rounding the size of this layout up to a multiple\n of the layout's alignment.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2381073,"byte_end":2381133,"line_start":218,"line_end":218,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2381138,"byte_end":2381147,"line_start":219,"line_end":219,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9180},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2381961,"byte_end":2381967,"line_start":238,"line_end":238,"column_start":12,"column_end":18},"name":"repeat","qualname":"<Layout>::repeat","value":"fn (&self, n: usize) -> Result<(Self, usize), LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for `n` instances of\n `self`, with a suitable amount of padding between each to\n ensure that each instance is given its requested size and\n alignment. On success, returns `(k, offs)` where `k` is the\n layout of the array and `offs` is the distance between the start\n of each element in the array.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2381875,"byte_end":2381935,"line_start":236,"line_end":236,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2381940,"byte_end":2381949,"line_start":237,"line_end":237,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9182},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2383368,"byte_end":2383374,"line_start":267,"line_end":267,"column_start":12,"column_end":18},"name":"extend","qualname":"<Layout>::extend","value":"fn (&self, next: Self) -> Result<(Self, usize), LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for `self` followed by\n `next`, including any necessary padding to ensure that `next`\n will be properly aligned. Note that the result layout will\n satisfy the alignment properties of both `self` and `next`.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2383282,"byte_end":2383342,"line_start":265,"line_end":265,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2383347,"byte_end":2383356,"line_start":266,"line_end":266,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9184},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2384545,"byte_end":2384558,"line_start":294,"line_end":294,"column_start":12,"column_end":25},"name":"repeat_packed","qualname":"<Layout>::repeat_packed","value":"fn (&self, n: usize) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for `n` instances of\n `self`, with no padding between each instance.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2384459,"byte_end":2384519,"line_start":292,"line_end":292,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2384524,"byte_end":2384533,"line_start":293,"line_end":293,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9186},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2385170,"byte_end":2385183,"line_start":307,"line_end":307,"column_start":12,"column_end":25},"name":"extend_packed","qualname":"<Layout>::extend_packed","value":"fn (&self, next: Self) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for `self` followed by\n `next` with no additional padding between the two. Since no\n padding is inserted, the alignment of `next` is irrelevant,\n and is not incorporated *at all* into the resulting layout.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2385084,"byte_end":2385144,"line_start":305,"line_end":305,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2385149,"byte_end":2385158,"line_start":306,"line_end":306,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9188},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2385651,"byte_end":2385656,"line_start":319,"line_end":319,"column_start":12,"column_end":17},"name":"array","qualname":"<Layout>::array","value":"fn <T> (n: usize) -> Result<Self, LayoutErr>","parent":null,"children":[],"decl_id":null,"docs":" Creates a layout describing the record for a `[T; n]`.","sig":null,"attributes":[{"value":"unstable(feature = \"alloc_layout_extra\", issue = \"55724\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2385565,"byte_end":2385625,"line_start":317,"line_end":317,"column_start":5,"column_end":65}},{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2385630,"byte_end":2385639,"line_start":318,"line_end":318,"column_start":5,"column_end":14}}]},{"kind":"Struct","id":{"krate":0,"index":44916},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2386126,"byte_end":2386135,"line_start":334,"line_end":334,"column_start":12,"column_end":21},"name":"LayoutErr","qualname":"::alloc::LayoutErr","value":"LayoutErr {  }","parent":null,"children":[{"krate":0,"index":24691}],"decl_id":null,"docs":" The parameters given to `Layout::from_size_align`\n or some other `Layout` constructor\n do not satisfy its documented constraints.\n","sig":null,"attributes":[{"value":"stable(feature = \"alloc_layout\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2386022,"byte_end":2386075,"line_start":332,"line_end":332,"column_start":1,"column_end":54}},{"value":"structural_match","span":{"file_name":"src/libcore/alloc.rs","byte_start":2386115,"byte_end":2386155,"line_start":334,"line_end":336,"column_start":1,"column_end":2}}]},{"kind":"Struct","id":{"krate":0,"index":44936},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2386737,"byte_end":2386745,"line_start":352,"line_end":352,"column_start":12,"column_end":20},"name":"AllocErr","qualname":"::alloc::AllocErr","value":"","parent":null,"children":[],"decl_id":null,"docs":" The `AllocErr` error indicates an allocation failure\n that may be due to resource exhaustion or to\n something wrong when combining the given input arguments with this\n allocator.\n","sig":null,"attributes":[{"value":"unstable(feature = \"allocator_api\", issue = \"32838\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2386631,"byte_end":2386686,"line_start":350,"line_end":350,"column_start":1,"column_end":56}},{"value":"structural_match","span":{"file_name":"src/libcore/alloc.rs","byte_start":2386726,"byte_end":2386746,"line_start":352,"line_end":352,"column_start":1,"column_end":21}}]},{"kind":"Struct","id":{"krate":0,"index":44954},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2387279,"byte_end":2387299,"line_start":367,"line_end":367,"column_start":12,"column_end":32},"name":"CannotReallocInPlace","qualname":"::alloc::CannotReallocInPlace","value":"","parent":null,"children":[],"decl_id":null,"docs":" The `CannotReallocInPlace` error is used when `grow_in_place` or\n `shrink_in_place` were unable to reuse the given memory block for\n a requested layout.\n","sig":null,"attributes":[{"value":"unstable(feature = \"allocator_api\", issue = \"32838\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2387173,"byte_end":2387228,"line_start":365,"line_end":365,"column_start":1,"column_end":56}},{"value":"structural_match","span":{"file_name":"src/libcore/alloc.rs","byte_start":2387268,"byte_end":2387300,"line_start":367,"line_end":367,"column_start":1,"column_end":33}}]},{"kind":"Method","id":{"krate":0,"index":9200},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2387397,"byte_end":2387408,"line_start":371,"line_end":371,"column_start":12,"column_end":23},"name":"description","qualname":"<CannotReallocInPlace>::description","value":"fn (&self) -> &str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":9206},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2389614,"byte_end":2389625,"line_start":436,"line_end":436,"column_start":18,"column_end":29},"name":"GlobalAlloc","qualname":"::alloc::GlobalAlloc","value":"GlobalAlloc","parent":null,"children":[{"krate":0,"index":9208},{"krate":0,"index":9210},{"krate":0,"index":9212},{"krate":0,"index":9214}],"decl_id":null,"docs":" A memory allocator that can be registered as the standard librarys default\n though the `#[global_allocator]` attributes.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2389543,"byte_end":2389596,"line_start":435,"line_end":435,"column_start":1,"column_end":54}}]},{"kind":"Method","id":{"krate":0,"index":9208},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2391115,"byte_end":2391120,"line_start":470,"line_end":470,"column_start":15,"column_end":20},"name":"alloc","qualname":"::alloc::GlobalAlloc::alloc","value":"fn (&self, layout: Layout) -> *mut u8","parent":{"krate":0,"index":9206},"children":[],"decl_id":null,"docs":" Allocate memory as described by the given `layout`.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2391047,"byte_end":2391100,"line_start":469,"line_end":469,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":9210},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2391697,"byte_end":2391704,"line_start":485,"line_end":485,"column_start":15,"column_end":22},"name":"dealloc","qualname":"::alloc::GlobalAlloc::dealloc","value":"fn (&self, ptr: *mut u8, layout: Layout) -> ()","parent":{"krate":0,"index":9206},"children":[],"decl_id":null,"docs":" Deallocate the block of memory at the given `ptr` pointer with the given `layout`.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2391629,"byte_end":2391682,"line_start":484,"line_end":484,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":9212},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2392623,"byte_end":2392635,"line_start":507,"line_end":507,"column_start":15,"column_end":27},"name":"alloc_zeroed","qualname":"::alloc::GlobalAlloc::alloc_zeroed","value":"fn (&self, layout: Layout) -> *mut u8","parent":{"krate":0,"index":9206},"children":[],"decl_id":null,"docs":" Behaves like `alloc`, but also ensures that the contents\n are set to zero before being returned.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2392555,"byte_end":2392608,"line_start":506,"line_end":506,"column_start":5,"column_end":58}}]},{"kind":"Method","id":{"krate":0,"index":9214},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2395210,"byte_end":2395217,"line_start":567,"line_end":567,"column_start":15,"column_end":22},"name":"realloc","qualname":"::alloc::GlobalAlloc::realloc","value":"fn (&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8","parent":{"krate":0,"index":9206},"children":[],"decl_id":null,"docs":" Shrink or grow a block of memory to the given `new_size`.\n The block is described by the given `ptr` pointer and `layout`.","sig":null,"attributes":[{"value":"stable(feature = \"global_alloc\", since = \"1.28.0\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2395142,"byte_end":2395195,"line_start":566,"line_end":566,"column_start":5,"column_end":58}}]},{"kind":"Trait","id":{"krate":0,"index":9216},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2399403,"byte_end":2399408,"line_start":662,"line_end":662,"column_start":18,"column_end":23},"name":"Alloc","qualname":"::alloc::Alloc","value":"Alloc","parent":null,"children":[{"krate":0,"index":9218},{"krate":0,"index":9220},{"krate":0,"index":9222},{"krate":0,"index":9224},{"krate":0,"index":9226},{"krate":0,"index":9228},{"krate":0,"index":9230},{"krate":0,"index":9232},{"krate":0,"index":9234},{"krate":0,"index":9236},{"krate":0,"index":9238},{"krate":0,"index":9240},{"krate":0,"index":9242},{"krate":0,"index":9244}],"decl_id":null,"docs":" An implementation of `Alloc` can allocate, reallocate, and\n deallocate arbitrary blocks of data described via `Layout`.","sig":null,"attributes":[{"value":"unstable(feature = \"allocator_api\", issue = \"32838\")","span":{"file_name":"src/libcore/alloc.rs","byte_start":2399330,"byte_end":2399385,"line_start":661,"line_end":661,"column_start":1,"column_end":56}}]},{"kind":"Method","id":{"krate":0,"index":9218},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2401515,"byte_end":2401520,"line_start":710,"line_end":710,"column_start":15,"column_end":20},"name":"alloc","qualname":"::alloc::Alloc::alloc","value":"fn (&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Returns a pointer meeting the size and alignment guarantees of\n `layout`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9220},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2402160,"byte_end":2402167,"line_start":727,"line_end":727,"column_start":15,"column_end":22},"name":"dealloc","qualname":"::alloc::Alloc::dealloc","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout) -> ()","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Deallocate the memory referenced by `ptr`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9222},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2403574,"byte_end":2403585,"line_start":759,"line_end":759,"column_start":8,"column_end":19},"name":"usable_size","qualname":"::alloc::Alloc::usable_size","value":"fn (&self, layout: &Layout) -> (usize, usize)","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Returns bounds on the guaranteed usable size of a successful\n allocation created with the specified `layout`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/alloc.rs","byte_start":2403557,"byte_end":2403566,"line_start":758,"line_end":758,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9224},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2406215,"byte_end":2406222,"line_start":820,"line_end":820,"column_start":15,"column_end":22},"name":"realloc","qualname":"::alloc::Alloc::realloc","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<NonNull<u8>, AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Returns a pointer suitable for holding data described by\n a new layout with `layout`s alignment and a size given\n by `new_size`. To\n accomplish this, this may extend or shrink the allocation\n referenced by `ptr` to fit the new layout.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9226},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2407970,"byte_end":2407982,"line_start":866,"line_end":866,"column_start":15,"column_end":27},"name":"alloc_zeroed","qualname":"::alloc::Alloc::alloc_zeroed","value":"fn (&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Behaves like `alloc`, but also ensures that the contents\n are set to zero before being returned.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9228},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2409040,"byte_end":2409052,"line_start":894,"line_end":894,"column_start":15,"column_end":27},"name":"alloc_excess","qualname":"::alloc::Alloc::alloc_excess","value":"fn (&mut self, layout: Layout) -> Result<Excess, AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Behaves like `alloc`, but also returns the whole size of\n the returned block. For some `layout` inputs, like arrays, this\n may include extra storage usable for additional data.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9230},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2410058,"byte_end":2410072,"line_start":918,"line_end":918,"column_start":15,"column_end":29},"name":"realloc_excess","qualname":"::alloc::Alloc::realloc_excess","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<Excess, AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Behaves like `realloc`, but also returns the whole size of\n the returned block. For some `layout` inputs, like arrays, this\n may include extra storage usable for additional data.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9232},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2412123,"byte_end":2412136,"line_start":963,"line_end":963,"column_start":15,"column_end":28},"name":"grow_in_place","qualname":"::alloc::Alloc::grow_in_place","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<(), CannotReallocInPlace>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Attempts to extend the allocation referenced by `ptr` to fit `new_size`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9234},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2414654,"byte_end":2414669,"line_start":1018,"line_end":1018,"column_start":15,"column_end":30},"name":"shrink_in_place","qualname":"::alloc::Alloc::shrink_in_place","value":"fn (&mut self, ptr: NonNull<u8>, layout: Layout, new_size: usize) -> Result<(), CannotReallocInPlace>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9236},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2416798,"byte_end":2416807,"line_start":1067,"line_end":1067,"column_start":8,"column_end":17},"name":"alloc_one","qualname":"::alloc::Alloc::alloc_one","value":"fn <T> (&mut self) -> Result<NonNull<T>, AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Allocates a block suitable for holding an instance of `T`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9238},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2417755,"byte_end":2417766,"line_start":1095,"line_end":1095,"column_start":15,"column_end":26},"name":"dealloc_one","qualname":"::alloc::Alloc::dealloc_one","value":"fn <T> (&mut self, ptr: NonNull<T>) -> ()","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Deallocates a block suitable for holding an instance of `T`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9240},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2419396,"byte_end":2419407,"line_start":1136,"line_end":1136,"column_start":8,"column_end":19},"name":"alloc_array","qualname":"::alloc::Alloc::alloc_array","value":"fn <T> (&mut self, n: usize) -> Result<NonNull<T>, AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Allocates a block suitable for holding `n` instances of `T`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9242},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2421122,"byte_end":2421135,"line_start":1183,"line_end":1183,"column_start":15,"column_end":28},"name":"realloc_array","qualname":"::alloc::Alloc::realloc_array","value":"fn <T> (&mut self, ptr: NonNull<T>, n_old: usize, n_new: usize) -> Result<NonNull<T>, AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Reallocates a block previously suitable for holding `n_old`\n instances of `T`, returning a block suitable for holding\n `n_new` instances of `T`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9244},"span":{"file_name":"src/libcore/alloc.rs","byte_start":2422468,"byte_end":2422481,"line_start":1220,"line_end":1220,"column_start":15,"column_end":28},"name":"dealloc_array","qualname":"::alloc::Alloc::dealloc_array","value":"fn <T> (&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>","parent":{"krate":0,"index":9216},"children":[],"decl_id":null,"docs":" Deallocates a block suitable for holding `n` instances of `T`.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":9278},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2429257,"byte_end":2429261,"line_start":17,"line_end":17,"column_start":9,"column_end":13},"name":"arch","qualname":"::core_arch::arch","value":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","parent":null,"children":[{"krate":0,"index":9280}],"decl_id":null,"docs":"SIMD and vendor intrinsics module.","sig":null,"attributes":[{"value":"stable(feature = \"simd_arch\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2429198,"byte_end":2429248,"line_start":16,"line_end":16,"column_start":1,"column_end":51}}]},{"kind":"Mod","id":{"krate":0,"index":9280},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2429958,"byte_end":2429964,"line_start":35,"line_end":35,"column_start":13,"column_end":19},"name":"x86_64","qualname":"::core_arch::arch::x86_64","value":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","parent":null,"children":[{"krate":0,"index":9282},{"krate":0,"index":9284}],"decl_id":null,"docs":" Platform-specific intrinsics for the `x86_64` platform.","sig":null,"attributes":[{"value":"cfg(any(target_arch = \"x86_64\", dox))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2429811,"byte_end":2429851,"line_start":32,"line_end":32,"column_start":5,"column_end":45}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/mod.rs","byte_start":2429896,"byte_end":2429945,"line_start":34,"line_end":34,"column_start":5,"column_end":54}}]},{"kind":"ForeignFunction","id":{"krate":0,"index":5077},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2449709,"byte_end":2449716,"line_start":6,"line_end":6,"column_start":12,"column_end":19},"name":"simd_eq","qualname":"::core_arch::simd_llvm::simd_eq","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5083},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2449752,"byte_end":2449759,"line_start":7,"line_end":7,"column_start":12,"column_end":19},"name":"simd_ne","qualname":"::core_arch::simd_llvm::simd_ne","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5089},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2449795,"byte_end":2449802,"line_start":8,"line_end":8,"column_start":12,"column_end":19},"name":"simd_lt","qualname":"::core_arch::simd_llvm::simd_lt","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5095},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2449838,"byte_end":2449845,"line_start":9,"line_end":9,"column_start":12,"column_end":19},"name":"simd_le","qualname":"::core_arch::simd_llvm::simd_le","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5101},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2449881,"byte_end":2449888,"line_start":10,"line_end":10,"column_start":12,"column_end":19},"name":"simd_gt","qualname":"::core_arch::simd_llvm::simd_gt","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5107},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2449924,"byte_end":2449931,"line_start":11,"line_end":11,"column_start":12,"column_end":19},"name":"simd_ge","qualname":"::core_arch::simd_llvm::simd_ge","value":"fn <T, U> (x: T, y: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5113},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2449968,"byte_end":2449981,"line_start":13,"line_end":13,"column_start":12,"column_end":25},"name":"simd_shuffle2","qualname":"::core_arch::simd_llvm::simd_shuffle2","value":"fn <T, U> (x: T, y: T, idx: [u32; 2]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5121},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450032,"byte_end":2450045,"line_start":14,"line_end":14,"column_start":12,"column_end":25},"name":"simd_shuffle4","qualname":"::core_arch::simd_llvm::simd_shuffle4","value":"fn <T, U> (x: T, y: T, idx: [u32; 4]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5129},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450096,"byte_end":2450109,"line_start":15,"line_end":15,"column_start":12,"column_end":25},"name":"simd_shuffle8","qualname":"::core_arch::simd_llvm::simd_shuffle8","value":"fn <T, U> (x: T, y: T, idx: [u32; 8]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5137},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450160,"byte_end":2450174,"line_start":16,"line_end":16,"column_start":12,"column_end":26},"name":"simd_shuffle16","qualname":"::core_arch::simd_llvm::simd_shuffle16","value":"fn <T, U> (x: T, y: T, idx: [u32; 16]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5145},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450226,"byte_end":2450240,"line_start":17,"line_end":17,"column_start":12,"column_end":26},"name":"simd_shuffle32","qualname":"::core_arch::simd_llvm::simd_shuffle32","value":"fn <T, U> (x: T, y: T, idx: [u32; 32]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5153},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450292,"byte_end":2450306,"line_start":18,"line_end":18,"column_start":12,"column_end":26},"name":"simd_shuffle64","qualname":"::core_arch::simd_llvm::simd_shuffle64","value":"fn <T, U> (x: T, y: T, idx: [u32; 64]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5161},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450358,"byte_end":2450373,"line_start":19,"line_end":19,"column_start":12,"column_end":27},"name":"simd_shuffle128","qualname":"::core_arch::simd_llvm::simd_shuffle128","value":"fn <T, U> (x: T, y: T, idx: [u32; 128]) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5169},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450427,"byte_end":2450438,"line_start":21,"line_end":21,"column_start":12,"column_end":23},"name":"simd_insert","qualname":"::core_arch::simd_llvm::simd_insert","value":"fn <T, U> (x: T, idx: u32, val: U) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5175},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450486,"byte_end":2450498,"line_start":22,"line_end":22,"column_start":12,"column_end":24},"name":"simd_extract","qualname":"::core_arch::simd_llvm::simd_extract","value":"fn <T, U> (x: T, idx: u32) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5181},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450539,"byte_end":2450548,"line_start":24,"line_end":24,"column_start":12,"column_end":21},"name":"simd_cast","qualname":"::core_arch::simd_llvm::simd_cast","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5187},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450579,"byte_end":2450587,"line_start":26,"line_end":26,"column_start":12,"column_end":20},"name":"simd_add","qualname":"::core_arch::simd_llvm::simd_add","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5191},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450620,"byte_end":2450628,"line_start":27,"line_end":27,"column_start":12,"column_end":20},"name":"simd_sub","qualname":"::core_arch::simd_llvm::simd_sub","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5195},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450661,"byte_end":2450669,"line_start":28,"line_end":28,"column_start":12,"column_end":20},"name":"simd_mul","qualname":"::core_arch::simd_llvm::simd_mul","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5199},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450702,"byte_end":2450710,"line_start":29,"line_end":29,"column_start":12,"column_end":20},"name":"simd_div","qualname":"::core_arch::simd_llvm::simd_div","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5203},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450743,"byte_end":2450751,"line_start":30,"line_end":30,"column_start":12,"column_end":20},"name":"simd_rem","qualname":"::core_arch::simd_llvm::simd_rem","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5207},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450784,"byte_end":2450792,"line_start":31,"line_end":31,"column_start":12,"column_end":20},"name":"simd_shl","qualname":"::core_arch::simd_llvm::simd_shl","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5211},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450825,"byte_end":2450833,"line_start":32,"line_end":32,"column_start":12,"column_end":20},"name":"simd_shr","qualname":"::core_arch::simd_llvm::simd_shr","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5215},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450866,"byte_end":2450874,"line_start":33,"line_end":33,"column_start":12,"column_end":20},"name":"simd_and","qualname":"::core_arch::simd_llvm::simd_and","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5219},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450907,"byte_end":2450914,"line_start":34,"line_end":34,"column_start":12,"column_end":19},"name":"simd_or","qualname":"::core_arch::simd_llvm::simd_or","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5223},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450947,"byte_end":2450955,"line_start":35,"line_end":35,"column_start":12,"column_end":20},"name":"simd_xor","qualname":"::core_arch::simd_llvm::simd_xor","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5227},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2450989,"byte_end":2451014,"line_start":37,"line_end":37,"column_start":12,"column_end":37},"name":"simd_reduce_add_unordered","qualname":"::core_arch::simd_llvm::simd_reduce_add_unordered","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5233},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451044,"byte_end":2451069,"line_start":38,"line_end":38,"column_start":12,"column_end":37},"name":"simd_reduce_mul_unordered","qualname":"::core_arch::simd_llvm::simd_reduce_mul_unordered","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5239},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451099,"byte_end":2451122,"line_start":39,"line_end":39,"column_start":12,"column_end":35},"name":"simd_reduce_add_ordered","qualname":"::core_arch::simd_llvm::simd_reduce_add_ordered","value":"fn <T, U> (x: T, acc: U) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5245},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451160,"byte_end":2451183,"line_start":40,"line_end":40,"column_start":12,"column_end":35},"name":"simd_reduce_mul_ordered","qualname":"::core_arch::simd_llvm::simd_reduce_mul_ordered","value":"fn <T, U> (x: T, acc: U) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5251},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451221,"byte_end":2451236,"line_start":41,"line_end":41,"column_start":12,"column_end":27},"name":"simd_reduce_min","qualname":"::core_arch::simd_llvm::simd_reduce_min","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5257},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451266,"byte_end":2451281,"line_start":42,"line_end":42,"column_start":12,"column_end":27},"name":"simd_reduce_max","qualname":"::core_arch::simd_llvm::simd_reduce_max","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5263},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451311,"byte_end":2451334,"line_start":43,"line_end":43,"column_start":12,"column_end":35},"name":"simd_reduce_min_nanless","qualname":"::core_arch::simd_llvm::simd_reduce_min_nanless","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5269},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451364,"byte_end":2451387,"line_start":44,"line_end":44,"column_start":12,"column_end":35},"name":"simd_reduce_max_nanless","qualname":"::core_arch::simd_llvm::simd_reduce_max_nanless","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5275},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451417,"byte_end":2451432,"line_start":45,"line_end":45,"column_start":12,"column_end":27},"name":"simd_reduce_and","qualname":"::core_arch::simd_llvm::simd_reduce_and","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5281},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451462,"byte_end":2451476,"line_start":46,"line_end":46,"column_start":12,"column_end":26},"name":"simd_reduce_or","qualname":"::core_arch::simd_llvm::simd_reduce_or","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5287},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451506,"byte_end":2451521,"line_start":47,"line_end":47,"column_start":12,"column_end":27},"name":"simd_reduce_xor","qualname":"::core_arch::simd_llvm::simd_reduce_xor","value":"fn <T, U> (x: T) -> U","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5293},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451551,"byte_end":2451566,"line_start":48,"line_end":48,"column_start":12,"column_end":27},"name":"simd_reduce_all","qualname":"::core_arch::simd_llvm::simd_reduce_all","value":"fn <T> (x: T) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5297},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451596,"byte_end":2451611,"line_start":49,"line_end":49,"column_start":12,"column_end":27},"name":"simd_reduce_any","qualname":"::core_arch::simd_llvm::simd_reduce_any","value":"fn <T> (x: T) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5301},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451642,"byte_end":2451653,"line_start":51,"line_end":51,"column_start":12,"column_end":23},"name":"simd_select","qualname":"::core_arch::simd_llvm::simd_select","value":"fn <M, T> (m: M, a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5307},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451695,"byte_end":2451714,"line_start":52,"line_end":52,"column_start":12,"column_end":31},"name":"simd_select_bitmask","qualname":"::core_arch::simd_llvm::simd_select_bitmask","value":"fn <M, T> (m: M, a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5313},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451757,"byte_end":2451766,"line_start":54,"line_end":54,"column_start":12,"column_end":21},"name":"simd_fmin","qualname":"::core_arch::simd_llvm::simd_fmin","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5317},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451799,"byte_end":2451808,"line_start":55,"line_end":55,"column_start":12,"column_end":21},"name":"simd_fmax","qualname":"::core_arch::simd_llvm::simd_fmax","value":"fn <T> (a: T, b: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5321},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451842,"byte_end":2451852,"line_start":57,"line_end":57,"column_start":12,"column_end":22},"name":"simd_fsqrt","qualname":"::core_arch::simd_llvm::simd_fsqrt","value":"fn <T> (a: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"ForeignFunction","id":{"krate":0,"index":5325},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/simd_llvm.rs","byte_start":2451879,"byte_end":2451887,"line_start":58,"line_end":58,"column_start":12,"column_end":20},"name":"simd_fma","qualname":"::core_arch::simd_llvm::simd_fma","value":"fn <T> (a: T, b: T, c: T) -> T","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":46912},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2453699,"byte_end":2453704,"line_start":51,"line_end":51,"column_start":16,"column_end":21},"name":"__m64","qualname":"::core_arch::x86::__m64","value":"","parent":null,"children":[],"decl_id":null,"docs":" 64-bit wide integer vector type, x86-specific","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":46924},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2455412,"byte_end":2455419,"line_start":95,"line_end":95,"column_start":16,"column_end":23},"name":"__m128i","qualname":"::core_arch::x86::__m128i","value":"","parent":null,"children":[],"decl_id":null,"docs":" 128-bit wide integer vector type, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443095,"byte_end":2443102,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":46936},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2456842,"byte_end":2456848,"line_start":132,"line_end":132,"column_start":16,"column_end":22},"name":"__m128","qualname":"::core_arch::x86::__m128","value":"","parent":null,"children":[],"decl_id":null,"docs":" 128-bit wide set of four `f32` types, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443095,"byte_end":2443102,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":46948},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2458268,"byte_end":2458275,"line_start":169,"line_end":169,"column_start":16,"column_end":23},"name":"__m128d","qualname":"::core_arch::x86::__m128d","value":"","parent":null,"children":[],"decl_id":null,"docs":" 128-bit wide set of two `f64` types, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443095,"byte_end":2443102,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":46960},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2459858,"byte_end":2459865,"line_start":210,"line_end":210,"column_start":16,"column_end":23},"name":"__m256i","qualname":"::core_arch::x86::__m256i","value":"","parent":null,"children":[],"decl_id":null,"docs":" 256-bit wide integer vector type, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443095,"byte_end":2443102,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":46972},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2461336,"byte_end":2461342,"line_start":247,"line_end":247,"column_start":16,"column_end":22},"name":"__m256","qualname":"::core_arch::x86::__m256","value":"","parent":null,"children":[],"decl_id":null,"docs":" 256-bit wide set of eight `f32` types, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443095,"byte_end":2443102,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":46984},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2462810,"byte_end":2462817,"line_start":284,"line_end":284,"column_start":16,"column_end":23},"name":"__m256d","qualname":"::core_arch::x86::__m256d","value":"","parent":null,"children":[],"decl_id":null,"docs":" 256-bit wide set of four `f64` types, x86-specific","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443095,"byte_end":2443102,"line_start":274,"line_end":274,"column_start":11,"column_end":18}},{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":46996},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2463808,"byte_end":2463815,"line_start":305,"line_end":305,"column_start":16,"column_end":23},"name":"__m512i","qualname":"::core_arch::x86::__m512i","value":"","parent":null,"children":[],"decl_id":null,"docs":" 512-bit wide integer vector type, x86-specific","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":47008},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2464695,"byte_end":2464701,"line_start":322,"line_end":322,"column_start":16,"column_end":22},"name":"__m512","qualname":"::core_arch::x86::__m512","value":"","parent":null,"children":[],"decl_id":null,"docs":" 512-bit wide set of sixteen `f32` types, x86-specific","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Struct","id":{"krate":0,"index":47020},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2465638,"byte_end":2465645,"line_start":342,"line_end":342,"column_start":16,"column_end":23},"name":"__m512d","qualname":"::core_arch::x86::__m512d","value":"","parent":null,"children":[],"decl_id":null,"docs":" 512-bit wide set of eight `f64` types, x86-specific","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443151,"byte_end":2443181,"line_start":276,"line_end":276,"column_start":9,"column_end":39}},{"value":"repr(simd)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443190,"byte_end":2443203,"line_start":277,"line_end":277,"column_start":9,"column_end":22}},{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443212,"byte_end":2443260,"line_start":278,"line_end":278,"column_start":9,"column_end":57}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/macros.rs","byte_start":2443269,"byte_end":2443299,"line_start":279,"line_end":279,"column_start":9,"column_end":39}}]},{"kind":"Type","id":{"krate":0,"index":9310},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2465800,"byte_end":2465809,"line_start":347,"line_end":347,"column_start":10,"column_end":19},"name":"__mmask16","qualname":"::core_arch::x86::__mmask16","value":"i16","parent":null,"children":[],"decl_id":null,"docs":" The `__mmask16` type used in AVX-512 intrinsics, a 16-bit integer\n","sig":null,"attributes":[{"value":"allow(non_camel_case_types)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2465760,"byte_end":2465790,"line_start":346,"line_end":346,"column_start":1,"column_end":31}}]},{"kind":"Method","id":{"krate":0,"index":9314},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466005,"byte_end":2466013,"line_start":357,"line_end":357,"column_start":8,"column_end":16},"name":"as_m128i","qualname":"::core_arch::x86::m128iExt::as_m128i","value":"fn (self) -> __m128i","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9316},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466054,"byte_end":2466062,"line_start":360,"line_end":360,"column_start":8,"column_end":16},"name":"as_u8x16","qualname":"::core_arch::x86::m128iExt::as_u8x16","value":"fn (self) -> crate::core_arch::simd::u8x16","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466037,"byte_end":2466046,"line_start":359,"line_end":359,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9318},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466178,"byte_end":2466186,"line_start":365,"line_end":365,"column_start":8,"column_end":16},"name":"as_u16x8","qualname":"::core_arch::x86::m128iExt::as_u16x8","value":"fn (self) -> crate::core_arch::simd::u16x8","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466161,"byte_end":2466170,"line_start":364,"line_end":364,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9320},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466302,"byte_end":2466310,"line_start":370,"line_end":370,"column_start":8,"column_end":16},"name":"as_u32x4","qualname":"::core_arch::x86::m128iExt::as_u32x4","value":"fn (self) -> crate::core_arch::simd::u32x4","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466285,"byte_end":2466294,"line_start":369,"line_end":369,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9322},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466426,"byte_end":2466434,"line_start":375,"line_end":375,"column_start":8,"column_end":16},"name":"as_u64x2","qualname":"::core_arch::x86::m128iExt::as_u64x2","value":"fn (self) -> crate::core_arch::simd::u64x2","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466409,"byte_end":2466418,"line_start":374,"line_end":374,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9324},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466550,"byte_end":2466558,"line_start":380,"line_end":380,"column_start":8,"column_end":16},"name":"as_i8x16","qualname":"::core_arch::x86::m128iExt::as_i8x16","value":"fn (self) -> crate::core_arch::simd::i8x16","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466533,"byte_end":2466542,"line_start":379,"line_end":379,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9326},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466674,"byte_end":2466682,"line_start":385,"line_end":385,"column_start":8,"column_end":16},"name":"as_i16x8","qualname":"::core_arch::x86::m128iExt::as_i16x8","value":"fn (self) -> crate::core_arch::simd::i16x8","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466657,"byte_end":2466666,"line_start":384,"line_end":384,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9328},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466798,"byte_end":2466806,"line_start":390,"line_end":390,"column_start":8,"column_end":16},"name":"as_i32x4","qualname":"::core_arch::x86::m128iExt::as_i32x4","value":"fn (self) -> crate::core_arch::simd::i32x4","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466781,"byte_end":2466790,"line_start":389,"line_end":389,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9330},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466922,"byte_end":2466930,"line_start":395,"line_end":395,"column_start":8,"column_end":16},"name":"as_i64x2","qualname":"::core_arch::x86::m128iExt::as_i64x2","value":"fn (self) -> crate::core_arch::simd::i64x2","parent":{"krate":0,"index":9312},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2466905,"byte_end":2466914,"line_start":394,"line_end":394,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9338},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467250,"byte_end":2467258,"line_start":410,"line_end":410,"column_start":8,"column_end":16},"name":"as_m256i","qualname":"::core_arch::x86::m256iExt::as_m256i","value":"fn (self) -> __m256i","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9340},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467299,"byte_end":2467307,"line_start":413,"line_end":413,"column_start":8,"column_end":16},"name":"as_u8x32","qualname":"::core_arch::x86::m256iExt::as_u8x32","value":"fn (self) -> crate::core_arch::simd::u8x32","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467282,"byte_end":2467291,"line_start":412,"line_end":412,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9342},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467423,"byte_end":2467432,"line_start":418,"line_end":418,"column_start":8,"column_end":17},"name":"as_u16x16","qualname":"::core_arch::x86::m256iExt::as_u16x16","value":"fn (self) -> crate::core_arch::simd::u16x16","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467406,"byte_end":2467415,"line_start":417,"line_end":417,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9344},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467549,"byte_end":2467557,"line_start":423,"line_end":423,"column_start":8,"column_end":16},"name":"as_u32x8","qualname":"::core_arch::x86::m256iExt::as_u32x8","value":"fn (self) -> crate::core_arch::simd::u32x8","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467532,"byte_end":2467541,"line_start":422,"line_end":422,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9346},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467673,"byte_end":2467681,"line_start":428,"line_end":428,"column_start":8,"column_end":16},"name":"as_u64x4","qualname":"::core_arch::x86::m256iExt::as_u64x4","value":"fn (self) -> crate::core_arch::simd::u64x4","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467656,"byte_end":2467665,"line_start":427,"line_end":427,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9348},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467797,"byte_end":2467805,"line_start":433,"line_end":433,"column_start":8,"column_end":16},"name":"as_i8x32","qualname":"::core_arch::x86::m256iExt::as_i8x32","value":"fn (self) -> crate::core_arch::simd::i8x32","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467780,"byte_end":2467789,"line_start":432,"line_end":432,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9350},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467921,"byte_end":2467930,"line_start":438,"line_end":438,"column_start":8,"column_end":17},"name":"as_i16x16","qualname":"::core_arch::x86::m256iExt::as_i16x16","value":"fn (self) -> crate::core_arch::simd::i16x16","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467904,"byte_end":2467913,"line_start":437,"line_end":437,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9352},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468047,"byte_end":2468055,"line_start":443,"line_end":443,"column_start":8,"column_end":16},"name":"as_i32x8","qualname":"::core_arch::x86::m256iExt::as_i32x8","value":"fn (self) -> crate::core_arch::simd::i32x8","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468030,"byte_end":2468039,"line_start":442,"line_end":442,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9354},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468171,"byte_end":2468179,"line_start":448,"line_end":448,"column_start":8,"column_end":16},"name":"as_i64x4","qualname":"::core_arch::x86::m256iExt::as_i64x4","value":"fn (self) -> crate::core_arch::simd::i64x4","parent":{"krate":0,"index":9336},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468154,"byte_end":2468163,"line_start":447,"line_end":447,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":9362},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468499,"byte_end":2468507,"line_start":463,"line_end":463,"column_start":8,"column_end":16},"name":"as_m512i","qualname":"::core_arch::x86::m512iExt::as_m512i","value":"fn (self) -> __m512i","parent":{"krate":0,"index":9360},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":9364},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468548,"byte_end":2468557,"line_start":466,"line_end":466,"column_start":8,"column_end":17},"name":"as_i32x16","qualname":"::core_arch::x86::m512iExt::as_i32x16","value":"fn (self) -> crate::core_arch::simd::i32x16","parent":{"krate":0,"index":9360},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468531,"byte_end":2468540,"line_start":465,"line_end":465,"column_start":5,"column_end":14}}]},{"kind":"Function","id":{"krate":0,"index":9372},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2473855,"byte_end":2473867,"line_start":31,"line_end":31,"column_start":15,"column_end":27},"name":"__readeflags","qualname":"::core_arch::x86::eflags::__readeflags","value":"fn () -> u64","parent":null,"children":[],"decl_id":null,"docs":" Reads EFLAGS.","sig":null,"attributes":[{"value":"cfg(target_arch = \"x86_64\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2473620,"byte_end":2473650,"line_start":23,"line_end":23,"column_start":1,"column_end":31}},{"value":"inline(always)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2473651,"byte_end":2473668,"line_start":24,"line_end":24,"column_start":1,"column_end":18}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2473669,"byte_end":2473718,"line_start":25,"line_end":25,"column_start":1,"column_end":50}},{"value":"rustc_deprecated(since = \"1.29.0\",\n                   reason = \"See issue #51810 - use inline assembly instead\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2473719,"byte_end":2473825,"line_start":26,"line_end":29,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":9374},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2474812,"byte_end":2474825,"line_start":63,"line_end":63,"column_start":15,"column_end":28},"name":"__writeeflags","qualname":"::core_arch::x86::eflags::__writeeflags","value":"fn (eflags: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Write EFLAGS.","sig":null,"attributes":[{"value":"cfg(target_arch = \"x86_64\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2474577,"byte_end":2474607,"line_start":55,"line_end":55,"column_start":1,"column_end":31}},{"value":"inline(always)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2474608,"byte_end":2474625,"line_start":56,"line_end":56,"column_start":1,"column_end":18}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2474626,"byte_end":2474675,"line_start":57,"line_end":57,"column_start":1,"column_end":50}},{"value":"rustc_deprecated(since = \"1.29.0\",\n                   reason = \"See issue #51810 - use inline assembly instead\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/eflags.rs","byte_start":2474676,"byte_end":2474782,"line_start":58,"line_end":61,"column_start":1,"column_end":3}}]},{"kind":"Function","id":{"krate":0,"index":9382},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2476294,"byte_end":2476301,"line_start":30,"line_end":30,"column_start":15,"column_end":22},"name":"_fxsave","qualname":"::core_arch::x86::fxsr::_fxsave","value":"fn (mem_addr: *mut u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2476145,"byte_end":2476154,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fxsr\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2476155,"byte_end":2476189,"line_start":27,"line_end":27,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2476230,"byte_end":2476279,"line_start":29,"line_end":29,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9384},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2477167,"byte_end":2477175,"line_start":54,"line_end":54,"column_start":15,"column_end":23},"name":"_fxrstor","qualname":"::core_arch::x86::fxsr::_fxrstor","value":"fn (mem_addr: *const u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Restores the `XMM`, `MMX`, `MXCSR`, and `x87` FPU registers from the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2477017,"byte_end":2477026,"line_start":50,"line_end":50,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fxsr\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2477027,"byte_end":2477061,"line_start":51,"line_end":51,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fxsr.rs","byte_start":2477103,"byte_end":2477152,"line_start":53,"line_end":53,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9390},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bswap.rs","byte_start":2478993,"byte_end":2478999,"line_start":13,"line_end":13,"column_start":15,"column_end":21},"name":"_bswap","qualname":"::core_arch::x86::bswap::_bswap","value":"fn (x: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns an integer with the reversed byte order of x","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bswap.rs","byte_start":2478880,"byte_end":2478889,"line_start":10,"line_end":10,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bswap.rs","byte_start":2478929,"byte_end":2478978,"line_start":12,"line_end":12,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9398},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2480294,"byte_end":2480300,"line_start":25,"line_end":25,"column_start":15,"column_end":21},"name":"_rdtsc","qualname":"::core_arch::x86::rdtsc::_rdtsc","value":"fn () -> i64","parent":null,"children":[],"decl_id":null,"docs":" Reads the current value of the processors time-stamp counter.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2480181,"byte_end":2480190,"line_start":22,"line_end":22,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2480230,"byte_end":2480279,"line_start":24,"line_end":24,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9400},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2481154,"byte_end":2481162,"line_start":48,"line_end":48,"column_start":15,"column_end":23},"name":"__rdtscp","qualname":"::core_arch::x86::rdtsc::__rdtscp","value":"fn (aux: *mut u32) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Reads the current value of the processors time-stamp counter and\n the `IA32_TSC_AUX MSR`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2481040,"byte_end":2481049,"line_start":45,"line_end":45,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdtsc.rs","byte_start":2481090,"byte_end":2481139,"line_start":47,"line_end":47,"column_start":1,"column_end":50}}]},{"kind":"Struct","id":{"krate":0,"index":47032},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482273,"byte_end":2482284,"line_start":12,"line_end":12,"column_start":12,"column_end":23},"name":"CpuidResult","qualname":"::core_arch::x86::cpuid::CpuidResult","value":"CpuidResult { eax, ebx, ecx, edx }","parent":null,"children":[{"krate":0,"index":26841},{"krate":0,"index":26843},{"krate":0,"index":26845},{"krate":0,"index":26847}],"decl_id":null,"docs":" Result of the `cpuid` instruction.\n","sig":null,"attributes":[{"value":"allow(clippy::missing_inline_in_public_items)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482021,"byte_end":2482069,"line_start":8,"line_end":8,"column_start":1,"column_end":49}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482212,"byte_end":2482261,"line_start":11,"line_end":11,"column_start":1,"column_end":50}},{"value":"structural_match","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482262,"byte_end":2482664,"line_start":12,"line_end":25,"column_start":1,"column_end":2}},{"value":"rustc_copy_clone_marker","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482262,"byte_end":2482664,"line_start":12,"line_end":25,"column_start":1,"column_end":2}}]},{"kind":"Field","id":{"krate":0,"index":26841},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482371,"byte_end":2482374,"line_start":15,"line_end":15,"column_start":9,"column_end":12},"name":"eax","qualname":"::core_arch::x86::cpuid::CpuidResult::eax","value":"u32","parent":{"krate":0,"index":47032},"children":[],"decl_id":null,"docs":" EAX register.\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482313,"byte_end":2482362,"line_start":14,"line_end":14,"column_start":5,"column_end":54}}]},{"kind":"Field","id":{"krate":0,"index":26843},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482465,"byte_end":2482468,"line_start":18,"line_end":18,"column_start":9,"column_end":12},"name":"ebx","qualname":"::core_arch::x86::cpuid::CpuidResult::ebx","value":"u32","parent":{"krate":0,"index":47032},"children":[],"decl_id":null,"docs":" EBX register.\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482407,"byte_end":2482456,"line_start":17,"line_end":17,"column_start":5,"column_end":54}}]},{"kind":"Field","id":{"krate":0,"index":26845},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482559,"byte_end":2482562,"line_start":21,"line_end":21,"column_start":9,"column_end":12},"name":"ecx","qualname":"::core_arch::x86::cpuid::CpuidResult::ecx","value":"u32","parent":{"krate":0,"index":47032},"children":[],"decl_id":null,"docs":" ECX register.\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482501,"byte_end":2482550,"line_start":20,"line_end":20,"column_start":5,"column_end":54}}]},{"kind":"Field","id":{"krate":0,"index":26847},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482653,"byte_end":2482656,"line_start":24,"line_end":24,"column_start":9,"column_end":12},"name":"edx","qualname":"::core_arch::x86::cpuid::CpuidResult::edx","value":"u32","parent":{"krate":0,"index":47032},"children":[],"decl_id":null,"docs":" EDX register.\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2482595,"byte_end":2482644,"line_start":23,"line_end":23,"column_start":5,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":9408},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2483920,"byte_end":2483933,"line_start":53,"line_end":53,"column_start":15,"column_end":28},"name":"__cpuid_count","qualname":"::core_arch::x86::cpuid::__cpuid_count","value":"fn (leaf: u32, sub_leaf: u32) -> CpuidResult","parent":null,"children":[],"decl_id":null,"docs":" Returns the result of the `cpuid` instruction for a given `leaf` (`EAX`)\n and\n `sub_leaf` (`ECX`).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2483807,"byte_end":2483816,"line_start":50,"line_end":50,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2483856,"byte_end":2483905,"line_start":52,"line_end":52,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9410},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2484723,"byte_end":2484730,"line_start":80,"line_end":80,"column_start":15,"column_end":22},"name":"__cpuid","qualname":"::core_arch::x86::cpuid::__cpuid","value":"fn (leaf: u32) -> CpuidResult","parent":null,"children":[],"decl_id":null,"docs":" See [`__cpuid_count`](fn.__cpuid_count.html).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2484610,"byte_end":2484619,"line_start":77,"line_end":77,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2484659,"byte_end":2484708,"line_start":79,"line_end":79,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9412},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2484857,"byte_end":2484866,"line_start":86,"line_end":86,"column_start":8,"column_end":17},"name":"has_cpuid","qualname":"::core_arch::x86::cpuid::has_cpuid","value":"fn () -> bool","parent":null,"children":[],"decl_id":null,"docs":" Does the host support the `cpuid` instruction?\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2484840,"byte_end":2484849,"line_start":85,"line_end":85,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":9414},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2487978,"byte_end":2487993,"line_start":167,"line_end":167,"column_start":15,"column_end":30},"name":"__get_cpuid_max","qualname":"::core_arch::x86::cpuid::__get_cpuid_max","value":"fn (leaf: u32) -> (u32, u32)","parent":null,"children":[],"decl_id":null,"docs":" Returns the highest-supported `leaf` (`EAX`) and sub-leaf (`ECX`) `cpuid`\n values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2487904,"byte_end":2487913,"line_start":165,"line_end":165,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/cpuid.rs","byte_start":2487914,"byte_end":2487963,"line_start":166,"line_end":166,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9422},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2489932,"byte_end":2489938,"line_start":39,"line_end":39,"column_start":15,"column_end":21},"name":"_xsave","qualname":"::core_arch::x86::xsave::_xsave","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2489783,"byte_end":2489792,"line_start":35,"line_end":35,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2489793,"byte_end":2489828,"line_start":36,"line_end":36,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2489868,"byte_end":2489917,"line_start":38,"line_end":38,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9424},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2490599,"byte_end":2490606,"line_start":55,"line_end":55,"column_start":15,"column_end":22},"name":"_xrstor","qualname":"::core_arch::x86::xsave::_xrstor","value":"fn (mem_addr: *const u8, rs_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial restore of the enabled processor states using\n the state information stored in memory at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2490449,"byte_end":2490458,"line_start":51,"line_end":51,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2490459,"byte_end":2490494,"line_start":52,"line_end":52,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2490535,"byte_end":2490584,"line_start":54,"line_end":54,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9426},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2490860,"byte_end":2490886,"line_start":63,"line_end":63,"column_start":11,"column_end":37},"name":"_XCR_XFEATURE_ENABLED_MASK","qualname":"::core_arch::x86::xsave::_XCR_XFEATURE_ENABLED_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" `XFEATURE_ENABLED_MASK` for `XCR`","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2490800,"byte_end":2490849,"line_start":62,"line_end":62,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9428},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2491316,"byte_end":2491323,"line_start":75,"line_end":75,"column_start":15,"column_end":22},"name":"_xsetbv","qualname":"::core_arch::x86::xsave::_xsetbv","value":"fn (a: u32, val: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Copies 64-bits from `val` to the extended control register (`XCR`) specified\n by `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2491166,"byte_end":2491175,"line_start":71,"line_end":71,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2491176,"byte_end":2491211,"line_start":72,"line_end":72,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2491252,"byte_end":2491301,"line_start":74,"line_end":74,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9430},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2491741,"byte_end":2491748,"line_start":87,"line_end":87,"column_start":15,"column_end":22},"name":"_xgetbv","qualname":"::core_arch::x86::xsave::_xgetbv","value":"fn (xcr_no: u32) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Reads the contents of the extended control register `XCR`\n specified in `xcr_no`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2491591,"byte_end":2491600,"line_start":83,"line_end":83,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2491601,"byte_end":2491636,"line_start":84,"line_end":84,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2491677,"byte_end":2491726,"line_start":86,"line_end":86,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9432},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2492582,"byte_end":2492591,"line_start":107,"line_end":107,"column_start":15,"column_end":24},"name":"_xsaveopt","qualname":"::core_arch::x86::xsave::_xsaveopt","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2492421,"byte_end":2492430,"line_start":103,"line_end":103,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaveopt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2492431,"byte_end":2492475,"line_start":104,"line_end":104,"column_start":1,"column_end":45}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2492518,"byte_end":2492567,"line_start":106,"line_end":106,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9434},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2493289,"byte_end":2493296,"line_start":123,"line_end":123,"column_start":15,"column_end":22},"name":"_xsavec","qualname":"::core_arch::x86::xsave::_xsavec","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory\n at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2493132,"byte_end":2493141,"line_start":119,"line_end":119,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsavec\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2493142,"byte_end":2493184,"line_start":120,"line_end":120,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2493225,"byte_end":2493274,"line_start":122,"line_end":122,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9436},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2494057,"byte_end":2494064,"line_start":140,"line_end":140,"column_start":15,"column_end":22},"name":"_xsaves","qualname":"::core_arch::x86::xsave::_xsaves","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2493900,"byte_end":2493909,"line_start":136,"line_end":136,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaves\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2493910,"byte_end":2493952,"line_start":137,"line_end":137,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2493993,"byte_end":2494042,"line_start":139,"line_end":139,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9438},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2494970,"byte_end":2494978,"line_start":159,"line_end":159,"column_start":15,"column_end":23},"name":"_xrstors","qualname":"::core_arch::x86::xsave::_xrstors","value":"fn (mem_addr: *const u8, rs_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial restore of the enabled processor states using the\n state information stored in memory at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2494812,"byte_end":2494821,"line_start":155,"line_end":155,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaves\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2494822,"byte_end":2494864,"line_start":156,"line_end":156,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/xsave.rs","byte_start":2494906,"byte_end":2494955,"line_start":158,"line_end":158,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9460},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2498943,"byte_end":2498953,"line_start":19,"line_end":19,"column_start":15,"column_end":25},"name":"_mm_add_ss","qualname":"::core_arch::x86::sse::_mm_add_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Adds the first component of `a` and `b`, the other components are copied\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2498796,"byte_end":2498805,"line_start":15,"line_end":15,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2498806,"byte_end":2498839,"line_start":16,"line_end":16,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2498879,"byte_end":2498928,"line_start":18,"line_end":18,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9462},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499290,"byte_end":2499300,"line_start":30,"line_end":30,"column_start":15,"column_end":25},"name":"_mm_add_ps","qualname":"::core_arch::x86::sse::_mm_add_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Adds __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499143,"byte_end":2499152,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499153,"byte_end":2499186,"line_start":27,"line_end":27,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499226,"byte_end":2499275,"line_start":29,"line_end":29,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9464},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499712,"byte_end":2499722,"line_start":42,"line_end":42,"column_start":15,"column_end":25},"name":"_mm_sub_ss","qualname":"::core_arch::x86::sse::_mm_sub_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Subtracts the first component of `b` from `a`, the other components are\n copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499565,"byte_end":2499574,"line_start":38,"line_end":38,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499575,"byte_end":2499608,"line_start":39,"line_end":39,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499648,"byte_end":2499697,"line_start":41,"line_end":41,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9466},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500064,"byte_end":2500074,"line_start":53,"line_end":53,"column_start":15,"column_end":25},"name":"_mm_sub_ps","qualname":"::core_arch::x86::sse::_mm_sub_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Subtracts __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499917,"byte_end":2499926,"line_start":49,"line_end":49,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2499927,"byte_end":2499960,"line_start":50,"line_end":50,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500000,"byte_end":2500049,"line_start":52,"line_end":52,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9468},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500486,"byte_end":2500496,"line_start":65,"line_end":65,"column_start":15,"column_end":25},"name":"_mm_mul_ss","qualname":"::core_arch::x86::sse::_mm_mul_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the first component of `a` and `b`, the other components are\n copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500339,"byte_end":2500348,"line_start":61,"line_end":61,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500349,"byte_end":2500382,"line_start":62,"line_end":62,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500422,"byte_end":2500471,"line_start":64,"line_end":64,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9470},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500839,"byte_end":2500849,"line_start":76,"line_end":76,"column_start":15,"column_end":25},"name":"_mm_mul_ps","qualname":"::core_arch::x86::sse::_mm_mul_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500692,"byte_end":2500701,"line_start":72,"line_end":72,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500702,"byte_end":2500735,"line_start":73,"line_end":73,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2500775,"byte_end":2500824,"line_start":75,"line_end":75,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9472},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501257,"byte_end":2501267,"line_start":88,"line_end":88,"column_start":15,"column_end":25},"name":"_mm_div_ss","qualname":"::core_arch::x86::sse::_mm_div_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Divides the first component of `b` by `a`, the other components are\n copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501110,"byte_end":2501119,"line_start":84,"line_end":84,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501120,"byte_end":2501153,"line_start":85,"line_end":85,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501193,"byte_end":2501242,"line_start":87,"line_end":87,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9474},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501607,"byte_end":2501617,"line_start":99,"line_end":99,"column_start":15,"column_end":25},"name":"_mm_div_ps","qualname":"::core_arch::x86::sse::_mm_div_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Divides __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501460,"byte_end":2501469,"line_start":95,"line_end":95,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501470,"byte_end":2501503,"line_start":96,"line_end":96,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501543,"byte_end":2501592,"line_start":98,"line_end":98,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9476},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502070,"byte_end":2502081,"line_start":111,"line_end":111,"column_start":15,"column_end":26},"name":"_mm_sqrt_ss","qualname":"::core_arch::x86::sse::_mm_sqrt_ss","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of the first single-precision (32-bit)\n floating-point element in `a`, the other elements are unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501922,"byte_end":2501931,"line_start":107,"line_end":107,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2501932,"byte_end":2501965,"line_start":108,"line_end":108,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502006,"byte_end":2502055,"line_start":110,"line_end":110,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9478},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502482,"byte_end":2502493,"line_start":123,"line_end":123,"column_start":15,"column_end":26},"name":"_mm_sqrt_ps","qualname":"::core_arch::x86::sse::_mm_sqrt_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of packed single-precision (32-bit) floating-point\n elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502334,"byte_end":2502343,"line_start":119,"line_end":119,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502344,"byte_end":2502377,"line_start":120,"line_end":120,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502418,"byte_end":2502467,"line_start":122,"line_end":122,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9480},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502939,"byte_end":2502949,"line_start":135,"line_end":135,"column_start":15,"column_end":25},"name":"_mm_rcp_ss","qualname":"::core_arch::x86::sse::_mm_rcp_ss","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the approximate reciprocal of the first single-precision\n (32-bit) floating-point element in `a`, the other elements are unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502792,"byte_end":2502801,"line_start":131,"line_end":131,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502802,"byte_end":2502835,"line_start":132,"line_end":132,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2502875,"byte_end":2502924,"line_start":134,"line_end":134,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9482},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2503358,"byte_end":2503368,"line_start":147,"line_end":147,"column_start":15,"column_end":25},"name":"_mm_rcp_ps","qualname":"::core_arch::x86::sse::_mm_rcp_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the approximate reciprocal of packed single-precision (32-bit)\n floating-point elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2503211,"byte_end":2503220,"line_start":143,"line_end":143,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2503221,"byte_end":2503254,"line_start":144,"line_end":144,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2503294,"byte_end":2503343,"line_start":146,"line_end":146,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9484},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2503829,"byte_end":2503841,"line_start":159,"line_end":159,"column_start":15,"column_end":27},"name":"_mm_rsqrt_ss","qualname":"::core_arch::x86::sse::_mm_rsqrt_ss","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the approximate reciprocal square root of the fist single-precision\n (32-bit) floating-point elements in `a`, the other elements are unchanged.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2503680,"byte_end":2503689,"line_start":155,"line_end":155,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2503690,"byte_end":2503723,"line_start":156,"line_end":156,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2503765,"byte_end":2503814,"line_start":158,"line_end":158,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9486},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2504268,"byte_end":2504280,"line_start":171,"line_end":171,"column_start":15,"column_end":27},"name":"_mm_rsqrt_ps","qualname":"::core_arch::x86::sse::_mm_rsqrt_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the approximate reciprocal square root of packed single-precision\n (32-bit) floating-point elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2504119,"byte_end":2504128,"line_start":167,"line_end":167,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2504129,"byte_end":2504162,"line_start":168,"line_end":168,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2504204,"byte_end":2504253,"line_start":170,"line_end":170,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9488},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2504787,"byte_end":2504797,"line_start":184,"line_end":184,"column_start":15,"column_end":25},"name":"_mm_min_ss","qualname":"::core_arch::x86::sse::_mm_min_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the first single-precision (32-bit) floating-point element of `a`\n and `b`, and return the minimum value in the first element of the return\n value, the other elements are copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2504640,"byte_end":2504649,"line_start":180,"line_end":180,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2504650,"byte_end":2504683,"line_start":181,"line_end":181,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2504723,"byte_end":2504772,"line_start":183,"line_end":183,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9490},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2505244,"byte_end":2505254,"line_start":196,"line_end":196,"column_start":15,"column_end":25},"name":"_mm_min_ps","qualname":"::core_arch::x86::sse::_mm_min_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point elements in `a` and\n `b`, and return the corresponding minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2505097,"byte_end":2505106,"line_start":192,"line_end":192,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2505107,"byte_end":2505140,"line_start":193,"line_end":193,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2505180,"byte_end":2505229,"line_start":195,"line_end":195,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9492},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2505773,"byte_end":2505783,"line_start":209,"line_end":209,"column_start":15,"column_end":25},"name":"_mm_max_ss","qualname":"::core_arch::x86::sse::_mm_max_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the first single-precision (32-bit) floating-point element of `a`\n and `b`, and return the maximum value in the first element of the return\n value, the other elements are copied from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2505626,"byte_end":2505635,"line_start":205,"line_end":205,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2505636,"byte_end":2505669,"line_start":206,"line_end":206,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2505709,"byte_end":2505758,"line_start":208,"line_end":208,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9494},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2506230,"byte_end":2506240,"line_start":221,"line_end":221,"column_start":15,"column_end":25},"name":"_mm_max_ps","qualname":"::core_arch::x86::sse::_mm_max_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point elements in `a` and\n `b`, and return the corresponding maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2506083,"byte_end":2506092,"line_start":217,"line_end":217,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2506093,"byte_end":2506126,"line_start":218,"line_end":218,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2506166,"byte_end":2506215,"line_start":220,"line_end":220,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9496},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2506769,"byte_end":2506779,"line_start":236,"line_end":236,"column_start":15,"column_end":25},"name":"_mm_and_ps","qualname":"::core_arch::x86::sse::_mm_and_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Bitwise AND of packed single-precision (32-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2506482,"byte_end":2506491,"line_start":228,"line_end":228,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2506492,"byte_end":2506525,"line_start":229,"line_end":229,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2506705,"byte_end":2506754,"line_start":235,"line_end":235,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9498},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2507487,"byte_end":2507500,"line_start":257,"line_end":257,"column_start":15,"column_end":28},"name":"_mm_andnot_ps","qualname":"::core_arch::x86::sse::_mm_andnot_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Bitwise AND-NOT of packed single-precision (32-bit) floating-point\n elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2507186,"byte_end":2507195,"line_start":248,"line_end":248,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2507196,"byte_end":2507229,"line_start":249,"line_end":249,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2507423,"byte_end":2507472,"line_start":256,"line_end":256,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9500},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2508201,"byte_end":2508210,"line_start":275,"line_end":275,"column_start":15,"column_end":24},"name":"_mm_or_ps","qualname":"::core_arch::x86::sse::_mm_or_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Bitwise OR of packed single-precision (32-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2507913,"byte_end":2507922,"line_start":267,"line_end":267,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2507923,"byte_end":2507956,"line_start":268,"line_end":268,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2508137,"byte_end":2508186,"line_start":274,"line_end":274,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9502},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2508853,"byte_end":2508863,"line_start":293,"line_end":293,"column_start":15,"column_end":25},"name":"_mm_xor_ps","qualname":"::core_arch::x86::sse::_mm_xor_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Bitwise exclusive OR of packed single-precision (32-bit) floating-point\n elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2508563,"byte_end":2508572,"line_start":285,"line_end":285,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2508573,"byte_end":2508606,"line_start":286,"line_end":286,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2508789,"byte_end":2508838,"line_start":292,"line_end":292,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9504},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2509508,"byte_end":2509520,"line_start":308,"line_end":308,"column_start":15,"column_end":27},"name":"_mm_cmpeq_ss","qualname":"::core_arch::x86::sse::_mm_cmpeq_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for equality. The lowest 32 bits of\n the result will be `0xffffffff` if the two inputs are equal, or `0`\n otherwise. The upper 96 bits of the result are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2509359,"byte_end":2509368,"line_start":304,"line_end":304,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2509369,"byte_end":2509402,"line_start":305,"line_end":305,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2509444,"byte_end":2509493,"line_start":307,"line_end":307,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9506},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2510092,"byte_end":2510104,"line_start":322,"line_end":322,"column_start":15,"column_end":27},"name":"_mm_cmplt_ss","qualname":"::core_arch::x86::sse::_mm_cmplt_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for less than. The lowest 32 bits\n of the result will be `0xffffffff` if `a.extract(0)` is less than\n `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the\n upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2509943,"byte_end":2509952,"line_start":318,"line_end":318,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2509953,"byte_end":2509986,"line_start":319,"line_end":319,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2510028,"byte_end":2510077,"line_start":321,"line_end":321,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9508},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2510694,"byte_end":2510706,"line_start":336,"line_end":336,"column_start":15,"column_end":27},"name":"_mm_cmple_ss","qualname":"::core_arch::x86::sse::_mm_cmple_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for less than or equal. The lowest\n 32 bits of the result will be `0xffffffff` if `a.extract(0)` is less than\n or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result\n are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2510545,"byte_end":2510554,"line_start":332,"line_end":332,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2510555,"byte_end":2510588,"line_start":333,"line_end":333,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2510630,"byte_end":2510679,"line_start":335,"line_end":335,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9510},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2511284,"byte_end":2511296,"line_start":350,"line_end":350,"column_start":15,"column_end":27},"name":"_mm_cmpgt_ss","qualname":"::core_arch::x86::sse::_mm_cmpgt_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for greater than. The lowest 32\n bits of the result will be `0xffffffff` if `a.extract(0)` is greater\n than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result\n are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2511135,"byte_end":2511144,"line_start":346,"line_end":346,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2511145,"byte_end":2511178,"line_start":347,"line_end":347,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2511220,"byte_end":2511269,"line_start":349,"line_end":349,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9512},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2511924,"byte_end":2511936,"line_start":364,"line_end":364,"column_start":15,"column_end":27},"name":"_mm_cmpge_ss","qualname":"::core_arch::x86::sse::_mm_cmpge_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for greater than or equal. The\n lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is\n greater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits\n of the result are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2511775,"byte_end":2511784,"line_start":360,"line_end":360,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2511785,"byte_end":2511818,"line_start":361,"line_end":361,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2511860,"byte_end":2511909,"line_start":363,"line_end":363,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9514},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2512546,"byte_end":2512559,"line_start":378,"line_end":378,"column_start":15,"column_end":28},"name":"_mm_cmpneq_ss","qualname":"::core_arch::x86::sse::_mm_cmpneq_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for inequality. The lowest 32 bits\n of the result will be `0xffffffff` if `a.extract(0)` is not equal to\n `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the\n upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2512396,"byte_end":2512405,"line_start":374,"line_end":374,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2512406,"byte_end":2512439,"line_start":375,"line_end":375,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2512482,"byte_end":2512531,"line_start":377,"line_end":377,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9516},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2513141,"byte_end":2513154,"line_start":392,"line_end":392,"column_start":15,"column_end":28},"name":"_mm_cmpnlt_ss","qualname":"::core_arch::x86::sse::_mm_cmpnlt_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for not-less-than. The lowest 32\n bits of the result will be `0xffffffff` if `a.extract(0)` is not less than\n `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are the\n upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2512991,"byte_end":2513000,"line_start":388,"line_end":388,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2513001,"byte_end":2513034,"line_start":389,"line_end":389,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2513077,"byte_end":2513126,"line_start":391,"line_end":391,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9518},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2513757,"byte_end":2513770,"line_start":406,"line_end":406,"column_start":15,"column_end":28},"name":"_mm_cmpnle_ss","qualname":"::core_arch::x86::sse::_mm_cmpnle_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for not-less-than-or-equal. The\n lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not\n less than or equal to `b.extract(0)`, or `0` otherwise. The upper 96 bits\n of the result are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2513607,"byte_end":2513616,"line_start":402,"line_end":402,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2513617,"byte_end":2513650,"line_start":403,"line_end":403,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2513693,"byte_end":2513742,"line_start":405,"line_end":405,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9520},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2514358,"byte_end":2514371,"line_start":420,"line_end":420,"column_start":15,"column_end":28},"name":"_mm_cmpngt_ss","qualname":"::core_arch::x86::sse::_mm_cmpngt_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for not-greater-than. The lowest 32\n bits of the result will be `0xffffffff` if `a.extract(0)` is not greater\n than `b.extract(0)`, or `0` otherwise. The upper 96 bits of the result are\n the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2514208,"byte_end":2514217,"line_start":416,"line_end":416,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2514218,"byte_end":2514251,"line_start":417,"line_end":417,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2514294,"byte_end":2514343,"line_start":419,"line_end":419,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9522},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2515012,"byte_end":2515025,"line_start":434,"line_end":434,"column_start":15,"column_end":28},"name":"_mm_cmpnge_ss","qualname":"::core_arch::x86::sse::_mm_cmpnge_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lowest `f32` of both inputs for not-greater-than-or-equal. The\n lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is not\n greater than or equal to `b.extract(0)`, or `0` otherwise. The upper 96\n bits of the result are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2514862,"byte_end":2514871,"line_start":430,"line_end":430,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2514872,"byte_end":2514905,"line_start":431,"line_end":431,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2514948,"byte_end":2514997,"line_start":433,"line_end":433,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9524},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2515640,"byte_end":2515653,"line_start":448,"line_end":448,"column_start":15,"column_end":28},"name":"_mm_cmpord_ss","qualname":"::core_arch::x86::sse::_mm_cmpord_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Checks if the lowest `f32` of both inputs are ordered. The lowest 32 bits of\n the result will be `0xffffffff` if neither of `a.extract(0)` or\n `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result\n are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2515490,"byte_end":2515499,"line_start":444,"line_end":444,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2515500,"byte_end":2515533,"line_start":445,"line_end":445,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2515576,"byte_end":2515625,"line_start":447,"line_end":447,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9526},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2516238,"byte_end":2516253,"line_start":462,"line_end":462,"column_start":15,"column_end":30},"name":"_mm_cmpunord_ss","qualname":"::core_arch::x86::sse::_mm_cmpunord_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Checks if the lowest `f32` of both inputs are unordered. The lowest 32 bits\n of the result will be `0xffffffff` if any of `a.extract(0)` or\n `b.extract(0)` is a NaN, or `0` otherwise. The upper 96 bits of the result\n are the upper 96 bits of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2516086,"byte_end":2516095,"line_start":458,"line_end":458,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2516096,"byte_end":2516129,"line_start":459,"line_end":459,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2516174,"byte_end":2516223,"line_start":461,"line_end":461,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9528},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2516766,"byte_end":2516778,"line_start":475,"line_end":475,"column_start":15,"column_end":27},"name":"_mm_cmpeq_ps","qualname":"::core_arch::x86::sse::_mm_cmpeq_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input elements\n were equal, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2516617,"byte_end":2516626,"line_start":471,"line_end":471,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2516627,"byte_end":2516660,"line_start":472,"line_end":472,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2516702,"byte_end":2516751,"line_start":474,"line_end":474,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9530},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2517332,"byte_end":2517344,"line_start":488,"line_end":488,"column_start":15,"column_end":27},"name":"_mm_cmplt_ps","qualname":"::core_arch::x86::sse::_mm_cmplt_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is less than the corresponding element in `b`, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2517183,"byte_end":2517192,"line_start":484,"line_end":484,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2517193,"byte_end":2517226,"line_start":485,"line_end":485,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2517268,"byte_end":2517317,"line_start":487,"line_end":487,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9532},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2517914,"byte_end":2517926,"line_start":502,"line_end":502,"column_start":15,"column_end":27},"name":"_mm_cmple_ps","qualname":"::core_arch::x86::sse::_mm_cmple_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is less than or equal to the corresponding element in `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2517765,"byte_end":2517774,"line_start":498,"line_end":498,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2517775,"byte_end":2517808,"line_start":499,"line_end":499,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2517850,"byte_end":2517899,"line_start":501,"line_end":501,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9534},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2518483,"byte_end":2518495,"line_start":515,"line_end":515,"column_start":15,"column_end":27},"name":"_mm_cmpgt_ps","qualname":"::core_arch::x86::sse::_mm_cmpgt_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is greater than the corresponding element in `b`, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2518334,"byte_end":2518343,"line_start":511,"line_end":511,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2518344,"byte_end":2518377,"line_start":512,"line_end":512,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2518419,"byte_end":2518468,"line_start":514,"line_end":514,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9536},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2519068,"byte_end":2519080,"line_start":529,"line_end":529,"column_start":15,"column_end":27},"name":"_mm_cmpge_ps","qualname":"::core_arch::x86::sse::_mm_cmpge_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is greater than or equal to the corresponding element in `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2518919,"byte_end":2518928,"line_start":525,"line_end":525,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2518929,"byte_end":2518962,"line_start":526,"line_end":526,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2519004,"byte_end":2519053,"line_start":528,"line_end":528,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9538},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2519602,"byte_end":2519615,"line_start":542,"line_end":542,"column_start":15,"column_end":28},"name":"_mm_cmpneq_ps","qualname":"::core_arch::x86::sse::_mm_cmpneq_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input elements\n are **not** equal, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2519452,"byte_end":2519461,"line_start":538,"line_end":538,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2519462,"byte_end":2519495,"line_start":539,"line_end":539,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2519538,"byte_end":2519587,"line_start":541,"line_end":541,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9540},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2520183,"byte_end":2520196,"line_start":556,"line_end":556,"column_start":15,"column_end":28},"name":"_mm_cmpnlt_ps","qualname":"::core_arch::x86::sse::_mm_cmpnlt_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is **not** less than the corresponding element in `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2520033,"byte_end":2520042,"line_start":552,"line_end":552,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2520043,"byte_end":2520076,"line_start":553,"line_end":553,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2520119,"byte_end":2520168,"line_start":555,"line_end":555,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9542},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2520776,"byte_end":2520789,"line_start":570,"line_end":570,"column_start":15,"column_end":28},"name":"_mm_cmpnle_ps","qualname":"::core_arch::x86::sse::_mm_cmpnle_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is **not** less than or equal to the corresponding element in `b`, or\n `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2520626,"byte_end":2520635,"line_start":566,"line_end":566,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2520636,"byte_end":2520669,"line_start":567,"line_end":567,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2520712,"byte_end":2520761,"line_start":569,"line_end":569,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9544},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2521360,"byte_end":2521373,"line_start":584,"line_end":584,"column_start":15,"column_end":28},"name":"_mm_cmpngt_ps","qualname":"::core_arch::x86::sse::_mm_cmpngt_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is **not** greater than the corresponding element in `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2521210,"byte_end":2521219,"line_start":580,"line_end":580,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2521220,"byte_end":2521253,"line_start":581,"line_end":581,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2521296,"byte_end":2521345,"line_start":583,"line_end":583,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9546},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2521956,"byte_end":2521969,"line_start":598,"line_end":598,"column_start":15,"column_end":28},"name":"_mm_cmpnge_ps","qualname":"::core_arch::x86::sse::_mm_cmpnge_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n The result in the output vector will be `0xffffffff` if the input element\n in `a` is **not** greater than or equal to the corresponding element in `b`,\n or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2521806,"byte_end":2521815,"line_start":594,"line_end":594,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2521816,"byte_end":2521849,"line_start":595,"line_end":595,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2521892,"byte_end":2521941,"line_start":597,"line_end":597,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9548},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2522600,"byte_end":2522613,"line_start":612,"line_end":612,"column_start":15,"column_end":28},"name":"_mm_cmpord_ps","qualname":"::core_arch::x86::sse::_mm_cmpord_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n Returns four floats that have one of two possible bit patterns. The element\n in the output vector will be `0xffffffff` if the input elements in `a` and\n `b` are ordered (i.e., neither of them is a NaN), or 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2522450,"byte_end":2522459,"line_start":608,"line_end":608,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2522460,"byte_end":2522493,"line_start":609,"line_end":609,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2522536,"byte_end":2522585,"line_start":611,"line_end":611,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9550},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2523254,"byte_end":2523269,"line_start":626,"line_end":626,"column_start":15,"column_end":30},"name":"_mm_cmpunord_ps","qualname":"::core_arch::x86::sse::_mm_cmpunord_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares each of the four floats in `a` to the corresponding element in `b`.\n Returns four floats that have one of two possible bit patterns. The element\n in the output vector will be `0xffffffff` if the input elements in `a` and\n `b` are unordered (i.e., at least on of them is a NaN), or 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2523102,"byte_end":2523111,"line_start":622,"line_end":622,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2523112,"byte_end":2523145,"line_start":623,"line_end":623,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2523190,"byte_end":2523239,"line_start":625,"line_end":625,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9552},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2523712,"byte_end":2523725,"line_start":638,"line_end":638,"column_start":15,"column_end":28},"name":"_mm_comieq_ss","qualname":"::core_arch::x86::sse::_mm_comieq_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if they are equal, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2523564,"byte_end":2523573,"line_start":634,"line_end":634,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2523574,"byte_end":2523607,"line_start":635,"line_end":635,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2523648,"byte_end":2523697,"line_start":637,"line_end":637,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9554},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2524200,"byte_end":2524213,"line_start":650,"line_end":650,"column_start":15,"column_end":28},"name":"_mm_comilt_ss","qualname":"::core_arch::x86::sse::_mm_comilt_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is less than the one from `b`, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2524052,"byte_end":2524061,"line_start":646,"line_end":646,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2524062,"byte_end":2524095,"line_start":647,"line_end":647,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2524136,"byte_end":2524185,"line_start":649,"line_end":649,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9556},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2524704,"byte_end":2524717,"line_start":663,"line_end":663,"column_start":15,"column_end":28},"name":"_mm_comile_ss","qualname":"::core_arch::x86::sse::_mm_comile_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is less than or equal to the one from `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2524556,"byte_end":2524565,"line_start":659,"line_end":659,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2524566,"byte_end":2524599,"line_start":660,"line_end":660,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2524640,"byte_end":2524689,"line_start":662,"line_end":662,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9558},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2525199,"byte_end":2525212,"line_start":676,"line_end":676,"column_start":15,"column_end":28},"name":"_mm_comigt_ss","qualname":"::core_arch::x86::sse::_mm_comigt_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is greater than the one from `b`, or `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2525051,"byte_end":2525060,"line_start":672,"line_end":672,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2525061,"byte_end":2525094,"line_start":673,"line_end":673,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2525135,"byte_end":2525184,"line_start":675,"line_end":675,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9560},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2525706,"byte_end":2525719,"line_start":689,"line_end":689,"column_start":15,"column_end":28},"name":"_mm_comige_ss","qualname":"::core_arch::x86::sse::_mm_comige_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is greater than or equal to the one from `b`, or\n `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2525558,"byte_end":2525567,"line_start":685,"line_end":685,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2525568,"byte_end":2525601,"line_start":686,"line_end":686,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2525642,"byte_end":2525691,"line_start":688,"line_end":688,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9562},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2526169,"byte_end":2526183,"line_start":701,"line_end":701,"column_start":15,"column_end":29},"name":"_mm_comineq_ss","qualname":"::core_arch::x86::sse::_mm_comineq_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if they are **not** equal, or `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2526021,"byte_end":2526030,"line_start":697,"line_end":697,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2526031,"byte_end":2526064,"line_start":698,"line_end":698,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2526105,"byte_end":2526154,"line_start":700,"line_end":700,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9564},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2526712,"byte_end":2526726,"line_start":714,"line_end":714,"column_start":15,"column_end":29},"name":"_mm_ucomieq_ss","qualname":"::core_arch::x86::sse::_mm_ucomieq_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if they are equal, or `0` otherwise. This instruction will not signal\n an exception if either argument is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2526563,"byte_end":2526572,"line_start":710,"line_end":710,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2526573,"byte_end":2526606,"line_start":711,"line_end":711,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2526648,"byte_end":2526697,"line_start":713,"line_end":713,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9566},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2527293,"byte_end":2527307,"line_start":728,"line_end":728,"column_start":15,"column_end":29},"name":"_mm_ucomilt_ss","qualname":"::core_arch::x86::sse::_mm_ucomilt_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is less than the one from `b`, or `0` otherwise.\n This instruction will not signal an exception if either argument is a quiet\n NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2527144,"byte_end":2527153,"line_start":724,"line_end":724,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2527154,"byte_end":2527187,"line_start":725,"line_end":725,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2527229,"byte_end":2527278,"line_start":727,"line_end":727,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9568},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2527886,"byte_end":2527900,"line_start":742,"line_end":742,"column_start":15,"column_end":29},"name":"_mm_ucomile_ss","qualname":"::core_arch::x86::sse::_mm_ucomile_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is less than or equal to the one from `b`, or `0`\n otherwise. This instruction will not signal an exception if either argument\n is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2527737,"byte_end":2527746,"line_start":738,"line_end":738,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2527747,"byte_end":2527780,"line_start":739,"line_end":739,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2527822,"byte_end":2527871,"line_start":741,"line_end":741,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9570},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2528470,"byte_end":2528484,"line_start":756,"line_end":756,"column_start":15,"column_end":29},"name":"_mm_ucomigt_ss","qualname":"::core_arch::x86::sse::_mm_ucomigt_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is greater than the one from `b`, or `0`\n otherwise. This instruction will not signal an exception if either argument\n is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2528321,"byte_end":2528330,"line_start":752,"line_end":752,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2528331,"byte_end":2528364,"line_start":753,"line_end":753,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2528406,"byte_end":2528455,"line_start":755,"line_end":755,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9572},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2529066,"byte_end":2529080,"line_start":770,"line_end":770,"column_start":15,"column_end":29},"name":"_mm_ucomige_ss","qualname":"::core_arch::x86::sse::_mm_ucomige_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if the value from `a` is greater than or equal to the one from `b`, or\n `0` otherwise. This instruction will not signal an exception if either\n argument is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2528917,"byte_end":2528926,"line_start":766,"line_end":766,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2528927,"byte_end":2528960,"line_start":767,"line_end":767,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2529002,"byte_end":2529051,"line_start":769,"line_end":769,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9574},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2529618,"byte_end":2529633,"line_start":783,"line_end":783,"column_start":15,"column_end":30},"name":"_mm_ucomineq_ss","qualname":"::core_arch::x86::sse::_mm_ucomineq_ss","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares two 32-bit floats from the low-order bits of `a` and `b`. Returns\n `1` if they are **not** equal, or `0` otherwise. This instruction will not\n signal an exception if either argument is a quiet NaN.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2529469,"byte_end":2529478,"line_start":779,"line_end":779,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2529479,"byte_end":2529512,"line_start":780,"line_end":780,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2529554,"byte_end":2529603,"line_start":782,"line_end":782,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9576},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2530402,"byte_end":2530416,"line_start":801,"line_end":801,"column_start":15,"column_end":29},"name":"_mm_cvtss_si32","qualname":"::core_arch::x86::sse::_mm_cvtss_si32","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Converts the lowest 32 bit float in the input vector to a 32 bit integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2530252,"byte_end":2530261,"line_start":797,"line_end":797,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2530262,"byte_end":2530295,"line_start":798,"line_end":798,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2530338,"byte_end":2530387,"line_start":800,"line_end":800,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9578},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2530778,"byte_end":2530791,"line_start":812,"line_end":812,"column_start":15,"column_end":28},"name":"_mm_cvt_ss2si","qualname":"::core_arch::x86::sse::_mm_cvt_ss2si","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_cvtss_si32`](fn._mm_cvtss_si32.html).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2530628,"byte_end":2530637,"line_start":808,"line_end":808,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2530638,"byte_end":2530671,"line_start":809,"line_end":809,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2530714,"byte_end":2530763,"line_start":811,"line_end":811,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9580},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2531582,"byte_end":2531597,"line_start":832,"line_end":832,"column_start":15,"column_end":30},"name":"_mm_cvttss_si32","qualname":"::core_arch::x86::sse::_mm_cvttss_si32","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Converts the lowest 32 bit float in the input vector to a 32 bit integer\n with\n truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2531431,"byte_end":2531440,"line_start":828,"line_end":828,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2531441,"byte_end":2531474,"line_start":829,"line_end":829,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2531518,"byte_end":2531567,"line_start":831,"line_end":831,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9582},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2531964,"byte_end":2531978,"line_start":843,"line_end":843,"column_start":15,"column_end":29},"name":"_mm_cvtt_ss2si","qualname":"::core_arch::x86::sse::_mm_cvtt_ss2si","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_cvttss_si32`](fn._mm_cvttss_si32.html).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2531813,"byte_end":2531822,"line_start":839,"line_end":839,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2531823,"byte_end":2531856,"line_start":840,"line_end":840,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2531900,"byte_end":2531949,"line_start":842,"line_end":842,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9584},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2532431,"byte_end":2532444,"line_start":855,"line_end":855,"column_start":15,"column_end":28},"name":"_mm_cvtss_f32","qualname":"::core_arch::x86::sse::_mm_cvtss_f32","value":"fn (a: __m128) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Extracts the lowest 32 bit float from the input vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2532199,"byte_end":2532208,"line_start":850,"line_end":850,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2532209,"byte_end":2532242,"line_start":851,"line_end":851,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2532367,"byte_end":2532416,"line_start":854,"line_end":854,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9586},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533005,"byte_end":2533019,"line_start":870,"line_end":870,"column_start":15,"column_end":29},"name":"_mm_cvtsi32_ss","qualname":"::core_arch::x86::sse::_mm_cvtsi32_ss","value":"fn (a: __m128, b: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts a 32 bit integer to a 32 bit float. The result vector is the input\n vector `a` with the lowest 32 bit float replaced by the converted integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2532855,"byte_end":2532864,"line_start":866,"line_end":866,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2532865,"byte_end":2532898,"line_start":867,"line_end":867,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2532941,"byte_end":2532990,"line_start":869,"line_end":869,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9588},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533395,"byte_end":2533408,"line_start":881,"line_end":881,"column_start":15,"column_end":28},"name":"_mm_cvt_si2ss","qualname":"::core_arch::x86::sse::_mm_cvt_si2ss","value":"fn (a: __m128, b: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_cvtsi32_ss`](fn._mm_cvtsi32_ss.html).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533245,"byte_end":2533254,"line_start":877,"line_end":877,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533255,"byte_end":2533288,"line_start":878,"line_end":878,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533331,"byte_end":2533380,"line_start":880,"line_end":880,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9590},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533816,"byte_end":2533826,"line_start":893,"line_end":893,"column_start":15,"column_end":25},"name":"_mm_set_ss","qualname":"::core_arch::x86::sse::_mm_set_ss","value":"fn (a: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` with the lowest element set to `a` and the rest set to\n zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533669,"byte_end":2533678,"line_start":889,"line_end":889,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533679,"byte_end":2533712,"line_start":890,"line_end":890,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2533752,"byte_end":2533801,"line_start":892,"line_end":892,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9592},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2534193,"byte_end":2534204,"line_start":904,"line_end":904,"column_start":15,"column_end":26},"name":"_mm_set1_ps","qualname":"::core_arch::x86::sse::_mm_set1_ps","value":"fn (a: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` with all element set to `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2534045,"byte_end":2534054,"line_start":900,"line_end":900,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2534055,"byte_end":2534088,"line_start":901,"line_end":901,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2534129,"byte_end":2534178,"line_start":903,"line_end":903,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9594},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2534562,"byte_end":2534573,"line_start":915,"line_end":915,"column_start":15,"column_end":26},"name":"_mm_set_ps1","qualname":"::core_arch::x86::sse::_mm_set_ps1","value":"fn (a: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_set1_ps`](fn._mm_set1_ps.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2534414,"byte_end":2534423,"line_start":911,"line_end":911,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2534424,"byte_end":2534457,"line_start":912,"line_end":912,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2534498,"byte_end":2534547,"line_start":914,"line_end":914,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9596},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2535430,"byte_end":2535440,"line_start":942,"line_end":942,"column_start":15,"column_end":25},"name":"_mm_set_ps","qualname":"::core_arch::x86::sse::_mm_set_ps","value":"fn (a: f32, b: f32, c: f32, d: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` from four floating point values highest to lowest.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2535280,"byte_end":2535289,"line_start":938,"line_end":938,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2535290,"byte_end":2535323,"line_start":939,"line_end":939,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2535366,"byte_end":2535415,"line_start":941,"line_end":941,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9598},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536234,"byte_end":2536245,"line_start":962,"line_end":962,"column_start":15,"column_end":26},"name":"_mm_setr_ps","qualname":"::core_arch::x86::sse::_mm_setr_ps","value":"fn (a: f32, b: f32, c: f32, d: f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` from four floating point values lowest to highest.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2535917,"byte_end":2535926,"line_start":956,"line_end":956,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2535927,"byte_end":2535960,"line_start":957,"line_end":957,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536170,"byte_end":2536219,"line_start":961,"line_end":961,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9600},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536642,"byte_end":2536656,"line_start":973,"line_end":973,"column_start":15,"column_end":29},"name":"_mm_setzero_ps","qualname":"::core_arch::x86::sse::_mm_setzero_ps","value":"fn () -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` with all elements initialized to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536495,"byte_end":2536504,"line_start":969,"line_end":969,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536505,"byte_end":2536538,"line_start":970,"line_end":970,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536578,"byte_end":2536627,"line_start":972,"line_end":972,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9602},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536899,"byte_end":2536910,"line_start":982,"line_end":982,"column_start":14,"column_end":25},"name":"_MM_SHUFFLE","qualname":"::core_arch::x86::sse::_MM_SHUFFLE","value":"fn (z: u32, y: u32, x: u32, w: u32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" A utility function for creating masks to use with Intel shuffle and\n permute intrinsics.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536801,"byte_end":2536810,"line_start":979,"line_end":979,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536811,"byte_end":2536835,"line_start":980,"line_end":980,"column_start":1,"column_end":25}},{"value":"unstable(feature = \"stdsimd\", issue = \"27731\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2536836,"byte_end":2536885,"line_start":981,"line_end":981,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9604},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2537571,"byte_end":2537585,"line_start":998,"line_end":998,"column_start":15,"column_end":29},"name":"_mm_shuffle_ps","qualname":"::core_arch::x86::sse::_mm_shuffle_ps","value":"fn (a: __m128, b: __m128, mask: u32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Shuffles packed single-precision (32-bit) floating-point elements in `a` and\n `b` using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2537381,"byte_end":2537390,"line_start":993,"line_end":993,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2537391,"byte_end":2537424,"line_start":994,"line_end":994,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2537475,"byte_end":2537506,"line_start":996,"line_end":996,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2537507,"byte_end":2537556,"line_start":997,"line_end":997,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9614},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2539421,"byte_end":2539436,"line_start":1052,"line_end":1052,"column_start":15,"column_end":30},"name":"_mm_unpackhi_ps","qualname":"::core_arch::x86::sse::_mm_unpackhi_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave single-precision (32-bit) floating-point elements\n from the higher half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2539271,"byte_end":2539280,"line_start":1048,"line_end":1048,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2539281,"byte_end":2539314,"line_start":1049,"line_end":1049,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2539357,"byte_end":2539406,"line_start":1051,"line_end":1051,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9616},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2539895,"byte_end":2539910,"line_start":1064,"line_end":1064,"column_start":15,"column_end":30},"name":"_mm_unpacklo_ps","qualname":"::core_arch::x86::sse::_mm_unpacklo_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave single-precision (32-bit) floating-point elements\n from the lower half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2539745,"byte_end":2539754,"line_start":1060,"line_end":1060,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2539755,"byte_end":2539788,"line_start":1061,"line_end":1061,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2539831,"byte_end":2539880,"line_start":1063,"line_end":1063,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9618},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2540384,"byte_end":2540397,"line_start":1076,"line_end":1076,"column_start":15,"column_end":28},"name":"_mm_movehl_ps","qualname":"::core_arch::x86::sse::_mm_movehl_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Combine higher half of `a` and `b`. The highwe half of `b` occupies the\n lower half of result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2540202,"byte_end":2540211,"line_start":1072,"line_end":1072,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2540212,"byte_end":2540245,"line_start":1073,"line_end":1073,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2540320,"byte_end":2540369,"line_start":1075,"line_end":1075,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9620},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2540938,"byte_end":2540951,"line_start":1089,"line_end":1089,"column_start":15,"column_end":28},"name":"_mm_movelh_ps","qualname":"::core_arch::x86::sse::_mm_movelh_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Combine lower half of `a` and `b`. The lower half of `b` occupies the\n higher half of result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2540756,"byte_end":2540765,"line_start":1085,"line_end":1085,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2540766,"byte_end":2540799,"line_start":1086,"line_end":1086,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2540874,"byte_end":2540923,"line_start":1088,"line_end":1088,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9622},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2541479,"byte_end":2541494,"line_start":1103,"line_end":1103,"column_start":15,"column_end":30},"name":"_mm_movemask_ps","qualname":"::core_arch::x86::sse::_mm_movemask_ps","value":"fn (a: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns a mask of the most significant bit of each element in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2541329,"byte_end":2541338,"line_start":1099,"line_end":1099,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2541339,"byte_end":2541372,"line_start":1100,"line_end":1100,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2541415,"byte_end":2541464,"line_start":1102,"line_end":1102,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9624},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2542291,"byte_end":2542303,"line_start":1129,"line_end":1129,"column_start":15,"column_end":27},"name":"_mm_loadh_pi","qualname":"::core_arch::x86::sse::_mm_loadh_pi","value":"fn (a: __m128, p: *const __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Sets the upper two single-precision floating-point values with 64 bits of\n data loaded from the address `p`; the lower two values are passed through\n from `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2541704,"byte_end":2541713,"line_start":1110,"line_end":1110,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2541714,"byte_end":2541747,"line_start":1111,"line_end":1111,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9626},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543018,"byte_end":2543030,"line_start":1150,"line_end":1150,"column_start":15,"column_end":27},"name":"_mm_loadl_pi","qualname":"::core_arch::x86::sse::_mm_loadl_pi","value":"fn (a: __m128, p: *const __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads two floats from `p` into the lower half of a `__m128`. The upper half\n is copied from the upper half of `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2542610,"byte_end":2542619,"line_start":1138,"line_end":1138,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2542620,"byte_end":2542653,"line_start":1139,"line_end":1139,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9628},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543638,"byte_end":2543649,"line_start":1167,"line_end":1167,"column_start":15,"column_end":26},"name":"_mm_load_ss","qualname":"::core_arch::x86::sse::_mm_load_ss","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` with the lowest element read from `p` and the other\n elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543491,"byte_end":2543500,"line_start":1163,"line_end":1163,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543501,"byte_end":2543534,"line_start":1164,"line_end":1164,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2543574,"byte_end":2543623,"line_start":1166,"line_end":1166,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9630},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544149,"byte_end":2544161,"line_start":1182,"line_end":1182,"column_start":15,"column_end":27},"name":"_mm_load1_ps","qualname":"::core_arch::x86::sse::_mm_load1_ps","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Construct a `__m128` by duplicating the value read from `p` into all\n elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544002,"byte_end":2544011,"line_start":1178,"line_end":1178,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544012,"byte_end":2544045,"line_start":1179,"line_end":1179,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544085,"byte_end":2544134,"line_start":1181,"line_end":1181,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9632},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544544,"byte_end":2544556,"line_start":1194,"line_end":1194,"column_start":15,"column_end":27},"name":"_mm_load_ps1","qualname":"::core_arch::x86::sse::_mm_load_ps1","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_load1_ps`](fn._mm_load1_ps.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544397,"byte_end":2544406,"line_start":1190,"line_end":1190,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544407,"byte_end":2544440,"line_start":1191,"line_end":1191,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2544480,"byte_end":2544529,"line_start":1193,"line_end":1193,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9634},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545262,"byte_end":2545273,"line_start":1213,"line_end":1213,"column_start":15,"column_end":26},"name":"_mm_load_ps","qualname":"::core_arch::x86::sse::_mm_load_ps","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads four `f32` values from *aligned* memory into a `__m128`. If the\n pointer is not aligned to a 128-bit boundary (16 bytes) a general\n protection fault will be triggered (fatal program crash).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545077,"byte_end":2545086,"line_start":1208,"line_end":1208,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545087,"byte_end":2545120,"line_start":1209,"line_end":1209,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545161,"byte_end":2545210,"line_start":1211,"line_end":1211,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545211,"byte_end":2545247,"line_start":1212,"line_end":1212,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":9636},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545845,"byte_end":2545857,"line_start":1230,"line_end":1230,"column_start":15,"column_end":27},"name":"_mm_loadu_ps","qualname":"::core_arch::x86::sse::_mm_loadu_ps","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads four `f32` values from memory into a `__m128`. There are no\n restrictions\n on memory alignment. For aligned memory\n [`_mm_load_ps`](fn._mm_load_ps.html)\n may be faster.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545697,"byte_end":2545706,"line_start":1226,"line_end":1226,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545707,"byte_end":2545740,"line_start":1227,"line_end":1227,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2545781,"byte_end":2545830,"line_start":1229,"line_end":1229,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9638},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547037,"byte_end":2547049,"line_start":1267,"line_end":1267,"column_start":15,"column_end":27},"name":"_mm_loadr_ps","qualname":"::core_arch::x86::sse::_mm_loadr_ps","value":"fn (p: *const f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads four `f32` values from aligned memory into a `__m128` in reverse\n order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546889,"byte_end":2546898,"line_start":1263,"line_end":1263,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546899,"byte_end":2546932,"line_start":1264,"line_end":1264,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2546973,"byte_end":2547022,"line_start":1266,"line_end":1266,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9640},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547777,"byte_end":2547790,"line_start":1287,"line_end":1287,"column_start":15,"column_end":28},"name":"_mm_storeh_pi","qualname":"::core_arch::x86::sse::_mm_storeh_pi","value":"fn (p: *mut __m64, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the upper half of `a` (64 bits) into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547352,"byte_end":2547361,"line_start":1276,"line_end":1276,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2547362,"byte_end":2547395,"line_start":1277,"line_end":1277,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9642},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548870,"byte_end":2548883,"line_start":1321,"line_end":1321,"column_start":15,"column_end":28},"name":"_mm_storel_pi","qualname":"::core_arch::x86::sse::_mm_storel_pi","value":"fn (p: *mut __m64, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower half of `a` (64 bits) into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548569,"byte_end":2548578,"line_start":1310,"line_end":1310,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2548579,"byte_end":2548612,"line_start":1311,"line_end":1311,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":9644},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549705,"byte_end":2549717,"line_start":1347,"line_end":1347,"column_start":15,"column_end":27},"name":"_mm_store_ss","qualname":"::core_arch::x86::sse::_mm_store_ss","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lowest 32 bit float of `a` into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549558,"byte_end":2549567,"line_start":1343,"line_end":1343,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549568,"byte_end":2549601,"line_start":1344,"line_end":1344,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2549641,"byte_end":2549690,"line_start":1346,"line_end":1346,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9646},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550555,"byte_end":2550568,"line_start":1374,"line_end":1374,"column_start":15,"column_end":28},"name":"_mm_store1_ps","qualname":"::core_arch::x86::sse::_mm_store1_ps","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lowest 32 bit float of `a` repeated four times into *aligned*\n memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550370,"byte_end":2550379,"line_start":1369,"line_end":1369,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550380,"byte_end":2550413,"line_start":1370,"line_end":1370,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550454,"byte_end":2550503,"line_start":1372,"line_end":1372,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550504,"byte_end":2550540,"line_start":1373,"line_end":1373,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":9648},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550999,"byte_end":2551012,"line_start":1386,"line_end":1386,"column_start":15,"column_end":28},"name":"_mm_store_ps1","qualname":"::core_arch::x86::sse::_mm_store_ps1","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Alias for [`_mm_store1_ps`](fn._mm_store1_ps.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550851,"byte_end":2550860,"line_start":1382,"line_end":1382,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550861,"byte_end":2550894,"line_start":1383,"line_end":1383,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2550935,"byte_end":2550984,"line_start":1385,"line_end":1385,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9650},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551715,"byte_end":2551727,"line_start":1406,"line_end":1406,"column_start":15,"column_end":27},"name":"_mm_store_ps","qualname":"::core_arch::x86::sse::_mm_store_ps","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores four 32-bit floats into *aligned* memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551530,"byte_end":2551539,"line_start":1401,"line_end":1401,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551540,"byte_end":2551573,"line_start":1402,"line_end":1402,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551614,"byte_end":2551663,"line_start":1404,"line_end":1404,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2551664,"byte_end":2551700,"line_start":1405,"line_end":1405,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":9652},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552282,"byte_end":2552295,"line_start":1421,"line_end":1421,"column_start":15,"column_end":28},"name":"_mm_storeu_ps","qualname":"::core_arch::x86::sse::_mm_storeu_ps","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores four 32-bit floats into memory. There are no restrictions on memory\n alignment. For aligned memory [`_mm_store_ps`](fn._mm_store_ps.html) may be\n faster.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552134,"byte_end":2552143,"line_start":1417,"line_end":1417,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552144,"byte_end":2552177,"line_start":1418,"line_end":1418,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2552218,"byte_end":2552267,"line_start":1420,"line_end":1420,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9654},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553238,"byte_end":2553251,"line_start":1450,"line_end":1450,"column_start":15,"column_end":28},"name":"_mm_storer_ps","qualname":"::core_arch::x86::sse::_mm_storer_ps","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores four 32-bit floats into *aligned* memory in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553053,"byte_end":2553062,"line_start":1445,"line_end":1445,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553063,"byte_end":2553096,"line_start":1446,"line_end":1446,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553137,"byte_end":2553186,"line_start":1448,"line_end":1448,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553187,"byte_end":2553223,"line_start":1449,"line_end":1449,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":9656},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553840,"byte_end":2553851,"line_start":1468,"line_end":1468,"column_start":15,"column_end":26},"name":"_mm_move_ss","qualname":"::core_arch::x86::sse::_mm_move_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns a `__m128` with the first component from `b` and the remaining\n components from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553693,"byte_end":2553702,"line_start":1464,"line_end":1464,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553703,"byte_end":2553736,"line_start":1465,"line_end":1465,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2553776,"byte_end":2553825,"line_start":1467,"line_end":1467,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9658},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554487,"byte_end":2554497,"line_start":1484,"line_end":1484,"column_start":15,"column_end":25},"name":"_mm_sfence","qualname":"::core_arch::x86::sse::_mm_sfence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a serializing operation on all store-to-memory instructions that\n were issued prior to this instruction.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554339,"byte_end":2554348,"line_start":1480,"line_end":1480,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554349,"byte_end":2554382,"line_start":1481,"line_end":1481,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554423,"byte_end":2554472,"line_start":1483,"line_end":1483,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9660},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554916,"byte_end":2554926,"line_start":1497,"line_end":1497,"column_start":15,"column_end":25},"name":"_mm_getcsr","qualname":"::core_arch::x86::sse::_mm_getcsr","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" Gets the unsigned 32-bit value of the MXCSR control and status register.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554767,"byte_end":2554776,"line_start":1493,"line_end":1493,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554777,"byte_end":2554810,"line_start":1494,"line_end":1494,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2554852,"byte_end":2554901,"line_start":1496,"line_end":1496,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9662},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559946,"byte_end":2559956,"line_start":1634,"line_end":1634,"column_start":15,"column_end":25},"name":"_mm_setcsr","qualname":"::core_arch::x86::sse::_mm_setcsr","value":"fn (val: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Sets the MXCSR register with the 32-bit unsigned integer value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559797,"byte_end":2559806,"line_start":1630,"line_end":1630,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559807,"byte_end":2559840,"line_start":1631,"line_end":1631,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2559882,"byte_end":2559931,"line_start":1633,"line_end":1633,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9664},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560119,"byte_end":2560137,"line_start":1640,"line_end":1640,"column_start":11,"column_end":29},"name":"_MM_EXCEPT_INVALID","qualname":"::core_arch::x86::sse::_MM_EXCEPT_INVALID","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560059,"byte_end":2560108,"line_start":1639,"line_end":1639,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9666},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560256,"byte_end":2560273,"line_start":1643,"line_end":1643,"column_start":11,"column_end":28},"name":"_MM_EXCEPT_DENORM","qualname":"::core_arch::x86::sse::_MM_EXCEPT_DENORM","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560196,"byte_end":2560245,"line_start":1642,"line_end":1642,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9668},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560392,"byte_end":2560411,"line_start":1646,"line_end":1646,"column_start":11,"column_end":30},"name":"_MM_EXCEPT_DIV_ZERO","qualname":"::core_arch::x86::sse::_MM_EXCEPT_DIV_ZERO","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560332,"byte_end":2560381,"line_start":1645,"line_end":1645,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9670},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560530,"byte_end":2560549,"line_start":1649,"line_end":1649,"column_start":11,"column_end":30},"name":"_MM_EXCEPT_OVERFLOW","qualname":"::core_arch::x86::sse::_MM_EXCEPT_OVERFLOW","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560470,"byte_end":2560519,"line_start":1648,"line_end":1648,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9672},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560668,"byte_end":2560688,"line_start":1652,"line_end":1652,"column_start":11,"column_end":31},"name":"_MM_EXCEPT_UNDERFLOW","qualname":"::core_arch::x86::sse::_MM_EXCEPT_UNDERFLOW","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560608,"byte_end":2560657,"line_start":1651,"line_end":1651,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9674},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560807,"byte_end":2560825,"line_start":1655,"line_end":1655,"column_start":11,"column_end":29},"name":"_MM_EXCEPT_INEXACT","qualname":"::core_arch::x86::sse::_MM_EXCEPT_INEXACT","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560747,"byte_end":2560796,"line_start":1654,"line_end":1654,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9676},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560970,"byte_end":2560985,"line_start":1658,"line_end":1658,"column_start":11,"column_end":26},"name":"_MM_EXCEPT_MASK","qualname":"::core_arch::x86::sse::_MM_EXCEPT_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_MM_GET_EXCEPTION_STATE`](fn._MM_GET_EXCEPTION_STATE.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2560910,"byte_end":2560959,"line_start":1657,"line_end":1657,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9678},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561105,"byte_end":2561121,"line_start":1662,"line_end":1662,"column_start":11,"column_end":27},"name":"_MM_MASK_INVALID","qualname":"::core_arch::x86::sse::_MM_MASK_INVALID","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561045,"byte_end":2561094,"line_start":1661,"line_end":1661,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9680},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561240,"byte_end":2561255,"line_start":1665,"line_end":1665,"column_start":11,"column_end":26},"name":"_MM_MASK_DENORM","qualname":"::core_arch::x86::sse::_MM_MASK_DENORM","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561180,"byte_end":2561229,"line_start":1664,"line_end":1664,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9682},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561374,"byte_end":2561391,"line_start":1668,"line_end":1668,"column_start":11,"column_end":28},"name":"_MM_MASK_DIV_ZERO","qualname":"::core_arch::x86::sse::_MM_MASK_DIV_ZERO","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561314,"byte_end":2561363,"line_start":1667,"line_end":1667,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9684},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561510,"byte_end":2561527,"line_start":1671,"line_end":1671,"column_start":11,"column_end":28},"name":"_MM_MASK_OVERFLOW","qualname":"::core_arch::x86::sse::_MM_MASK_OVERFLOW","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561450,"byte_end":2561499,"line_start":1670,"line_end":1670,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9686},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561646,"byte_end":2561664,"line_start":1674,"line_end":1674,"column_start":11,"column_end":29},"name":"_MM_MASK_UNDERFLOW","qualname":"::core_arch::x86::sse::_MM_MASK_UNDERFLOW","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561586,"byte_end":2561635,"line_start":1673,"line_end":1673,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9688},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561783,"byte_end":2561799,"line_start":1677,"line_end":1677,"column_start":11,"column_end":27},"name":"_MM_MASK_INEXACT","qualname":"::core_arch::x86::sse::_MM_MASK_INEXACT","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561723,"byte_end":2561772,"line_start":1676,"line_end":1676,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9690},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561942,"byte_end":2561955,"line_start":1680,"line_end":1680,"column_start":11,"column_end":24},"name":"_MM_MASK_MASK","qualname":"::core_arch::x86::sse::_MM_MASK_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_MM_GET_EXCEPTION_MASK`](fn._MM_GET_EXCEPTION_MASK.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2561882,"byte_end":2561931,"line_start":1679,"line_end":1679,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9692},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562075,"byte_end":2562092,"line_start":1684,"line_end":1684,"column_start":11,"column_end":28},"name":"_MM_ROUND_NEAREST","qualname":"::core_arch::x86::sse::_MM_ROUND_NEAREST","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562015,"byte_end":2562064,"line_start":1683,"line_end":1683,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9694},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562211,"byte_end":2562225,"line_start":1687,"line_end":1687,"column_start":11,"column_end":25},"name":"_MM_ROUND_DOWN","qualname":"::core_arch::x86::sse::_MM_ROUND_DOWN","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562151,"byte_end":2562200,"line_start":1686,"line_end":1686,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9696},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562344,"byte_end":2562356,"line_start":1690,"line_end":1690,"column_start":11,"column_end":23},"name":"_MM_ROUND_UP","qualname":"::core_arch::x86::sse::_MM_ROUND_UP","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562284,"byte_end":2562333,"line_start":1689,"line_end":1689,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9698},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562475,"byte_end":2562496,"line_start":1693,"line_end":1693,"column_start":11,"column_end":32},"name":"_MM_ROUND_TOWARD_ZERO","qualname":"::core_arch::x86::sse::_MM_ROUND_TOWARD_ZERO","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562415,"byte_end":2562464,"line_start":1692,"line_end":1692,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9700},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562638,"byte_end":2562652,"line_start":1697,"line_end":1697,"column_start":11,"column_end":25},"name":"_MM_ROUND_MASK","qualname":"::core_arch::x86::sse::_MM_ROUND_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_MM_GET_ROUNDING_MODE`](fn._MM_GET_ROUNDING_MODE.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562578,"byte_end":2562627,"line_start":1696,"line_end":1696,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9702},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562798,"byte_end":2562817,"line_start":1701,"line_end":1701,"column_start":11,"column_end":30},"name":"_MM_FLUSH_ZERO_MASK","qualname":"::core_arch::x86::sse::_MM_FLUSH_ZERO_MASK","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_MM_GET_FLUSH_ZERO_MODE`](fn._MM_GET_FLUSH_ZERO_MODE.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562738,"byte_end":2562787,"line_start":1700,"line_end":1700,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9704},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562936,"byte_end":2562953,"line_start":1704,"line_end":1704,"column_start":11,"column_end":28},"name":"_MM_FLUSH_ZERO_ON","qualname":"::core_arch::x86::sse::_MM_FLUSH_ZERO_ON","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2562876,"byte_end":2562925,"line_start":1703,"line_end":1703,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9706},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563072,"byte_end":2563090,"line_start":1707,"line_end":1707,"column_start":11,"column_end":29},"name":"_MM_FLUSH_ZERO_OFF","qualname":"::core_arch::x86::sse::_MM_FLUSH_ZERO_OFF","value":"u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563012,"byte_end":2563061,"line_start":1706,"line_end":1706,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9708},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563406,"byte_end":2563428,"line_start":1716,"line_end":1716,"column_start":15,"column_end":37},"name":"_MM_GET_EXCEPTION_MASK","qualname":"::core_arch::x86::sse::_MM_GET_EXCEPTION_MASK","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563273,"byte_end":2563282,"line_start":1712,"line_end":1712,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563283,"byte_end":2563307,"line_start":1713,"line_end":1713,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563308,"byte_end":2563341,"line_start":1714,"line_end":1714,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563342,"byte_end":2563391,"line_start":1715,"line_end":1715,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9710},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563776,"byte_end":2563799,"line_start":1727,"line_end":1727,"column_start":15,"column_end":38},"name":"_MM_GET_EXCEPTION_STATE","qualname":"::core_arch::x86::sse::_MM_GET_EXCEPTION_STATE","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563643,"byte_end":2563652,"line_start":1723,"line_end":1723,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563653,"byte_end":2563677,"line_start":1724,"line_end":1724,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563678,"byte_end":2563711,"line_start":1725,"line_end":1725,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2563712,"byte_end":2563761,"line_start":1726,"line_end":1726,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9712},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564149,"byte_end":2564172,"line_start":1738,"line_end":1738,"column_start":15,"column_end":38},"name":"_MM_GET_FLUSH_ZERO_MODE","qualname":"::core_arch::x86::sse::_MM_GET_FLUSH_ZERO_MODE","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564016,"byte_end":2564025,"line_start":1734,"line_end":1734,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564026,"byte_end":2564050,"line_start":1735,"line_end":1735,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564051,"byte_end":2564084,"line_start":1736,"line_end":1736,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564085,"byte_end":2564134,"line_start":1737,"line_end":1737,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9714},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564524,"byte_end":2564545,"line_start":1749,"line_end":1749,"column_start":15,"column_end":36},"name":"_MM_GET_ROUNDING_MODE","qualname":"::core_arch::x86::sse::_MM_GET_ROUNDING_MODE","value":"fn () -> u32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564391,"byte_end":2564400,"line_start":1745,"line_end":1745,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564401,"byte_end":2564425,"line_start":1746,"line_end":1746,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564426,"byte_end":2564459,"line_start":1747,"line_end":1747,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564460,"byte_end":2564509,"line_start":1748,"line_end":1748,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9716},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564893,"byte_end":2564915,"line_start":1760,"line_end":1760,"column_start":15,"column_end":37},"name":"_MM_SET_EXCEPTION_MASK","qualname":"::core_arch::x86::sse::_MM_SET_EXCEPTION_MASK","value":"fn (x: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564760,"byte_end":2564769,"line_start":1756,"line_end":1756,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564770,"byte_end":2564794,"line_start":1757,"line_end":1757,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564795,"byte_end":2564828,"line_start":1758,"line_end":1758,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2564829,"byte_end":2564878,"line_start":1759,"line_end":1759,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9718},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565281,"byte_end":2565304,"line_start":1771,"line_end":1771,"column_start":15,"column_end":38},"name":"_MM_SET_EXCEPTION_STATE","qualname":"::core_arch::x86::sse::_MM_SET_EXCEPTION_STATE","value":"fn (x: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565148,"byte_end":2565157,"line_start":1767,"line_end":1767,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565158,"byte_end":2565182,"line_start":1768,"line_end":1768,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565183,"byte_end":2565216,"line_start":1769,"line_end":1769,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565217,"byte_end":2565266,"line_start":1770,"line_end":1770,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9720},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565672,"byte_end":2565695,"line_start":1782,"line_end":1782,"column_start":15,"column_end":38},"name":"_MM_SET_FLUSH_ZERO_MODE","qualname":"::core_arch::x86::sse::_MM_SET_FLUSH_ZERO_MODE","value":"fn (x: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565539,"byte_end":2565548,"line_start":1778,"line_end":1778,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565549,"byte_end":2565573,"line_start":1779,"line_end":1779,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565574,"byte_end":2565607,"line_start":1780,"line_end":1780,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565608,"byte_end":2565657,"line_start":1781,"line_end":1781,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9722},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566126,"byte_end":2566147,"line_start":1795,"line_end":1795,"column_start":15,"column_end":36},"name":"_MM_SET_ROUNDING_MODE","qualname":"::core_arch::x86::sse::_MM_SET_ROUNDING_MODE","value":"fn (x: u32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_setcsr`](fn._mm_setcsr.html)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2565993,"byte_end":2566002,"line_start":1791,"line_end":1791,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566003,"byte_end":2566027,"line_start":1792,"line_end":1792,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566028,"byte_end":2566061,"line_start":1793,"line_end":1793,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566062,"byte_end":2566111,"line_start":1794,"line_end":1794,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9724},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566322,"byte_end":2566333,"line_start":1801,"line_end":1801,"column_start":11,"column_end":22},"name":"_MM_HINT_T0","qualname":"::core_arch::x86::sse::_MM_HINT_T0","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_prefetch`](fn._mm_prefetch.html).\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566262,"byte_end":2566311,"line_start":1800,"line_end":1800,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9726},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566453,"byte_end":2566464,"line_start":1805,"line_end":1805,"column_start":11,"column_end":22},"name":"_MM_HINT_T1","qualname":"::core_arch::x86::sse::_MM_HINT_T1","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_prefetch`](fn._mm_prefetch.html).\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566393,"byte_end":2566442,"line_start":1804,"line_end":1804,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9728},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566584,"byte_end":2566595,"line_start":1809,"line_end":1809,"column_start":11,"column_end":22},"name":"_MM_HINT_T2","qualname":"::core_arch::x86::sse::_MM_HINT_T2","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_prefetch`](fn._mm_prefetch.html).\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566524,"byte_end":2566573,"line_start":1808,"line_end":1808,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":9730},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566715,"byte_end":2566727,"line_start":1813,"line_end":1813,"column_start":11,"column_end":23},"name":"_MM_HINT_NTA","qualname":"::core_arch::x86::sse::_MM_HINT_NTA","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" See [`_mm_prefetch`](fn._mm_prefetch.html).\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2566655,"byte_end":2566704,"line_start":1812,"line_end":1812,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9732},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568696,"byte_end":2568708,"line_start":1861,"line_end":1861,"column_start":15,"column_end":27},"name":"_mm_prefetch","qualname":"::core_arch::x86::sse::_mm_prefetch","value":"fn (p: *const i8, strategy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Fetch the cache line that contains address `p` using the given `strategy`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568282,"byte_end":2568291,"line_start":1853,"line_end":1853,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568292,"byte_end":2568325,"line_start":1854,"line_end":1854,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568600,"byte_end":2568631,"line_start":1859,"line_end":1859,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2568632,"byte_end":2568681,"line_start":1860,"line_end":1860,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9736},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569588,"byte_end":2569604,"line_start":1885,"line_end":1885,"column_start":15,"column_end":31},"name":"_mm_undefined_ps","qualname":"::core_arch::x86::sse::_mm_undefined_ps","value":"fn () -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m128 with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569480,"byte_end":2569489,"line_start":1882,"line_end":1882,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569490,"byte_end":2569523,"line_start":1883,"line_end":1883,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569524,"byte_end":2569573,"line_start":1884,"line_end":1884,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9738},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2570056,"byte_end":2570073,"line_start":1897,"line_end":1897,"column_start":15,"column_end":32},"name":"_MM_TRANSPOSE4_PS","qualname":"::core_arch::x86::sse::_MM_TRANSPOSE4_PS","value":"fn (row0: &mut __m128, row1: &mut __m128, row2: &mut __m128, row3: &mut __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Transpose the 4x4 matrix formed by 4 rows of __m128 in place.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569923,"byte_end":2569932,"line_start":1893,"line_end":1893,"column_start":1,"column_end":10}},{"value":"allow(non_snake_case)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569933,"byte_end":2569957,"line_start":1894,"line_end":1894,"column_start":1,"column_end":25}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569958,"byte_end":2569991,"line_start":1895,"line_end":1895,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2569992,"byte_end":2570041,"line_start":1896,"line_end":1896,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9742},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575691,"byte_end":2575704,"line_start":2037,"line_end":2037,"column_start":15,"column_end":28},"name":"_mm_stream_ps","qualname":"::core_arch::x86::sse::_mm_stream_ps","value":"fn (mem_addr: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores `a` into the memory at `mem_addr` using a non-temporal memory hint.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575505,"byte_end":2575514,"line_start":2032,"line_end":2032,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575515,"byte_end":2575548,"line_start":2033,"line_end":2033,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575590,"byte_end":2575639,"line_start":2035,"line_end":2035,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575640,"byte_end":2575676,"line_start":2036,"line_end":2036,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":9744},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575998,"byte_end":2576011,"line_start":2046,"line_end":2046,"column_start":15,"column_end":28},"name":"_mm_stream_pi","qualname":"::core_arch::x86::sse::_mm_stream_pi","value":"fn (mem_addr: *mut __m64, a: __m64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 64-bits of integer data from a into memory using a non-temporal\n memory hint.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575896,"byte_end":2575905,"line_start":2043,"line_end":2043,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2575906,"byte_end":2575943,"line_start":2044,"line_end":2044,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9746},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576286,"byte_end":2576298,"line_start":2055,"line_end":2055,"column_start":15,"column_end":27},"name":"_mm_max_pi16","qualname":"::core_arch::x86::sse::_mm_max_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 16-bit signed integers of `a` and `b` writing the\n greatest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576184,"byte_end":2576193,"line_start":2052,"line_end":2052,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576194,"byte_end":2576231,"line_start":2053,"line_end":2053,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9748},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576562,"byte_end":2576571,"line_start":2064,"line_end":2064,"column_start":15,"column_end":24},"name":"_m_pmaxsw","qualname":"::core_arch::x86::sse::_m_pmaxsw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 16-bit signed integers of `a` and `b` writing the\n greatest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576460,"byte_end":2576469,"line_start":2061,"line_end":2061,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576470,"byte_end":2576507,"line_start":2062,"line_end":2062,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9750},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576840,"byte_end":2576851,"line_start":2073,"line_end":2073,"column_start":15,"column_end":26},"name":"_mm_max_pu8","qualname":"::core_arch::x86::sse::_mm_max_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 8-bit signed integers of `a` and `b` writing the\n greatest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576738,"byte_end":2576747,"line_start":2070,"line_end":2070,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2576748,"byte_end":2576785,"line_start":2071,"line_end":2071,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9752},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577114,"byte_end":2577123,"line_start":2082,"line_end":2082,"column_start":15,"column_end":24},"name":"_m_pmaxub","qualname":"::core_arch::x86::sse::_m_pmaxub","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 8-bit signed integers of `a` and `b` writing the\n greatest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577012,"byte_end":2577021,"line_start":2079,"line_end":2079,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577022,"byte_end":2577059,"line_start":2080,"line_end":2080,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9754},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577392,"byte_end":2577404,"line_start":2091,"line_end":2091,"column_start":15,"column_end":27},"name":"_mm_min_pi16","qualname":"::core_arch::x86::sse::_mm_min_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 16-bit signed integers of `a` and `b` writing the\n smallest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577290,"byte_end":2577299,"line_start":2088,"line_end":2088,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577300,"byte_end":2577337,"line_start":2089,"line_end":2089,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9756},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577668,"byte_end":2577677,"line_start":2100,"line_end":2100,"column_start":15,"column_end":24},"name":"_m_pminsw","qualname":"::core_arch::x86::sse::_m_pminsw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 16-bit signed integers of `a` and `b` writing the\n smallest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577566,"byte_end":2577575,"line_start":2097,"line_end":2097,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577576,"byte_end":2577613,"line_start":2098,"line_end":2098,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9758},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577946,"byte_end":2577957,"line_start":2109,"line_end":2109,"column_start":15,"column_end":26},"name":"_mm_min_pu8","qualname":"::core_arch::x86::sse::_mm_min_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 8-bit signed integers of `a` and `b` writing the\n smallest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577844,"byte_end":2577853,"line_start":2106,"line_end":2106,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2577854,"byte_end":2577891,"line_start":2107,"line_end":2107,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9760},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578220,"byte_end":2578229,"line_start":2118,"line_end":2118,"column_start":15,"column_end":24},"name":"_m_pminub","qualname":"::core_arch::x86::sse::_m_pminub","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares the packed 8-bit signed integers of `a` and `b` writing the\n smallest value into the result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578118,"byte_end":2578127,"line_start":2115,"line_end":2115,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578128,"byte_end":2578165,"line_start":2116,"line_end":2116,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9762},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578553,"byte_end":2578567,"line_start":2128,"line_end":2128,"column_start":15,"column_end":29},"name":"_mm_mulhi_pu16","qualname":"::core_arch::x86::sse::_mm_mulhi_pu16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit unsigned integer values and writes the\n high-order 16 bits of each 32-bit product to the corresponding bits in\n the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578450,"byte_end":2578459,"line_start":2125,"line_end":2125,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578460,"byte_end":2578497,"line_start":2126,"line_end":2126,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9764},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578876,"byte_end":2578890,"line_start":2138,"line_end":2138,"column_start":15,"column_end":29},"name":"_mm_mullo_pi16","qualname":"::core_arch::x86::sse::_mm_mullo_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit integer values and writes the\n low-order 16 bits of each 32-bit product to the corresponding bits in\n the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578774,"byte_end":2578783,"line_start":2135,"line_end":2135,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2578784,"byte_end":2578821,"line_start":2136,"line_end":2136,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9766},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579209,"byte_end":2579219,"line_start":2148,"line_end":2148,"column_start":15,"column_end":25},"name":"_m_pmulhuw","qualname":"::core_arch::x86::sse::_m_pmulhuw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit unsigned integer values and writes the\n high-order 16 bits of each 32-bit product to the corresponding bits in\n the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579106,"byte_end":2579115,"line_start":2145,"line_end":2145,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579116,"byte_end":2579153,"line_start":2146,"line_end":2146,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9768},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579536,"byte_end":2579547,"line_start":2158,"line_end":2158,"column_start":15,"column_end":26},"name":"_mm_avg_pu8","qualname":"::core_arch::x86::sse::_mm_avg_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the rounded averages of the packed unsigned 8-bit integer\n values and writes the averages to the corresponding bits in the\n destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579435,"byte_end":2579444,"line_start":2155,"line_end":2155,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579445,"byte_end":2579482,"line_start":2156,"line_end":2156,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9770},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579855,"byte_end":2579863,"line_start":2168,"line_end":2168,"column_start":15,"column_end":23},"name":"_m_pavgb","qualname":"::core_arch::x86::sse::_m_pavgb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the rounded averages of the packed unsigned 8-bit integer\n values and writes the averages to the corresponding bits in the\n destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579754,"byte_end":2579763,"line_start":2165,"line_end":2165,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2579764,"byte_end":2579801,"line_start":2166,"line_end":2166,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9772},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580178,"byte_end":2580190,"line_start":2178,"line_end":2178,"column_start":15,"column_end":27},"name":"_mm_avg_pu16","qualname":"::core_arch::x86::sse::_mm_avg_pu16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the rounded averages of the packed unsigned 16-bit integer\n values and writes the averages to the corresponding bits in the\n destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580077,"byte_end":2580086,"line_start":2175,"line_end":2175,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580087,"byte_end":2580124,"line_start":2176,"line_end":2176,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9774},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580499,"byte_end":2580507,"line_start":2188,"line_end":2188,"column_start":15,"column_end":23},"name":"_m_pavgw","qualname":"::core_arch::x86::sse::_m_pavgw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the rounded averages of the packed unsigned 16-bit integer\n values and writes the averages to the corresponding bits in the\n destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580398,"byte_end":2580407,"line_start":2185,"line_end":2185,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580408,"byte_end":2580445,"line_start":2186,"line_end":2186,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9776},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580968,"byte_end":2580979,"line_start":2199,"line_end":2199,"column_start":15,"column_end":26},"name":"_mm_sad_pu8","qualname":"::core_arch::x86::sse::_mm_sad_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtracts the corresponding 8-bit unsigned integer values of the two\n 64-bit vector operands and computes the absolute value for each of the\n difference. Then sum of the 8 absolute differences is written to the\n bits `[15:0]` of the destination; the remaining bits `[63:16]` are cleared.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580866,"byte_end":2580875,"line_start":2196,"line_end":2196,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2580876,"byte_end":2580913,"line_start":2197,"line_end":2197,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9778},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581434,"byte_end":2581443,"line_start":2210,"line_end":2210,"column_start":15,"column_end":24},"name":"_m_psadbw","qualname":"::core_arch::x86::sse::_m_psadbw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtracts the corresponding 8-bit unsigned integer values of the two\n 64-bit vector operands and computes the absolute value for each of the\n difference. Then sum of the 8 absolute differences is written to the\n bits `[15:0]` of the destination; the remaining bits `[63:16]` are cleared.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581332,"byte_end":2581341,"line_start":2207,"line_end":2207,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581342,"byte_end":2581379,"line_start":2208,"line_end":2208,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9780},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581884,"byte_end":2581898,"line_start":2221,"line_end":2221,"column_start":15,"column_end":29},"name":"_mm_cvtpi32_ps","qualname":"::core_arch::x86::sse::_mm_cvtpi32_ps","value":"fn (a: __m128, b: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts two elements of a 64-bit vector of `[2 x i32]` into two\n floating point values and writes them to the lower 64-bits of the\n destination. The remaining higher order elements of the destination are\n copied from the corresponding elements in the first operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581780,"byte_end":2581789,"line_start":2218,"line_end":2218,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2581790,"byte_end":2581827,"line_start":2219,"line_end":2219,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9782},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582338,"byte_end":2582351,"line_start":2232,"line_end":2232,"column_start":15,"column_end":28},"name":"_mm_cvt_pi2ps","qualname":"::core_arch::x86::sse::_mm_cvt_pi2ps","value":"fn (a: __m128, b: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts two elements of a 64-bit vector of `[2 x i32]` into two\n floating point values and writes them to the lower 64-bits of the\n destination. The remaining higher order elements of the destination are\n copied from the corresponding elements in the first operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582234,"byte_end":2582243,"line_start":2229,"line_end":2229,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582244,"byte_end":2582281,"line_start":2230,"line_end":2230,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9784},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582597,"byte_end":2582610,"line_start":2240,"line_end":2240,"column_start":15,"column_end":28},"name":"_mm_cvtpi8_ps","qualname":"::core_arch::x86::sse::_mm_cvtpi8_ps","value":"fn (a: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower 4 8-bit values of `a` into a 128-bit vector of 4 `f32`s.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582493,"byte_end":2582502,"line_start":2237,"line_end":2237,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582503,"byte_end":2582540,"line_start":2238,"line_end":2238,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9786},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582943,"byte_end":2582956,"line_start":2251,"line_end":2251,"column_start":15,"column_end":28},"name":"_mm_cvtpu8_ps","qualname":"::core_arch::x86::sse::_mm_cvtpu8_ps","value":"fn (a: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower 4 8-bit values of `a` into a 128-bit vector of 4 `f32`s.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582839,"byte_end":2582848,"line_start":2248,"line_end":2248,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2582849,"byte_end":2582886,"line_start":2249,"line_end":2249,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9788},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2583250,"byte_end":2583264,"line_start":2261,"line_end":2261,"column_start":15,"column_end":29},"name":"_mm_cvtpi16_ps","qualname":"::core_arch::x86::sse::_mm_cvtpi16_ps","value":"fn (a: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts a 64-bit vector of `i16`s into a 128-bit vector of 4 `f32`s.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2583146,"byte_end":2583155,"line_start":2258,"line_end":2258,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2583156,"byte_end":2583193,"line_start":2259,"line_end":2259,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9790},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2583718,"byte_end":2583732,"line_start":2276,"line_end":2276,"column_start":15,"column_end":29},"name":"_mm_cvtpu16_ps","qualname":"::core_arch::x86::sse::_mm_cvtpu16_ps","value":"fn (a: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts a 64-bit vector of `i16`s into a 128-bit vector of 4 `f32`s.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2583614,"byte_end":2583623,"line_start":2273,"line_end":2273,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2583624,"byte_end":2583661,"line_start":2274,"line_end":2274,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9792},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584219,"byte_end":2584235,"line_start":2291,"line_end":2291,"column_start":15,"column_end":31},"name":"_mm_cvtpi32x2_ps","qualname":"::core_arch::x86::sse::_mm_cvtpi32x2_ps","value":"fn (a: __m64, b: __m64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts the two 32-bit signed integer values from each 64-bit vector\n operand of `[2 x i32]` into a 128-bit vector of `[4 x float]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584115,"byte_end":2584124,"line_start":2288,"line_end":2288,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584125,"byte_end":2584162,"line_start":2289,"line_end":2289,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9794},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584864,"byte_end":2584881,"line_start":2308,"line_end":2308,"column_start":15,"column_end":32},"name":"_mm_maskmove_si64","qualname":"::core_arch::x86::sse::_mm_maskmove_si64","value":"fn (a: __m64, mask: __m64, mem_addr: *mut i8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Conditionally copies the values from each 8-bit element in the first\n 64-bit integer vector operand to the specified memory location, as\n specified by the most significant bit in the corresponding element in the\n second 64-bit integer vector operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584760,"byte_end":2584769,"line_start":2305,"line_end":2305,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2584770,"byte_end":2584807,"line_start":2306,"line_end":2306,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9796},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585432,"byte_end":2585443,"line_start":2322,"line_end":2322,"column_start":15,"column_end":26},"name":"_m_maskmovq","qualname":"::core_arch::x86::sse::_m_maskmovq","value":"fn (a: __m64, mask: __m64, mem_addr: *mut i8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Conditionally copies the values from each 8-bit element in the first\n 64-bit integer vector operand to the specified memory location, as\n specified by the most significant bit in the corresponding element in the\n second 64-bit integer vector operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585328,"byte_end":2585337,"line_start":2319,"line_end":2319,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585338,"byte_end":2585375,"line_start":2320,"line_end":2320,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9798},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585807,"byte_end":2585823,"line_start":2332,"line_end":2332,"column_start":15,"column_end":31},"name":"_mm_extract_pi16","qualname":"::core_arch::x86::sse::_mm_extract_pi16","value":"fn (a: __m64, imm2: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts 16-bit element from a 64-bit vector of `[4 x i16]` and\n returns it, as specified by the immediate integer operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585663,"byte_end":2585672,"line_start":2328,"line_end":2328,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585673,"byte_end":2585710,"line_start":2329,"line_end":2329,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2585761,"byte_end":2585792,"line_start":2331,"line_end":2331,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":9802},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586266,"byte_end":2586275,"line_start":2347,"line_end":2347,"column_start":15,"column_end":24},"name":"_m_pextrw","qualname":"::core_arch::x86::sse::_m_pextrw","value":"fn (a: __m64, imm2: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts 16-bit element from a 64-bit vector of `[4 x i16]` and\n returns it, as specified by the immediate integer operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586122,"byte_end":2586131,"line_start":2343,"line_end":2343,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586132,"byte_end":2586169,"line_start":2344,"line_end":2344,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586220,"byte_end":2586251,"line_start":2346,"line_end":2346,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":9806},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586782,"byte_end":2586797,"line_start":2363,"line_end":2363,"column_start":15,"column_end":30},"name":"_mm_insert_pi16","qualname":"::core_arch::x86::sse::_mm_insert_pi16","value":"fn (a: __m64, d: i32, imm2: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Copies data from the 64-bit vector of `[4 x i16]` to the destination,\n and inserts the lower 16-bits of an integer operand at the 16-bit offset\n specified by the immediate operand `n`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586638,"byte_end":2586647,"line_start":2359,"line_end":2359,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586648,"byte_end":2586685,"line_start":2360,"line_end":2360,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2586736,"byte_end":2586767,"line_start":2362,"line_end":2362,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":9810},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587310,"byte_end":2587319,"line_start":2379,"line_end":2379,"column_start":15,"column_end":24},"name":"_m_pinsrw","qualname":"::core_arch::x86::sse::_m_pinsrw","value":"fn (a: __m64, d: i32, imm2: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Copies data from the 64-bit vector of `[4 x i16]` to the destination,\n and inserts the lower 16-bits of an integer operand at the 16-bit offset\n specified by the immediate operand `n`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587166,"byte_end":2587175,"line_start":2375,"line_end":2375,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587176,"byte_end":2587213,"line_start":2376,"line_end":2376,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587264,"byte_end":2587295,"line_start":2378,"line_end":2378,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":9814},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587797,"byte_end":2587813,"line_start":2394,"line_end":2394,"column_start":15,"column_end":31},"name":"_mm_movemask_pi8","qualname":"::core_arch::x86::sse::_mm_movemask_pi8","value":"fn (a: __m64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Takes the most significant bit from each 8-bit element in a 64-bit\n integer vector to create a 16-bit mask value. Zero-extends the value to\n 32-bit integer and writes it to the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587693,"byte_end":2587702,"line_start":2391,"line_end":2391,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2587703,"byte_end":2587740,"line_start":2392,"line_end":2392,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9816},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588156,"byte_end":2588167,"line_start":2404,"line_end":2404,"column_start":15,"column_end":26},"name":"_m_pmovmskb","qualname":"::core_arch::x86::sse::_m_pmovmskb","value":"fn (a: __m64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Takes the most significant bit from each 8-bit element in a 64-bit\n integer vector to create a 16-bit mask value. Zero-extends the value to\n 32-bit integer and writes it to the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588052,"byte_end":2588061,"line_start":2401,"line_end":2401,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588062,"byte_end":2588099,"line_start":2402,"line_end":2402,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9818},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588491,"byte_end":2588507,"line_start":2414,"line_end":2414,"column_start":15,"column_end":31},"name":"_mm_shuffle_pi16","qualname":"::core_arch::x86::sse::_mm_shuffle_pi16","value":"fn (a: __m64, imm8: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Shuffles the 4 16-bit integers from a 64-bit integer vector to the\n destination, as specified by the immediate value operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588347,"byte_end":2588356,"line_start":2410,"line_end":2410,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588357,"byte_end":2588394,"line_start":2411,"line_end":2411,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588445,"byte_end":2588476,"line_start":2413,"line_end":2413,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":9822},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588947,"byte_end":2588956,"line_start":2429,"line_end":2429,"column_start":15,"column_end":24},"name":"_m_pshufw","qualname":"::core_arch::x86::sse::_m_pshufw","value":"fn (a: __m64, imm8: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Shuffles the 4 16-bit integers from a 64-bit integer vector to the\n destination, as specified by the immediate value operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588803,"byte_end":2588812,"line_start":2425,"line_end":2425,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588813,"byte_end":2588850,"line_start":2426,"line_end":2426,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2588901,"byte_end":2588932,"line_start":2428,"line_end":2428,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":9826},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589362,"byte_end":2589377,"line_start":2443,"line_end":2443,"column_start":15,"column_end":30},"name":"_mm_cvttps_pi32","qualname":"::core_arch::x86::sse::_mm_cvttps_pi32","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two lower packed single-precision (32-bit) floating-point\n elements in `a` to packed 32-bit integers with truncation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589257,"byte_end":2589266,"line_start":2440,"line_end":2440,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589267,"byte_end":2589304,"line_start":2441,"line_end":2441,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9828},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589663,"byte_end":2589677,"line_start":2452,"line_end":2452,"column_start":15,"column_end":29},"name":"_mm_cvtt_ps2pi","qualname":"::core_arch::x86::sse::_mm_cvtt_ps2pi","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two lower packed single-precision (32-bit) floating-point\n elements in `a` to packed 32-bit integers with truncation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589558,"byte_end":2589567,"line_start":2449,"line_end":2449,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589568,"byte_end":2589605,"line_start":2450,"line_end":2450,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9830},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589952,"byte_end":2589966,"line_start":2461,"line_end":2461,"column_start":15,"column_end":29},"name":"_mm_cvtps_pi32","qualname":"::core_arch::x86::sse::_mm_cvtps_pi32","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two lower packed single-precision (32-bit) floating-point\n elements in `a` to packed 32-bit integers.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589848,"byte_end":2589857,"line_start":2458,"line_end":2458,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2589858,"byte_end":2589895,"line_start":2459,"line_end":2459,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9832},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590234,"byte_end":2590247,"line_start":2470,"line_end":2470,"column_start":15,"column_end":28},"name":"_mm_cvt_ps2pi","qualname":"::core_arch::x86::sse::_mm_cvt_ps2pi","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two lower packed single-precision (32-bit) floating-point\n elements in `a` to packed 32-bit integers.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590130,"byte_end":2590139,"line_start":2467,"line_end":2467,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590140,"byte_end":2590177,"line_start":2468,"line_end":2468,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9834},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590507,"byte_end":2590521,"line_start":2479,"line_end":2479,"column_start":15,"column_end":29},"name":"_mm_cvtps_pi16","qualname":"::core_arch::x86::sse::_mm_cvtps_pi16","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a` to\n packed 16-bit integers.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590403,"byte_end":2590412,"line_start":2476,"line_end":2476,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590413,"byte_end":2590450,"line_start":2477,"line_end":2477,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9836},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590939,"byte_end":2590952,"line_start":2492,"line_end":2492,"column_start":15,"column_end":28},"name":"_mm_cvtps_pi8","qualname":"::core_arch::x86::sse::_mm_cvtps_pi8","value":"fn (a: __m128) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a` to\n packed 8-bit integers, and returns theem in the lower 4 elements of the\n result.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590835,"byte_end":2590844,"line_start":2489,"line_end":2489,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse.rs","byte_start":2590845,"byte_end":2590882,"line_start":2490,"line_end":2490,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":9862},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2645062,"byte_end":2645071,"line_start":22,"line_end":22,"column_start":15,"column_end":24},"name":"_mm_pause","qualname":"::core_arch::x86::sse2::_mm_pause","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Provides a hint to the processor that the code sequence is a spin-wait loop.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2644919,"byte_end":2644928,"line_start":19,"line_end":19,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2644998,"byte_end":2645047,"line_start":21,"line_end":21,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9864},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2645621,"byte_end":2645632,"line_start":36,"line_end":36,"column_start":15,"column_end":26},"name":"_mm_clflush","qualname":"::core_arch::x86::sse2::_mm_clflush","value":"fn (p: *mut u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Invalidates and flushes the cache line that contains `p` from all levels of\n the cache hierarchy.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2645471,"byte_end":2645480,"line_start":32,"line_end":32,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2645481,"byte_end":2645515,"line_start":33,"line_end":33,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2645557,"byte_end":2645606,"line_start":35,"line_end":35,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9866},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2646225,"byte_end":2646235,"line_start":52,"line_end":52,"column_start":15,"column_end":25},"name":"_mm_lfence","qualname":"::core_arch::x86::sse2::_mm_lfence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a serializing operation on all load-from-memory instructions\n that were issued prior to this instruction.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2646076,"byte_end":2646085,"line_start":48,"line_end":48,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2646086,"byte_end":2646120,"line_start":49,"line_end":49,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2646161,"byte_end":2646210,"line_start":51,"line_end":51,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9868},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2646864,"byte_end":2646874,"line_start":68,"line_end":68,"column_start":15,"column_end":25},"name":"_mm_mfence","qualname":"::core_arch::x86::sse2::_mm_mfence","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a serializing operation on all load-from-memory and store-to-memory\n instructions that were issued prior to this instruction.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2646715,"byte_end":2646724,"line_start":64,"line_end":64,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2646725,"byte_end":2646759,"line_start":65,"line_end":65,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2646800,"byte_end":2646849,"line_start":67,"line_end":67,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9870},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647203,"byte_end":2647215,"line_start":79,"line_end":79,"column_start":15,"column_end":27},"name":"_mm_add_epi8","qualname":"::core_arch::x86::sse2::_mm_add_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647055,"byte_end":2647064,"line_start":75,"line_end":75,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647065,"byte_end":2647099,"line_start":76,"line_end":76,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647139,"byte_end":2647188,"line_start":78,"line_end":78,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9872},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647618,"byte_end":2647631,"line_start":90,"line_end":90,"column_start":15,"column_end":28},"name":"_mm_add_epi16","qualname":"::core_arch::x86::sse2::_mm_add_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647470,"byte_end":2647479,"line_start":86,"line_end":86,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647480,"byte_end":2647514,"line_start":87,"line_end":87,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647554,"byte_end":2647603,"line_start":89,"line_end":89,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9874},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648034,"byte_end":2648047,"line_start":101,"line_end":101,"column_start":15,"column_end":28},"name":"_mm_add_epi32","qualname":"::core_arch::x86::sse2::_mm_add_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 32-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647886,"byte_end":2647895,"line_start":97,"line_end":97,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647896,"byte_end":2647930,"line_start":98,"line_end":98,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2647970,"byte_end":2648019,"line_start":100,"line_end":100,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9876},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648450,"byte_end":2648463,"line_start":112,"line_end":112,"column_start":15,"column_end":28},"name":"_mm_add_epi64","qualname":"::core_arch::x86::sse2::_mm_add_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 64-bit integers in `a` and \"b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648302,"byte_end":2648311,"line_start":108,"line_end":108,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648312,"byte_end":2648346,"line_start":109,"line_end":109,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648386,"byte_end":2648435,"line_start":111,"line_end":111,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9878},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648883,"byte_end":2648896,"line_start":123,"line_end":123,"column_start":15,"column_end":28},"name":"_mm_adds_epi8","qualname":"::core_arch::x86::sse2::_mm_adds_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648734,"byte_end":2648743,"line_start":119,"line_end":119,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648744,"byte_end":2648778,"line_start":120,"line_end":120,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2648819,"byte_end":2648868,"line_start":122,"line_end":122,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9880},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2649316,"byte_end":2649330,"line_start":134,"line_end":134,"column_start":15,"column_end":29},"name":"_mm_adds_epi16","qualname":"::core_arch::x86::sse2::_mm_adds_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2649167,"byte_end":2649176,"line_start":130,"line_end":130,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2649177,"byte_end":2649211,"line_start":131,"line_end":131,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2649252,"byte_end":2649301,"line_start":133,"line_end":133,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9882},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2649758,"byte_end":2649771,"line_start":145,"line_end":145,"column_start":15,"column_end":28},"name":"_mm_adds_epu8","qualname":"::core_arch::x86::sse2::_mm_adds_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 8-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2649608,"byte_end":2649617,"line_start":141,"line_end":141,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2649618,"byte_end":2649652,"line_start":142,"line_end":142,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2649694,"byte_end":2649743,"line_start":144,"line_end":144,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9884},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650202,"byte_end":2650216,"line_start":156,"line_end":156,"column_start":15,"column_end":29},"name":"_mm_adds_epu16","qualname":"::core_arch::x86::sse2::_mm_adds_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 16-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650052,"byte_end":2650061,"line_start":152,"line_end":152,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650062,"byte_end":2650096,"line_start":153,"line_end":153,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650138,"byte_end":2650187,"line_start":155,"line_end":155,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9886},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650629,"byte_end":2650641,"line_start":167,"line_end":167,"column_start":15,"column_end":27},"name":"_mm_avg_epu8","qualname":"::core_arch::x86::sse2::_mm_avg_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Averages packed unsigned 8-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650481,"byte_end":2650490,"line_start":163,"line_end":163,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650491,"byte_end":2650525,"line_start":164,"line_end":164,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650565,"byte_end":2650614,"line_start":166,"line_end":166,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9888},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2651054,"byte_end":2651067,"line_start":178,"line_end":178,"column_start":15,"column_end":28},"name":"_mm_avg_epu16","qualname":"::core_arch::x86::sse2::_mm_avg_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Averages packed unsigned 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650906,"byte_end":2650915,"line_start":174,"line_end":174,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650916,"byte_end":2650950,"line_start":175,"line_end":175,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2650990,"byte_end":2651039,"line_start":177,"line_end":177,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9890},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2651687,"byte_end":2651701,"line_start":193,"line_end":193,"column_start":15,"column_end":29},"name":"_mm_madd_epi16","qualname":"::core_arch::x86::sse2::_mm_madd_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies and then horizontally add signed 16 bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2651537,"byte_end":2651546,"line_start":189,"line_end":189,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2651547,"byte_end":2651581,"line_start":190,"line_end":190,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2651623,"byte_end":2651672,"line_start":192,"line_end":192,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9892},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652151,"byte_end":2652164,"line_start":205,"line_end":205,"column_start":15,"column_end":28},"name":"_mm_max_epi16","qualname":"::core_arch::x86::sse2::_mm_max_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b`, and returns the packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652002,"byte_end":2652011,"line_start":201,"line_end":201,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652012,"byte_end":2652046,"line_start":202,"line_end":202,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652087,"byte_end":2652136,"line_start":204,"line_end":204,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9894},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652620,"byte_end":2652632,"line_start":217,"line_end":217,"column_start":15,"column_end":27},"name":"_mm_max_epu8","qualname":"::core_arch::x86::sse2::_mm_max_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 8-bit integers in `a` and `b`, and returns the\n packed maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652471,"byte_end":2652480,"line_start":213,"line_end":213,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652481,"byte_end":2652515,"line_start":214,"line_end":214,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652556,"byte_end":2652605,"line_start":216,"line_end":216,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9896},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2653081,"byte_end":2653094,"line_start":229,"line_end":229,"column_start":15,"column_end":28},"name":"_mm_min_epi16","qualname":"::core_arch::x86::sse2::_mm_min_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b`, and returns the packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652932,"byte_end":2652941,"line_start":225,"line_end":225,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2652942,"byte_end":2652976,"line_start":226,"line_end":226,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2653017,"byte_end":2653066,"line_start":228,"line_end":228,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9898},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2653550,"byte_end":2653562,"line_start":241,"line_end":241,"column_start":15,"column_end":27},"name":"_mm_min_epu8","qualname":"::core_arch::x86::sse2::_mm_min_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 8-bit integers in `a` and `b`, and returns the\n packed minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2653401,"byte_end":2653410,"line_start":237,"line_end":237,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2653411,"byte_end":2653445,"line_start":238,"line_end":238,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2653486,"byte_end":2653535,"line_start":240,"line_end":240,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9900},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2654105,"byte_end":2654120,"line_start":255,"line_end":255,"column_start":15,"column_end":30},"name":"_mm_mulhi_epi16","qualname":"::core_arch::x86::sse2::_mm_mulhi_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2653956,"byte_end":2653965,"line_start":251,"line_end":251,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2653966,"byte_end":2654000,"line_start":252,"line_end":252,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2654041,"byte_end":2654090,"line_start":254,"line_end":254,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9902},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2654673,"byte_end":2654688,"line_start":269,"line_end":269,"column_start":15,"column_end":30},"name":"_mm_mulhi_epu16","qualname":"::core_arch::x86::sse2::_mm_mulhi_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed unsigned 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2654523,"byte_end":2654532,"line_start":265,"line_end":265,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2654533,"byte_end":2654567,"line_start":266,"line_end":266,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2654609,"byte_end":2654658,"line_start":268,"line_end":268,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9904},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2655231,"byte_end":2655246,"line_start":283,"line_end":283,"column_start":15,"column_end":30},"name":"_mm_mullo_epi16","qualname":"::core_arch::x86::sse2::_mm_mullo_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2655082,"byte_end":2655091,"line_start":279,"line_end":279,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2655092,"byte_end":2655126,"line_start":280,"line_end":280,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2655167,"byte_end":2655216,"line_start":282,"line_end":282,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9906},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2655748,"byte_end":2655761,"line_start":297,"line_end":297,"column_start":15,"column_end":28},"name":"_mm_mul_epu32","qualname":"::core_arch::x86::sse2::_mm_mul_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the low unsigned 32-bit integers from each packed 64-bit element\n in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2655598,"byte_end":2655607,"line_start":293,"line_end":293,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2655608,"byte_end":2655642,"line_start":294,"line_end":294,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2655684,"byte_end":2655733,"line_start":296,"line_end":296,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9908},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2656469,"byte_end":2656481,"line_start":313,"line_end":313,"column_start":15,"column_end":27},"name":"_mm_sad_epu8","qualname":"::core_arch::x86::sse2::_mm_sad_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sum the absolute differences of packed unsigned 8-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2656320,"byte_end":2656329,"line_start":309,"line_end":309,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2656330,"byte_end":2656364,"line_start":310,"line_end":310,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2656405,"byte_end":2656454,"line_start":312,"line_end":312,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9910},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2656911,"byte_end":2656923,"line_start":324,"line_end":324,"column_start":15,"column_end":27},"name":"_mm_sub_epi8","qualname":"::core_arch::x86::sse2::_mm_sub_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtracts packed 8-bit integers in `b` from packed 8-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2656763,"byte_end":2656772,"line_start":320,"line_end":320,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2656773,"byte_end":2656807,"line_start":321,"line_end":321,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2656847,"byte_end":2656896,"line_start":323,"line_end":323,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9912},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2657358,"byte_end":2657371,"line_start":335,"line_end":335,"column_start":15,"column_end":28},"name":"_mm_sub_epi16","qualname":"::core_arch::x86::sse2::_mm_sub_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtracts packed 16-bit integers in `b` from packed 16-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2657210,"byte_end":2657219,"line_start":331,"line_end":331,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2657220,"byte_end":2657254,"line_start":332,"line_end":332,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2657294,"byte_end":2657343,"line_start":334,"line_end":334,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9914},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2657805,"byte_end":2657818,"line_start":346,"line_end":346,"column_start":15,"column_end":28},"name":"_mm_sub_epi32","qualname":"::core_arch::x86::sse2::_mm_sub_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2657657,"byte_end":2657666,"line_start":342,"line_end":342,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2657667,"byte_end":2657701,"line_start":343,"line_end":343,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2657741,"byte_end":2657790,"line_start":345,"line_end":345,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9916},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2658252,"byte_end":2658265,"line_start":357,"line_end":357,"column_start":15,"column_end":28},"name":"_mm_sub_epi64","qualname":"::core_arch::x86::sse2::_mm_sub_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 64-bit integers in `b` from packed 64-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2658104,"byte_end":2658113,"line_start":353,"line_end":353,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2658114,"byte_end":2658148,"line_start":354,"line_end":354,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2658188,"byte_end":2658237,"line_start":356,"line_end":356,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9918},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2658719,"byte_end":2658732,"line_start":369,"line_end":369,"column_start":15,"column_end":28},"name":"_mm_subs_epi8","qualname":"::core_arch::x86::sse2::_mm_subs_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`\n using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2658570,"byte_end":2658579,"line_start":365,"line_end":365,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2658580,"byte_end":2658614,"line_start":366,"line_end":366,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2658655,"byte_end":2658704,"line_start":368,"line_end":368,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9920},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2659187,"byte_end":2659201,"line_start":381,"line_end":381,"column_start":15,"column_end":29},"name":"_mm_subs_epi16","qualname":"::core_arch::x86::sse2::_mm_subs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`\n using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2659038,"byte_end":2659047,"line_start":377,"line_end":377,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2659048,"byte_end":2659082,"line_start":378,"line_end":378,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2659123,"byte_end":2659172,"line_start":380,"line_end":380,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9922},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2659672,"byte_end":2659685,"line_start":393,"line_end":393,"column_start":15,"column_end":28},"name":"_mm_subs_epu8","qualname":"::core_arch::x86::sse2::_mm_subs_epu8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit\n integers in `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2659522,"byte_end":2659531,"line_start":389,"line_end":389,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2659532,"byte_end":2659566,"line_start":390,"line_end":390,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2659608,"byte_end":2659657,"line_start":392,"line_end":392,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9924},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660160,"byte_end":2660174,"line_start":405,"line_end":405,"column_start":15,"column_end":29},"name":"_mm_subs_epu16","qualname":"::core_arch::x86::sse2::_mm_subs_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 16-bit integers in `b` from packed unsigned 16-bit\n integers in `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660010,"byte_end":2660019,"line_start":401,"line_end":401,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660020,"byte_end":2660054,"line_start":402,"line_end":402,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660096,"byte_end":2660145,"line_start":404,"line_end":404,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9926},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660633,"byte_end":2660647,"line_start":417,"line_end":417,"column_start":15,"column_end":29},"name":"_mm_slli_si128","qualname":"::core_arch::x86::sse2::_mm_slli_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts `a` left by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660442,"byte_end":2660451,"line_start":412,"line_end":412,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660452,"byte_end":2660486,"line_start":413,"line_end":413,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660537,"byte_end":2660568,"line_start":415,"line_end":415,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2660569,"byte_end":2660618,"line_start":416,"line_end":416,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9932},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2662661,"byte_end":2662676,"line_start":484,"line_end":484,"column_start":15,"column_end":30},"name":"_mm_bslli_si128","qualname":"::core_arch::x86::sse2::_mm_bslli_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts `a` left by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2662470,"byte_end":2662479,"line_start":479,"line_end":479,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2662480,"byte_end":2662514,"line_start":480,"line_end":480,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2662565,"byte_end":2662596,"line_start":482,"line_end":482,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2662597,"byte_end":2662646,"line_start":483,"line_end":483,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9934},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663118,"byte_end":2663133,"line_start":496,"line_end":496,"column_start":15,"column_end":30},"name":"_mm_bsrli_si128","qualname":"::core_arch::x86::sse2::_mm_bsrli_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts `a` right by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2662927,"byte_end":2662936,"line_start":491,"line_end":491,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2662937,"byte_end":2662971,"line_start":492,"line_end":492,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663022,"byte_end":2663053,"line_start":494,"line_end":494,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663054,"byte_end":2663103,"line_start":495,"line_end":495,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9936},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663592,"byte_end":2663606,"line_start":508,"line_end":508,"column_start":15,"column_end":29},"name":"_mm_slli_epi16","qualname":"::core_arch::x86::sse2::_mm_slli_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` left by `imm8` while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663402,"byte_end":2663411,"line_start":503,"line_end":503,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663412,"byte_end":2663446,"line_start":504,"line_end":504,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663496,"byte_end":2663527,"line_start":506,"line_end":506,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663528,"byte_end":2663577,"line_start":507,"line_end":507,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9938},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664036,"byte_end":2664049,"line_start":520,"line_end":520,"column_start":15,"column_end":28},"name":"_mm_sll_epi16","qualname":"::core_arch::x86::sse2::_mm_sll_epi16","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` left by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663888,"byte_end":2663897,"line_start":516,"line_end":516,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663898,"byte_end":2663932,"line_start":517,"line_end":517,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2663972,"byte_end":2664021,"line_start":519,"line_end":519,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9940},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664533,"byte_end":2664547,"line_start":532,"line_end":532,"column_start":15,"column_end":29},"name":"_mm_slli_epi32","qualname":"::core_arch::x86::sse2::_mm_slli_epi32","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by `imm8` while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664343,"byte_end":2664352,"line_start":527,"line_end":527,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664353,"byte_end":2664387,"line_start":528,"line_end":528,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664437,"byte_end":2664468,"line_start":530,"line_end":530,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664469,"byte_end":2664518,"line_start":531,"line_end":531,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9942},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664977,"byte_end":2664990,"line_start":544,"line_end":544,"column_start":15,"column_end":28},"name":"_mm_sll_epi32","qualname":"::core_arch::x86::sse2::_mm_sll_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664829,"byte_end":2664838,"line_start":540,"line_end":540,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664839,"byte_end":2664873,"line_start":541,"line_end":541,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2664913,"byte_end":2664962,"line_start":543,"line_end":543,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9944},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665474,"byte_end":2665488,"line_start":556,"line_end":556,"column_start":15,"column_end":29},"name":"_mm_slli_epi64","qualname":"::core_arch::x86::sse2::_mm_slli_epi64","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by `imm8` while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665284,"byte_end":2665293,"line_start":551,"line_end":551,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665294,"byte_end":2665328,"line_start":552,"line_end":552,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665378,"byte_end":2665409,"line_start":554,"line_end":554,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665410,"byte_end":2665459,"line_start":555,"line_end":555,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9946},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665918,"byte_end":2665931,"line_start":568,"line_end":568,"column_start":15,"column_end":28},"name":"_mm_sll_epi64","qualname":"::core_arch::x86::sse2::_mm_sll_epi64","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665770,"byte_end":2665779,"line_start":564,"line_end":564,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665780,"byte_end":2665814,"line_start":565,"line_end":565,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2665854,"byte_end":2665903,"line_start":567,"line_end":567,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9948},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666424,"byte_end":2666438,"line_start":581,"line_end":581,"column_start":15,"column_end":29},"name":"_mm_srai_epi16","qualname":"::core_arch::x86::sse2::_mm_srai_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `imm8` while shifting in sign\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666234,"byte_end":2666243,"line_start":576,"line_end":576,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666244,"byte_end":2666278,"line_start":577,"line_end":577,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666328,"byte_end":2666359,"line_start":579,"line_end":579,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666360,"byte_end":2666409,"line_start":580,"line_end":580,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9950},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666873,"byte_end":2666886,"line_start":593,"line_end":593,"column_start":15,"column_end":28},"name":"_mm_sra_epi16","qualname":"::core_arch::x86::sse2::_mm_sra_epi16","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `count` while shifting in sign\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666725,"byte_end":2666734,"line_start":589,"line_end":589,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666735,"byte_end":2666769,"line_start":590,"line_end":590,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2666809,"byte_end":2666858,"line_start":592,"line_end":592,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9952},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667379,"byte_end":2667393,"line_start":606,"line_end":606,"column_start":15,"column_end":29},"name":"_mm_srai_epi32","qualname":"::core_arch::x86::sse2::_mm_srai_epi32","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `imm8` while shifting in sign\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667189,"byte_end":2667198,"line_start":601,"line_end":601,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667199,"byte_end":2667233,"line_start":602,"line_end":602,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667283,"byte_end":2667314,"line_start":604,"line_end":604,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667315,"byte_end":2667364,"line_start":605,"line_end":605,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9954},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667828,"byte_end":2667841,"line_start":618,"line_end":618,"column_start":15,"column_end":28},"name":"_mm_sra_epi32","qualname":"::core_arch::x86::sse2::_mm_sra_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `count` while shifting in sign\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667680,"byte_end":2667689,"line_start":614,"line_end":614,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667690,"byte_end":2667724,"line_start":615,"line_end":615,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2667764,"byte_end":2667813,"line_start":617,"line_end":617,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9956},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2668307,"byte_end":2668321,"line_start":630,"line_end":630,"column_start":15,"column_end":29},"name":"_mm_srli_si128","qualname":"::core_arch::x86::sse2::_mm_srli_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts `a` right by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2668116,"byte_end":2668125,"line_start":625,"line_end":625,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2668126,"byte_end":2668160,"line_start":626,"line_end":626,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2668211,"byte_end":2668242,"line_start":628,"line_end":628,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2668243,"byte_end":2668292,"line_start":629,"line_end":629,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9962},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670339,"byte_end":2670353,"line_start":698,"line_end":698,"column_start":15,"column_end":29},"name":"_mm_srli_epi16","qualname":"::core_arch::x86::sse2::_mm_srli_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `imm8` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670149,"byte_end":2670158,"line_start":693,"line_end":693,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670159,"byte_end":2670193,"line_start":694,"line_end":694,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670243,"byte_end":2670274,"line_start":696,"line_end":696,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670275,"byte_end":2670324,"line_start":697,"line_end":697,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9964},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670784,"byte_end":2670797,"line_start":710,"line_end":710,"column_start":15,"column_end":28},"name":"_mm_srl_epi16","qualname":"::core_arch::x86::sse2::_mm_srl_epi16","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670636,"byte_end":2670645,"line_start":706,"line_end":706,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670646,"byte_end":2670680,"line_start":707,"line_end":707,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2670720,"byte_end":2670769,"line_start":709,"line_end":709,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9966},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671286,"byte_end":2671300,"line_start":723,"line_end":723,"column_start":15,"column_end":29},"name":"_mm_srli_epi32","qualname":"::core_arch::x86::sse2::_mm_srli_epi32","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `imm8` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671096,"byte_end":2671105,"line_start":718,"line_end":718,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671106,"byte_end":2671140,"line_start":719,"line_end":719,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671190,"byte_end":2671221,"line_start":721,"line_end":721,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671222,"byte_end":2671271,"line_start":722,"line_end":722,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9968},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671731,"byte_end":2671744,"line_start":735,"line_end":735,"column_start":15,"column_end":28},"name":"_mm_srl_epi32","qualname":"::core_arch::x86::sse2::_mm_srl_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671583,"byte_end":2671592,"line_start":731,"line_end":731,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671593,"byte_end":2671627,"line_start":732,"line_end":732,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2671667,"byte_end":2671716,"line_start":734,"line_end":734,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9970},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672233,"byte_end":2672247,"line_start":748,"line_end":748,"column_start":15,"column_end":29},"name":"_mm_srli_epi64","qualname":"::core_arch::x86::sse2::_mm_srli_epi64","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by `imm8` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672043,"byte_end":2672052,"line_start":743,"line_end":743,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672053,"byte_end":2672087,"line_start":744,"line_end":744,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672137,"byte_end":2672168,"line_start":746,"line_end":746,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672169,"byte_end":2672218,"line_start":747,"line_end":747,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9972},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672678,"byte_end":2672691,"line_start":760,"line_end":760,"column_start":15,"column_end":28},"name":"_mm_srl_epi64","qualname":"::core_arch::x86::sse2::_mm_srl_epi64","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672530,"byte_end":2672539,"line_start":756,"line_end":756,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672540,"byte_end":2672574,"line_start":757,"line_end":757,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672614,"byte_end":2672663,"line_start":759,"line_end":759,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9974},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673140,"byte_end":2673153,"line_start":772,"line_end":772,"column_start":15,"column_end":28},"name":"_mm_and_si128","qualname":"::core_arch::x86::sse2::_mm_and_si128","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing integer data) in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2672992,"byte_end":2673001,"line_start":768,"line_end":768,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673002,"byte_end":2673036,"line_start":769,"line_end":769,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673076,"byte_end":2673125,"line_start":771,"line_end":771,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9976},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673582,"byte_end":2673598,"line_start":784,"line_end":784,"column_start":15,"column_end":31},"name":"_mm_andnot_si128","qualname":"::core_arch::x86::sse2::_mm_andnot_si128","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of 128 bits (representing integer data) in `a` and\n then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673433,"byte_end":2673442,"line_start":780,"line_end":780,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673443,"byte_end":2673477,"line_start":781,"line_end":781,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673518,"byte_end":2673567,"line_start":783,"line_end":783,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9978},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674035,"byte_end":2674047,"line_start":796,"line_end":796,"column_start":15,"column_end":27},"name":"_mm_or_si128","qualname":"::core_arch::x86::sse2::_mm_or_si128","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR of 128 bits (representing integer data) in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673888,"byte_end":2673897,"line_start":792,"line_end":792,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673898,"byte_end":2673932,"line_start":793,"line_end":793,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2673971,"byte_end":2674020,"line_start":795,"line_end":795,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9980},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674457,"byte_end":2674470,"line_start":808,"line_end":808,"column_start":15,"column_end":28},"name":"_mm_xor_si128","qualname":"::core_arch::x86::sse2::_mm_xor_si128","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise XOR of 128 bits (representing integer data) in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674309,"byte_end":2674318,"line_start":804,"line_end":804,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674319,"byte_end":2674353,"line_start":805,"line_end":805,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674393,"byte_end":2674442,"line_start":807,"line_end":807,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9982},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674859,"byte_end":2674873,"line_start":819,"line_end":819,"column_start":15,"column_end":29},"name":"_mm_cmpeq_epi8","qualname":"::core_arch::x86::sse2::_mm_cmpeq_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674709,"byte_end":2674718,"line_start":815,"line_end":815,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674719,"byte_end":2674753,"line_start":816,"line_end":816,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2674795,"byte_end":2674844,"line_start":818,"line_end":818,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9984},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2675308,"byte_end":2675323,"line_start":830,"line_end":830,"column_start":15,"column_end":30},"name":"_mm_cmpeq_epi16","qualname":"::core_arch::x86::sse2::_mm_cmpeq_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2675158,"byte_end":2675167,"line_start":826,"line_end":826,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2675168,"byte_end":2675202,"line_start":827,"line_end":827,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2675244,"byte_end":2675293,"line_start":829,"line_end":829,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9986},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2675758,"byte_end":2675773,"line_start":841,"line_end":841,"column_start":15,"column_end":30},"name":"_mm_cmpeq_epi32","qualname":"::core_arch::x86::sse2::_mm_cmpeq_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2675608,"byte_end":2675617,"line_start":837,"line_end":837,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2675618,"byte_end":2675652,"line_start":838,"line_end":838,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2675694,"byte_end":2675743,"line_start":840,"line_end":840,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9988},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676210,"byte_end":2676224,"line_start":852,"line_end":852,"column_start":15,"column_end":29},"name":"_mm_cmpgt_epi8","qualname":"::core_arch::x86::sse2::_mm_cmpgt_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676060,"byte_end":2676069,"line_start":848,"line_end":848,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676070,"byte_end":2676104,"line_start":849,"line_end":849,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676146,"byte_end":2676195,"line_start":851,"line_end":851,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9990},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676663,"byte_end":2676678,"line_start":863,"line_end":863,"column_start":15,"column_end":30},"name":"_mm_cmpgt_epi16","qualname":"::core_arch::x86::sse2::_mm_cmpgt_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676513,"byte_end":2676522,"line_start":859,"line_end":859,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676523,"byte_end":2676557,"line_start":860,"line_end":860,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676599,"byte_end":2676648,"line_start":862,"line_end":862,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9992},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677117,"byte_end":2677132,"line_start":874,"line_end":874,"column_start":15,"column_end":30},"name":"_mm_cmpgt_epi32","qualname":"::core_arch::x86::sse2::_mm_cmpgt_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676967,"byte_end":2676976,"line_start":870,"line_end":870,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2676977,"byte_end":2677011,"line_start":871,"line_end":871,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677053,"byte_end":2677102,"line_start":873,"line_end":873,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9994},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677566,"byte_end":2677580,"line_start":885,"line_end":885,"column_start":15,"column_end":29},"name":"_mm_cmplt_epi8","qualname":"::core_arch::x86::sse2::_mm_cmplt_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677416,"byte_end":2677425,"line_start":881,"line_end":881,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677426,"byte_end":2677460,"line_start":882,"line_end":882,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677502,"byte_end":2677551,"line_start":884,"line_end":884,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9996},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678016,"byte_end":2678031,"line_start":896,"line_end":896,"column_start":15,"column_end":30},"name":"_mm_cmplt_epi16","qualname":"::core_arch::x86::sse2::_mm_cmplt_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677866,"byte_end":2677875,"line_start":892,"line_end":892,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677876,"byte_end":2677910,"line_start":893,"line_end":893,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2677952,"byte_end":2678001,"line_start":895,"line_end":895,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":9998},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678467,"byte_end":2678482,"line_start":907,"line_end":907,"column_start":15,"column_end":30},"name":"_mm_cmplt_epi32","qualname":"::core_arch::x86::sse2::_mm_cmplt_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678317,"byte_end":2678326,"line_start":903,"line_end":903,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678327,"byte_end":2678361,"line_start":904,"line_end":904,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678403,"byte_end":2678452,"line_start":906,"line_end":906,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10000},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678975,"byte_end":2678990,"line_start":919,"line_end":919,"column_start":15,"column_end":30},"name":"_mm_cvtepi32_pd","qualname":"::core_arch::x86::sse2::_mm_cvtepi32_pd","value":"fn (a: __m128i) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower two packed 32-bit integers in `a` to packed\n double-precision (64-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678824,"byte_end":2678833,"line_start":915,"line_end":915,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678834,"byte_end":2678868,"line_start":916,"line_end":916,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2678911,"byte_end":2678960,"line_start":918,"line_end":918,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10002},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2679464,"byte_end":2679478,"line_start":932,"line_end":932,"column_start":15,"column_end":29},"name":"_mm_cvtsi32_sd","qualname":"::core_arch::x86::sse2::_mm_cvtsi32_sd","value":"fn (a: __m128d, b: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns `a` with its lower element replaced by `b` after converting it to\n an `f64`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2679313,"byte_end":2679322,"line_start":928,"line_end":928,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2679323,"byte_end":2679357,"line_start":929,"line_end":929,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2679400,"byte_end":2679449,"line_start":931,"line_end":931,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10004},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2679922,"byte_end":2679937,"line_start":944,"line_end":944,"column_start":15,"column_end":30},"name":"_mm_cvtepi32_ps","qualname":"::core_arch::x86::sse2::_mm_cvtepi32_ps","value":"fn (a: __m128i) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers in `a` to packed single-precision (32-bit)\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2679771,"byte_end":2679780,"line_start":940,"line_end":940,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2679781,"byte_end":2679815,"line_start":941,"line_end":941,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2679858,"byte_end":2679907,"line_start":943,"line_end":943,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10006},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2680367,"byte_end":2680382,"line_start":956,"line_end":956,"column_start":15,"column_end":30},"name":"_mm_cvtps_epi32","qualname":"::core_arch::x86::sse2::_mm_cvtps_epi32","value":"fn (a: __m128) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a`\n to packed 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2680216,"byte_end":2680225,"line_start":952,"line_end":952,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2680226,"byte_end":2680260,"line_start":953,"line_end":953,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2680303,"byte_end":2680352,"line_start":955,"line_end":955,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10008},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2680817,"byte_end":2680834,"line_start":968,"line_end":968,"column_start":15,"column_end":32},"name":"_mm_cvtsi32_si128","qualname":"::core_arch::x86::sse2::_mm_cvtsi32_si128","value":"fn (a: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector whose lowest element is `a` and all higher elements are\n `0`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2680641,"byte_end":2680650,"line_start":964,"line_end":964,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2680651,"byte_end":2680685,"line_start":965,"line_end":965,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2680753,"byte_end":2680802,"line_start":967,"line_end":967,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10010},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681234,"byte_end":2681251,"line_start":979,"line_end":979,"column_start":15,"column_end":32},"name":"_mm_cvtsi128_si32","qualname":"::core_arch::x86::sse2::_mm_cvtsi128_si32","value":"fn (a: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns the lowest element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681054,"byte_end":2681063,"line_start":975,"line_end":975,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681064,"byte_end":2681098,"line_start":976,"line_end":976,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681170,"byte_end":2681219,"line_start":978,"line_end":978,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10012},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681657,"byte_end":2681671,"line_start":991,"line_end":991,"column_start":15,"column_end":29},"name":"_mm_set_epi64x","qualname":"::core_arch::x86::sse2::_mm_set_epi64x","value":"fn (e1: i64, e0: i64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 64-bit integers with the supplied values, from highest to\n lowest.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681511,"byte_end":2681520,"line_start":987,"line_end":987,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681521,"byte_end":2681555,"line_start":988,"line_end":988,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681593,"byte_end":2681642,"line_start":990,"line_end":990,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10014},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682058,"byte_end":2682071,"line_start":1002,"line_end":1002,"column_start":15,"column_end":28},"name":"_mm_set_epi32","qualname":"::core_arch::x86::sse2::_mm_set_epi32","value":"fn (e3: i32, e2: i32, e1: i32, e0: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681912,"byte_end":2681921,"line_start":998,"line_end":998,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681922,"byte_end":2681956,"line_start":999,"line_end":999,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2681994,"byte_end":2682043,"line_start":1001,"line_end":1001,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10016},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682484,"byte_end":2682497,"line_start":1013,"line_end":1013,"column_start":15,"column_end":28},"name":"_mm_set_epi16","qualname":"::core_arch::x86::sse2::_mm_set_epi16","value":"fn (e7: i16, e6: i16, e5: i16, e4: i16, e3: i16, e2: i16, e1: i16, e0: i16) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682338,"byte_end":2682347,"line_start":1009,"line_end":1009,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682348,"byte_end":2682382,"line_start":1010,"line_end":1010,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682420,"byte_end":2682469,"line_start":1012,"line_end":1012,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10018},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682995,"byte_end":2683007,"line_start":1033,"line_end":1033,"column_start":15,"column_end":27},"name":"_mm_set_epi8","qualname":"::core_arch::x86::sse2::_mm_set_epi8","value":"fn (e15: i8, e14: i8, e13: i8, e12: i8, e11: i8, e10: i8, e9: i8, e8: i8, e7: i8, e6: i8, e5: i8, e4: i8, e3: i8, e2: i8, e1: i8, e0: i8) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682849,"byte_end":2682858,"line_start":1029,"line_end":1029,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682859,"byte_end":2682893,"line_start":1030,"line_end":1030,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2682931,"byte_end":2682980,"line_start":1032,"line_end":1032,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10020},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2683670,"byte_end":2683685,"line_start":1064,"line_end":1064,"column_start":15,"column_end":30},"name":"_mm_set1_epi64x","qualname":"::core_arch::x86::sse2::_mm_set1_epi64x","value":"fn (a: i64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 64-bit integer `a` to all elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2683524,"byte_end":2683533,"line_start":1060,"line_end":1060,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2683534,"byte_end":2683568,"line_start":1061,"line_end":1061,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2683606,"byte_end":2683655,"line_start":1063,"line_end":1063,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10022},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684047,"byte_end":2684061,"line_start":1075,"line_end":1075,"column_start":15,"column_end":29},"name":"_mm_set1_epi32","qualname":"::core_arch::x86::sse2::_mm_set1_epi32","value":"fn (a: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 32-bit integer `a` to all elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2683901,"byte_end":2683910,"line_start":1071,"line_end":1071,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2683911,"byte_end":2683945,"line_start":1072,"line_end":1072,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2683983,"byte_end":2684032,"line_start":1074,"line_end":1074,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10024},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684428,"byte_end":2684442,"line_start":1086,"line_end":1086,"column_start":15,"column_end":29},"name":"_mm_set1_epi16","qualname":"::core_arch::x86::sse2::_mm_set1_epi16","value":"fn (a: i16) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 16-bit integer `a` to all elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684282,"byte_end":2684291,"line_start":1082,"line_end":1082,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684292,"byte_end":2684326,"line_start":1083,"line_end":1083,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684364,"byte_end":2684413,"line_start":1085,"line_end":1085,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10026},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684819,"byte_end":2684832,"line_start":1097,"line_end":1097,"column_start":15,"column_end":28},"name":"_mm_set1_epi8","qualname":"::core_arch::x86::sse2::_mm_set1_epi8","value":"fn (a: i8) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 8-bit integer `a` to all elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684673,"byte_end":2684682,"line_start":1093,"line_end":1093,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684683,"byte_end":2684717,"line_start":1094,"line_end":1094,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2684755,"byte_end":2684804,"line_start":1096,"line_end":1096,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10028},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2685257,"byte_end":2685271,"line_start":1108,"line_end":1108,"column_start":15,"column_end":29},"name":"_mm_setr_epi32","qualname":"::core_arch::x86::sse2::_mm_setr_epi32","value":"fn (e3: i32, e2: i32, e1: i32, e0: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2685111,"byte_end":2685120,"line_start":1104,"line_end":1104,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2685121,"byte_end":2685155,"line_start":1105,"line_end":1105,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2685193,"byte_end":2685242,"line_start":1107,"line_end":1107,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10030},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2685694,"byte_end":2685708,"line_start":1119,"line_end":1119,"column_start":15,"column_end":29},"name":"_mm_setr_epi16","qualname":"::core_arch::x86::sse2::_mm_setr_epi16","value":"fn (e7: i16, e6: i16, e5: i16, e4: i16, e3: i16, e2: i16, e1: i16, e0: i16) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2685548,"byte_end":2685557,"line_start":1115,"line_end":1115,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2685558,"byte_end":2685592,"line_start":1116,"line_end":1116,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2685630,"byte_end":2685679,"line_start":1118,"line_end":1118,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10032},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2686216,"byte_end":2686229,"line_start":1139,"line_end":1139,"column_start":15,"column_end":28},"name":"_mm_setr_epi8","qualname":"::core_arch::x86::sse2::_mm_setr_epi8","value":"fn (e15: i8, e14: i8, e13: i8, e12: i8, e11: i8, e10: i8, e9: i8, e8: i8, e7: i8, e6: i8, e5: i8, e4: i8, e3: i8, e2: i8, e1: i8, e0: i8) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2686070,"byte_end":2686079,"line_start":1135,"line_end":1135,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2686080,"byte_end":2686114,"line_start":1136,"line_end":1136,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2686152,"byte_end":2686201,"line_start":1138,"line_end":1138,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10034},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2686888,"byte_end":2686905,"line_start":1170,"line_end":1170,"column_start":15,"column_end":32},"name":"_mm_setzero_si128","qualname":"::core_arch::x86::sse2::_mm_setzero_si128","value":"fn () -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2686740,"byte_end":2686749,"line_start":1166,"line_end":1166,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2686750,"byte_end":2686784,"line_start":1167,"line_end":1167,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2686824,"byte_end":2686873,"line_start":1169,"line_end":1169,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10036},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2687458,"byte_end":2687473,"line_start":1190,"line_end":1190,"column_start":15,"column_end":30},"name":"_mm_loadl_epi64","qualname":"::core_arch::x86::sse2::_mm_loadl_epi64","value":"fn (mem_addr: *const __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads 64-bit integer from memory into first element of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2687139,"byte_end":2687148,"line_start":1177,"line_end":1177,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2687149,"byte_end":2687183,"line_start":1178,"line_end":1178,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2687394,"byte_end":2687443,"line_start":1189,"line_end":1189,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10038},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2687971,"byte_end":2687985,"line_start":1203,"line_end":1203,"column_start":15,"column_end":29},"name":"_mm_load_si128","qualname":"::core_arch::x86::sse2::_mm_load_si128","value":"fn (mem_addr: *const __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits of integer data from memory into a new vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2687822,"byte_end":2687831,"line_start":1199,"line_end":1199,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2687832,"byte_end":2687866,"line_start":1200,"line_end":1200,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2687907,"byte_end":2687956,"line_start":1202,"line_end":1202,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10040},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2688448,"byte_end":2688463,"line_start":1216,"line_end":1216,"column_start":15,"column_end":30},"name":"_mm_loadu_si128","qualname":"::core_arch::x86::sse2::_mm_loadu_si128","value":"fn (mem_addr: *const __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits of integer data from memory into a new vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2688299,"byte_end":2688308,"line_start":1212,"line_end":1212,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2688309,"byte_end":2688343,"line_start":1213,"line_end":1213,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2688384,"byte_end":2688433,"line_start":1215,"line_end":1215,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10042},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689299,"byte_end":2689318,"line_start":1240,"line_end":1240,"column_start":15,"column_end":34},"name":"_mm_maskmoveu_si128","qualname":"::core_arch::x86::sse2::_mm_maskmoveu_si128","value":"fn (a: __m128i, mask: __m128i, mem_addr: *mut i8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Conditionally store 8-bit integer elements from `a` into memory using\n `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689146,"byte_end":2689155,"line_start":1236,"line_end":1236,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689156,"byte_end":2689190,"line_start":1237,"line_end":1237,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689235,"byte_end":2689284,"line_start":1239,"line_end":1239,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10044},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689807,"byte_end":2689822,"line_start":1253,"line_end":1253,"column_start":15,"column_end":30},"name":"_mm_store_si128","qualname":"::core_arch::x86::sse2::_mm_store_si128","value":"fn (mem_addr: *mut __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 128-bits of integer data from `a` into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689658,"byte_end":2689667,"line_start":1249,"line_end":1249,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689668,"byte_end":2689702,"line_start":1250,"line_end":1250,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2689743,"byte_end":2689792,"line_start":1252,"line_end":1252,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10046},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690307,"byte_end":2690323,"line_start":1266,"line_end":1266,"column_start":15,"column_end":31},"name":"_mm_storeu_si128","qualname":"::core_arch::x86::sse2::_mm_storeu_si128","value":"fn (mem_addr: *mut __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 128-bits of integer data from `a` into memory.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690133,"byte_end":2690142,"line_start":1262,"line_end":1262,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690143,"byte_end":2690177,"line_start":1263,"line_end":1263,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690243,"byte_end":2690292,"line_start":1265,"line_end":1265,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10048},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690990,"byte_end":2691006,"line_start":1288,"line_end":1288,"column_start":15,"column_end":31},"name":"_mm_storel_epi64","qualname":"::core_arch::x86::sse2::_mm_storel_epi64","value":"fn (mem_addr: *mut __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower 64-bit integer `a` to a memory location.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690657,"byte_end":2690666,"line_start":1275,"line_end":1275,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690667,"byte_end":2690701,"line_start":1276,"line_end":1276,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2690926,"byte_end":2690975,"line_start":1287,"line_end":1287,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10050},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691588,"byte_end":2691604,"line_start":1301,"line_end":1301,"column_start":15,"column_end":31},"name":"_mm_stream_si128","qualname":"::core_arch::x86::sse2::_mm_stream_si128","value":"fn (mem_addr: *mut __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a 128-bit integer vector to a 128-bit aligned memory location.\n To minimize caching, the data is flagged as non-temporal (unlikely to be\n used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691421,"byte_end":2691430,"line_start":1297,"line_end":1297,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691431,"byte_end":2691465,"line_start":1298,"line_end":1298,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691524,"byte_end":2691573,"line_start":1300,"line_end":1300,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10052},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692126,"byte_end":2692141,"line_start":1314,"line_end":1314,"column_start":15,"column_end":30},"name":"_mm_stream_si32","qualname":"::core_arch::x86::sse2::_mm_stream_si32","value":"fn (mem_addr: *mut i32, a: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a 32-bit integer value in the specified memory location.\n To minimize caching, the data is flagged as non-temporal (unlikely to be\n used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691977,"byte_end":2691986,"line_start":1310,"line_end":1310,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2691987,"byte_end":2692021,"line_start":1311,"line_end":1311,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692062,"byte_end":2692111,"line_start":1313,"line_end":1313,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10054},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692667,"byte_end":2692681,"line_start":1327,"line_end":1327,"column_start":15,"column_end":29},"name":"_mm_move_epi64","qualname":"::core_arch::x86::sse2::_mm_move_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector where the low element is extracted from `a` and its upper\n element is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692438,"byte_end":2692447,"line_start":1322,"line_end":1322,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692448,"byte_end":2692482,"line_start":1323,"line_end":1323,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2692603,"byte_end":2692652,"line_start":1326,"line_end":1326,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10056},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693210,"byte_end":2693225,"line_start":1341,"line_end":1341,"column_start":15,"column_end":30},"name":"_mm_packs_epi16","qualname":"::core_arch::x86::sse2::_mm_packs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using signed saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693059,"byte_end":2693068,"line_start":1337,"line_end":1337,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693069,"byte_end":2693103,"line_start":1338,"line_end":1338,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693146,"byte_end":2693195,"line_start":1340,"line_end":1340,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10058},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693693,"byte_end":2693708,"line_start":1353,"line_end":1353,"column_start":15,"column_end":30},"name":"_mm_packs_epi32","qualname":"::core_arch::x86::sse2::_mm_packs_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using signed saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693542,"byte_end":2693551,"line_start":1349,"line_end":1349,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693552,"byte_end":2693586,"line_start":1350,"line_end":1350,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2693629,"byte_end":2693678,"line_start":1352,"line_end":1352,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10060},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694178,"byte_end":2694194,"line_start":1365,"line_end":1365,"column_start":15,"column_end":31},"name":"_mm_packus_epi16","qualname":"::core_arch::x86::sse2::_mm_packus_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using unsigned saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694027,"byte_end":2694036,"line_start":1361,"line_end":1361,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694037,"byte_end":2694071,"line_start":1362,"line_end":1362,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694114,"byte_end":2694163,"line_start":1364,"line_end":1364,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10062},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694635,"byte_end":2694652,"line_start":1377,"line_end":1377,"column_start":15,"column_end":32},"name":"_mm_extract_epi16","qualname":"::core_arch::x86::sse2::_mm_extract_epi16","value":"fn (a: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns the `imm8` element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694444,"byte_end":2694453,"line_start":1372,"line_end":1372,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694454,"byte_end":2694488,"line_start":1373,"line_end":1373,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694539,"byte_end":2694570,"line_start":1375,"line_end":1375,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694571,"byte_end":2694620,"line_start":1376,"line_end":1376,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10064},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695142,"byte_end":2695158,"line_start":1389,"line_end":1389,"column_start":15,"column_end":31},"name":"_mm_insert_epi16","qualname":"::core_arch::x86::sse2::_mm_insert_epi16","value":"fn (a: __m128i, i: i32, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector where the `imm8` element of `a` is replaced with `i`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694951,"byte_end":2694960,"line_start":1384,"line_end":1384,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2694961,"byte_end":2694995,"line_start":1385,"line_end":1385,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695046,"byte_end":2695077,"line_start":1387,"line_end":1387,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695078,"byte_end":2695127,"line_start":1388,"line_end":1388,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10066},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695616,"byte_end":2695633,"line_start":1400,"line_end":1400,"column_start":15,"column_end":32},"name":"_mm_movemask_epi8","qualname":"::core_arch::x86::sse2::_mm_movemask_epi8","value":"fn (a: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns a mask of the most significant bit of each element in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695465,"byte_end":2695474,"line_start":1396,"line_end":1396,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695475,"byte_end":2695509,"line_start":1397,"line_end":1397,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695552,"byte_end":2695601,"line_start":1399,"line_end":1399,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10068},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2696059,"byte_end":2696076,"line_start":1412,"line_end":1412,"column_start":15,"column_end":32},"name":"_mm_shuffle_epi32","qualname":"::core_arch::x86::sse2::_mm_shuffle_epi32","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 32-bit integers in `a` using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695868,"byte_end":2695877,"line_start":1407,"line_end":1407,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695878,"byte_end":2695912,"line_start":1408,"line_end":1408,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695963,"byte_end":2695994,"line_start":1410,"line_end":1410,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2695995,"byte_end":2696044,"line_start":1411,"line_end":1411,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10078},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698527,"byte_end":2698546,"line_start":1479,"line_end":1479,"column_start":15,"column_end":34},"name":"_mm_shufflehi_epi16","qualname":"::core_arch::x86::sse2::_mm_shufflehi_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 16-bit integers in the high 64 bits of `a` using the control in\n `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698335,"byte_end":2698344,"line_start":1474,"line_end":1474,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698345,"byte_end":2698379,"line_start":1475,"line_end":1475,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698431,"byte_end":2698462,"line_start":1477,"line_end":1477,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2698463,"byte_end":2698512,"line_start":1478,"line_end":1478,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10088},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700626,"byte_end":2700645,"line_start":1539,"line_end":1539,"column_start":15,"column_end":34},"name":"_mm_shufflelo_epi16","qualname":"::core_arch::x86::sse2::_mm_shufflelo_epi16","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 16-bit integers in the low 64 bits of `a` using the control in\n `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700434,"byte_end":2700443,"line_start":1534,"line_end":1534,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700444,"byte_end":2700478,"line_start":1535,"line_end":1535,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700530,"byte_end":2700561,"line_start":1537,"line_end":1537,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2700562,"byte_end":2700611,"line_start":1538,"line_end":1538,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10098},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702536,"byte_end":2702553,"line_start":1595,"line_end":1595,"column_start":15,"column_end":32},"name":"_mm_unpackhi_epi8","qualname":"::core_arch::x86::sse2::_mm_unpackhi_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 8-bit integers from the high half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702384,"byte_end":2702393,"line_start":1591,"line_end":1591,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702394,"byte_end":2702428,"line_start":1592,"line_end":1592,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702472,"byte_end":2702521,"line_start":1594,"line_end":1594,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10100},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703108,"byte_end":2703126,"line_start":1610,"line_end":1610,"column_start":15,"column_end":33},"name":"_mm_unpackhi_epi16","qualname":"::core_arch::x86::sse2::_mm_unpackhi_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 16-bit integers from the high half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702956,"byte_end":2702965,"line_start":1606,"line_end":1606,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2702966,"byte_end":2703000,"line_start":1607,"line_end":1607,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703044,"byte_end":2703093,"line_start":1609,"line_end":1609,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10102},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703629,"byte_end":2703647,"line_start":1622,"line_end":1622,"column_start":15,"column_end":33},"name":"_mm_unpackhi_epi32","qualname":"::core_arch::x86::sse2::_mm_unpackhi_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 32-bit integers from the high half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703478,"byte_end":2703487,"line_start":1618,"line_end":1618,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703488,"byte_end":2703522,"line_start":1619,"line_end":1619,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703565,"byte_end":2703614,"line_start":1621,"line_end":1621,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10104},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704119,"byte_end":2704137,"line_start":1633,"line_end":1633,"column_start":15,"column_end":33},"name":"_mm_unpackhi_epi64","qualname":"::core_arch::x86::sse2::_mm_unpackhi_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 64-bit integers from the high half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703968,"byte_end":2703977,"line_start":1629,"line_end":1629,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2703978,"byte_end":2704012,"line_start":1630,"line_end":1630,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704055,"byte_end":2704104,"line_start":1632,"line_end":1632,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10106},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704601,"byte_end":2704618,"line_start":1644,"line_end":1644,"column_start":15,"column_end":32},"name":"_mm_unpacklo_epi8","qualname":"::core_arch::x86::sse2::_mm_unpacklo_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 8-bit integers from the low half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704449,"byte_end":2704458,"line_start":1640,"line_end":1640,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704459,"byte_end":2704493,"line_start":1641,"line_end":1641,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2704537,"byte_end":2704586,"line_start":1643,"line_end":1643,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10108},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705166,"byte_end":2705184,"line_start":1659,"line_end":1659,"column_start":15,"column_end":33},"name":"_mm_unpacklo_epi16","qualname":"::core_arch::x86::sse2::_mm_unpacklo_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 16-bit integers from the low half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705014,"byte_end":2705023,"line_start":1655,"line_end":1655,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705024,"byte_end":2705058,"line_start":1656,"line_end":1656,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705102,"byte_end":2705151,"line_start":1658,"line_end":1658,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10110},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705684,"byte_end":2705702,"line_start":1671,"line_end":1671,"column_start":15,"column_end":33},"name":"_mm_unpacklo_epi32","qualname":"::core_arch::x86::sse2::_mm_unpacklo_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 32-bit integers from the low half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705533,"byte_end":2705542,"line_start":1667,"line_end":1667,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705543,"byte_end":2705577,"line_start":1668,"line_end":1668,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2705620,"byte_end":2705669,"line_start":1670,"line_end":1670,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10112},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2706205,"byte_end":2706223,"line_start":1682,"line_end":1682,"column_start":15,"column_end":33},"name":"_mm_unpacklo_epi64","qualname":"::core_arch::x86::sse2::_mm_unpacklo_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 64-bit integers from the low half of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2706022,"byte_end":2706031,"line_start":1678,"line_end":1678,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2706032,"byte_end":2706066,"line_start":1679,"line_end":1679,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2706141,"byte_end":2706190,"line_start":1681,"line_end":1681,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10114},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2706713,"byte_end":2706723,"line_start":1694,"line_end":1694,"column_start":15,"column_end":25},"name":"_mm_add_sd","qualname":"::core_arch::x86::sse2::_mm_add_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the sum of the\n low elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2706565,"byte_end":2706574,"line_start":1690,"line_end":1690,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2706575,"byte_end":2706609,"line_start":1691,"line_end":1691,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2706649,"byte_end":2706698,"line_start":1693,"line_end":1693,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10116},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707168,"byte_end":2707178,"line_start":1706,"line_end":1706,"column_start":15,"column_end":25},"name":"_mm_add_pd","qualname":"::core_arch::x86::sse2::_mm_add_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Adds packed double-precision (64-bit) floating-point elements in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707020,"byte_end":2707029,"line_start":1702,"line_end":1702,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707030,"byte_end":2707064,"line_start":1703,"line_end":1703,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707104,"byte_end":2707153,"line_start":1705,"line_end":1705,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10118},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707641,"byte_end":2707651,"line_start":1718,"line_end":1718,"column_start":15,"column_end":25},"name":"_mm_div_sd","qualname":"::core_arch::x86::sse2::_mm_div_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the result of\n diving the lower element of `a` by the lower element of `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707493,"byte_end":2707502,"line_start":1714,"line_end":1714,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707503,"byte_end":2707537,"line_start":1715,"line_end":1715,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707577,"byte_end":2707626,"line_start":1717,"line_end":1717,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10120},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708116,"byte_end":2708126,"line_start":1730,"line_end":1730,"column_start":15,"column_end":25},"name":"_mm_div_pd","qualname":"::core_arch::x86::sse2::_mm_div_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Divide packed double-precision (64-bit) floating-point elements in `a` by\n packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707968,"byte_end":2707977,"line_start":1726,"line_end":1726,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2707978,"byte_end":2708012,"line_start":1727,"line_end":1727,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708052,"byte_end":2708101,"line_start":1729,"line_end":1729,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10122},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708564,"byte_end":2708574,"line_start":1742,"line_end":1742,"column_start":15,"column_end":25},"name":"_mm_max_sd","qualname":"::core_arch::x86::sse2::_mm_max_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the maximum\n of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708416,"byte_end":2708425,"line_start":1738,"line_end":1738,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708426,"byte_end":2708460,"line_start":1739,"line_end":1739,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708500,"byte_end":2708549,"line_start":1741,"line_end":1741,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10124},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708987,"byte_end":2708997,"line_start":1754,"line_end":1754,"column_start":15,"column_end":25},"name":"_mm_max_pd","qualname":"::core_arch::x86::sse2::_mm_max_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the maximum values from corresponding elements in\n `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708839,"byte_end":2708848,"line_start":1750,"line_end":1750,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708849,"byte_end":2708883,"line_start":1751,"line_end":1751,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2708923,"byte_end":2708972,"line_start":1753,"line_end":1753,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10126},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709432,"byte_end":2709442,"line_start":1766,"line_end":1766,"column_start":15,"column_end":25},"name":"_mm_min_sd","qualname":"::core_arch::x86::sse2::_mm_min_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the minimum\n of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709284,"byte_end":2709293,"line_start":1762,"line_end":1762,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709294,"byte_end":2709328,"line_start":1763,"line_end":1763,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709368,"byte_end":2709417,"line_start":1765,"line_end":1765,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10128},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709855,"byte_end":2709865,"line_start":1778,"line_end":1778,"column_start":15,"column_end":25},"name":"_mm_min_pd","qualname":"::core_arch::x86::sse2::_mm_min_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the minimum values from corresponding elements in\n `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709707,"byte_end":2709716,"line_start":1774,"line_end":1774,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709717,"byte_end":2709751,"line_start":1775,"line_end":1775,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2709791,"byte_end":2709840,"line_start":1777,"line_end":1777,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10130},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710295,"byte_end":2710305,"line_start":1790,"line_end":1790,"column_start":15,"column_end":25},"name":"_mm_mul_sd","qualname":"::core_arch::x86::sse2::_mm_mul_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by multiplying the\n low elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710147,"byte_end":2710156,"line_start":1786,"line_end":1786,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710157,"byte_end":2710191,"line_start":1787,"line_end":1787,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710231,"byte_end":2710280,"line_start":1789,"line_end":1789,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10132},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710756,"byte_end":2710766,"line_start":1802,"line_end":1802,"column_start":15,"column_end":25},"name":"_mm_mul_pd","qualname":"::core_arch::x86::sse2::_mm_mul_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710608,"byte_end":2710617,"line_start":1798,"line_end":1798,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710618,"byte_end":2710652,"line_start":1799,"line_end":1799,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2710692,"byte_end":2710741,"line_start":1801,"line_end":1801,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10134},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711198,"byte_end":2711209,"line_start":1814,"line_end":1814,"column_start":15,"column_end":26},"name":"_mm_sqrt_sd","qualname":"::core_arch::x86::sse2::_mm_sqrt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the square\n root of the lower element `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711049,"byte_end":2711058,"line_start":1810,"line_end":1810,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711059,"byte_end":2711093,"line_start":1811,"line_end":1811,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711134,"byte_end":2711183,"line_start":1813,"line_end":1813,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10136},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711635,"byte_end":2711646,"line_start":1825,"line_end":1825,"column_start":15,"column_end":26},"name":"_mm_sqrt_pd","qualname":"::core_arch::x86::sse2::_mm_sqrt_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the square root of each of the values in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711486,"byte_end":2711495,"line_start":1821,"line_end":1821,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711496,"byte_end":2711530,"line_start":1822,"line_end":1822,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711571,"byte_end":2711620,"line_start":1824,"line_end":1824,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10138},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712081,"byte_end":2712091,"line_start":1837,"line_end":1837,"column_start":15,"column_end":25},"name":"_mm_sub_sd","qualname":"::core_arch::x86::sse2::_mm_sub_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by subtracting the\n low element by `b` from the low element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711933,"byte_end":2711942,"line_start":1833,"line_end":1833,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2711943,"byte_end":2711977,"line_start":1834,"line_end":1834,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712017,"byte_end":2712066,"line_start":1836,"line_end":1836,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10140},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712541,"byte_end":2712551,"line_start":1849,"line_end":1849,"column_start":15,"column_end":25},"name":"_mm_sub_pd","qualname":"::core_arch::x86::sse2::_mm_sub_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed double-precision (64-bit) floating-point elements in `b`\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712393,"byte_end":2712402,"line_start":1845,"line_end":1845,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712403,"byte_end":2712437,"line_start":1846,"line_end":1846,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712477,"byte_end":2712526,"line_start":1848,"line_end":1848,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10142},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712979,"byte_end":2712989,"line_start":1861,"line_end":1861,"column_start":15,"column_end":25},"name":"_mm_and_pd","qualname":"::core_arch::x86::sse2::_mm_and_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of packed double-precision (64-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712831,"byte_end":2712840,"line_start":1857,"line_end":1857,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712841,"byte_end":2712875,"line_start":1858,"line_end":1858,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2712915,"byte_end":2712964,"line_start":1860,"line_end":1860,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10144},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713457,"byte_end":2713470,"line_start":1874,"line_end":1874,"column_start":15,"column_end":28},"name":"_mm_andnot_pd","qualname":"::core_arch::x86::sse2::_mm_andnot_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of `a` and then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713308,"byte_end":2713317,"line_start":1870,"line_end":1870,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713318,"byte_end":2713352,"line_start":1871,"line_end":1871,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713393,"byte_end":2713442,"line_start":1873,"line_end":1873,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10146},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713920,"byte_end":2713929,"line_start":1887,"line_end":1887,"column_start":15,"column_end":24},"name":"_mm_or_pd","qualname":"::core_arch::x86::sse2::_mm_or_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713773,"byte_end":2713782,"line_start":1883,"line_end":1883,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713783,"byte_end":2713817,"line_start":1884,"line_end":1884,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2713856,"byte_end":2713905,"line_start":1886,"line_end":1886,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10148},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714377,"byte_end":2714387,"line_start":1900,"line_end":1900,"column_start":15,"column_end":25},"name":"_mm_xor_pd","qualname":"::core_arch::x86::sse2::_mm_xor_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714229,"byte_end":2714238,"line_start":1896,"line_end":1896,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714239,"byte_end":2714273,"line_start":1897,"line_end":1897,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714313,"byte_end":2714362,"line_start":1899,"line_end":1899,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10150},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714927,"byte_end":2714939,"line_start":1914,"line_end":1914,"column_start":15,"column_end":27},"name":"_mm_cmpeq_sd","qualname":"::core_arch::x86::sse2::_mm_cmpeq_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the equality\n comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714777,"byte_end":2714786,"line_start":1910,"line_end":1910,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714787,"byte_end":2714821,"line_start":1911,"line_end":1911,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2714863,"byte_end":2714912,"line_start":1913,"line_end":1913,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10152},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715394,"byte_end":2715406,"line_start":1926,"line_end":1926,"column_start":15,"column_end":27},"name":"_mm_cmplt_sd","qualname":"::core_arch::x86::sse2::_mm_cmplt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the less-than\n comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715244,"byte_end":2715253,"line_start":1922,"line_end":1922,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715254,"byte_end":2715288,"line_start":1923,"line_end":1923,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715330,"byte_end":2715379,"line_start":1925,"line_end":1925,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10154},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715870,"byte_end":2715882,"line_start":1938,"line_end":1938,"column_start":15,"column_end":27},"name":"_mm_cmple_sd","qualname":"::core_arch::x86::sse2::_mm_cmple_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n less-than-or-equal comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715720,"byte_end":2715729,"line_start":1934,"line_end":1934,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715730,"byte_end":2715764,"line_start":1935,"line_end":1935,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2715806,"byte_end":2715855,"line_start":1937,"line_end":1937,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10156},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716340,"byte_end":2716352,"line_start":1950,"line_end":1950,"column_start":15,"column_end":27},"name":"_mm_cmpgt_sd","qualname":"::core_arch::x86::sse2::_mm_cmpgt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n greater-than comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716190,"byte_end":2716199,"line_start":1946,"line_end":1946,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716200,"byte_end":2716234,"line_start":1947,"line_end":1947,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716276,"byte_end":2716325,"line_start":1949,"line_end":1949,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10158},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716869,"byte_end":2716881,"line_start":1962,"line_end":1962,"column_start":15,"column_end":27},"name":"_mm_cmpge_sd","qualname":"::core_arch::x86::sse2::_mm_cmpge_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n greater-than-or-equal comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716719,"byte_end":2716728,"line_start":1958,"line_end":1958,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716729,"byte_end":2716763,"line_start":1959,"line_end":1959,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2716805,"byte_end":2716854,"line_start":1961,"line_end":1961,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10160},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717492,"byte_end":2717505,"line_start":1976,"line_end":1976,"column_start":15,"column_end":28},"name":"_mm_cmpord_sd","qualname":"::core_arch::x86::sse2::_mm_cmpord_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the result\n of comparing both of the lower elements of `a` and `b` to `NaN`. If\n neither are equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717341,"byte_end":2717350,"line_start":1972,"line_end":1972,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717351,"byte_end":2717385,"line_start":1973,"line_end":1973,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717428,"byte_end":2717477,"line_start":1975,"line_end":1975,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10162},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718064,"byte_end":2718079,"line_start":1989,"line_end":1989,"column_start":15,"column_end":30},"name":"_mm_cmpunord_sd","qualname":"::core_arch::x86::sse2::_mm_cmpunord_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the result of\n comparing both of the lower elements of `a` and `b` to `NaN`. If either is\n equal to `NaN` then `0xFFFFFFFFFFFFFFFF` is used and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717911,"byte_end":2717920,"line_start":1985,"line_end":1985,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2717921,"byte_end":2717955,"line_start":1986,"line_end":1986,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718000,"byte_end":2718049,"line_start":1988,"line_end":1988,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10164},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718536,"byte_end":2718549,"line_start":2001,"line_end":2001,"column_start":15,"column_end":28},"name":"_mm_cmpneq_sd","qualname":"::core_arch::x86::sse2::_mm_cmpneq_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the not-equal\n comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718385,"byte_end":2718394,"line_start":1997,"line_end":1997,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718395,"byte_end":2718429,"line_start":1998,"line_end":1998,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718472,"byte_end":2718521,"line_start":2000,"line_end":2000,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10166},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719010,"byte_end":2719023,"line_start":2013,"line_end":2013,"column_start":15,"column_end":28},"name":"_mm_cmpnlt_sd","qualname":"::core_arch::x86::sse2::_mm_cmpnlt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n not-less-than comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718859,"byte_end":2718868,"line_start":2009,"line_end":2009,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718869,"byte_end":2718903,"line_start":2010,"line_end":2010,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2718946,"byte_end":2718995,"line_start":2012,"line_end":2012,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10168},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719493,"byte_end":2719506,"line_start":2025,"line_end":2025,"column_start":15,"column_end":28},"name":"_mm_cmpnle_sd","qualname":"::core_arch::x86::sse2::_mm_cmpnle_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n not-less-than-or-equal comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719342,"byte_end":2719351,"line_start":2021,"line_end":2021,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719352,"byte_end":2719386,"line_start":2022,"line_end":2022,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719429,"byte_end":2719478,"line_start":2024,"line_end":2024,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10170},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719970,"byte_end":2719983,"line_start":2037,"line_end":2037,"column_start":15,"column_end":28},"name":"_mm_cmpngt_sd","qualname":"::core_arch::x86::sse2::_mm_cmpngt_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n not-greater-than comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719819,"byte_end":2719828,"line_start":2033,"line_end":2033,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719829,"byte_end":2719863,"line_start":2034,"line_end":2034,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2719906,"byte_end":2719955,"line_start":2036,"line_end":2036,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10172},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720507,"byte_end":2720520,"line_start":2049,"line_end":2049,"column_start":15,"column_end":28},"name":"_mm_cmpnge_sd","qualname":"::core_arch::x86::sse2::_mm_cmpnge_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns a new vector with the low element of `a` replaced by the\n not-greater-than-or-equal comparison of the lower elements of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720356,"byte_end":2720365,"line_start":2045,"line_end":2045,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720366,"byte_end":2720400,"line_start":2046,"line_end":2046,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720443,"byte_end":2720492,"line_start":2048,"line_end":2048,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10174},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720959,"byte_end":2720971,"line_start":2060,"line_end":2060,"column_start":15,"column_end":27},"name":"_mm_cmpeq_pd","qualname":"::core_arch::x86::sse2::_mm_cmpeq_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720809,"byte_end":2720818,"line_start":2056,"line_end":2056,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720819,"byte_end":2720853,"line_start":2057,"line_end":2057,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2720895,"byte_end":2720944,"line_start":2059,"line_end":2059,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10176},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721360,"byte_end":2721372,"line_start":2071,"line_end":2071,"column_start":15,"column_end":27},"name":"_mm_cmplt_pd","qualname":"::core_arch::x86::sse2::_mm_cmplt_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721210,"byte_end":2721219,"line_start":2067,"line_end":2067,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721220,"byte_end":2721254,"line_start":2068,"line_end":2068,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721296,"byte_end":2721345,"line_start":2070,"line_end":2070,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10178},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721769,"byte_end":2721781,"line_start":2082,"line_end":2082,"column_start":15,"column_end":27},"name":"_mm_cmple_pd","qualname":"::core_arch::x86::sse2::_mm_cmple_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for less-than-or-equal","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721619,"byte_end":2721628,"line_start":2078,"line_end":2078,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721629,"byte_end":2721663,"line_start":2079,"line_end":2079,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2721705,"byte_end":2721754,"line_start":2081,"line_end":2081,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10180},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722173,"byte_end":2722185,"line_start":2093,"line_end":2093,"column_start":15,"column_end":27},"name":"_mm_cmpgt_pd","qualname":"::core_arch::x86::sse2::_mm_cmpgt_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722023,"byte_end":2722032,"line_start":2089,"line_end":2089,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722033,"byte_end":2722067,"line_start":2090,"line_end":2090,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722109,"byte_end":2722158,"line_start":2092,"line_end":2092,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10182},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722590,"byte_end":2722602,"line_start":2104,"line_end":2104,"column_start":15,"column_end":27},"name":"_mm_cmpge_pd","qualname":"::core_arch::x86::sse2::_mm_cmpge_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for greater-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722440,"byte_end":2722449,"line_start":2100,"line_end":2100,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722450,"byte_end":2722484,"line_start":2101,"line_end":2101,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722526,"byte_end":2722575,"line_start":2103,"line_end":2103,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10184},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723010,"byte_end":2723023,"line_start":2115,"line_end":2115,"column_start":15,"column_end":28},"name":"_mm_cmpord_pd","qualname":"::core_arch::x86::sse2::_mm_cmpord_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` to see if neither is `NaN`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722859,"byte_end":2722868,"line_start":2111,"line_end":2111,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722869,"byte_end":2722903,"line_start":2112,"line_end":2112,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2722946,"byte_end":2722995,"line_start":2114,"line_end":2114,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10186},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723430,"byte_end":2723445,"line_start":2126,"line_end":2126,"column_start":15,"column_end":30},"name":"_mm_cmpunord_pd","qualname":"::core_arch::x86::sse2::_mm_cmpunord_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` to see if either is `NaN`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723277,"byte_end":2723286,"line_start":2122,"line_end":2122,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723287,"byte_end":2723321,"line_start":2123,"line_end":2123,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723366,"byte_end":2723415,"line_start":2125,"line_end":2125,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10188},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723836,"byte_end":2723849,"line_start":2137,"line_end":2137,"column_start":15,"column_end":28},"name":"_mm_cmpneq_pd","qualname":"::core_arch::x86::sse2::_mm_cmpneq_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for not-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723685,"byte_end":2723694,"line_start":2133,"line_end":2133,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723695,"byte_end":2723729,"line_start":2134,"line_end":2134,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2723772,"byte_end":2723821,"line_start":2136,"line_end":2136,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10190},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724244,"byte_end":2724257,"line_start":2148,"line_end":2148,"column_start":15,"column_end":28},"name":"_mm_cmpnlt_pd","qualname":"::core_arch::x86::sse2::_mm_cmpnlt_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for not-less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724093,"byte_end":2724102,"line_start":2144,"line_end":2144,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724103,"byte_end":2724137,"line_start":2145,"line_end":2145,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724180,"byte_end":2724229,"line_start":2147,"line_end":2147,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10192},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724661,"byte_end":2724674,"line_start":2159,"line_end":2159,"column_start":15,"column_end":28},"name":"_mm_cmpnle_pd","qualname":"::core_arch::x86::sse2::_mm_cmpnle_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for not-less-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724510,"byte_end":2724519,"line_start":2155,"line_end":2155,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724520,"byte_end":2724554,"line_start":2156,"line_end":2156,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724597,"byte_end":2724646,"line_start":2158,"line_end":2158,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10194},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725072,"byte_end":2725085,"line_start":2170,"line_end":2170,"column_start":15,"column_end":28},"name":"_mm_cmpngt_pd","qualname":"::core_arch::x86::sse2::_mm_cmpngt_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for not-greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724921,"byte_end":2724930,"line_start":2166,"line_end":2166,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2724931,"byte_end":2724965,"line_start":2167,"line_end":2167,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725008,"byte_end":2725057,"line_start":2169,"line_end":2169,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10196},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725501,"byte_end":2725514,"line_start":2182,"line_end":2182,"column_start":15,"column_end":28},"name":"_mm_cmpnge_pd","qualname":"::core_arch::x86::sse2::_mm_cmpnge_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares corresponding elements in `a` and `b` for\n not-greater-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725350,"byte_end":2725359,"line_start":2178,"line_end":2178,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725360,"byte_end":2725394,"line_start":2179,"line_end":2179,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725437,"byte_end":2725486,"line_start":2181,"line_end":2181,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10198},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725902,"byte_end":2725915,"line_start":2193,"line_end":2193,"column_start":15,"column_end":28},"name":"_mm_comieq_sd","qualname":"::core_arch::x86::sse2::_mm_comieq_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725753,"byte_end":2725762,"line_start":2189,"line_end":2189,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725763,"byte_end":2725797,"line_start":2190,"line_end":2190,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2725838,"byte_end":2725887,"line_start":2192,"line_end":2192,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10200},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726295,"byte_end":2726308,"line_start":2204,"line_end":2204,"column_start":15,"column_end":28},"name":"_mm_comilt_sd","qualname":"::core_arch::x86::sse2::_mm_comilt_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726146,"byte_end":2726155,"line_start":2200,"line_end":2200,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726156,"byte_end":2726190,"line_start":2201,"line_end":2201,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726231,"byte_end":2726280,"line_start":2203,"line_end":2203,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10202},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726697,"byte_end":2726710,"line_start":2215,"line_end":2215,"column_start":15,"column_end":28},"name":"_mm_comile_sd","qualname":"::core_arch::x86::sse2::_mm_comile_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for less-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726548,"byte_end":2726557,"line_start":2211,"line_end":2211,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726558,"byte_end":2726592,"line_start":2212,"line_end":2212,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726633,"byte_end":2726682,"line_start":2214,"line_end":2214,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10204},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727093,"byte_end":2727106,"line_start":2226,"line_end":2226,"column_start":15,"column_end":28},"name":"_mm_comigt_sd","qualname":"::core_arch::x86::sse2::_mm_comigt_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726944,"byte_end":2726953,"line_start":2222,"line_end":2222,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2726954,"byte_end":2726988,"line_start":2223,"line_end":2223,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727029,"byte_end":2727078,"line_start":2225,"line_end":2225,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10206},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727498,"byte_end":2727511,"line_start":2237,"line_end":2237,"column_start":15,"column_end":28},"name":"_mm_comige_sd","qualname":"::core_arch::x86::sse2::_mm_comige_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for greater-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727349,"byte_end":2727358,"line_start":2233,"line_end":2233,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727359,"byte_end":2727393,"line_start":2234,"line_end":2234,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727434,"byte_end":2727483,"line_start":2236,"line_end":2236,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10208},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727892,"byte_end":2727906,"line_start":2248,"line_end":2248,"column_start":15,"column_end":29},"name":"_mm_comineq_sd","qualname":"::core_arch::x86::sse2::_mm_comineq_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for not-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727743,"byte_end":2727752,"line_start":2244,"line_end":2244,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727753,"byte_end":2727787,"line_start":2245,"line_end":2245,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2727828,"byte_end":2727877,"line_start":2247,"line_end":2247,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10210},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728288,"byte_end":2728302,"line_start":2259,"line_end":2259,"column_start":15,"column_end":29},"name":"_mm_ucomieq_sd","qualname":"::core_arch::x86::sse2::_mm_ucomieq_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728138,"byte_end":2728147,"line_start":2255,"line_end":2255,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728148,"byte_end":2728182,"line_start":2256,"line_end":2256,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728224,"byte_end":2728273,"line_start":2258,"line_end":2258,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10212},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728685,"byte_end":2728699,"line_start":2270,"line_end":2270,"column_start":15,"column_end":29},"name":"_mm_ucomilt_sd","qualname":"::core_arch::x86::sse2::_mm_ucomilt_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for less-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728535,"byte_end":2728544,"line_start":2266,"line_end":2266,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728545,"byte_end":2728579,"line_start":2267,"line_end":2267,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728621,"byte_end":2728670,"line_start":2269,"line_end":2269,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10214},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729091,"byte_end":2729105,"line_start":2281,"line_end":2281,"column_start":15,"column_end":29},"name":"_mm_ucomile_sd","qualname":"::core_arch::x86::sse2::_mm_ucomile_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for less-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728941,"byte_end":2728950,"line_start":2277,"line_end":2277,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2728951,"byte_end":2728985,"line_start":2278,"line_end":2278,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729027,"byte_end":2729076,"line_start":2280,"line_end":2280,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10216},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729491,"byte_end":2729505,"line_start":2292,"line_end":2292,"column_start":15,"column_end":29},"name":"_mm_ucomigt_sd","qualname":"::core_arch::x86::sse2::_mm_ucomigt_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729341,"byte_end":2729350,"line_start":2288,"line_end":2288,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729351,"byte_end":2729385,"line_start":2289,"line_end":2289,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729427,"byte_end":2729476,"line_start":2291,"line_end":2291,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10218},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729900,"byte_end":2729914,"line_start":2303,"line_end":2303,"column_start":15,"column_end":29},"name":"_mm_ucomige_sd","qualname":"::core_arch::x86::sse2::_mm_ucomige_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for greater-than-or-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729750,"byte_end":2729759,"line_start":2299,"line_end":2299,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729760,"byte_end":2729794,"line_start":2300,"line_end":2300,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2729836,"byte_end":2729885,"line_start":2302,"line_end":2302,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10220},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730298,"byte_end":2730313,"line_start":2314,"line_end":2314,"column_start":15,"column_end":30},"name":"_mm_ucomineq_sd","qualname":"::core_arch::x86::sse2::_mm_ucomineq_sd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower element of `a` and `b` for not-equal.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730148,"byte_end":2730157,"line_start":2310,"line_end":2310,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730158,"byte_end":2730192,"line_start":2311,"line_end":2311,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730234,"byte_end":2730283,"line_start":2313,"line_end":2313,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10222},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730776,"byte_end":2730788,"line_start":2326,"line_end":2326,"column_start":15,"column_end":27},"name":"_mm_cvtpd_ps","qualname":"::core_arch::x86::sse2::_mm_cvtpd_ps","value":"fn (a: __m128d) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in \"a\" to\n packed single-precision (32-bit) floating-point elements","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730625,"byte_end":2730634,"line_start":2322,"line_end":2322,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730635,"byte_end":2730669,"line_start":2323,"line_end":2323,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2730712,"byte_end":2730761,"line_start":2325,"line_end":2325,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10224},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731242,"byte_end":2731254,"line_start":2339,"line_end":2339,"column_start":15,"column_end":27},"name":"_mm_cvtps_pd","qualname":"::core_arch::x86::sse2::_mm_cvtps_pd","value":"fn (a: __m128) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a` to\n packed\n double-precision (64-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731091,"byte_end":2731100,"line_start":2335,"line_end":2335,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731101,"byte_end":2731135,"line_start":2336,"line_end":2336,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731178,"byte_end":2731227,"line_start":2338,"line_end":2338,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10226},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731673,"byte_end":2731688,"line_start":2351,"line_end":2351,"column_start":15,"column_end":30},"name":"_mm_cvtpd_epi32","qualname":"::core_arch::x86::sse2::_mm_cvtpd_epi32","value":"fn (a: __m128d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a` to\n packed 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731522,"byte_end":2731531,"line_start":2347,"line_end":2347,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731532,"byte_end":2731566,"line_start":2348,"line_end":2348,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731609,"byte_end":2731658,"line_start":2350,"line_end":2350,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10228},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732112,"byte_end":2732126,"line_start":2363,"line_end":2363,"column_start":15,"column_end":29},"name":"_mm_cvtsd_si32","qualname":"::core_arch::x86::sse2::_mm_cvtsd_si32","value":"fn (a: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in a to\n a 32-bit integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731961,"byte_end":2731970,"line_start":2359,"line_end":2359,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2731971,"byte_end":2732005,"line_start":2360,"line_end":2360,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732048,"byte_end":2732097,"line_start":2362,"line_end":2362,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10230},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732713,"byte_end":2732725,"line_start":2377,"line_end":2377,"column_start":15,"column_end":27},"name":"_mm_cvtsd_ss","qualname":"::core_arch::x86::sse2::_mm_cvtsd_ss","value":"fn (a: __m128, b: __m128d) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in `b`\n to a single-precision (32-bit) floating-point element, store the result in\n the lower element of the return value, and copies the upper element from `a`\n to the upper element the return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732562,"byte_end":2732571,"line_start":2373,"line_end":2373,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732572,"byte_end":2732606,"line_start":2374,"line_end":2374,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732649,"byte_end":2732698,"line_start":2376,"line_end":2376,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10232},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733085,"byte_end":2733098,"line_start":2387,"line_end":2387,"column_start":15,"column_end":28},"name":"_mm_cvtsd_f64","qualname":"::core_arch::x86::sse2::_mm_cvtsd_f64","value":"fn (a: __m128d) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the lower double-precision (64-bit) floating-point element of \"a\".","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732976,"byte_end":2732985,"line_start":2384,"line_end":2384,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2732986,"byte_end":2733020,"line_start":2385,"line_end":2385,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733021,"byte_end":2733070,"line_start":2386,"line_end":2386,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10234},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733692,"byte_end":2733704,"line_start":2401,"line_end":2401,"column_start":15,"column_end":27},"name":"_mm_cvtss_sd","qualname":"::core_arch::x86::sse2::_mm_cvtss_sd","value":"fn (a: __m128d, b: __m128) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower single-precision (32-bit) floating-point element in `b`\n to a double-precision (64-bit) floating-point element, store the result in\n the lower element of the return value, and copies the upper element from `a`\n to the upper element the return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733541,"byte_end":2733550,"line_start":2397,"line_end":2397,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733551,"byte_end":2733585,"line_start":2398,"line_end":2398,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2733628,"byte_end":2733677,"line_start":2400,"line_end":2400,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10236},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734156,"byte_end":2734172,"line_start":2413,"line_end":2413,"column_start":15,"column_end":31},"name":"_mm_cvttpd_epi32","qualname":"::core_arch::x86::sse2::_mm_cvttpd_epi32","value":"fn (a: __m128d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a` to\n packed 32-bit integers with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734004,"byte_end":2734013,"line_start":2409,"line_end":2409,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734014,"byte_end":2734048,"line_start":2410,"line_end":2410,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734092,"byte_end":2734141,"line_start":2412,"line_end":2412,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10238},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734617,"byte_end":2734632,"line_start":2425,"line_end":2425,"column_start":15,"column_end":30},"name":"_mm_cvttsd_si32","qualname":"::core_arch::x86::sse2::_mm_cvttsd_si32","value":"fn (a: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in `a`\n to a 32-bit integer with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734465,"byte_end":2734474,"line_start":2421,"line_end":2421,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734475,"byte_end":2734509,"line_start":2422,"line_end":2422,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734553,"byte_end":2734602,"line_start":2424,"line_end":2424,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10240},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735067,"byte_end":2735083,"line_start":2437,"line_end":2437,"column_start":15,"column_end":31},"name":"_mm_cvttps_epi32","qualname":"::core_arch::x86::sse2::_mm_cvttps_epi32","value":"fn (a: __m128) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a` to\n packed 32-bit integers with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734915,"byte_end":2734924,"line_start":2433,"line_end":2433,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2734925,"byte_end":2734959,"line_start":2434,"line_end":2434,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735003,"byte_end":2735052,"line_start":2436,"line_end":2436,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10242},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735483,"byte_end":2735493,"line_start":2448,"line_end":2448,"column_start":15,"column_end":25},"name":"_mm_set_sd","qualname":"::core_arch::x86::sse2::_mm_set_sd","value":"fn (a: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Copies double-precision (64-bit) floating-point element `a` to the lower\n element of the packed 64-bit return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735374,"byte_end":2735383,"line_start":2445,"line_end":2445,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735384,"byte_end":2735418,"line_start":2446,"line_end":2446,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735419,"byte_end":2735468,"line_start":2447,"line_end":2447,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10244},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735867,"byte_end":2735878,"line_start":2459,"line_end":2459,"column_start":15,"column_end":26},"name":"_mm_set1_pd","qualname":"::core_arch::x86::sse2::_mm_set1_pd","value":"fn (a: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts double-precision (64-bit) floating-point value a to all elements\n of the return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735758,"byte_end":2735767,"line_start":2456,"line_end":2456,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735768,"byte_end":2735802,"line_start":2457,"line_end":2457,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2735803,"byte_end":2735852,"line_start":2458,"line_end":2458,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10246},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736250,"byte_end":2736261,"line_start":2470,"line_end":2470,"column_start":15,"column_end":26},"name":"_mm_set_pd1","qualname":"::core_arch::x86::sse2::_mm_set_pd1","value":"fn (a: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts double-precision (64-bit) floating-point value a to all elements\n of the return value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736141,"byte_end":2736150,"line_start":2467,"line_end":2467,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736151,"byte_end":2736185,"line_start":2468,"line_end":2468,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736186,"byte_end":2736235,"line_start":2469,"line_end":2469,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10248},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736643,"byte_end":2736653,"line_start":2481,"line_end":2481,"column_start":15,"column_end":25},"name":"_mm_set_pd","qualname":"::core_arch::x86::sse2::_mm_set_pd","value":"fn (a: f64, b: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed double-precision (64-bit) floating-point elements in the return\n value with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736534,"byte_end":2736543,"line_start":2478,"line_end":2478,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736544,"byte_end":2736578,"line_start":2479,"line_end":2479,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736579,"byte_end":2736628,"line_start":2480,"line_end":2480,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10250},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737058,"byte_end":2737069,"line_start":2492,"line_end":2492,"column_start":15,"column_end":26},"name":"_mm_setr_pd","qualname":"::core_arch::x86::sse2::_mm_setr_pd","value":"fn (a: f64, b: f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed double-precision (64-bit) floating-point elements in the return\n value with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736949,"byte_end":2736958,"line_start":2489,"line_end":2489,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736959,"byte_end":2736993,"line_start":2490,"line_end":2490,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2736994,"byte_end":2737043,"line_start":2491,"line_end":2491,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10252},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737499,"byte_end":2737513,"line_start":2504,"line_end":2504,"column_start":15,"column_end":29},"name":"_mm_setzero_pd","qualname":"::core_arch::x86::sse2::_mm_setzero_pd","value":"fn () -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns packed double-precision (64-bit) floating-point elements with all\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737327,"byte_end":2737336,"line_start":2500,"line_end":2500,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737337,"byte_end":2737371,"line_start":2501,"line_end":2501,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737435,"byte_end":2737484,"line_start":2503,"line_end":2503,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10254},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738010,"byte_end":2738025,"line_start":2518,"line_end":2518,"column_start":15,"column_end":30},"name":"_mm_movemask_pd","qualname":"::core_arch::x86::sse2::_mm_movemask_pd","value":"fn (a: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns a mask of the most significant bit of each element in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737859,"byte_end":2737868,"line_start":2514,"line_end":2514,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737869,"byte_end":2737903,"line_start":2515,"line_end":2515,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2737946,"byte_end":2737995,"line_start":2517,"line_end":2517,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10256},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738607,"byte_end":2738618,"line_start":2533,"line_end":2533,"column_start":15,"column_end":26},"name":"_mm_load_pd","qualname":"::core_arch::x86::sse2::_mm_load_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from memory into the returned vector.\n `mem_addr` must be aligned on a 16-byte boundary or a general-protection\n exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738421,"byte_end":2738430,"line_start":2528,"line_end":2528,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738431,"byte_end":2738465,"line_start":2529,"line_end":2529,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738506,"byte_end":2738555,"line_start":2531,"line_end":2531,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738556,"byte_end":2738592,"line_start":2532,"line_end":2532,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":10258},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739074,"byte_end":2739085,"line_start":2545,"line_end":2545,"column_start":15,"column_end":26},"name":"_mm_load_sd","qualname":"::core_arch::x86::sse2::_mm_load_sd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a 64-bit double-precision value to the low element of a\n 128-bit integer vector and clears the upper element.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738926,"byte_end":2738935,"line_start":2541,"line_end":2541,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2738936,"byte_end":2738970,"line_start":2542,"line_end":2542,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739010,"byte_end":2739059,"line_start":2544,"line_end":2544,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10260},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739600,"byte_end":2739612,"line_start":2558,"line_end":2558,"column_start":15,"column_end":27},"name":"_mm_loadh_pd","qualname":"::core_arch::x86::sse2::_mm_loadh_pd","value":"fn (a: __m128d, mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision value into the high-order bits of a 128-bit\n vector of `[2 x double]`. The low-order bits are copied from the low-order\n bits of the first operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739451,"byte_end":2739460,"line_start":2554,"line_end":2554,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739461,"byte_end":2739495,"line_start":2555,"line_end":2555,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2739536,"byte_end":2739585,"line_start":2557,"line_end":2557,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10262},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740156,"byte_end":2740168,"line_start":2571,"line_end":2571,"column_start":15,"column_end":27},"name":"_mm_loadl_pd","qualname":"::core_arch::x86::sse2::_mm_loadl_pd","value":"fn (a: __m128d, mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision value into the low-order bits of a 128-bit\n vector of `[2 x double]`. The high-order bits are copied from the\n high-order bits of the first operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740007,"byte_end":2740016,"line_start":2567,"line_end":2567,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740017,"byte_end":2740051,"line_start":2568,"line_end":2568,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740092,"byte_end":2740141,"line_start":2570,"line_end":2570,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10264},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740786,"byte_end":2740799,"line_start":2586,"line_end":2586,"column_start":15,"column_end":28},"name":"_mm_stream_pd","qualname":"::core_arch::x86::sse2::_mm_stream_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a 128-bit floating point vector of `[2 x double]` to a 128-bit\n aligned memory location.\n To minimize caching, the data is flagged as non-temporal (unlikely to be\n used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740582,"byte_end":2740591,"line_start":2581,"line_end":2581,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740592,"byte_end":2740626,"line_start":2582,"line_end":2582,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740685,"byte_end":2740734,"line_start":2584,"line_end":2584,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2740735,"byte_end":2740771,"line_start":2585,"line_end":2585,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":10266},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741289,"byte_end":2741301,"line_start":2598,"line_end":2598,"column_start":15,"column_end":27},"name":"_mm_store_sd","qualname":"::core_arch::x86::sse2::_mm_store_sd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a\n memory location.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741107,"byte_end":2741116,"line_start":2594,"line_end":2594,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741117,"byte_end":2741151,"line_start":2595,"line_end":2595,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741225,"byte_end":2741274,"line_start":2597,"line_end":2597,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10268},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741897,"byte_end":2741909,"line_start":2612,"line_end":2612,"column_start":15,"column_end":27},"name":"_mm_store_pd","qualname":"::core_arch::x86::sse2::_mm_store_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 128-bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from `a` into memory. `mem_addr` must be aligned\n on a 16-byte boundary or a general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741711,"byte_end":2741720,"line_start":2607,"line_end":2607,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741721,"byte_end":2741755,"line_start":2608,"line_end":2608,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741796,"byte_end":2741845,"line_start":2610,"line_end":2610,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2741846,"byte_end":2741882,"line_start":2611,"line_end":2611,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":10270},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2742462,"byte_end":2742475,"line_start":2625,"line_end":2625,"column_start":15,"column_end":28},"name":"_mm_storeu_pd","qualname":"::core_arch::x86::sse2::_mm_storeu_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 128-bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2742288,"byte_end":2742297,"line_start":2621,"line_end":2621,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2742298,"byte_end":2742332,"line_start":2622,"line_end":2622,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2742398,"byte_end":2742447,"line_start":2624,"line_end":2624,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10272},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743037,"byte_end":2743050,"line_start":2638,"line_end":2638,"column_start":15,"column_end":28},"name":"_mm_store1_pd","qualname":"::core_arch::x86::sse2::_mm_store1_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower double-precision (64-bit) floating-point element from `a`\n into 2 contiguous elements in memory. `mem_addr` must be aligned on a\n 16-byte boundary or a general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2742891,"byte_end":2742900,"line_start":2634,"line_end":2634,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2742901,"byte_end":2742935,"line_start":2635,"line_end":2635,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2742936,"byte_end":2742985,"line_start":2636,"line_end":2636,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2742986,"byte_end":2743022,"line_start":2637,"line_end":2637,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":10274},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743661,"byte_end":2743674,"line_start":2652,"line_end":2652,"column_start":15,"column_end":28},"name":"_mm_store_pd1","qualname":"::core_arch::x86::sse2::_mm_store_pd1","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower double-precision (64-bit) floating-point element from `a`\n into 2 contiguous elements in memory. `mem_addr` must be aligned on a\n 16-byte boundary or a general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743515,"byte_end":2743524,"line_start":2648,"line_end":2648,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743525,"byte_end":2743559,"line_start":2649,"line_end":2649,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743560,"byte_end":2743609,"line_start":2650,"line_end":2650,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2743610,"byte_end":2743646,"line_start":2651,"line_end":2651,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":10276},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744274,"byte_end":2744287,"line_start":2667,"line_end":2667,"column_start":15,"column_end":28},"name":"_mm_storer_pd","qualname":"::core_arch::x86::sse2::_mm_storer_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 2 double-precision (64-bit) floating-point elements from `a` into\n memory in reverse order.\n `mem_addr` must be aligned on a 16-byte boundary or a general-protection\n exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744128,"byte_end":2744137,"line_start":2663,"line_end":2663,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744138,"byte_end":2744172,"line_start":2664,"line_end":2664,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744173,"byte_end":2744222,"line_start":2665,"line_end":2665,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744223,"byte_end":2744259,"line_start":2666,"line_end":2666,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":10278},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744801,"byte_end":2744814,"line_start":2680,"line_end":2680,"column_start":15,"column_end":28},"name":"_mm_storeh_pd","qualname":"::core_arch::x86::sse2::_mm_storeh_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the upper 64 bits of a 128-bit vector of `[2 x double]` to a\n memory location.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744619,"byte_end":2744628,"line_start":2676,"line_end":2676,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744629,"byte_end":2744663,"line_start":2677,"line_end":2677,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2744737,"byte_end":2744786,"line_start":2679,"line_end":2679,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10280},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745277,"byte_end":2745290,"line_start":2692,"line_end":2692,"column_start":15,"column_end":28},"name":"_mm_storel_pd","qualname":"::core_arch::x86::sse2::_mm_storel_pd","value":"fn (mem_addr: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the lower 64 bits of a 128-bit vector of `[2 x double]` to a\n memory location.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745095,"byte_end":2745104,"line_start":2688,"line_end":2688,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745105,"byte_end":2745139,"line_start":2689,"line_end":2689,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745213,"byte_end":2745262,"line_start":2691,"line_end":2691,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10282},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745782,"byte_end":2745794,"line_start":2704,"line_end":2704,"column_start":15,"column_end":27},"name":"_mm_load1_pd","qualname":"::core_arch::x86::sse2::_mm_load1_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision (64-bit) floating-point element from memory\n into both elements of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745593,"byte_end":2745602,"line_start":2700,"line_end":2700,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745603,"byte_end":2745637,"line_start":2701,"line_end":2701,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2745718,"byte_end":2745767,"line_start":2703,"line_end":2703,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10284},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2746289,"byte_end":2746301,"line_start":2717,"line_end":2717,"column_start":15,"column_end":27},"name":"_mm_load_pd1","qualname":"::core_arch::x86::sse2::_mm_load_pd1","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision (64-bit) floating-point element from memory\n into both elements of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2746107,"byte_end":2746116,"line_start":2713,"line_end":2713,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2746117,"byte_end":2746151,"line_start":2714,"line_end":2714,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2746225,"byte_end":2746274,"line_start":2716,"line_end":2716,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10286},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2746855,"byte_end":2746867,"line_start":2730,"line_end":2730,"column_start":15,"column_end":27},"name":"_mm_loadr_pd","qualname":"::core_arch::x86::sse2::_mm_loadr_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads 2 double-precision (64-bit) floating-point elements from memory into\n the returned vector in reverse order. `mem_addr` must be aligned on a\n 16-byte boundary or a general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2746706,"byte_end":2746715,"line_start":2726,"line_end":2726,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2746716,"byte_end":2746750,"line_start":2727,"line_end":2727,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2746791,"byte_end":2746840,"line_start":2729,"line_end":2729,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10288},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747440,"byte_end":2747452,"line_start":2744,"line_end":2744,"column_start":15,"column_end":27},"name":"_mm_loadu_pd","qualname":"::core_arch::x86::sse2::_mm_loadu_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from memory into the returned vector.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747291,"byte_end":2747300,"line_start":2740,"line_end":2740,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747301,"byte_end":2747335,"line_start":2741,"line_end":2741,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747376,"byte_end":2747425,"line_start":2743,"line_end":2743,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10290},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748170,"byte_end":2748184,"line_start":2764,"line_end":2764,"column_start":15,"column_end":29},"name":"_mm_shuffle_pd","qualname":"::core_arch::x86::sse2::_mm_shuffle_pd","value":"fn (a: __m128d, b: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 128-bit floating-point vector of `[2 x double]` from two\n 128-bit vector parameters of `[2 x double]`, using the immediate-value\n parameter as a specifier.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747979,"byte_end":2747988,"line_start":2759,"line_end":2759,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2747989,"byte_end":2748023,"line_start":2760,"line_end":2760,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748074,"byte_end":2748105,"line_start":2762,"line_end":2762,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748106,"byte_end":2748155,"line_start":2763,"line_end":2763,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10292},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748920,"byte_end":2748931,"line_start":2782,"line_end":2782,"column_start":15,"column_end":26},"name":"_mm_move_sd","qualname":"::core_arch::x86::sse2::_mm_move_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 128-bit floating-point vector of `[2 x double]`. The lower\n 64 bits are set to the lower 64 bits of the second parameter. The upper\n 64 bits are set to the upper 64 bits of the first parameter.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748772,"byte_end":2748781,"line_start":2778,"line_end":2778,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748782,"byte_end":2748816,"line_start":2779,"line_end":2779,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2748856,"byte_end":2748905,"line_start":2781,"line_end":2781,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10294},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749370,"byte_end":2749383,"line_start":2793,"line_end":2793,"column_start":15,"column_end":28},"name":"_mm_castpd_ps","qualname":"::core_arch::x86::sse2::_mm_castpd_ps","value":"fn (a: __m128d) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit\n floating-point vector of `[4 x float]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749261,"byte_end":2749270,"line_start":2790,"line_end":2790,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749271,"byte_end":2749305,"line_start":2791,"line_end":2791,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749306,"byte_end":2749355,"line_start":2792,"line_end":2792,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10296},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749749,"byte_end":2749765,"line_start":2804,"line_end":2804,"column_start":15,"column_end":31},"name":"_mm_castpd_si128","qualname":"::core_arch::x86::sse2::_mm_castpd_si128","value":"fn (a: __m128d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit floating-point vector of `[2 x double]` into a 128-bit\n integer vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749640,"byte_end":2749649,"line_start":2801,"line_end":2801,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749650,"byte_end":2749684,"line_start":2802,"line_end":2802,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2749685,"byte_end":2749734,"line_start":2803,"line_end":2803,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10298},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750153,"byte_end":2750166,"line_start":2815,"line_end":2815,"column_start":15,"column_end":28},"name":"_mm_castps_pd","qualname":"::core_arch::x86::sse2::_mm_castps_pd","value":"fn (a: __m128) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit\n floating-point vector of `[2 x double]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750044,"byte_end":2750053,"line_start":2812,"line_end":2812,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750054,"byte_end":2750088,"line_start":2813,"line_end":2813,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750089,"byte_end":2750138,"line_start":2814,"line_end":2814,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10300},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750531,"byte_end":2750547,"line_start":2826,"line_end":2826,"column_start":15,"column_end":31},"name":"_mm_castps_si128","qualname":"::core_arch::x86::sse2::_mm_castps_si128","value":"fn (a: __m128) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit floating-point vector of `[4 x float]` into a 128-bit\n integer vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750422,"byte_end":2750431,"line_start":2823,"line_end":2823,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750432,"byte_end":2750466,"line_start":2824,"line_end":2824,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750467,"byte_end":2750516,"line_start":2825,"line_end":2825,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10302},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750913,"byte_end":2750929,"line_start":2837,"line_end":2837,"column_start":15,"column_end":31},"name":"_mm_castsi128_pd","qualname":"::core_arch::x86::sse2::_mm_castsi128_pd","value":"fn (a: __m128i) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit integer vector into a 128-bit floating-point vector\n of `[2 x double]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750804,"byte_end":2750813,"line_start":2834,"line_end":2834,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750814,"byte_end":2750848,"line_start":2835,"line_end":2835,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2750849,"byte_end":2750898,"line_start":2836,"line_end":2836,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10304},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751295,"byte_end":2751311,"line_start":2848,"line_end":2848,"column_start":15,"column_end":31},"name":"_mm_castsi128_ps","qualname":"::core_arch::x86::sse2::_mm_castsi128_ps","value":"fn (a: __m128i) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Casts a 128-bit integer vector into a 128-bit floating-point vector\n of `[4 x float]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751186,"byte_end":2751195,"line_start":2845,"line_end":2845,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751196,"byte_end":2751230,"line_start":2846,"line_end":2846,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751231,"byte_end":2751280,"line_start":2847,"line_end":2847,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10306},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751642,"byte_end":2751658,"line_start":2858,"line_end":2858,"column_start":15,"column_end":31},"name":"_mm_undefined_pd","qualname":"::core_arch::x86::sse2::_mm_undefined_pd","value":"fn () -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m128d with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751533,"byte_end":2751542,"line_start":2855,"line_end":2855,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751543,"byte_end":2751577,"line_start":2856,"line_end":2856,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751578,"byte_end":2751627,"line_start":2857,"line_end":2857,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10308},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752085,"byte_end":2752104,"line_start":2869,"line_end":2869,"column_start":15,"column_end":34},"name":"_mm_undefined_si128","qualname":"::core_arch::x86::sse2::_mm_undefined_si128","value":"fn () -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m128i with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751976,"byte_end":2751985,"line_start":2866,"line_end":2866,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2751986,"byte_end":2752020,"line_start":2867,"line_end":2867,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752021,"byte_end":2752070,"line_start":2868,"line_end":2868,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10310},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752809,"byte_end":2752824,"line_start":2886,"line_end":2886,"column_start":15,"column_end":30},"name":"_mm_unpackhi_pd","qualname":"::core_arch::x86::sse2::_mm_unpackhi_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" The resulting `__m128d` element is composed by the low-order values of\n the two `__m128d` interleaved input elements, i.e.:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752658,"byte_end":2752667,"line_start":2882,"line_end":2882,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752668,"byte_end":2752702,"line_start":2883,"line_end":2883,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2752745,"byte_end":2752794,"line_start":2885,"line_end":2885,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10312},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753489,"byte_end":2753504,"line_start":2901,"line_end":2901,"column_start":15,"column_end":30},"name":"_mm_unpacklo_pd","qualname":"::core_arch::x86::sse2::_mm_unpacklo_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" The resulting `__m128d` element is composed by the high-order values of\n the two `__m128d` interleaved input elements, i.e.:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753306,"byte_end":2753315,"line_start":2897,"line_end":2897,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753316,"byte_end":2753350,"line_start":2898,"line_end":2898,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753425,"byte_end":2753474,"line_start":2900,"line_end":2900,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10314},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753778,"byte_end":2753790,"line_start":2910,"line_end":2910,"column_start":15,"column_end":27},"name":"_mm_add_si64","qualname":"::core_arch::x86::sse2::_mm_add_si64","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds two signed or unsigned 64-bit integer values, returning the\n lower 64 bits of the sum.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753676,"byte_end":2753685,"line_start":2907,"line_end":2907,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753686,"byte_end":2753724,"line_start":2908,"line_end":2908,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10316},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754102,"byte_end":2754114,"line_start":2920,"line_end":2920,"column_start":15,"column_end":27},"name":"_mm_mul_su32","qualname":"::core_arch::x86::sse2::_mm_mul_su32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies 32-bit unsigned integer values contained in the lower bits\n of the two 64-bit integer vectors and returns the 64-bit unsigned\n product.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2753998,"byte_end":2754007,"line_start":2917,"line_end":2917,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754008,"byte_end":2754046,"line_start":2918,"line_end":2918,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10318},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754401,"byte_end":2754413,"line_start":2929,"line_end":2929,"column_start":15,"column_end":27},"name":"_mm_sub_si64","qualname":"::core_arch::x86::sse2::_mm_sub_si64","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtracts signed or unsigned 64-bit integer values and writes the\n difference to the corresponding bits in the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754299,"byte_end":2754308,"line_start":2926,"line_end":2926,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754309,"byte_end":2754347,"line_start":2927,"line_end":2927,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10320},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754760,"byte_end":2754774,"line_start":2939,"line_end":2939,"column_start":15,"column_end":29},"name":"_mm_cvtpi32_pd","qualname":"::core_arch::x86::sse2::_mm_cvtpi32_pd","value":"fn (a: __m64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Converts the two signed 32-bit integer elements of a 64-bit vector of\n `[2 x i32]` into two double-precision floating-point values, returned in a\n 128-bit vector of `[2 x double]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754655,"byte_end":2754664,"line_start":2936,"line_end":2936,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754665,"byte_end":2754703,"line_start":2937,"line_end":2937,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10322},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755033,"byte_end":2755046,"line_start":2948,"line_end":2948,"column_start":15,"column_end":28},"name":"_mm_set_epi64","qualname":"::core_arch::x86::sse2::_mm_set_epi64","value":"fn (e1: __m64, e0: __m64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Initializes both 64-bit values in a 128-bit vector of `[2 x i64]` with\n the specified 64-bit integer values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754933,"byte_end":2754942,"line_start":2945,"line_end":2945,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2754943,"byte_end":2754981,"line_start":2946,"line_end":2946,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10324},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755334,"byte_end":2755348,"line_start":2957,"line_end":2957,"column_start":15,"column_end":29},"name":"_mm_set1_epi64","qualname":"::core_arch::x86::sse2::_mm_set1_epi64","value":"fn (a: __m64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Initializes both values in a 128-bit vector of `[2 x i64]` with the\n specified 64-bit value.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755234,"byte_end":2755243,"line_start":2954,"line_end":2954,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755244,"byte_end":2755282,"line_start":2955,"line_end":2955,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10326},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755639,"byte_end":2755653,"line_start":2966,"line_end":2966,"column_start":15,"column_end":29},"name":"_mm_setr_epi64","qualname":"::core_arch::x86::sse2::_mm_setr_epi64","value":"fn (e1: __m64, e0: __m64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 128-bit integer vector, initialized in reverse order\n with the specified 64-bit integral values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755539,"byte_end":2755548,"line_start":2963,"line_end":2963,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755549,"byte_end":2755587,"line_start":2964,"line_end":2964,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10328},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755971,"byte_end":2755988,"line_start":2976,"line_end":2976,"column_start":15,"column_end":32},"name":"_mm_movepi64_pi64","qualname":"::core_arch::x86::sse2::_mm_movepi64_pi64","value":"fn (a: __m128i) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Returns the lower 64 bits of a 128-bit integer vector as a 64-bit\n integer.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755824,"byte_end":2755833,"line_start":2972,"line_end":2972,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2755834,"byte_end":2755872,"line_start":2973,"line_end":2973,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10330},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756303,"byte_end":2756320,"line_start":2986,"line_end":2986,"column_start":15,"column_end":32},"name":"_mm_movpi64_epi64","qualname":"::core_arch::x86::sse2::_mm_movpi64_epi64","value":"fn (a: __m64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Moves the 64-bit operand to a 128-bit integer vector, zeroing the\n upper bits.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756156,"byte_end":2756165,"line_start":2982,"line_end":2982,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756166,"byte_end":2756204,"line_start":2983,"line_end":2983,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10332},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756679,"byte_end":2756693,"line_start":2996,"line_end":2996,"column_start":15,"column_end":29},"name":"_mm_cvtpd_pi32","qualname":"::core_arch::x86::sse2::_mm_cvtpd_pi32","value":"fn (a: __m128d) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two double-precision floating-point elements of a\n 128-bit vector of `[2 x double]` into two signed 32-bit integer values,\n returned in a 64-bit vector of `[2 x i32]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756574,"byte_end":2756583,"line_start":2993,"line_end":2993,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2756584,"byte_end":2756622,"line_start":2994,"line_end":2994,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10334},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757176,"byte_end":2757191,"line_start":3008,"line_end":3008,"column_start":15,"column_end":30},"name":"_mm_cvttpd_pi32","qualname":"::core_arch::x86::sse2::_mm_cvttpd_pi32","value":"fn (a: __m128d) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts the two double-precision floating-point elements of a\n 128-bit vector of `[2 x double]` into two signed 32-bit integer values,\n returned in a 64-bit vector of `[2 x i32]`.\n If the result of either conversion is inexact, the result is truncated\n (rounded towards zero) regardless of the current MXCSR setting.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757070,"byte_end":2757079,"line_start":3005,"line_end":3005,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs","byte_start":2757080,"byte_end":2757118,"line_start":3006,"line_end":3006,"column_start":1,"column_end":39}}]},{"kind":"Function","id":{"krate":0,"index":10358},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830073,"byte_end":2830086,"line_start":23,"line_end":23,"column_start":15,"column_end":28},"name":"_mm_addsub_ps","qualname":"::core_arch::x86::sse3::_mm_addsub_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Alternatively add and subtract packed single-precision (32-bit)\n floating-point elements in `a` to/from packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2829922,"byte_end":2829931,"line_start":19,"line_end":19,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2829932,"byte_end":2829966,"line_start":20,"line_end":20,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830009,"byte_end":2830058,"line_start":22,"line_end":22,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10360},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830543,"byte_end":2830556,"line_start":35,"line_end":35,"column_start":15,"column_end":28},"name":"_mm_addsub_pd","qualname":"::core_arch::x86::sse3::_mm_addsub_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Alternatively add and subtract packed double-precision (64-bit)\n floating-point elements in `a` to/from packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830392,"byte_end":2830401,"line_start":31,"line_end":31,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830402,"byte_end":2830436,"line_start":32,"line_end":32,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830479,"byte_end":2830528,"line_start":34,"line_end":34,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10362},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831009,"byte_end":2831020,"line_start":47,"line_end":47,"column_start":15,"column_end":26},"name":"_mm_hadd_pd","qualname":"::core_arch::x86::sse3::_mm_hadd_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of double-precision (64-bit)\n floating-point elements in `a` and `b`, and pack the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830860,"byte_end":2830869,"line_start":43,"line_end":43,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830870,"byte_end":2830904,"line_start":44,"line_end":44,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2830945,"byte_end":2830994,"line_start":46,"line_end":46,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10364},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831471,"byte_end":2831482,"line_start":59,"line_end":59,"column_start":15,"column_end":26},"name":"_mm_hadd_ps","qualname":"::core_arch::x86::sse3::_mm_hadd_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of single-precision (32-bit)\n floating-point elements in `a` and `b`, and pack the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831322,"byte_end":2831331,"line_start":55,"line_end":55,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831332,"byte_end":2831366,"line_start":56,"line_end":56,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831407,"byte_end":2831456,"line_start":58,"line_end":58,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10366},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831934,"byte_end":2831945,"line_start":71,"line_end":71,"column_start":15,"column_end":26},"name":"_mm_hsub_pd","qualname":"::core_arch::x86::sse3::_mm_hsub_pd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract adjacent pairs of double-precision (64-bit)\n floating-point elements in `a` and `b`, and pack the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831785,"byte_end":2831794,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831795,"byte_end":2831829,"line_start":68,"line_end":68,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2831870,"byte_end":2831919,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10368},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2832396,"byte_end":2832407,"line_start":83,"line_end":83,"column_start":15,"column_end":26},"name":"_mm_hsub_ps","qualname":"::core_arch::x86::sse3::_mm_hsub_ps","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of single-precision (32-bit)\n floating-point elements in `a` and `b`, and pack the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2832247,"byte_end":2832256,"line_start":79,"line_end":79,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2832257,"byte_end":2832291,"line_start":80,"line_end":80,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2832332,"byte_end":2832381,"line_start":82,"line_end":82,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10370},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2832894,"byte_end":2832909,"line_start":96,"line_end":96,"column_start":15,"column_end":30},"name":"_mm_lddqu_si128","qualname":"::core_arch::x86::sse3::_mm_lddqu_si128","value":"fn (mem_addr: *const __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads 128-bits of integer data from unaligned memory.\n This intrinsic may perform better than `_mm_loadu_si128`\n when the data crosses a cache line boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2832746,"byte_end":2832755,"line_start":92,"line_end":92,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2832756,"byte_end":2832790,"line_start":93,"line_end":93,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2832830,"byte_end":2832879,"line_start":95,"line_end":95,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10372},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2833345,"byte_end":2833359,"line_start":108,"line_end":108,"column_start":15,"column_end":29},"name":"_mm_movedup_pd","qualname":"::core_arch::x86::sse3::_mm_movedup_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Duplicate the low double-precision (64-bit) floating-point element\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2833195,"byte_end":2833204,"line_start":104,"line_end":104,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2833205,"byte_end":2833239,"line_start":105,"line_end":105,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2833281,"byte_end":2833330,"line_start":107,"line_end":107,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10374},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2833799,"byte_end":2833813,"line_start":120,"line_end":120,"column_start":15,"column_end":29},"name":"_mm_loaddup_pd","qualname":"::core_arch::x86::sse3::_mm_loaddup_pd","value":"fn (mem_addr: *const f64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads a double-precision (64-bit) floating-point element from memory\n into both elements of return vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2833649,"byte_end":2833658,"line_start":116,"line_end":116,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2833659,"byte_end":2833693,"line_start":117,"line_end":117,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2833735,"byte_end":2833784,"line_start":119,"line_end":119,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10376},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2834236,"byte_end":2834251,"line_start":132,"line_end":132,"column_start":15,"column_end":30},"name":"_mm_movehdup_ps","qualname":"::core_arch::x86::sse3::_mm_movehdup_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Duplicate odd-indexed single-precision (32-bit) floating-point elements\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2834085,"byte_end":2834094,"line_start":128,"line_end":128,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2834095,"byte_end":2834129,"line_start":129,"line_end":129,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2834172,"byte_end":2834221,"line_start":131,"line_end":131,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10378},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2834674,"byte_end":2834689,"line_start":144,"line_end":144,"column_start":15,"column_end":30},"name":"_mm_moveldup_ps","qualname":"::core_arch::x86::sse3::_mm_moveldup_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Duplicate even-indexed single-precision (32-bit) floating-point elements\n from `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2834523,"byte_end":2834532,"line_start":140,"line_end":140,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2834533,"byte_end":2834567,"line_start":141,"line_end":141,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse3.rs","byte_start":2834610,"byte_end":2834659,"line_start":143,"line_end":143,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10398},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2838846,"byte_end":2838858,"line_start":19,"line_end":19,"column_start":15,"column_end":27},"name":"_mm_abs_epi8","qualname":"::core_arch::x86::ssse3::_mm_abs_epi8","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 8-bit signed integers in `a` and\n return the unsigned results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2838697,"byte_end":2838706,"line_start":15,"line_end":15,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2838707,"byte_end":2838742,"line_start":16,"line_end":16,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2838782,"byte_end":2838831,"line_start":18,"line_end":18,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10400},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2839319,"byte_end":2839332,"line_start":32,"line_end":32,"column_start":15,"column_end":28},"name":"_mm_abs_epi16","qualname":"::core_arch::x86::ssse3::_mm_abs_epi16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of each of the packed 16-bit signed integers in\n `a` and\n return the 16-bit unsigned integer","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2839170,"byte_end":2839179,"line_start":28,"line_end":28,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2839180,"byte_end":2839215,"line_start":29,"line_end":29,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2839255,"byte_end":2839304,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10402},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2839793,"byte_end":2839806,"line_start":45,"line_end":45,"column_start":15,"column_end":28},"name":"_mm_abs_epi32","qualname":"::core_arch::x86::ssse3::_mm_abs_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of each of the packed 32-bit signed integers in\n `a` and\n return the 32-bit unsigned integer","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2839644,"byte_end":2839653,"line_start":41,"line_end":41,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2839654,"byte_end":2839689,"line_start":42,"line_end":42,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2839729,"byte_end":2839778,"line_start":44,"line_end":44,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10404},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2840892,"byte_end":2840908,"line_start":79,"line_end":79,"column_start":15,"column_end":31},"name":"_mm_shuffle_epi8","qualname":"::core_arch::x86::ssse3::_mm_shuffle_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles bytes from `a` according to the content of `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2840742,"byte_end":2840751,"line_start":75,"line_end":75,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2840752,"byte_end":2840787,"line_start":76,"line_end":76,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2840828,"byte_end":2840877,"line_start":78,"line_end":78,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10406},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2841459,"byte_end":2841474,"line_start":92,"line_end":92,"column_start":15,"column_end":30},"name":"_mm_alignr_epi8","qualname":"::core_arch::x86::ssse3::_mm_alignr_epi8","value":"fn (a: __m128i, b: __m128i, n: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Concatenate 16-byte blocks in `a` and `b` into a 32-byte temporary result,\n shift the result right by `n` bytes, and returns the low 16 bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2841268,"byte_end":2841277,"line_start":87,"line_end":87,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2841278,"byte_end":2841313,"line_start":88,"line_end":88,"column_start":1,"column_end":36}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2841363,"byte_end":2841394,"line_start":90,"line_end":90,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2841395,"byte_end":2841444,"line_start":91,"line_end":91,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10410},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2843589,"byte_end":2843603,"line_start":165,"line_end":165,"column_start":15,"column_end":29},"name":"_mm_hadd_epi16","qualname":"::core_arch::x86::ssse3::_mm_hadd_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 128-bit vectors of `[8 x i16]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2843439,"byte_end":2843448,"line_start":161,"line_end":161,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2843449,"byte_end":2843484,"line_start":162,"line_end":162,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2843525,"byte_end":2843574,"line_start":164,"line_end":164,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10412},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2844188,"byte_end":2844203,"line_start":178,"line_end":178,"column_start":15,"column_end":30},"name":"_mm_hadds_epi16","qualname":"::core_arch::x86::ssse3::_mm_hadds_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 128-bit vectors of `[8 x i16]`. Positive sums greater than 7FFFh are\n saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2844037,"byte_end":2844046,"line_start":174,"line_end":174,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2844047,"byte_end":2844082,"line_start":175,"line_end":175,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2844124,"byte_end":2844173,"line_start":177,"line_end":177,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10414},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2844672,"byte_end":2844686,"line_start":190,"line_end":190,"column_start":15,"column_end":29},"name":"_mm_hadd_epi32","qualname":"::core_arch::x86::ssse3::_mm_hadd_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 128-bit vectors of `[4 x i32]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2844522,"byte_end":2844531,"line_start":186,"line_end":186,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2844532,"byte_end":2844567,"line_start":187,"line_end":187,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2844608,"byte_end":2844657,"line_start":189,"line_end":189,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10416},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2845158,"byte_end":2845172,"line_start":202,"line_end":202,"column_start":15,"column_end":29},"name":"_mm_hsub_epi16","qualname":"::core_arch::x86::ssse3::_mm_hsub_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract the adjacent pairs of values contained in 2\n packed 128-bit vectors of `[8 x i16]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2845008,"byte_end":2845017,"line_start":198,"line_end":198,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2845018,"byte_end":2845053,"line_start":199,"line_end":199,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2845094,"byte_end":2845143,"line_start":201,"line_end":201,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10418},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2845779,"byte_end":2845794,"line_start":216,"line_end":216,"column_start":15,"column_end":30},"name":"_mm_hsubs_epi16","qualname":"::core_arch::x86::ssse3::_mm_hsubs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract the adjacent pairs of values contained in 2\n packed 128-bit vectors of `[8 x i16]`. Positive differences greater than\n 7FFFh are saturated to 7FFFh. Negative differences less than 8000h are\n saturated to 8000h.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2845628,"byte_end":2845637,"line_start":212,"line_end":212,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2845638,"byte_end":2845673,"line_start":213,"line_end":213,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2845715,"byte_end":2845764,"line_start":215,"line_end":215,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10420},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2846267,"byte_end":2846281,"line_start":228,"line_end":228,"column_start":15,"column_end":29},"name":"_mm_hsub_epi32","qualname":"::core_arch::x86::ssse3::_mm_hsub_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract the adjacent pairs of values contained in 2\n packed 128-bit vectors of `[4 x i32]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2846117,"byte_end":2846126,"line_start":224,"line_end":224,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2846127,"byte_end":2846162,"line_start":225,"line_end":225,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2846203,"byte_end":2846252,"line_start":227,"line_end":227,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10422},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2846984,"byte_end":2847001,"line_start":243,"line_end":243,"column_start":15,"column_end":32},"name":"_mm_maddubs_epi16","qualname":"::core_arch::x86::ssse3::_mm_maddubs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies corresponding pairs of packed 8-bit unsigned integer\n values contained in the first source operand and packed 8-bit signed\n integer values contained in the second source operand, add pairs of\n contiguous products with signed saturation, and writes the 16-bit sums to\n the corresponding bits in the destination.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2846831,"byte_end":2846840,"line_start":239,"line_end":239,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2846841,"byte_end":2846876,"line_start":240,"line_end":240,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2846920,"byte_end":2846969,"line_start":242,"line_end":242,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10424},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2847589,"byte_end":2847605,"line_start":256,"line_end":256,"column_start":15,"column_end":31},"name":"_mm_mulhrs_epi16","qualname":"::core_arch::x86::ssse3::_mm_mulhrs_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit signed integer values, truncate the 32-bit\n product to the 18 most significant bits by right-shifting, round the\n truncated value by adding 1, and write bits `[16:1]` to the destination.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2847437,"byte_end":2847446,"line_start":252,"line_end":252,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2847447,"byte_end":2847482,"line_start":253,"line_end":253,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2847525,"byte_end":2847574,"line_start":255,"line_end":255,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10426},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2848187,"byte_end":2848200,"line_start":270,"line_end":270,"column_start":15,"column_end":28},"name":"_mm_sign_epi8","qualname":"::core_arch::x86::ssse3::_mm_sign_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 8-bit integers in `a` when the corresponding signed 8-bit\n integer in `b` is negative, and returns the result.\n Elements in result are zeroed out when the corresponding element in `b`\n is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2848037,"byte_end":2848046,"line_start":266,"line_end":266,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2848047,"byte_end":2848082,"line_start":267,"line_end":267,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2848123,"byte_end":2848172,"line_start":269,"line_end":269,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10428},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2848784,"byte_end":2848798,"line_start":284,"line_end":284,"column_start":15,"column_end":29},"name":"_mm_sign_epi16","qualname":"::core_arch::x86::ssse3::_mm_sign_epi16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 16-bit integers in `a` when the corresponding signed 16-bit\n integer in `b` is negative, and returns the results.\n Elements in result are zeroed out when the corresponding element in `b`\n is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2848634,"byte_end":2848643,"line_start":280,"line_end":280,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2848644,"byte_end":2848679,"line_start":281,"line_end":281,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2848720,"byte_end":2848769,"line_start":283,"line_end":283,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10430},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849381,"byte_end":2849395,"line_start":298,"line_end":298,"column_start":15,"column_end":29},"name":"_mm_sign_epi32","qualname":"::core_arch::x86::ssse3::_mm_sign_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 32-bit integers in `a` when the corresponding signed 32-bit\n integer in `b` is negative, and returns the results.\n Element in result are zeroed out when the corresponding element in `b`\n is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849231,"byte_end":2849240,"line_start":294,"line_end":294,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849241,"byte_end":2849276,"line_start":295,"line_end":295,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849317,"byte_end":2849366,"line_start":297,"line_end":297,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10432},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849693,"byte_end":2849704,"line_start":307,"line_end":307,"column_start":15,"column_end":26},"name":"_mm_abs_pi8","qualname":"::core_arch::x86::ssse3::_mm_abs_pi8","value":"fn (a: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 8-bit integers in `a` and\n return the unsigned results.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849590,"byte_end":2849599,"line_start":304,"line_end":304,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849600,"byte_end":2849639,"line_start":305,"line_end":305,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10434},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849948,"byte_end":2849960,"line_start":316,"line_end":316,"column_start":15,"column_end":27},"name":"_mm_abs_pi16","qualname":"::core_arch::x86::ssse3::_mm_abs_pi16","value":"fn (a: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 8-bit integers in `a`, and returns the\n unsigned results.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849845,"byte_end":2849854,"line_start":313,"line_end":313,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2849855,"byte_end":2849894,"line_start":314,"line_end":314,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10436},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850205,"byte_end":2850217,"line_start":325,"line_end":325,"column_start":15,"column_end":27},"name":"_mm_abs_pi32","qualname":"::core_arch::x86::ssse3::_mm_abs_pi32","value":"fn (a: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 32-bit integers in `a`, and returns the\n unsigned results.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850102,"byte_end":2850111,"line_start":322,"line_end":322,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850112,"byte_end":2850151,"line_start":323,"line_end":323,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10438},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850506,"byte_end":2850521,"line_start":334,"line_end":334,"column_start":15,"column_end":30},"name":"_mm_shuffle_pi8","qualname":"::core_arch::x86::ssse3::_mm_shuffle_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Shuffles packed 8-bit integers in `a` according to shuffle control mask in\n the corresponding 8-bit element of `b`, and returns the results\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850402,"byte_end":2850411,"line_start":331,"line_end":331,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850412,"byte_end":2850451,"line_start":332,"line_end":332,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10440},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850866,"byte_end":2850880,"line_start":344,"line_end":344,"column_start":15,"column_end":29},"name":"_mm_alignr_pi8","qualname":"::core_arch::x86::ssse3::_mm_alignr_pi8","value":"fn (a: __m64, b: __m64, n: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Concatenates the two 64-bit integer vector operands, and right-shifts\n the result by the number of bytes specified in the immediate operand.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850721,"byte_end":2850730,"line_start":340,"line_end":340,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850731,"byte_end":2850770,"line_start":341,"line_end":341,"column_start":1,"column_end":40}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2850820,"byte_end":2850851,"line_start":343,"line_end":343,"column_start":1,"column_end":32}}]},{"kind":"Function","id":{"krate":0,"index":10444},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851264,"byte_end":2851277,"line_start":358,"line_end":358,"column_start":15,"column_end":28},"name":"_mm_hadd_pi16","qualname":"::core_arch::x86::ssse3::_mm_hadd_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 64-bit vectors of `[4 x i16]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851160,"byte_end":2851169,"line_start":355,"line_end":355,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851170,"byte_end":2851209,"line_start":356,"line_end":356,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10446},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851541,"byte_end":2851554,"line_start":367,"line_end":367,"column_start":15,"column_end":28},"name":"_mm_hadd_pi32","qualname":"::core_arch::x86::ssse3::_mm_hadd_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 64-bit vectors of `[2 x i32]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851437,"byte_end":2851446,"line_start":364,"line_end":364,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851447,"byte_end":2851486,"line_start":365,"line_end":365,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10448},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851934,"byte_end":2851948,"line_start":377,"line_end":377,"column_start":15,"column_end":29},"name":"_mm_hadds_pi16","qualname":"::core_arch::x86::ssse3::_mm_hadds_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds the adjacent pairs of values contained in 2 packed\n 64-bit vectors of `[4 x i16]`. Positive sums greater than 7FFFh are\n saturated to 7FFFh. Negative sums less than 8000h are saturated to 8000h.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851829,"byte_end":2851838,"line_start":374,"line_end":374,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2851839,"byte_end":2851878,"line_start":375,"line_end":375,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10450},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852218,"byte_end":2852231,"line_start":386,"line_end":386,"column_start":15,"column_end":28},"name":"_mm_hsub_pi16","qualname":"::core_arch::x86::ssse3::_mm_hsub_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtracts the adjacent pairs of values contained in 2\n packed 64-bit vectors of `[4 x i16]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852114,"byte_end":2852123,"line_start":383,"line_end":383,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852124,"byte_end":2852163,"line_start":384,"line_end":384,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10452},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852500,"byte_end":2852513,"line_start":395,"line_end":395,"column_start":15,"column_end":28},"name":"_mm_hsub_pi32","qualname":"::core_arch::x86::ssse3::_mm_hsub_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtracts the adjacent pairs of values contained in 2\n packed 64-bit vectors of `[2 x i32]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852396,"byte_end":2852405,"line_start":392,"line_end":392,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852406,"byte_end":2852445,"line_start":393,"line_end":393,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10454},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852916,"byte_end":2852930,"line_start":406,"line_end":406,"column_start":15,"column_end":29},"name":"_mm_hsubs_pi16","qualname":"::core_arch::x86::ssse3::_mm_hsubs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtracts the adjacent pairs of values contained in 2\n packed 64-bit vectors of `[4 x i16]`. Positive differences greater than\n 7FFFh are saturated to 7FFFh. Negative differences less than 8000h are\n saturated to 8000h.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852811,"byte_end":2852820,"line_start":403,"line_end":403,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2852821,"byte_end":2852860,"line_start":404,"line_end":404,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10456},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2853429,"byte_end":2853445,"line_start":418,"line_end":418,"column_start":15,"column_end":31},"name":"_mm_maddubs_pi16","qualname":"::core_arch::x86::ssse3::_mm_maddubs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies corresponding pairs of packed 8-bit unsigned integer\n values contained in the first source operand and packed 8-bit signed\n integer values contained in the second source operand, adds pairs of\n contiguous products with signed saturation, and writes the 16-bit sums to\n the corresponding bits in the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2853322,"byte_end":2853331,"line_start":415,"line_end":415,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2853332,"byte_end":2853371,"line_start":416,"line_end":416,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10458},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2853832,"byte_end":2853847,"line_start":428,"line_end":428,"column_start":15,"column_end":30},"name":"_mm_mulhrs_pi16","qualname":"::core_arch::x86::ssse3::_mm_mulhrs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit signed integer values, truncates the 32-bit\n products to the 18 most significant bits by right-shifting, rounds the\n truncated value by adding 1, and writes bits `[16:1]` to the destination.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2853726,"byte_end":2853735,"line_start":425,"line_end":425,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2853736,"byte_end":2853775,"line_start":426,"line_end":426,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10460},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2854227,"byte_end":2854239,"line_start":439,"line_end":439,"column_start":15,"column_end":27},"name":"_mm_sign_pi8","qualname":"::core_arch::x86::ssse3::_mm_sign_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 8-bit integers in `a` when the corresponding signed 8-bit\n integer in `b` is negative, and returns the results.\n Element in result are zeroed out when the corresponding element in `b` is\n zero.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2854123,"byte_end":2854132,"line_start":436,"line_end":436,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2854133,"byte_end":2854172,"line_start":437,"line_end":437,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10462},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2854619,"byte_end":2854632,"line_start":450,"line_end":450,"column_start":15,"column_end":28},"name":"_mm_sign_pi16","qualname":"::core_arch::x86::ssse3::_mm_sign_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 16-bit integers in `a` when the corresponding signed 16-bit\n integer in `b` is negative, and returns the results.\n Element in result are zeroed out when the corresponding element in `b` is\n zero.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2854515,"byte_end":2854524,"line_start":447,"line_end":447,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2854525,"byte_end":2854564,"line_start":448,"line_end":448,"column_start":1,"column_end":40}}]},{"kind":"Function","id":{"krate":0,"index":10464},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2855012,"byte_end":2855025,"line_start":461,"line_end":461,"column_start":15,"column_end":28},"name":"_mm_sign_pi32","qualname":"::core_arch::x86::ssse3::_mm_sign_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 32-bit integers in `a` when the corresponding signed 32-bit\n integer in `b` is negative, and returns the results.\n Element in result are zeroed out when the corresponding element in `b` is\n zero.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2854908,"byte_end":2854917,"line_start":458,"line_end":458,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"ssse3,mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/ssse3.rs","byte_start":2854918,"byte_end":2854957,"line_start":459,"line_end":459,"column_start":1,"column_end":40}}]},{"kind":"Const","id":{"krate":0,"index":10484},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869168,"byte_end":2869193,"line_start":14,"line_end":14,"column_start":11,"column_end":36},"name":"_MM_FROUND_TO_NEAREST_INT","qualname":"::core_arch::x86::sse41::_MM_FROUND_TO_NEAREST_INT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round to nearest\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869108,"byte_end":2869157,"line_start":13,"line_end":13,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10486},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869282,"byte_end":2869303,"line_start":17,"line_end":17,"column_start":11,"column_end":32},"name":"_MM_FROUND_TO_NEG_INF","qualname":"::core_arch::x86::sse41::_MM_FROUND_TO_NEG_INF","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round down\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869222,"byte_end":2869271,"line_start":16,"line_end":16,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10488},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869390,"byte_end":2869411,"line_start":20,"line_end":20,"column_start":11,"column_end":32},"name":"_MM_FROUND_TO_POS_INF","qualname":"::core_arch::x86::sse41::_MM_FROUND_TO_POS_INF","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round up\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869330,"byte_end":2869379,"line_start":19,"line_end":19,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10490},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869498,"byte_end":2869516,"line_start":23,"line_end":23,"column_start":11,"column_end":29},"name":"_MM_FROUND_TO_ZERO","qualname":"::core_arch::x86::sse41::_MM_FROUND_TO_ZERO","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" truncate\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869438,"byte_end":2869487,"line_start":22,"line_end":22,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10492},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869644,"byte_end":2869668,"line_start":26,"line_end":26,"column_start":11,"column_end":35},"name":"_MM_FROUND_CUR_DIRECTION","qualname":"::core_arch::x86::sse41::_MM_FROUND_CUR_DIRECTION","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" use MXCSR.RC; see `vendor::_MM_SET_ROUNDING_MODE`\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869584,"byte_end":2869633,"line_start":25,"line_end":25,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10494},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869773,"byte_end":2869793,"line_start":29,"line_end":29,"column_start":11,"column_end":31},"name":"_MM_FROUND_RAISE_EXC","qualname":"::core_arch::x86::sse41::_MM_FROUND_RAISE_EXC","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869713,"byte_end":2869762,"line_start":28,"line_end":28,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10496},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869891,"byte_end":2869908,"line_start":32,"line_end":32,"column_start":11,"column_end":28},"name":"_MM_FROUND_NO_EXC","qualname":"::core_arch::x86::sse41::_MM_FROUND_NO_EXC","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869831,"byte_end":2869880,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10498},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870034,"byte_end":2870049,"line_start":35,"line_end":35,"column_start":11,"column_end":26},"name":"_MM_FROUND_NINT","qualname":"::core_arch::x86::sse41::_MM_FROUND_NINT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round to nearest and do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2869974,"byte_end":2870023,"line_start":34,"line_end":34,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10500},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870169,"byte_end":2870185,"line_start":38,"line_end":38,"column_start":11,"column_end":27},"name":"_MM_FROUND_FLOOR","qualname":"::core_arch::x86::sse41::_MM_FROUND_FLOOR","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round down and do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870109,"byte_end":2870158,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10502},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870345,"byte_end":2870360,"line_start":41,"line_end":41,"column_start":11,"column_end":26},"name":"_MM_FROUND_CEIL","qualname":"::core_arch::x86::sse41::_MM_FROUND_CEIL","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" round up and do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870285,"byte_end":2870334,"line_start":40,"line_end":40,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10504},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870520,"byte_end":2870536,"line_start":44,"line_end":44,"column_start":11,"column_end":27},"name":"_MM_FROUND_TRUNC","qualname":"::core_arch::x86::sse41::_MM_FROUND_TRUNC","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" truncate and do not suppress exceptions\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870460,"byte_end":2870509,"line_start":43,"line_end":43,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10506},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870738,"byte_end":2870753,"line_start":48,"line_end":48,"column_start":11,"column_end":26},"name":"_MM_FROUND_RINT","qualname":"::core_arch::x86::sse41::_MM_FROUND_RINT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" use MXCSR.RC and do not suppress exceptions; see\n `vendor::_MM_SET_ROUNDING_MODE`\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870678,"byte_end":2870727,"line_start":47,"line_end":47,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10508},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870950,"byte_end":2870970,"line_start":51,"line_end":51,"column_start":11,"column_end":31},"name":"_MM_FROUND_NEARBYINT","qualname":"::core_arch::x86::sse41::_MM_FROUND_NEARBYINT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" use MXCSR.RC and suppress exceptions; see `vendor::_MM_SET_ROUNDING_MODE`\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2870890,"byte_end":2870939,"line_start":50,"line_end":50,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10510},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2871542,"byte_end":2871557,"line_start":64,"line_end":64,"column_start":15,"column_end":30},"name":"_mm_blendv_epi8","qualname":"::core_arch::x86::sse41::_mm_blendv_epi8","value":"fn (a: __m128i, b: __m128i, mask: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Blend packed 8-bit integers from `a` and `b` using `mask`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2871389,"byte_end":2871398,"line_start":60,"line_end":60,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2871399,"byte_end":2871435,"line_start":61,"line_end":61,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2871478,"byte_end":2871527,"line_start":63,"line_end":63,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10512},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2872413,"byte_end":2872428,"line_start":83,"line_end":83,"column_start":15,"column_end":30},"name":"_mm_blend_epi16","qualname":"::core_arch::x86::sse41::_mm_blend_epi16","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Blend packed 16-bit integers from `a` and `b` using the mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2872028,"byte_end":2872037,"line_start":75,"line_end":75,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2872038,"byte_end":2872074,"line_start":76,"line_end":76,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2872317,"byte_end":2872348,"line_start":81,"line_end":81,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2872349,"byte_end":2872398,"line_start":82,"line_end":82,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10516},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2873042,"byte_end":2873055,"line_start":102,"line_end":102,"column_start":15,"column_end":28},"name":"_mm_blendv_pd","qualname":"::core_arch::x86::sse41::_mm_blendv_pd","value":"fn (a: __m128d, b: __m128d, mask: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Blend packed double-precision (64-bit) floating-point elements from `a`\n and `b` using `mask`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2872889,"byte_end":2872898,"line_start":98,"line_end":98,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2872899,"byte_end":2872935,"line_start":99,"line_end":99,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2872978,"byte_end":2873027,"line_start":101,"line_end":101,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10518},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2873504,"byte_end":2873517,"line_start":114,"line_end":114,"column_start":15,"column_end":28},"name":"_mm_blendv_ps","qualname":"::core_arch::x86::sse41::_mm_blendv_ps","value":"fn (a: __m128, b: __m128, mask: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Blend packed single-precision (32-bit) floating-point elements from `a`\n and `b` using `mask`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2873351,"byte_end":2873360,"line_start":110,"line_end":110,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2873361,"byte_end":2873397,"line_start":111,"line_end":111,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2873440,"byte_end":2873489,"line_start":113,"line_end":113,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10520},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2874206,"byte_end":2874218,"line_start":130,"line_end":130,"column_start":15,"column_end":27},"name":"_mm_blend_pd","qualname":"::core_arch::x86::sse41::_mm_blend_pd","value":"fn (a: __m128d, b: __m128d, imm2: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Blend packed double-precision (64-bit) floating-point elements from `a`\n and `b` using control mask `imm2`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2873821,"byte_end":2873830,"line_start":122,"line_end":122,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2873831,"byte_end":2873867,"line_start":123,"line_end":123,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2874110,"byte_end":2874141,"line_start":128,"line_end":128,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2874142,"byte_end":2874191,"line_start":129,"line_end":129,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10524},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2874819,"byte_end":2874831,"line_start":148,"line_end":148,"column_start":15,"column_end":27},"name":"_mm_blend_ps","qualname":"::core_arch::x86::sse41::_mm_blend_ps","value":"fn (a: __m128, b: __m128, imm4: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Blend packed single-precision (32-bit) floating-point elements from `a`\n and `b` using mask `imm4`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2874620,"byte_end":2874629,"line_start":143,"line_end":143,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2874630,"byte_end":2874666,"line_start":144,"line_end":144,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2874723,"byte_end":2874754,"line_start":146,"line_end":146,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2874755,"byte_end":2874804,"line_start":147,"line_end":147,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10528},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2875464,"byte_end":2875478,"line_start":169,"line_end":169,"column_start":15,"column_end":29},"name":"_mm_extract_ps","qualname":"::core_arch::x86::sse41::_mm_extract_ps","value":"fn (a: __m128, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts a single-precision (32-bit) floating-point element from `a`,\n selected with `imm8`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2875225,"byte_end":2875234,"line_start":161,"line_end":161,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2875235,"byte_end":2875271,"line_start":162,"line_end":162,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2875368,"byte_end":2875399,"line_start":167,"line_end":167,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2875400,"byte_end":2875449,"line_start":168,"line_end":168,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10530},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2876085,"byte_end":2876101,"line_start":184,"line_end":184,"column_start":15,"column_end":31},"name":"_mm_extract_epi8","qualname":"::core_arch::x86::sse41::_mm_extract_epi8","value":"fn (a: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts an 8-bit integer from `a`, selected with `imm8`. Returns a 32-bit\n integer containing the zero-extended integer data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2875892,"byte_end":2875901,"line_start":179,"line_end":179,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2875902,"byte_end":2875938,"line_start":180,"line_end":180,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2875989,"byte_end":2876020,"line_start":182,"line_end":182,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2876021,"byte_end":2876070,"line_start":183,"line_end":183,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10532},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2876643,"byte_end":2876660,"line_start":200,"line_end":200,"column_start":15,"column_end":32},"name":"_mm_extract_epi32","qualname":"::core_arch::x86::sse41::_mm_extract_epi32","value":"fn (a: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts an 32-bit integer from `a` selected with `imm8`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2876404,"byte_end":2876413,"line_start":192,"line_end":192,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2876414,"byte_end":2876450,"line_start":193,"line_end":193,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2876547,"byte_end":2876578,"line_start":198,"line_end":198,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2876579,"byte_end":2876628,"line_start":199,"line_end":199,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10534},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878225,"byte_end":2878238,"line_start":234,"line_end":234,"column_start":15,"column_end":28},"name":"_mm_insert_ps","qualname":"::core_arch::x86::sse41::_mm_insert_ps","value":"fn (a: __m128, b: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Select a single value in `a` to store at some position in `b`,\n Then zero elements according to `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878025,"byte_end":2878034,"line_start":229,"line_end":229,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878035,"byte_end":2878071,"line_start":230,"line_end":230,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878129,"byte_end":2878160,"line_start":232,"line_end":232,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878161,"byte_end":2878210,"line_start":233,"line_end":233,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10538},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878834,"byte_end":2878849,"line_start":252,"line_end":252,"column_start":15,"column_end":30},"name":"_mm_insert_epi8","qualname":"::core_arch::x86::sse41::_mm_insert_epi8","value":"fn (a: __m128i, i: i32, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a copy of `a` with the 8-bit integer from `i` inserted at a\n location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878641,"byte_end":2878650,"line_start":247,"line_end":247,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878651,"byte_end":2878687,"line_start":248,"line_end":248,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878738,"byte_end":2878769,"line_start":250,"line_end":250,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2878770,"byte_end":2878819,"line_start":251,"line_end":251,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10540},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879388,"byte_end":2879404,"line_start":265,"line_end":265,"column_start":15,"column_end":31},"name":"_mm_insert_epi32","qualname":"::core_arch::x86::sse41::_mm_insert_epi32","value":"fn (a: __m128i, i: i32, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a copy of `a` with the 32-bit integer from `i` inserted at a\n location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879195,"byte_end":2879204,"line_start":260,"line_end":260,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879205,"byte_end":2879241,"line_start":261,"line_end":261,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879292,"byte_end":2879323,"line_start":263,"line_end":263,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879324,"byte_end":2879373,"line_start":264,"line_end":264,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10542},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879878,"byte_end":2879890,"line_start":277,"line_end":277,"column_start":15,"column_end":27},"name":"_mm_max_epi8","qualname":"::core_arch::x86::sse41::_mm_max_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` and returns packed maximum\n values in dst.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879727,"byte_end":2879736,"line_start":273,"line_end":273,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879737,"byte_end":2879773,"line_start":274,"line_end":274,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2879814,"byte_end":2879863,"line_start":276,"line_end":276,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10544},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2880339,"byte_end":2880352,"line_start":289,"line_end":289,"column_start":15,"column_end":28},"name":"_mm_max_epu16","qualname":"::core_arch::x86::sse41::_mm_max_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 16-bit integers in `a` and `b`, and returns packed\n maximum.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2880188,"byte_end":2880197,"line_start":285,"line_end":285,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2880198,"byte_end":2880234,"line_start":286,"line_end":286,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2880275,"byte_end":2880324,"line_start":288,"line_end":288,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10546},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2880799,"byte_end":2880812,"line_start":301,"line_end":301,"column_start":15,"column_end":28},"name":"_mm_max_epi32","qualname":"::core_arch::x86::sse41::_mm_max_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b`, and returns packed maximum\n values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2880648,"byte_end":2880657,"line_start":297,"line_end":297,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2880658,"byte_end":2880694,"line_start":298,"line_end":298,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2880735,"byte_end":2880784,"line_start":300,"line_end":300,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10548},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2881268,"byte_end":2881281,"line_start":313,"line_end":313,"column_start":15,"column_end":28},"name":"_mm_max_epu32","qualname":"::core_arch::x86::sse41::_mm_max_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 32-bit integers in `a` and `b`, and returns packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2881117,"byte_end":2881126,"line_start":309,"line_end":309,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2881127,"byte_end":2881163,"line_start":310,"line_end":310,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2881204,"byte_end":2881253,"line_start":312,"line_end":312,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10550},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2881732,"byte_end":2881744,"line_start":325,"line_end":325,"column_start":15,"column_end":27},"name":"_mm_min_epi8","qualname":"::core_arch::x86::sse41::_mm_min_epi8","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` and returns packed minimum\n values in dst.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2881581,"byte_end":2881590,"line_start":321,"line_end":321,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2881591,"byte_end":2881627,"line_start":322,"line_end":322,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2881668,"byte_end":2881717,"line_start":324,"line_end":324,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10552},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882193,"byte_end":2882206,"line_start":337,"line_end":337,"column_start":15,"column_end":28},"name":"_mm_min_epu16","qualname":"::core_arch::x86::sse41::_mm_min_epu16","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 16-bit integers in `a` and `b`, and returns packed\n minimum.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882042,"byte_end":2882051,"line_start":333,"line_end":333,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882052,"byte_end":2882088,"line_start":334,"line_end":334,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882129,"byte_end":2882178,"line_start":336,"line_end":336,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10554},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882653,"byte_end":2882666,"line_start":349,"line_end":349,"column_start":15,"column_end":28},"name":"_mm_min_epi32","qualname":"::core_arch::x86::sse41::_mm_min_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b`, and returns packed minimum\n values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882502,"byte_end":2882511,"line_start":345,"line_end":345,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882512,"byte_end":2882548,"line_start":346,"line_end":346,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882589,"byte_end":2882638,"line_start":348,"line_end":348,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10556},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883122,"byte_end":2883135,"line_start":361,"line_end":361,"column_start":15,"column_end":28},"name":"_mm_min_epu32","qualname":"::core_arch::x86::sse41::_mm_min_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 32-bit integers in `a` and `b`, and returns packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882971,"byte_end":2882980,"line_start":357,"line_end":357,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2882981,"byte_end":2883017,"line_start":358,"line_end":358,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883058,"byte_end":2883107,"line_start":360,"line_end":360,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10558},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883605,"byte_end":2883621,"line_start":373,"line_end":373,"column_start":15,"column_end":31},"name":"_mm_packus_epi32","qualname":"::core_arch::x86::sse41::_mm_packus_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using unsigned saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883452,"byte_end":2883461,"line_start":369,"line_end":369,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883462,"byte_end":2883498,"line_start":370,"line_end":370,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883541,"byte_end":2883590,"line_start":372,"line_end":372,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10560},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2884046,"byte_end":2884061,"line_start":384,"line_end":384,"column_start":15,"column_end":30},"name":"_mm_cmpeq_epi64","qualname":"::core_arch::x86::sse41::_mm_cmpeq_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 64-bit integers in `a` and `b` for equality","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883894,"byte_end":2883903,"line_start":380,"line_end":380,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883904,"byte_end":2883940,"line_start":381,"line_end":381,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2883982,"byte_end":2884031,"line_start":383,"line_end":383,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10562},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2884507,"byte_end":2884524,"line_start":395,"line_end":395,"column_start":15,"column_end":32},"name":"_mm_cvtepi8_epi16","qualname":"::core_arch::x86::sse41::_mm_cvtepi8_epi16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 8-bit integers in `a` to packed 16-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2884354,"byte_end":2884363,"line_start":391,"line_end":391,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2884364,"byte_end":2884400,"line_start":392,"line_end":392,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2884443,"byte_end":2884492,"line_start":394,"line_end":394,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10564},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2885031,"byte_end":2885048,"line_start":408,"line_end":408,"column_start":15,"column_end":32},"name":"_mm_cvtepi8_epi32","qualname":"::core_arch::x86::sse41::_mm_cvtepi8_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 8-bit integers in `a` to packed 32-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2884878,"byte_end":2884887,"line_start":404,"line_end":404,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2884888,"byte_end":2884924,"line_start":405,"line_end":405,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2884967,"byte_end":2885016,"line_start":407,"line_end":407,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10566},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2885566,"byte_end":2885583,"line_start":422,"line_end":422,"column_start":15,"column_end":32},"name":"_mm_cvtepi8_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepi8_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 8-bit integers in the low 8 bytes of `a` to packed\n 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2885413,"byte_end":2885422,"line_start":418,"line_end":418,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2885423,"byte_end":2885459,"line_start":419,"line_end":419,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2885502,"byte_end":2885551,"line_start":421,"line_end":421,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10568},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2886074,"byte_end":2886092,"line_start":435,"line_end":435,"column_start":15,"column_end":33},"name":"_mm_cvtepi16_epi32","qualname":"::core_arch::x86::sse41::_mm_cvtepi16_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 16-bit integers in `a` to packed 32-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2885921,"byte_end":2885930,"line_start":431,"line_end":431,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2885931,"byte_end":2885967,"line_start":432,"line_end":432,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2886010,"byte_end":2886059,"line_start":434,"line_end":434,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10570},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2886590,"byte_end":2886608,"line_start":448,"line_end":448,"column_start":15,"column_end":33},"name":"_mm_cvtepi16_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepi16_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 16-bit integers in `a` to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2886437,"byte_end":2886446,"line_start":444,"line_end":444,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2886447,"byte_end":2886483,"line_start":445,"line_end":445,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2886526,"byte_end":2886575,"line_start":447,"line_end":447,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10572},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2887100,"byte_end":2887118,"line_start":461,"line_end":461,"column_start":15,"column_end":33},"name":"_mm_cvtepi32_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepi32_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Sign extend packed 32-bit integers in `a` to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2886947,"byte_end":2886956,"line_start":457,"line_end":457,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2886957,"byte_end":2886993,"line_start":458,"line_end":458,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2887036,"byte_end":2887085,"line_start":460,"line_end":460,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10574},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2887619,"byte_end":2887636,"line_start":474,"line_end":474,"column_start":15,"column_end":32},"name":"_mm_cvtepu8_epi16","qualname":"::core_arch::x86::sse41::_mm_cvtepu8_epi16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 8-bit integers in `a` to packed 16-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2887466,"byte_end":2887475,"line_start":470,"line_end":470,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2887476,"byte_end":2887512,"line_start":471,"line_end":471,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2887555,"byte_end":2887604,"line_start":473,"line_end":473,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10576},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2888154,"byte_end":2888171,"line_start":487,"line_end":487,"column_start":15,"column_end":32},"name":"_mm_cvtepu8_epi32","qualname":"::core_arch::x86::sse41::_mm_cvtepu8_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 8-bit integers in `a` to packed 32-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2888001,"byte_end":2888010,"line_start":483,"line_end":483,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2888011,"byte_end":2888047,"line_start":484,"line_end":484,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2888090,"byte_end":2888139,"line_start":486,"line_end":486,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10578},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2888677,"byte_end":2888694,"line_start":500,"line_end":500,"column_start":15,"column_end":32},"name":"_mm_cvtepu8_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepu8_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 8-bit integers in `a` to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2888524,"byte_end":2888533,"line_start":496,"line_end":496,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2888534,"byte_end":2888570,"line_start":497,"line_end":497,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2888613,"byte_end":2888662,"line_start":499,"line_end":499,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10580},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2889200,"byte_end":2889218,"line_start":514,"line_end":514,"column_start":15,"column_end":33},"name":"_mm_cvtepu16_epi32","qualname":"::core_arch::x86::sse41::_mm_cvtepu16_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 16-bit integers in `a`\n to packed 32-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2889047,"byte_end":2889056,"line_start":510,"line_end":510,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2889057,"byte_end":2889093,"line_start":511,"line_end":511,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2889136,"byte_end":2889185,"line_start":513,"line_end":513,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10582},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2889731,"byte_end":2889749,"line_start":528,"line_end":528,"column_start":15,"column_end":33},"name":"_mm_cvtepu16_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepu16_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 16-bit integers in `a`\n to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2889578,"byte_end":2889587,"line_start":524,"line_end":524,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2889588,"byte_end":2889624,"line_start":525,"line_end":525,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2889667,"byte_end":2889716,"line_start":527,"line_end":527,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10584},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2890256,"byte_end":2890274,"line_start":542,"line_end":542,"column_start":15,"column_end":33},"name":"_mm_cvtepu32_epi64","qualname":"::core_arch::x86::sse41::_mm_cvtepu32_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 32-bit integers in `a`\n to packed 64-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2890103,"byte_end":2890112,"line_start":538,"line_end":538,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2890113,"byte_end":2890149,"line_start":539,"line_end":539,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2890192,"byte_end":2890241,"line_start":541,"line_end":541,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10586},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2891164,"byte_end":2891173,"line_start":562,"line_end":562,"column_start":15,"column_end":24},"name":"_mm_dp_pd","qualname":"::core_arch::x86::sse41::_mm_dp_pd","value":"fn (a: __m128d, b: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns the dot product of two __m128d vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2890973,"byte_end":2890982,"line_start":557,"line_end":557,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2890983,"byte_end":2891019,"line_start":558,"line_end":558,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2891068,"byte_end":2891099,"line_start":560,"line_end":560,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2891100,"byte_end":2891149,"line_start":561,"line_end":561,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10590},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2892094,"byte_end":2892103,"line_start":585,"line_end":585,"column_start":15,"column_end":24},"name":"_mm_dp_ps","qualname":"::core_arch::x86::sse41::_mm_dp_ps","value":"fn (a: __m128, b: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns the dot product of two __m128 vectors.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2891903,"byte_end":2891912,"line_start":580,"line_end":580,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2891913,"byte_end":2891949,"line_start":581,"line_end":581,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2891998,"byte_end":2892029,"line_start":583,"line_end":583,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2892030,"byte_end":2892079,"line_start":584,"line_end":584,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10594},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2892732,"byte_end":2892744,"line_start":603,"line_end":603,"column_start":15,"column_end":27},"name":"_mm_floor_pd","qualname":"::core_arch::x86::sse41::_mm_floor_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the packed double-precision (64-bit) floating-point elements in `a`\n down to an integer value, and stores the results as packed double-precision\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2892580,"byte_end":2892589,"line_start":599,"line_end":599,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2892590,"byte_end":2892626,"line_start":600,"line_end":600,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2892668,"byte_end":2892717,"line_start":602,"line_end":602,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10596},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2893258,"byte_end":2893270,"line_start":616,"line_end":616,"column_start":15,"column_end":27},"name":"_mm_floor_ps","qualname":"::core_arch::x86::sse41::_mm_floor_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the packed single-precision (32-bit) floating-point elements in `a`\n down to an integer value, and stores the results as packed single-precision\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2893106,"byte_end":2893115,"line_start":612,"line_end":612,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2893116,"byte_end":2893152,"line_start":613,"line_end":613,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2893194,"byte_end":2893243,"line_start":615,"line_end":615,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10598},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2893905,"byte_end":2893917,"line_start":631,"line_end":631,"column_start":15,"column_end":27},"name":"_mm_floor_sd","qualname":"::core_arch::x86::sse41::_mm_floor_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the lower double-precision (64-bit) floating-point element in `b`\n down to an integer value, store the result as a double-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper element from `a` to the upper element of the intrinsic\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2893753,"byte_end":2893762,"line_start":627,"line_end":627,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2893763,"byte_end":2893799,"line_start":628,"line_end":628,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2893841,"byte_end":2893890,"line_start":630,"line_end":630,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10600},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2894580,"byte_end":2894592,"line_start":646,"line_end":646,"column_start":15,"column_end":27},"name":"_mm_floor_ss","qualname":"::core_arch::x86::sse41::_mm_floor_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the lower single-precision (32-bit) floating-point element in `b`\n down to an integer value, store the result as a single-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper 3 packed elements from `a` to the upper elements\n of the intrinsic result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2894428,"byte_end":2894437,"line_start":642,"line_end":642,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2894438,"byte_end":2894474,"line_start":643,"line_end":643,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2894516,"byte_end":2894565,"line_start":645,"line_end":645,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10602},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2895115,"byte_end":2895126,"line_start":659,"line_end":659,"column_start":15,"column_end":26},"name":"_mm_ceil_pd","qualname":"::core_arch::x86::sse41::_mm_ceil_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the packed double-precision (64-bit) floating-point elements in `a`\n up to an integer value, and stores the results as packed double-precision\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2894963,"byte_end":2894972,"line_start":655,"line_end":655,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2894973,"byte_end":2895009,"line_start":656,"line_end":656,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2895051,"byte_end":2895100,"line_start":658,"line_end":658,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10604},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2895636,"byte_end":2895647,"line_start":672,"line_end":672,"column_start":15,"column_end":26},"name":"_mm_ceil_ps","qualname":"::core_arch::x86::sse41::_mm_ceil_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the packed single-precision (32-bit) floating-point elements in `a`\n up to an integer value, and stores the results as packed single-precision\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2895484,"byte_end":2895493,"line_start":668,"line_end":668,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2895494,"byte_end":2895530,"line_start":669,"line_end":669,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2895572,"byte_end":2895621,"line_start":671,"line_end":671,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10606},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2896277,"byte_end":2896288,"line_start":687,"line_end":687,"column_start":15,"column_end":26},"name":"_mm_ceil_sd","qualname":"::core_arch::x86::sse41::_mm_ceil_sd","value":"fn (a: __m128d, b: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the lower double-precision (64-bit) floating-point element in `b`\n up to an integer value, store the result as a double-precision\n floating-point element in the lower element of the intrisic result,\n and copies the upper element from `a` to the upper element\n of the intrinsic result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2896125,"byte_end":2896134,"line_start":683,"line_end":683,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2896135,"byte_end":2896171,"line_start":684,"line_end":684,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2896213,"byte_end":2896262,"line_start":686,"line_end":686,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10608},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2896947,"byte_end":2896958,"line_start":702,"line_end":702,"column_start":15,"column_end":26},"name":"_mm_ceil_ss","qualname":"::core_arch::x86::sse41::_mm_ceil_ss","value":"fn (a: __m128, b: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the lower single-precision (32-bit) floating-point element in `b`\n up to an integer value, store the result as a single-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper 3 packed elements from `a` to the upper elements\n of the intrinsic result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2896795,"byte_end":2896804,"line_start":698,"line_end":698,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2896805,"byte_end":2896841,"line_start":699,"line_end":699,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2896883,"byte_end":2896932,"line_start":701,"line_end":701,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10610},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2898310,"byte_end":2898322,"line_start":742,"line_end":742,"column_start":15,"column_end":27},"name":"_mm_round_pd","qualname":"::core_arch::x86::sse41::_mm_round_pd","value":"fn (a: __m128d, rounding: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the packed double-precision (64-bit) floating-point elements in `a`\n using the `rounding` parameter, and stores the results as packed\n double-precision floating-point elements.\n Rounding is done according to the rounding parameter, which can be one of:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2898112,"byte_end":2898121,"line_start":737,"line_end":737,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2898122,"byte_end":2898158,"line_start":738,"line_end":738,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2898214,"byte_end":2898245,"line_start":740,"line_end":740,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2898246,"byte_end":2898295,"line_start":741,"line_end":741,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10614},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2899777,"byte_end":2899789,"line_start":787,"line_end":787,"column_start":15,"column_end":27},"name":"_mm_round_ps","qualname":"::core_arch::x86::sse41::_mm_round_ps","value":"fn (a: __m128, rounding: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the packed single-precision (32-bit) floating-point elements in `a`\n using the `rounding` parameter, and stores the results as packed\n single-precision floating-point elements.\n Rounding is done according to the rounding parameter, which can be one of:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2899579,"byte_end":2899588,"line_start":782,"line_end":782,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2899589,"byte_end":2899625,"line_start":783,"line_end":783,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2899681,"byte_end":2899712,"line_start":785,"line_end":785,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2899713,"byte_end":2899762,"line_start":786,"line_end":786,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10618},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2901365,"byte_end":2901377,"line_start":834,"line_end":834,"column_start":15,"column_end":27},"name":"_mm_round_sd","qualname":"::core_arch::x86::sse41::_mm_round_sd","value":"fn (a: __m128d, b: __m128d, rounding: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Round the lower double-precision (64-bit) floating-point element in `b`\n using the `rounding` parameter, store the result as a double-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper element from `a` to the upper element of the intrinsic\n result.\n Rounding is done according to the rounding parameter, which can be one of:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2901167,"byte_end":2901176,"line_start":829,"line_end":829,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2901177,"byte_end":2901213,"line_start":830,"line_end":830,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2901269,"byte_end":2901300,"line_start":832,"line_end":832,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2901301,"byte_end":2901350,"line_start":833,"line_end":833,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10622},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2902982,"byte_end":2902994,"line_start":881,"line_end":881,"column_start":15,"column_end":27},"name":"_mm_round_ss","qualname":"::core_arch::x86::sse41::_mm_round_ss","value":"fn (a: __m128, b: __m128, rounding: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Round the lower single-precision (32-bit) floating-point element in `b`\n using the `rounding` parameter, store the result as a single-precision\n floating-point element in the lower element of the intrinsic result,\n and copies the upper 3 packed elements from `a` to the upper elements\n of the instrinsic result.\n Rounding is done according to the rounding parameter, which can be one of:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2902784,"byte_end":2902793,"line_start":876,"line_end":876,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2902794,"byte_end":2902830,"line_start":877,"line_end":877,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2902886,"byte_end":2902917,"line_start":879,"line_end":879,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2902918,"byte_end":2902967,"line_start":880,"line_end":880,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10626},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2904067,"byte_end":2904083,"line_start":915,"line_end":915,"column_start":15,"column_end":31},"name":"_mm_minpos_epu16","qualname":"::core_arch::x86::sse41::_mm_minpos_epu16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Finds the minimum unsigned 16-bit element in the 128-bit __m128i vector,\n returning a vector containing its value in its first position, and its\n index\n in its second position; all other elements are set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2903912,"byte_end":2903921,"line_start":911,"line_end":911,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2903922,"byte_end":2903958,"line_start":912,"line_end":912,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2904003,"byte_end":2904052,"line_start":914,"line_end":914,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10628},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2904546,"byte_end":2904559,"line_start":927,"line_end":927,"column_start":15,"column_end":28},"name":"_mm_mul_epi32","qualname":"::core_arch::x86::sse41::_mm_mul_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the low 32-bit integers from each packed 64-bit\n element in `a` and `b`, and returns the signed 64-bit result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2904395,"byte_end":2904404,"line_start":923,"line_end":923,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2904405,"byte_end":2904441,"line_start":924,"line_end":924,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2904482,"byte_end":2904531,"line_start":926,"line_end":926,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10630},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2905330,"byte_end":2905345,"line_start":943,"line_end":943,"column_start":15,"column_end":30},"name":"_mm_mullo_epi32","qualname":"::core_arch::x86::sse41::_mm_mullo_epi32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 32-bit integers in `a` and `b`, producing intermediate\n 64-bit integers, and returns the lowest 32-bit, whatever they might be,\n reinterpreted as a signed integer. While `pmulld __m128i::splat(2),\n __m128i::splat(2)` returns the obvious `__m128i::splat(4)`, due to wrapping\n arithmetic `pmulld __m128i::splat(i32::MAX), __m128i::splat(2)` would\n return a negative number.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2905179,"byte_end":2905188,"line_start":939,"line_end":939,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2905189,"byte_end":2905225,"line_start":940,"line_end":940,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2905266,"byte_end":2905315,"line_start":942,"line_end":942,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10632},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2906817,"byte_end":2906833,"line_start":985,"line_end":985,"column_start":15,"column_end":31},"name":"_mm_mpsadbw_epu8","qualname":"::core_arch::x86::sse41::_mm_mpsadbw_epu8","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Subtracts 8-bit unsigned integer values and computes the absolute\n values of the differences to the corresponding bits in the destination.\n Then sums of the absolute differences are returned according to the bit\n fields in the immediate operand.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2906623,"byte_end":2906632,"line_start":980,"line_end":980,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2906633,"byte_end":2906669,"line_start":981,"line_end":981,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2906721,"byte_end":2906752,"line_start":983,"line_end":983,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2906753,"byte_end":2906802,"line_start":984,"line_end":984,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10636},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2907707,"byte_end":2907722,"line_start":1015,"line_end":1015,"column_start":15,"column_end":30},"name":"_mm_testz_si128","qualname":"::core_arch::x86::sse41::_mm_testz_si128","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are all\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2907557,"byte_end":2907566,"line_start":1011,"line_end":1011,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2907567,"byte_end":2907603,"line_start":1012,"line_end":1012,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2907643,"byte_end":2907692,"line_start":1014,"line_end":1014,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10638},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2908430,"byte_end":2908445,"line_start":1038,"line_end":1038,"column_start":15,"column_end":30},"name":"_mm_testc_si128","qualname":"::core_arch::x86::sse41::_mm_testc_si128","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are all\n ones.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2908280,"byte_end":2908289,"line_start":1034,"line_end":1034,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2908290,"byte_end":2908326,"line_start":1035,"line_end":1035,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2908366,"byte_end":2908415,"line_start":1037,"line_end":1037,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10640},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2909199,"byte_end":2909216,"line_start":1061,"line_end":1061,"column_start":15,"column_end":32},"name":"_mm_testnzc_si128","qualname":"::core_arch::x86::sse41::_mm_testnzc_si128","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are\n neither all zeros nor all ones.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2909049,"byte_end":2909058,"line_start":1057,"line_end":1057,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2909059,"byte_end":2909095,"line_start":1058,"line_end":1058,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2909135,"byte_end":2909184,"line_start":1060,"line_end":1060,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10642},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2909931,"byte_end":2909949,"line_start":1084,"line_end":1084,"column_start":15,"column_end":33},"name":"_mm_test_all_zeros","qualname":"::core_arch::x86::sse41::_mm_test_all_zeros","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are all\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2909781,"byte_end":2909790,"line_start":1080,"line_end":1080,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2909791,"byte_end":2909827,"line_start":1081,"line_end":1081,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2909867,"byte_end":2909916,"line_start":1083,"line_end":1083,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10644},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2910616,"byte_end":2910633,"line_start":1106,"line_end":1106,"column_start":15,"column_end":32},"name":"_mm_test_all_ones","qualname":"::core_arch::x86::sse41::_mm_test_all_ones","value":"fn (a: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in `a` 128-bit integer vector are all\n ones.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2910425,"byte_end":2910434,"line_start":1101,"line_end":1101,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2910435,"byte_end":2910471,"line_start":1102,"line_end":1102,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2910552,"byte_end":2910601,"line_start":1105,"line_end":1105,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10646},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2911382,"byte_end":2911405,"line_start":1129,"line_end":1129,"column_start":15,"column_end":38},"name":"_mm_test_mix_ones_zeros","qualname":"::core_arch::x86::sse41::_mm_test_mix_ones_zeros","value":"fn (a: __m128i, mask: __m128i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Tests whether the specified bits in a 128-bit integer vector are\n neither all zeros nor all ones.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2911232,"byte_end":2911241,"line_start":1125,"line_end":1125,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2911242,"byte_end":2911278,"line_start":1126,"line_end":1126,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse41.rs","byte_start":2911318,"byte_end":2911367,"line_start":1128,"line_end":1128,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10666},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937072,"byte_end":2937087,"line_start":15,"line_end":15,"column_start":11,"column_end":26},"name":"_SIDD_UBYTE_OPS","qualname":"::core_arch::x86::sse42::_SIDD_UBYTE_OPS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" String contains unsigned 8-bit characters *(Default)*\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937012,"byte_end":2937061,"line_start":14,"line_end":14,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10668},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937215,"byte_end":2937230,"line_start":18,"line_end":18,"column_start":11,"column_end":26},"name":"_SIDD_UWORD_OPS","qualname":"::core_arch::x86::sse42::_SIDD_UWORD_OPS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" String contains unsigned 16-bit characters\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937155,"byte_end":2937204,"line_start":17,"line_end":17,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10670},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937355,"byte_end":2937370,"line_start":21,"line_end":21,"column_start":11,"column_end":26},"name":"_SIDD_SBYTE_OPS","qualname":"::core_arch::x86::sse42::_SIDD_SBYTE_OPS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" String contains signed 8-bit characters\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937295,"byte_end":2937344,"line_start":20,"line_end":20,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10672},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937498,"byte_end":2937513,"line_start":24,"line_end":24,"column_start":11,"column_end":26},"name":"_SIDD_SWORD_OPS","qualname":"::core_arch::x86::sse42::_SIDD_SWORD_OPS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" String contains unsigned 16-bit characters\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937438,"byte_end":2937487,"line_start":23,"line_end":23,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10674},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937659,"byte_end":2937678,"line_start":28,"line_end":28,"column_start":11,"column_end":30},"name":"_SIDD_CMP_EQUAL_ANY","qualname":"::core_arch::x86::sse42::_SIDD_CMP_EQUAL_ANY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" For each character in `a`, find if it is in `b` *(Default)*\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937599,"byte_end":2937648,"line_start":27,"line_end":27,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10676},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937851,"byte_end":2937867,"line_start":32,"line_end":32,"column_start":11,"column_end":27},"name":"_SIDD_CMP_RANGES","qualname":"::core_arch::x86::sse42::_SIDD_CMP_RANGES","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" For each character in `a`, determine if\n `b[0] <= c <= b[1] or b[1] <= c <= b[2]...`\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937791,"byte_end":2937840,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10678},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937997,"byte_end":2938017,"line_start":35,"line_end":35,"column_start":11,"column_end":31},"name":"_SIDD_CMP_EQUAL_EACH","qualname":"::core_arch::x86::sse42::_SIDD_CMP_EQUAL_EACH","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" The strings defined by `a` and `b` are equal\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2937937,"byte_end":2937986,"line_start":34,"line_end":34,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10680},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938149,"byte_end":2938172,"line_start":38,"line_end":38,"column_start":11,"column_end":34},"name":"_SIDD_CMP_EQUAL_ORDERED","qualname":"::core_arch::x86::sse42::_SIDD_CMP_EQUAL_ORDERED","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Search for the defined substring in the target\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938089,"byte_end":2938138,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10682},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938292,"byte_end":2938315,"line_start":42,"line_end":42,"column_start":11,"column_end":34},"name":"_SIDD_POSITIVE_POLARITY","qualname":"::core_arch::x86::sse42::_SIDD_POSITIVE_POLARITY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Do not negate results *(Default)*\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938232,"byte_end":2938281,"line_start":41,"line_end":41,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10684},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938416,"byte_end":2938439,"line_start":45,"line_end":45,"column_start":11,"column_end":34},"name":"_SIDD_NEGATIVE_POLARITY","qualname":"::core_arch::x86::sse42::_SIDD_NEGATIVE_POLARITY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Negates results\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938356,"byte_end":2938405,"line_start":44,"line_end":44,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10686},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938575,"byte_end":2938605,"line_start":48,"line_end":48,"column_start":11,"column_end":41},"name":"_SIDD_MASKED_POSITIVE_POLARITY","qualname":"::core_arch::x86::sse42::_SIDD_MASKED_POSITIVE_POLARITY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Do not negate results before the end of the string\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938515,"byte_end":2938564,"line_start":47,"line_end":47,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10688},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938740,"byte_end":2938770,"line_start":51,"line_end":51,"column_start":11,"column_end":41},"name":"_SIDD_MASKED_NEGATIVE_POLARITY","qualname":"::core_arch::x86::sse42::_SIDD_MASKED_NEGATIVE_POLARITY","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Negates results only before the end of the string\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938680,"byte_end":2938729,"line_start":50,"line_end":50,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10690},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938917,"byte_end":2938940,"line_start":55,"line_end":55,"column_start":11,"column_end":34},"name":"_SIDD_LEAST_SIGNIFICANT","qualname":"::core_arch::x86::sse42::_SIDD_LEAST_SIGNIFICANT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" **Index only**: return the least significant bit *(Default)*\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2938857,"byte_end":2938906,"line_start":54,"line_end":54,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10692},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939073,"byte_end":2939095,"line_start":58,"line_end":58,"column_start":11,"column_end":33},"name":"_SIDD_MOST_SIGNIFICANT","qualname":"::core_arch::x86::sse42::_SIDD_MOST_SIGNIFICANT","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" **Index only**: return the most significant bit\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939013,"byte_end":2939062,"line_start":57,"line_end":57,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10694},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939216,"byte_end":2939230,"line_start":62,"line_end":62,"column_start":11,"column_end":25},"name":"_SIDD_BIT_MASK","qualname":"::core_arch::x86::sse42::_SIDD_BIT_MASK","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" **Mask only**: return the bit mask\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939156,"byte_end":2939205,"line_start":61,"line_end":61,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10696},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939351,"byte_end":2939366,"line_start":65,"line_end":65,"column_start":11,"column_end":26},"name":"_SIDD_UNIT_MASK","qualname":"::core_arch::x86::sse42::_SIDD_UNIT_MASK","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" **Mask only**: return the byte mask\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939291,"byte_end":2939340,"line_start":64,"line_end":64,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10698},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939826,"byte_end":2939838,"line_start":76,"line_end":76,"column_start":15,"column_end":27},"name":"_mm_cmpistrm","qualname":"::core_arch::x86::sse42::_mm_cmpistrm","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return the generated mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939630,"byte_end":2939639,"line_start":71,"line_end":71,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939640,"byte_end":2939676,"line_start":72,"line_end":72,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939730,"byte_end":2939761,"line_start":74,"line_end":74,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2939762,"byte_end":2939811,"line_start":75,"line_end":75,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10702},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2946746,"byte_end":2946758,"line_start":284,"line_end":284,"column_start":15,"column_end":27},"name":"_mm_cmpistri","qualname":"::core_arch::x86::sse42::_mm_cmpistri","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8` and return the generated index. Similar to\n [`_mm_cmpestri`] with the exception that [`_mm_cmpestri`] requires the\n lengths of `a` and `b` to be explicitly specified.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2946550,"byte_end":2946559,"line_start":279,"line_end":279,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2946560,"byte_end":2946596,"line_start":280,"line_end":280,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2946650,"byte_end":2946681,"line_start":282,"line_end":282,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2946682,"byte_end":2946731,"line_start":283,"line_end":283,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10706},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2947473,"byte_end":2947485,"line_start":305,"line_end":305,"column_start":15,"column_end":27},"name":"_mm_cmpistrz","qualname":"::core_arch::x86::sse42::_mm_cmpistrz","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return `1` if any character in `b` was null.\n and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2947277,"byte_end":2947286,"line_start":300,"line_end":300,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2947287,"byte_end":2947323,"line_start":301,"line_end":301,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2947377,"byte_end":2947408,"line_start":303,"line_end":303,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2947409,"byte_end":2947458,"line_start":304,"line_end":304,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10710},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948203,"byte_end":2948215,"line_start":326,"line_end":326,"column_start":15,"column_end":27},"name":"_mm_cmpistrc","qualname":"::core_arch::x86::sse42::_mm_cmpistrc","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return `1` if the resulting mask was non-zero,\n and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948007,"byte_end":2948016,"line_start":321,"line_end":321,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948017,"byte_end":2948053,"line_start":322,"line_end":322,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948107,"byte_end":2948138,"line_start":324,"line_end":324,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948139,"byte_end":2948188,"line_start":325,"line_end":325,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10714},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948932,"byte_end":2948944,"line_start":347,"line_end":347,"column_start":15,"column_end":27},"name":"_mm_cmpistrs","qualname":"::core_arch::x86::sse42::_mm_cmpistrs","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and returns `1` if any character in `a` was null,\n and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948736,"byte_end":2948745,"line_start":342,"line_end":342,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948746,"byte_end":2948782,"line_start":343,"line_end":343,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948836,"byte_end":2948867,"line_start":345,"line_end":345,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2948868,"byte_end":2948917,"line_start":346,"line_end":346,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10718},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2949634,"byte_end":2949646,"line_start":367,"line_end":367,"column_start":15,"column_end":27},"name":"_mm_cmpistro","qualname":"::core_arch::x86::sse42::_mm_cmpistro","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return bit `0` of the resulting bit mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2949438,"byte_end":2949447,"line_start":362,"line_end":362,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2949448,"byte_end":2949484,"line_start":363,"line_end":363,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2949538,"byte_end":2949569,"line_start":365,"line_end":365,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2949570,"byte_end":2949619,"line_start":366,"line_end":366,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10722},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2950401,"byte_end":2950413,"line_start":388,"line_end":388,"column_start":15,"column_end":27},"name":"_mm_cmpistra","qualname":"::core_arch::x86::sse42::_mm_cmpistra","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings with implicit lengths in `a` and `b` using the\n control in `imm8`, and return `1` if `b` did not contain a null\n character and the resulting mask was zero, and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2950205,"byte_end":2950214,"line_start":383,"line_end":383,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2950215,"byte_end":2950251,"line_start":384,"line_end":384,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2950305,"byte_end":2950336,"line_start":386,"line_end":386,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2950337,"byte_end":2950386,"line_start":387,"line_end":387,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10726},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2951093,"byte_end":2951105,"line_start":408,"line_end":408,"column_start":15,"column_end":27},"name":"_mm_cmpestrm","qualname":"::core_arch::x86::sse42::_mm_cmpestrm","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return the generated mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2950897,"byte_end":2950906,"line_start":403,"line_end":403,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2950907,"byte_end":2950943,"line_start":404,"line_end":404,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2950997,"byte_end":2951028,"line_start":406,"line_end":406,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2951029,"byte_end":2951078,"line_start":407,"line_end":407,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10730},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2954342,"byte_end":2954354,"line_start":503,"line_end":503,"column_start":15,"column_end":27},"name":"_mm_cmpestri","qualname":"::core_arch::x86::sse42::_mm_cmpestri","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings `a` and `b` with lengths `la` and `lb` using the\n control in `imm8` and return the generated index. Similar to\n [`_mm_cmpistri`] with the exception that [`_mm_cmpistri`] implicitly\n determines the length of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2954146,"byte_end":2954155,"line_start":498,"line_end":498,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2954156,"byte_end":2954192,"line_start":499,"line_end":499,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2954246,"byte_end":2954277,"line_start":501,"line_end":501,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2954278,"byte_end":2954327,"line_start":502,"line_end":502,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10734},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2955100,"byte_end":2955112,"line_start":524,"line_end":524,"column_start":15,"column_end":27},"name":"_mm_cmpestrz","qualname":"::core_arch::x86::sse42::_mm_cmpestrz","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return `1` if any character in\n `b` was null, and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2954904,"byte_end":2954913,"line_start":519,"line_end":519,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2954914,"byte_end":2954950,"line_start":520,"line_end":520,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2955004,"byte_end":2955035,"line_start":522,"line_end":522,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2955036,"byte_end":2955085,"line_start":523,"line_end":523,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10738},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2955861,"byte_end":2955873,"line_start":545,"line_end":545,"column_start":15,"column_end":27},"name":"_mm_cmpestrc","qualname":"::core_arch::x86::sse42::_mm_cmpestrc","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return `1` if the resulting mask\n was non-zero, and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2955665,"byte_end":2955674,"line_start":540,"line_end":540,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2955675,"byte_end":2955711,"line_start":541,"line_end":541,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2955765,"byte_end":2955796,"line_start":543,"line_end":543,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2955797,"byte_end":2955846,"line_start":544,"line_end":544,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10742},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2956618,"byte_end":2956630,"line_start":566,"line_end":566,"column_start":15,"column_end":27},"name":"_mm_cmpestrs","qualname":"::core_arch::x86::sse42::_mm_cmpestrs","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return `1` if any character in\n a was null, and `0` otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2956422,"byte_end":2956431,"line_start":561,"line_end":561,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2956432,"byte_end":2956468,"line_start":562,"line_end":562,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2956522,"byte_end":2956553,"line_start":564,"line_end":564,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2956554,"byte_end":2956603,"line_start":565,"line_end":565,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10746},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2957355,"byte_end":2957367,"line_start":587,"line_end":587,"column_start":15,"column_end":27},"name":"_mm_cmpestro","qualname":"::core_arch::x86::sse42::_mm_cmpestro","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return bit `0` of the resulting\n bit mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2957159,"byte_end":2957168,"line_start":582,"line_end":582,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2957169,"byte_end":2957205,"line_start":583,"line_end":583,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2957259,"byte_end":2957290,"line_start":585,"line_end":585,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2957291,"byte_end":2957340,"line_start":586,"line_end":586,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10750},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2958157,"byte_end":2958169,"line_start":609,"line_end":609,"column_start":15,"column_end":27},"name":"_mm_cmpestra","qualname":"::core_arch::x86::sse42::_mm_cmpestra","value":"fn (a: __m128i, la: i32, b: __m128i, lb: i32, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Compares packed strings in `a` and `b` with lengths `la` and `lb`\n using the control in `imm8`, and return `1` if `b` did not\n contain a null character and the resulting mask was zero, and `0`\n otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2957961,"byte_end":2957970,"line_start":604,"line_end":604,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2957971,"byte_end":2958007,"line_start":605,"line_end":605,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2958061,"byte_end":2958092,"line_start":607,"line_end":607,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2958093,"byte_end":2958142,"line_start":608,"line_end":608,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10754},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2958812,"byte_end":2958824,"line_start":628,"line_end":628,"column_start":15,"column_end":27},"name":"_mm_crc32_u8","qualname":"::core_arch::x86::sse42::_mm_crc32_u8","value":"fn (crc: u32, v: u8) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Starting with the initial value in `crc`, return the accumulated\n CRC32 value for unsigned 8-bit integer `v`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2958662,"byte_end":2958671,"line_start":624,"line_end":624,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2958672,"byte_end":2958708,"line_start":625,"line_end":625,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2958748,"byte_end":2958797,"line_start":627,"line_end":627,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10756},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959259,"byte_end":2959272,"line_start":640,"line_end":640,"column_start":15,"column_end":28},"name":"_mm_crc32_u16","qualname":"::core_arch::x86::sse42::_mm_crc32_u16","value":"fn (crc: u32, v: u16) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Starting with the initial value in `crc`, return the accumulated\n CRC32 value for unsigned 16-bit integer `v`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959109,"byte_end":2959118,"line_start":636,"line_end":636,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959119,"byte_end":2959155,"line_start":637,"line_end":637,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959195,"byte_end":2959244,"line_start":639,"line_end":639,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10758},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959709,"byte_end":2959722,"line_start":652,"line_end":652,"column_start":15,"column_end":28},"name":"_mm_crc32_u32","qualname":"::core_arch::x86::sse42::_mm_crc32_u32","value":"fn (crc: u32, v: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Starting with the initial value in `crc`, return the accumulated\n CRC32 value for unsigned 32-bit integer `v`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959559,"byte_end":2959568,"line_start":648,"line_end":648,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959569,"byte_end":2959605,"line_start":649,"line_end":649,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959645,"byte_end":2959694,"line_start":651,"line_end":651,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10760},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2960138,"byte_end":2960153,"line_start":664,"line_end":664,"column_start":15,"column_end":30},"name":"_mm_cmpgt_epi64","qualname":"::core_arch::x86::sse42::_mm_cmpgt_epi64","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 64-bit integers in `a` and `b` for greater-than,\n return the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959986,"byte_end":2959995,"line_start":660,"line_end":660,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2959996,"byte_end":2960032,"line_start":661,"line_end":661,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse42.rs","byte_start":2960074,"byte_end":2960123,"line_start":663,"line_end":663,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10788},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2969655,"byte_end":2969668,"line_start":34,"line_end":34,"column_start":15,"column_end":28},"name":"_mm256_add_pd","qualname":"::core_arch::x86::avx::_mm256_add_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Adds packed double-precision (64-bit) floating-point elements\n in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2969507,"byte_end":2969516,"line_start":30,"line_end":30,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2969517,"byte_end":2969550,"line_start":31,"line_end":31,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2969591,"byte_end":2969640,"line_start":33,"line_end":33,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10790},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2970076,"byte_end":2970089,"line_start":46,"line_end":46,"column_start":15,"column_end":28},"name":"_mm256_add_ps","qualname":"::core_arch::x86::avx::_mm256_add_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Adds packed single-precision (32-bit) floating-point elements in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2969928,"byte_end":2969937,"line_start":42,"line_end":42,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2969938,"byte_end":2969971,"line_start":43,"line_end":43,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2970012,"byte_end":2970061,"line_start":45,"line_end":45,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10792},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2970622,"byte_end":2970635,"line_start":60,"line_end":60,"column_start":15,"column_end":28},"name":"_mm256_and_pd","qualname":"::core_arch::x86::avx::_mm256_and_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of a packed double-precision (64-bit)\n floating-point elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2970371,"byte_end":2970380,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2970381,"byte_end":2970414,"line_start":55,"line_end":55,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2970558,"byte_end":2970607,"line_start":59,"line_end":59,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10794},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2971143,"byte_end":2971156,"line_start":74,"line_end":74,"column_start":15,"column_end":28},"name":"_mm256_and_ps","qualname":"::core_arch::x86::avx::_mm256_and_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of packed single-precision (32-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2970995,"byte_end":2971004,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2971005,"byte_end":2971038,"line_start":71,"line_end":71,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2971079,"byte_end":2971128,"line_start":73,"line_end":73,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10796},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2971760,"byte_end":2971772,"line_start":90,"line_end":90,"column_start":15,"column_end":27},"name":"_mm256_or_pd","qualname":"::core_arch::x86::avx::_mm256_or_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR packed double-precision (64-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2971508,"byte_end":2971517,"line_start":84,"line_end":84,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2971518,"byte_end":2971551,"line_start":85,"line_end":85,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2971696,"byte_end":2971745,"line_start":89,"line_end":89,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10798},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972273,"byte_end":2972285,"line_start":104,"line_end":104,"column_start":15,"column_end":27},"name":"_mm256_or_ps","qualname":"::core_arch::x86::avx::_mm256_or_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR packed single-precision (32-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972126,"byte_end":2972135,"line_start":100,"line_end":100,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972136,"byte_end":2972169,"line_start":101,"line_end":101,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972209,"byte_end":2972258,"line_start":103,"line_end":103,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10800},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972846,"byte_end":2972863,"line_start":119,"line_end":119,"column_start":15,"column_end":32},"name":"_mm256_shuffle_pd","qualname":"::core_arch::x86::avx::_mm256_shuffle_pd","value":"fn (a: __m256d, b: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements within 128-bit\n lanes using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972653,"byte_end":2972662,"line_start":114,"line_end":114,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972663,"byte_end":2972696,"line_start":115,"line_end":115,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972750,"byte_end":2972781,"line_start":117,"line_end":117,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2972782,"byte_end":2972831,"line_start":118,"line_end":118,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10810},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2974260,"byte_end":2974277,"line_start":165,"line_end":165,"column_start":15,"column_end":32},"name":"_mm256_shuffle_ps","qualname":"::core_arch::x86::avx::_mm256_shuffle_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a` within\n 128-bit lanes using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2974067,"byte_end":2974076,"line_start":160,"line_end":160,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2974077,"byte_end":2974110,"line_start":161,"line_end":161,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2974164,"byte_end":2974195,"line_start":163,"line_end":163,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2974196,"byte_end":2974245,"line_start":164,"line_end":164,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10820},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2976349,"byte_end":2976365,"line_start":228,"line_end":228,"column_start":15,"column_end":31},"name":"_mm256_andnot_pd","qualname":"::core_arch::x86::avx::_mm256_andnot_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of packed double-precision (64-bit) floating-point\n elements in `a`, and then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2976157,"byte_end":2976166,"line_start":223,"line_end":223,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2976167,"byte_end":2976200,"line_start":224,"line_end":224,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2976285,"byte_end":2976334,"line_start":227,"line_end":227,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10822},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2976929,"byte_end":2976945,"line_start":243,"line_end":243,"column_start":15,"column_end":31},"name":"_mm256_andnot_ps","qualname":"::core_arch::x86::avx::_mm256_andnot_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of packed single-precision (32-bit) floating-point\n elements in `a`\n and then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2976780,"byte_end":2976789,"line_start":239,"line_end":239,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2976790,"byte_end":2976823,"line_start":240,"line_end":240,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2976865,"byte_end":2976914,"line_start":242,"line_end":242,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10824},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2977499,"byte_end":2977512,"line_start":257,"line_end":257,"column_start":15,"column_end":28},"name":"_mm256_max_pd","qualname":"::core_arch::x86::avx::_mm256_max_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Compares packed double-precision (64-bit) floating-point elements\n in `a` and `b`, and returns packed maximum values","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2977351,"byte_end":2977360,"line_start":253,"line_end":253,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2977361,"byte_end":2977394,"line_start":254,"line_end":254,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2977435,"byte_end":2977484,"line_start":256,"line_end":256,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10826},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2977958,"byte_end":2977971,"line_start":269,"line_end":269,"column_start":15,"column_end":28},"name":"_mm256_max_ps","qualname":"::core_arch::x86::avx::_mm256_max_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and returns packed maximum values","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2977810,"byte_end":2977819,"line_start":265,"line_end":265,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2977820,"byte_end":2977853,"line_start":266,"line_end":266,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2977894,"byte_end":2977943,"line_start":268,"line_end":268,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10828},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2978414,"byte_end":2978427,"line_start":281,"line_end":281,"column_start":15,"column_end":28},"name":"_mm256_min_pd","qualname":"::core_arch::x86::avx::_mm256_min_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Compares packed double-precision (64-bit) floating-point elements\n in `a` and `b`, and returns packed minimum values","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2978266,"byte_end":2978275,"line_start":277,"line_end":277,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2978276,"byte_end":2978309,"line_start":278,"line_end":278,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2978350,"byte_end":2978399,"line_start":280,"line_end":280,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10830},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2978873,"byte_end":2978886,"line_start":293,"line_end":293,"column_start":15,"column_end":28},"name":"_mm256_min_ps","qualname":"::core_arch::x86::avx::_mm256_min_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and returns packed minimum values","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2978725,"byte_end":2978734,"line_start":289,"line_end":289,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2978735,"byte_end":2978768,"line_start":290,"line_end":290,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2978809,"byte_end":2978858,"line_start":292,"line_end":292,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10832},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2979297,"byte_end":2979310,"line_start":305,"line_end":305,"column_start":15,"column_end":28},"name":"_mm256_mul_pd","qualname":"::core_arch::x86::avx::_mm256_mul_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements\n in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2979149,"byte_end":2979158,"line_start":301,"line_end":301,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2979159,"byte_end":2979192,"line_start":302,"line_end":302,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2979233,"byte_end":2979282,"line_start":304,"line_end":304,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10834},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2979724,"byte_end":2979737,"line_start":317,"line_end":317,"column_start":15,"column_end":28},"name":"_mm256_mul_ps","qualname":"::core_arch::x86::avx::_mm256_mul_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a` and\n `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2979576,"byte_end":2979585,"line_start":313,"line_end":313,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2979586,"byte_end":2979619,"line_start":314,"line_end":314,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2979660,"byte_end":2979709,"line_start":316,"line_end":316,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10836},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980199,"byte_end":2980215,"line_start":329,"line_end":329,"column_start":15,"column_end":31},"name":"_mm256_addsub_pd","qualname":"::core_arch::x86::avx::_mm256_addsub_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Alternatively adds and subtracts packed double-precision (64-bit)\n floating-point elements in `a` to/from packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980048,"byte_end":2980057,"line_start":325,"line_end":325,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980058,"byte_end":2980091,"line_start":326,"line_end":326,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980135,"byte_end":2980184,"line_start":328,"line_end":328,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10838},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980683,"byte_end":2980699,"line_start":341,"line_end":341,"column_start":15,"column_end":31},"name":"_mm256_addsub_ps","qualname":"::core_arch::x86::avx::_mm256_addsub_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Alternatively adds and subtracts packed single-precision (32-bit)\n floating-point elements in `a` to/from packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980532,"byte_end":2980541,"line_start":337,"line_end":337,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980542,"byte_end":2980575,"line_start":338,"line_end":338,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980619,"byte_end":2980668,"line_start":340,"line_end":340,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10840},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981132,"byte_end":2981145,"line_start":353,"line_end":353,"column_start":15,"column_end":28},"name":"_mm256_sub_pd","qualname":"::core_arch::x86::avx::_mm256_sub_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Subtracts packed double-precision (64-bit) floating-point elements in `b`\n from packed elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980984,"byte_end":2980993,"line_start":349,"line_end":349,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2980994,"byte_end":2981027,"line_start":350,"line_end":350,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981068,"byte_end":2981117,"line_start":352,"line_end":352,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10842},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981578,"byte_end":2981591,"line_start":365,"line_end":365,"column_start":15,"column_end":28},"name":"_mm256_sub_ps","qualname":"::core_arch::x86::avx::_mm256_sub_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Subtracts packed single-precision (32-bit) floating-point elements in `b`\n from packed elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981430,"byte_end":2981439,"line_start":361,"line_end":361,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981440,"byte_end":2981473,"line_start":362,"line_end":362,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981514,"byte_end":2981563,"line_start":364,"line_end":364,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10844},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2982047,"byte_end":2982060,"line_start":377,"line_end":377,"column_start":15,"column_end":28},"name":"_mm256_div_ps","qualname":"::core_arch::x86::avx::_mm256_div_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the division of each of the 8 packed 32-bit floating-point elements\n in `a` by the corresponding packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981899,"byte_end":2981908,"line_start":373,"line_end":373,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981909,"byte_end":2981942,"line_start":374,"line_end":374,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2981983,"byte_end":2982032,"line_start":376,"line_end":376,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10846},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2982516,"byte_end":2982529,"line_start":389,"line_end":389,"column_start":15,"column_end":28},"name":"_mm256_div_pd","qualname":"::core_arch::x86::avx::_mm256_div_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the division of each of the 4 packed 64-bit floating-point elements\n in `a` by the corresponding packed elements in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2982368,"byte_end":2982377,"line_start":385,"line_end":385,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2982378,"byte_end":2982411,"line_start":386,"line_end":386,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2982452,"byte_end":2982501,"line_start":388,"line_end":388,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10848},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983435,"byte_end":2983450,"line_start":411,"line_end":411,"column_start":15,"column_end":30},"name":"_mm256_round_pd","qualname":"::core_arch::x86::avx::_mm256_round_pd","value":"fn (a: __m256d, b: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed double-precision (64-bit) floating point elements in `a`\n according to the flag `b`. The value of `b` may be as follows:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983244,"byte_end":2983253,"line_start":406,"line_end":406,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983254,"byte_end":2983287,"line_start":407,"line_end":407,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983339,"byte_end":2983370,"line_start":409,"line_end":409,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983371,"byte_end":2983420,"line_start":410,"line_end":410,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10852},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983985,"byte_end":2983999,"line_start":428,"line_end":428,"column_start":15,"column_end":29},"name":"_mm256_ceil_pd","qualname":"::core_arch::x86::avx::_mm256_ceil_pd","value":"fn (a: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed double-precision (64-bit) floating point elements in `a`\n toward positive infinity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983835,"byte_end":2983844,"line_start":424,"line_end":424,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983845,"byte_end":2983878,"line_start":425,"line_end":425,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2983921,"byte_end":2983970,"line_start":427,"line_end":427,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10854},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2984423,"byte_end":2984438,"line_start":440,"line_end":440,"column_start":15,"column_end":30},"name":"_mm256_floor_pd","qualname":"::core_arch::x86::avx::_mm256_floor_pd","value":"fn (a: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed double-precision (64-bit) floating point elements in `a`\n toward negative infinity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2984273,"byte_end":2984282,"line_start":436,"line_end":436,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2984283,"byte_end":2984316,"line_start":437,"line_end":437,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2984359,"byte_end":2984408,"line_start":439,"line_end":439,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10856},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985338,"byte_end":2985353,"line_start":462,"line_end":462,"column_start":15,"column_end":30},"name":"_mm256_round_ps","qualname":"::core_arch::x86::avx::_mm256_round_ps","value":"fn (a: __m256, b: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed single-precision (32-bit) floating point elements in `a`\n according to the flag `b`. The value of `b` may be as follows:","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985146,"byte_end":2985155,"line_start":457,"line_end":457,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985156,"byte_end":2985189,"line_start":458,"line_end":458,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985242,"byte_end":2985273,"line_start":460,"line_end":460,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985274,"byte_end":2985323,"line_start":461,"line_end":461,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10860},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985886,"byte_end":2985900,"line_start":479,"line_end":479,"column_start":15,"column_end":29},"name":"_mm256_ceil_ps","qualname":"::core_arch::x86::avx::_mm256_ceil_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed single-precision (32-bit) floating point elements in `a`\n toward positive infinity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985736,"byte_end":2985745,"line_start":475,"line_end":475,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985746,"byte_end":2985779,"line_start":476,"line_end":476,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2985822,"byte_end":2985871,"line_start":478,"line_end":478,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10862},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2986322,"byte_end":2986337,"line_start":491,"line_end":491,"column_start":15,"column_end":30},"name":"_mm256_floor_ps","qualname":"::core_arch::x86::avx::_mm256_floor_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Rounds packed single-precision (32-bit) floating point elements in `a`\n toward negative infinity.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2986172,"byte_end":2986181,"line_start":487,"line_end":487,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2986182,"byte_end":2986215,"line_start":488,"line_end":488,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2986258,"byte_end":2986307,"line_start":490,"line_end":490,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10864},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2986752,"byte_end":2986766,"line_start":503,"line_end":503,"column_start":15,"column_end":29},"name":"_mm256_sqrt_ps","qualname":"::core_arch::x86::avx::_mm256_sqrt_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of packed single-precision (32-bit) floating point\n elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2986603,"byte_end":2986612,"line_start":499,"line_end":499,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2986613,"byte_end":2986646,"line_start":500,"line_end":500,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2986688,"byte_end":2986737,"line_start":502,"line_end":502,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10866},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987174,"byte_end":2987188,"line_start":515,"line_end":515,"column_start":15,"column_end":29},"name":"_mm256_sqrt_pd","qualname":"::core_arch::x86::avx::_mm256_sqrt_pd","value":"fn (a: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns the square root of packed double-precision (64-bit) floating point\n elements in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987025,"byte_end":2987034,"line_start":511,"line_end":511,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987035,"byte_end":2987068,"line_start":512,"line_end":512,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987110,"byte_end":2987159,"line_start":514,"line_end":514,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10868},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987839,"byte_end":2987854,"line_start":531,"line_end":531,"column_start":15,"column_end":30},"name":"_mm256_blend_pd","qualname":"::core_arch::x86::avx::_mm256_blend_pd","value":"fn (a: __m256d, b: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Blends packed double-precision (64-bit) floating-point elements from\n `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987466,"byte_end":2987475,"line_start":523,"line_end":523,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987476,"byte_end":2987509,"line_start":524,"line_end":524,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987743,"byte_end":2987774,"line_start":529,"line_end":529,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2987775,"byte_end":2987824,"line_start":530,"line_end":530,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10878},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2989195,"byte_end":2989210,"line_start":577,"line_end":577,"column_start":15,"column_end":30},"name":"_mm256_blend_ps","qualname":"::core_arch::x86::avx::_mm256_blend_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Blends packed single-precision (32-bit) floating-point elements from\n `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2989003,"byte_end":2989012,"line_start":572,"line_end":572,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2989013,"byte_end":2989046,"line_start":573,"line_end":573,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2989099,"byte_end":2989130,"line_start":575,"line_end":575,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2989131,"byte_end":2989180,"line_start":576,"line_end":576,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10888},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2991227,"byte_end":2991243,"line_start":639,"line_end":639,"column_start":15,"column_end":31},"name":"_mm256_blendv_pd","qualname":"::core_arch::x86::avx::_mm256_blendv_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Blends packed double-precision (64-bit) floating-point elements from\n `a` and `b` using `c` as a mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2991076,"byte_end":2991085,"line_start":635,"line_end":635,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2991086,"byte_end":2991119,"line_start":636,"line_end":636,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2991163,"byte_end":2991212,"line_start":638,"line_end":638,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10890},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2991697,"byte_end":2991713,"line_start":651,"line_end":651,"column_start":15,"column_end":31},"name":"_mm256_blendv_ps","qualname":"::core_arch::x86::avx::_mm256_blendv_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Blends packed single-precision (32-bit) floating-point elements from\n `a` and `b` using `c` as a mask.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2991546,"byte_end":2991555,"line_start":647,"line_end":647,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2991556,"byte_end":2991589,"line_start":648,"line_end":648,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2991633,"byte_end":2991682,"line_start":650,"line_end":650,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10892},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2992328,"byte_end":2992340,"line_start":666,"line_end":666,"column_start":15,"column_end":27},"name":"_mm256_dp_ps","qualname":"::core_arch::x86::avx::_mm256_dp_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Conditionally multiplies the packed single-precision (32-bit) floating-point\n elements in `a` and `b` using the high 4 bits in `imm8`,\n sum the four products, and conditionally return the sum\n  using the low 4 bits of `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2992137,"byte_end":2992146,"line_start":661,"line_end":661,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2992147,"byte_end":2992180,"line_start":662,"line_end":662,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2992232,"byte_end":2992263,"line_start":664,"line_end":664,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2992264,"byte_end":2992313,"line_start":665,"line_end":665,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10896},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2993039,"byte_end":2993053,"line_start":685,"line_end":685,"column_start":15,"column_end":29},"name":"_mm256_hadd_pd","qualname":"::core_arch::x86::avx::_mm256_hadd_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Horizontal addition of adjacent pairs in the two packed vectors\n of 4 64-bit floating points `a` and `b`.\n In the result, sums of elements from `a` are returned in even locations,\n while sums of elements from `b` are returned in odd locations.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2992890,"byte_end":2992899,"line_start":681,"line_end":681,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2992900,"byte_end":2992933,"line_start":682,"line_end":682,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2992975,"byte_end":2993024,"line_start":684,"line_end":684,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10898},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2993649,"byte_end":2993663,"line_start":700,"line_end":700,"column_start":15,"column_end":29},"name":"_mm256_hadd_ps","qualname":"::core_arch::x86::avx::_mm256_hadd_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Horizontal addition of adjacent pairs in the two packed vectors\n of 8 32-bit floating points `a` and `b`.\n In the result, sums of elements from `a` are returned in locations of\n indices 0, 1, 4, 5; while sums of elements from `b` are locations\n 2, 3, 6, 7.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2993500,"byte_end":2993509,"line_start":696,"line_end":696,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2993510,"byte_end":2993543,"line_start":697,"line_end":697,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2993585,"byte_end":2993634,"line_start":699,"line_end":699,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10900},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2994243,"byte_end":2994257,"line_start":714,"line_end":714,"column_start":15,"column_end":29},"name":"_mm256_hsub_pd","qualname":"::core_arch::x86::avx::_mm256_hsub_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Horizontal subtraction of adjacent pairs in the two packed vectors\n of 4 64-bit floating points `a` and `b`.\n In the result, sums of elements from `a` are returned in even locations,\n while sums of elements from `b` are returned in odd locations.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2994094,"byte_end":2994103,"line_start":710,"line_end":710,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2994104,"byte_end":2994137,"line_start":711,"line_end":711,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2994179,"byte_end":2994228,"line_start":713,"line_end":713,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10902},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2994856,"byte_end":2994870,"line_start":729,"line_end":729,"column_start":15,"column_end":29},"name":"_mm256_hsub_ps","qualname":"::core_arch::x86::avx::_mm256_hsub_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Horizontal subtraction of adjacent pairs in the two packed vectors\n of 8 32-bit floating points `a` and `b`.\n In the result, sums of elements from `a` are returned in locations of\n indices 0, 1, 4, 5; while sums of elements from `b` are locations\n 2, 3, 6, 7.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2994707,"byte_end":2994716,"line_start":725,"line_end":725,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2994717,"byte_end":2994750,"line_start":726,"line_end":726,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2994792,"byte_end":2994841,"line_start":728,"line_end":728,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10904},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2995338,"byte_end":2995351,"line_start":742,"line_end":742,"column_start":15,"column_end":28},"name":"_mm256_xor_pd","qualname":"::core_arch::x86::avx::_mm256_xor_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise XOR of packed double-precision (64-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2995149,"byte_end":2995158,"line_start":737,"line_end":737,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2995159,"byte_end":2995192,"line_start":738,"line_end":738,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2995274,"byte_end":2995323,"line_start":741,"line_end":741,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10906},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2995859,"byte_end":2995872,"line_start":756,"line_end":756,"column_start":15,"column_end":28},"name":"_mm256_xor_ps","qualname":"::core_arch::x86::avx::_mm256_xor_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise XOR of packed single-precision (32-bit) floating-point\n elements in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2995711,"byte_end":2995720,"line_start":752,"line_end":752,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2995721,"byte_end":2995754,"line_start":753,"line_end":753,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2995795,"byte_end":2995844,"line_start":755,"line_end":755,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10908},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996101,"byte_end":2996111,"line_start":764,"line_end":764,"column_start":11,"column_end":21},"name":"_CMP_EQ_OQ","qualname":"::core_arch::x86::avx::_CMP_EQ_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Equal (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996041,"byte_end":2996090,"line_start":763,"line_end":763,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10910},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996220,"byte_end":2996230,"line_start":767,"line_end":767,"column_start":11,"column_end":21},"name":"_CMP_LT_OS","qualname":"::core_arch::x86::avx::_CMP_LT_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Less-than (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996160,"byte_end":2996209,"line_start":766,"line_end":766,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10912},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996348,"byte_end":2996358,"line_start":770,"line_end":770,"column_start":11,"column_end":21},"name":"_CMP_LE_OS","qualname":"::core_arch::x86::avx::_CMP_LE_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Less-than-or-equal (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996288,"byte_end":2996337,"line_start":769,"line_end":769,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10914},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996462,"byte_end":2996474,"line_start":773,"line_end":773,"column_start":11,"column_end":23},"name":"_CMP_UNORD_Q","qualname":"::core_arch::x86::avx::_CMP_UNORD_Q","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Unordered (non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996402,"byte_end":2996451,"line_start":772,"line_end":772,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10916},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996589,"byte_end":2996600,"line_start":776,"line_end":776,"column_start":11,"column_end":22},"name":"_CMP_NEQ_UQ","qualname":"::core_arch::x86::avx::_CMP_NEQ_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-equal (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996529,"byte_end":2996578,"line_start":775,"line_end":775,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10918},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996715,"byte_end":2996726,"line_start":779,"line_end":779,"column_start":11,"column_end":22},"name":"_CMP_NLT_US","qualname":"::core_arch::x86::avx::_CMP_NLT_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-less-than (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996655,"byte_end":2996704,"line_start":778,"line_end":778,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10920},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996850,"byte_end":2996861,"line_start":782,"line_end":782,"column_start":11,"column_end":22},"name":"_CMP_NLE_US","qualname":"::core_arch::x86::avx::_CMP_NLE_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-less-than-or-equal (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996790,"byte_end":2996839,"line_start":781,"line_end":781,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10922},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996963,"byte_end":2996973,"line_start":785,"line_end":785,"column_start":11,"column_end":21},"name":"_CMP_ORD_Q","qualname":"::core_arch::x86::avx::_CMP_ORD_Q","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Ordered (non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2996903,"byte_end":2996952,"line_start":784,"line_end":784,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10924},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997084,"byte_end":2997094,"line_start":788,"line_end":788,"column_start":11,"column_end":21},"name":"_CMP_EQ_UQ","qualname":"::core_arch::x86::avx::_CMP_EQ_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Equal (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997024,"byte_end":2997073,"line_start":787,"line_end":787,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10926},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997221,"byte_end":2997232,"line_start":791,"line_end":791,"column_start":11,"column_end":22},"name":"_CMP_NGE_US","qualname":"::core_arch::x86::avx::_CMP_NGE_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-greater-than-or-equal (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997161,"byte_end":2997210,"line_start":790,"line_end":790,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10928},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997350,"byte_end":2997361,"line_start":794,"line_end":794,"column_start":11,"column_end":22},"name":"_CMP_NGT_US","qualname":"::core_arch::x86::avx::_CMP_NGT_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-greater-than (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997290,"byte_end":2997339,"line_start":793,"line_end":793,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10930},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997470,"byte_end":2997483,"line_start":797,"line_end":797,"column_start":11,"column_end":24},"name":"_CMP_FALSE_OQ","qualname":"::core_arch::x86::avx::_CMP_FALSE_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" False (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997410,"byte_end":2997459,"line_start":796,"line_end":796,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10932},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997596,"byte_end":2997607,"line_start":800,"line_end":800,"column_start":11,"column_end":22},"name":"_CMP_NEQ_OQ","qualname":"::core_arch::x86::avx::_CMP_NEQ_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-equal (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997536,"byte_end":2997585,"line_start":799,"line_end":799,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10934},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997728,"byte_end":2997738,"line_start":803,"line_end":803,"column_start":11,"column_end":21},"name":"_CMP_GE_OS","qualname":"::core_arch::x86::avx::_CMP_GE_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Greater-than-or-equal (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997668,"byte_end":2997717,"line_start":802,"line_end":802,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10936},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997850,"byte_end":2997860,"line_start":806,"line_end":806,"column_start":11,"column_end":21},"name":"_CMP_GT_OS","qualname":"::core_arch::x86::avx::_CMP_GT_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Greater-than (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997790,"byte_end":2997839,"line_start":805,"line_end":805,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10938},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997970,"byte_end":2997982,"line_start":809,"line_end":809,"column_start":11,"column_end":23},"name":"_CMP_TRUE_UQ","qualname":"::core_arch::x86::avx::_CMP_TRUE_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" True (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2997910,"byte_end":2997959,"line_start":808,"line_end":808,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10940},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998087,"byte_end":2998097,"line_start":812,"line_end":812,"column_start":11,"column_end":21},"name":"_CMP_EQ_OS","qualname":"::core_arch::x86::avx::_CMP_EQ_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Equal (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998027,"byte_end":2998076,"line_start":811,"line_end":811,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10942},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998210,"byte_end":2998220,"line_start":815,"line_end":815,"column_start":11,"column_end":21},"name":"_CMP_LT_OQ","qualname":"::core_arch::x86::avx::_CMP_LT_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Less-than (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998150,"byte_end":2998199,"line_start":814,"line_end":814,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10944},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998342,"byte_end":2998352,"line_start":818,"line_end":818,"column_start":11,"column_end":21},"name":"_CMP_LE_OQ","qualname":"::core_arch::x86::avx::_CMP_LE_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Less-than-or-equal (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998282,"byte_end":2998331,"line_start":817,"line_end":817,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10946},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998452,"byte_end":2998464,"line_start":821,"line_end":821,"column_start":11,"column_end":23},"name":"_CMP_UNORD_S","qualname":"::core_arch::x86::avx::_CMP_UNORD_S","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Unordered (signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998392,"byte_end":2998441,"line_start":820,"line_end":820,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10948},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998575,"byte_end":2998586,"line_start":824,"line_end":824,"column_start":11,"column_end":22},"name":"_CMP_NEQ_US","qualname":"::core_arch::x86::avx::_CMP_NEQ_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-equal (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998515,"byte_end":2998564,"line_start":823,"line_end":823,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10950},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998705,"byte_end":2998716,"line_start":827,"line_end":827,"column_start":11,"column_end":22},"name":"_CMP_NLT_UQ","qualname":"::core_arch::x86::avx::_CMP_NLT_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-less-than (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998645,"byte_end":2998694,"line_start":826,"line_end":826,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10952},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998844,"byte_end":2998855,"line_start":830,"line_end":830,"column_start":11,"column_end":22},"name":"_CMP_NLE_UQ","qualname":"::core_arch::x86::avx::_CMP_NLE_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-less-than-or-equal (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998784,"byte_end":2998833,"line_start":829,"line_end":829,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10954},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998953,"byte_end":2998963,"line_start":833,"line_end":833,"column_start":11,"column_end":21},"name":"_CMP_ORD_S","qualname":"::core_arch::x86::avx::_CMP_ORD_S","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Ordered (signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2998893,"byte_end":2998942,"line_start":832,"line_end":832,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10956},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999070,"byte_end":2999080,"line_start":836,"line_end":836,"column_start":11,"column_end":21},"name":"_CMP_EQ_US","qualname":"::core_arch::x86::avx::_CMP_EQ_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Equal (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999010,"byte_end":2999059,"line_start":835,"line_end":835,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10958},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999211,"byte_end":2999222,"line_start":839,"line_end":839,"column_start":11,"column_end":22},"name":"_CMP_NGE_UQ","qualname":"::core_arch::x86::avx::_CMP_NGE_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-greater-than-or-equal (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999151,"byte_end":2999200,"line_start":838,"line_end":838,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10960},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999344,"byte_end":2999355,"line_start":842,"line_end":842,"column_start":11,"column_end":22},"name":"_CMP_NGT_UQ","qualname":"::core_arch::x86::avx::_CMP_NGT_UQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-greater-than (unordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999284,"byte_end":2999333,"line_start":841,"line_end":841,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10962},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999460,"byte_end":2999473,"line_start":845,"line_end":845,"column_start":11,"column_end":24},"name":"_CMP_FALSE_OS","qualname":"::core_arch::x86::avx::_CMP_FALSE_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" False (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999400,"byte_end":2999449,"line_start":844,"line_end":844,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10964},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999582,"byte_end":2999593,"line_start":848,"line_end":848,"column_start":11,"column_end":22},"name":"_CMP_NEQ_OS","qualname":"::core_arch::x86::avx::_CMP_NEQ_OS","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Not-equal (ordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999522,"byte_end":2999571,"line_start":847,"line_end":847,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10966},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999718,"byte_end":2999728,"line_start":851,"line_end":851,"column_start":11,"column_end":21},"name":"_CMP_GE_OQ","qualname":"::core_arch::x86::avx::_CMP_GE_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Greater-than-or-equal (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999658,"byte_end":2999707,"line_start":850,"line_end":850,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10968},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999844,"byte_end":2999854,"line_start":854,"line_end":854,"column_start":11,"column_end":21},"name":"_CMP_GT_OQ","qualname":"::core_arch::x86::avx::_CMP_GT_OQ","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" Greater-than (ordered, non-signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999784,"byte_end":2999833,"line_start":853,"line_end":853,"column_start":1,"column_end":50}}]},{"kind":"Const","id":{"krate":0,"index":10970},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999960,"byte_end":2999972,"line_start":857,"line_end":857,"column_start":11,"column_end":23},"name":"_CMP_TRUE_US","qualname":"::core_arch::x86::avx::_CMP_TRUE_US","value":"i32","parent":null,"children":[],"decl_id":null,"docs":" True (unordered, signaling)\n","sig":null,"attributes":[{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":2999900,"byte_end":2999949,"line_start":856,"line_end":856,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10972},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3000465,"byte_end":3000475,"line_start":869,"line_end":869,"column_start":15,"column_end":25},"name":"_mm_cmp_pd","qualname":"::core_arch::x86::avx::_mm_cmp_pd","value":"fn (a: __m128d, b: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares packed double-precision (64-bit) floating-point\n elements in `a` and `b` based on the comparison operand\n specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3000244,"byte_end":3000253,"line_start":864,"line_end":864,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3000254,"byte_end":3000292,"line_start":865,"line_end":865,"column_start":1,"column_end":39}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3000369,"byte_end":3000400,"line_start":867,"line_end":867,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3000401,"byte_end":3000450,"line_start":868,"line_end":868,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10976},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3001133,"byte_end":3001146,"line_start":888,"line_end":888,"column_start":15,"column_end":28},"name":"_mm256_cmp_pd","qualname":"::core_arch::x86::avx::_mm256_cmp_pd","value":"fn (a: __m256d, b: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Compares packed double-precision (64-bit) floating-point\n elements in `a` and `b` based on the comparison operand\n specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3000917,"byte_end":3000926,"line_start":883,"line_end":883,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3000927,"byte_end":3000960,"line_start":884,"line_end":884,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3001037,"byte_end":3001068,"line_start":886,"line_end":886,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3001069,"byte_end":3001118,"line_start":887,"line_end":887,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10980},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3001808,"byte_end":3001818,"line_start":907,"line_end":907,"column_start":15,"column_end":25},"name":"_mm_cmp_ps","qualname":"::core_arch::x86::avx::_mm_cmp_ps","value":"fn (a: __m128, b: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point\n elements in `a` and `b` based on the comparison operand\n specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3001588,"byte_end":3001597,"line_start":902,"line_end":902,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3001598,"byte_end":3001635,"line_start":903,"line_end":903,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3001712,"byte_end":3001743,"line_start":905,"line_end":905,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3001744,"byte_end":3001793,"line_start":906,"line_end":906,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10984},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3002473,"byte_end":3002486,"line_start":926,"line_end":926,"column_start":15,"column_end":28},"name":"_mm256_cmp_ps","qualname":"::core_arch::x86::avx::_mm256_cmp_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Compares packed single-precision (32-bit) floating-point\n elements in `a` and `b` based on the comparison operand\n specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3002257,"byte_end":3002266,"line_start":921,"line_end":921,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3002267,"byte_end":3002300,"line_start":922,"line_end":922,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3002377,"byte_end":3002408,"line_start":924,"line_end":924,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3002409,"byte_end":3002458,"line_start":925,"line_end":925,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10988},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3003293,"byte_end":3003303,"line_start":947,"line_end":947,"column_start":15,"column_end":25},"name":"_mm_cmp_sd","qualname":"::core_arch::x86::avx::_mm_cmp_sd","value":"fn (a: __m128d, b: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower double-precision (64-bit) floating-point element in\n `a` and `b` based on the comparison operand specified by `imm8`,\n store the result in the lower element of returned vector,\n and copies the upper element from `a` to the upper element of returned\n vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3003072,"byte_end":3003081,"line_start":942,"line_end":942,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3003082,"byte_end":3003120,"line_start":943,"line_end":943,"column_start":1,"column_end":39}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3003197,"byte_end":3003228,"line_start":945,"line_end":945,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3003229,"byte_end":3003278,"line_start":946,"line_end":946,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10992},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004120,"byte_end":3004130,"line_start":968,"line_end":968,"column_start":15,"column_end":25},"name":"_mm_cmp_ss","qualname":"::core_arch::x86::avx::_mm_cmp_ss","value":"fn (a: __m128, b: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Compares the lower single-precision (32-bit) floating-point element in\n `a` and `b` based on the comparison operand specified by `imm8`,\n store the result in the lower element of returned vector,\n and copies the upper 3 packed elements from `a` to the upper elements of\n returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3003900,"byte_end":3003909,"line_start":963,"line_end":963,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3003910,"byte_end":3003947,"line_start":964,"line_end":964,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004024,"byte_end":3004055,"line_start":966,"line_end":966,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004056,"byte_end":3004105,"line_start":967,"line_end":967,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10996},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004687,"byte_end":3004705,"line_start":985,"line_end":985,"column_start":15,"column_end":33},"name":"_mm256_cvtepi32_pd","qualname":"::core_arch::x86::avx::_mm256_cvtepi32_pd","value":"fn (a: __m128i) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers in `a` to packed double-precision (64-bit)\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004536,"byte_end":3004545,"line_start":981,"line_end":981,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004546,"byte_end":3004579,"line_start":982,"line_end":982,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004623,"byte_end":3004672,"line_start":984,"line_end":984,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":10998},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005140,"byte_end":3005158,"line_start":997,"line_end":997,"column_start":15,"column_end":33},"name":"_mm256_cvtepi32_ps","qualname":"::core_arch::x86::avx::_mm256_cvtepi32_ps","value":"fn (a: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers in `a` to packed single-precision (32-bit)\n floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004989,"byte_end":3004998,"line_start":993,"line_end":993,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3004999,"byte_end":3005032,"line_start":994,"line_end":994,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005076,"byte_end":3005125,"line_start":996,"line_end":996,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11000},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005623,"byte_end":3005638,"line_start":1009,"line_end":1009,"column_start":15,"column_end":30},"name":"_mm256_cvtpd_ps","qualname":"::core_arch::x86::avx::_mm256_cvtpd_ps","value":"fn (a: __m256d) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a`\n to packed single-precision (32-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005472,"byte_end":3005481,"line_start":1005,"line_end":1005,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005482,"byte_end":3005515,"line_start":1006,"line_end":1006,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005559,"byte_end":3005608,"line_start":1008,"line_end":1008,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11002},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3006061,"byte_end":3006079,"line_start":1021,"line_end":1021,"column_start":15,"column_end":33},"name":"_mm256_cvtps_epi32","qualname":"::core_arch::x86::avx::_mm256_cvtps_epi32","value":"fn (a: __m256) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a`\n to packed 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005910,"byte_end":3005919,"line_start":1017,"line_end":1017,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005920,"byte_end":3005953,"line_start":1018,"line_end":1018,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3005997,"byte_end":3006046,"line_start":1020,"line_end":1020,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11004},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3006544,"byte_end":3006559,"line_start":1033,"line_end":1033,"column_start":15,"column_end":30},"name":"_mm256_cvtps_pd","qualname":"::core_arch::x86::avx::_mm256_cvtps_pd","value":"fn (a: __m128) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a`\n to packed double-precision (64-bit) floating-point elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3006393,"byte_end":3006402,"line_start":1029,"line_end":1029,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3006403,"byte_end":3006436,"line_start":1030,"line_end":1030,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3006480,"byte_end":3006529,"line_start":1032,"line_end":1032,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11006},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007000,"byte_end":3007019,"line_start":1045,"line_end":1045,"column_start":15,"column_end":34},"name":"_mm256_cvttpd_epi32","qualname":"::core_arch::x86::avx::_mm256_cvttpd_epi32","value":"fn (a: __m256d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a`\n to packed 32-bit integers with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3006848,"byte_end":3006857,"line_start":1041,"line_end":1041,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3006858,"byte_end":3006891,"line_start":1042,"line_end":1042,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3006936,"byte_end":3006985,"line_start":1044,"line_end":1044,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11008},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007455,"byte_end":3007473,"line_start":1057,"line_end":1057,"column_start":15,"column_end":33},"name":"_mm256_cvtpd_epi32","qualname":"::core_arch::x86::avx::_mm256_cvtpd_epi32","value":"fn (a: __m256d) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed double-precision (64-bit) floating-point elements in `a`\n to packed 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007304,"byte_end":3007313,"line_start":1053,"line_end":1053,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007314,"byte_end":3007347,"line_start":1054,"line_end":1054,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007391,"byte_end":3007440,"line_start":1056,"line_end":1056,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11010},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007926,"byte_end":3007945,"line_start":1069,"line_end":1069,"column_start":15,"column_end":34},"name":"_mm256_cvttps_epi32","qualname":"::core_arch::x86::avx::_mm256_cvttps_epi32","value":"fn (a: __m256) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed single-precision (32-bit) floating-point elements in `a`\n to packed 32-bit integers with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007774,"byte_end":3007783,"line_start":1065,"line_end":1065,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007784,"byte_end":3007817,"line_start":1066,"line_end":1066,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3007862,"byte_end":3007911,"line_start":1068,"line_end":1068,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11012},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3008494,"byte_end":3008515,"line_start":1085,"line_end":1085,"column_start":15,"column_end":36},"name":"_mm256_extractf128_ps","qualname":"::core_arch::x86::avx::_mm256_extractf128_ps","value":"fn (a: __m256, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Extracts 128 bits (composed of 4 packed single-precision (32-bit)\n floating-point elements) from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3008255,"byte_end":3008264,"line_start":1077,"line_end":1077,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3008265,"byte_end":3008298,"line_start":1078,"line_end":1078,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3008398,"byte_end":3008429,"line_start":1083,"line_end":1083,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3008430,"byte_end":3008479,"line_start":1084,"line_end":1084,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11014},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3009208,"byte_end":3009229,"line_start":1104,"line_end":1104,"column_start":15,"column_end":36},"name":"_mm256_extractf128_pd","qualname":"::core_arch::x86::avx::_mm256_extractf128_pd","value":"fn (a: __m256d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Extracts 128 bits (composed of 2 packed double-precision (64-bit)\n floating-point elements) from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3008969,"byte_end":3008978,"line_start":1096,"line_end":1096,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3008979,"byte_end":3009012,"line_start":1097,"line_end":1097,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3009112,"byte_end":3009143,"line_start":1102,"line_end":1102,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3009144,"byte_end":3009193,"line_start":1103,"line_end":1103,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11016},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3009865,"byte_end":3009889,"line_start":1122,"line_end":1122,"column_start":15,"column_end":39},"name":"_mm256_extractf128_si256","qualname":"::core_arch::x86::avx::_mm256_extractf128_si256","value":"fn (a: __m256i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Extracts 128 bits (composed of integer data) from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3009626,"byte_end":3009635,"line_start":1114,"line_end":1114,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3009636,"byte_end":3009669,"line_start":1115,"line_end":1115,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3009769,"byte_end":3009800,"line_start":1120,"line_end":1120,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3009801,"byte_end":3009850,"line_start":1121,"line_end":1121,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11018},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3010466,"byte_end":3010480,"line_start":1138,"line_end":1138,"column_start":15,"column_end":29},"name":"_mm256_zeroall","qualname":"::core_arch::x86::avx::_mm256_zeroall","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Zeroes the contents of all XMM or YMM registers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3010316,"byte_end":3010325,"line_start":1134,"line_end":1134,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3010326,"byte_end":3010359,"line_start":1135,"line_end":1135,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3010402,"byte_end":3010451,"line_start":1137,"line_end":1137,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11020},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3010880,"byte_end":3010896,"line_start":1150,"line_end":1150,"column_start":15,"column_end":31},"name":"_mm256_zeroupper","qualname":"::core_arch::x86::avx::_mm256_zeroupper","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Zeroes the upper 128 bits of all YMM registers;\n the lower 128-bits of the registers are unmodified.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3010728,"byte_end":3010737,"line_start":1146,"line_end":1146,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3010738,"byte_end":3010771,"line_start":1147,"line_end":1147,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3010816,"byte_end":3010865,"line_start":1149,"line_end":1149,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11022},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3011314,"byte_end":3011334,"line_start":1162,"line_end":1162,"column_start":15,"column_end":35},"name":"_mm256_permutevar_ps","qualname":"::core_arch::x86::avx::_mm256_permutevar_ps","value":"fn (a: __m256, b: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a`\n within 128-bit lanes using the control in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3011163,"byte_end":3011172,"line_start":1158,"line_end":1158,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3011173,"byte_end":3011206,"line_start":1159,"line_end":1159,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3011250,"byte_end":3011299,"line_start":1161,"line_end":1161,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11024},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3011776,"byte_end":3011793,"line_start":1174,"line_end":1174,"column_start":15,"column_end":32},"name":"_mm_permutevar_ps","qualname":"::core_arch::x86::avx::_mm_permutevar_ps","value":"fn (a: __m128, b: __m128i) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a`\n using the control in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3011625,"byte_end":3011634,"line_start":1170,"line_end":1170,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3011635,"byte_end":3011668,"line_start":1171,"line_end":1171,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3011712,"byte_end":3011761,"line_start":1173,"line_end":1173,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11026},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3012298,"byte_end":3012315,"line_start":1187,"line_end":1187,"column_start":15,"column_end":32},"name":"_mm256_permute_ps","qualname":"::core_arch::x86::avx::_mm256_permute_ps","value":"fn (a: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a`\n within 128-bit lanes using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3012105,"byte_end":3012114,"line_start":1182,"line_end":1182,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3012115,"byte_end":3012148,"line_start":1183,"line_end":1183,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3012202,"byte_end":3012233,"line_start":1185,"line_end":1185,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3012234,"byte_end":3012283,"line_start":1186,"line_end":1186,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11036},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014144,"byte_end":3014158,"line_start":1245,"line_end":1245,"column_start":15,"column_end":29},"name":"_mm_permute_ps","qualname":"::core_arch::x86::avx::_mm_permute_ps","value":"fn (a: __m128, imm8: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Shuffles single-precision (32-bit) floating-point elements in `a`\n using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3013947,"byte_end":3013956,"line_start":1240,"line_end":1240,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3013957,"byte_end":3013994,"line_start":1241,"line_end":1241,"column_start":1,"column_end":38}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014048,"byte_end":3014079,"line_start":1243,"line_end":1243,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3014080,"byte_end":3014129,"line_start":1244,"line_end":1244,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11046},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015867,"byte_end":3015887,"line_start":1298,"line_end":1298,"column_start":15,"column_end":35},"name":"_mm256_permutevar_pd","qualname":"::core_arch::x86::avx::_mm256_permutevar_pd","value":"fn (a: __m256d, b: __m256i) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements in `a`\n within 256-bit lanes using the control in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015716,"byte_end":3015725,"line_start":1294,"line_end":1294,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015726,"byte_end":3015759,"line_start":1295,"line_end":1295,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3015803,"byte_end":3015852,"line_start":1297,"line_end":1297,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11048},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016331,"byte_end":3016348,"line_start":1310,"line_end":1310,"column_start":15,"column_end":32},"name":"_mm_permutevar_pd","qualname":"::core_arch::x86::avx::_mm_permutevar_pd","value":"fn (a: __m128d, b: __m128i) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements in `a`\n using the control in `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016180,"byte_end":3016189,"line_start":1306,"line_end":1306,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016190,"byte_end":3016223,"line_start":1307,"line_end":1307,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016267,"byte_end":3016316,"line_start":1309,"line_end":1309,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11050},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016857,"byte_end":3016874,"line_start":1323,"line_end":1323,"column_start":15,"column_end":32},"name":"_mm256_permute_pd","qualname":"::core_arch::x86::avx::_mm256_permute_pd","value":"fn (a: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements in `a`\n within 128-bit lanes using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016662,"byte_end":3016671,"line_start":1318,"line_end":1318,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016672,"byte_end":3016705,"line_start":1319,"line_end":1319,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016761,"byte_end":3016792,"line_start":1321,"line_end":1321,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3016793,"byte_end":3016842,"line_start":1322,"line_end":1322,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11060},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018262,"byte_end":3018276,"line_start":1369,"line_end":1369,"column_start":15,"column_end":29},"name":"_mm_permute_pd","qualname":"::core_arch::x86::avx::_mm_permute_pd","value":"fn (a: __m128d, imm8: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles double-precision (64-bit) floating-point elements in `a`\n using the control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018062,"byte_end":3018071,"line_start":1364,"line_end":1364,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018072,"byte_end":3018110,"line_start":1365,"line_end":1365,"column_start":1,"column_end":39}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018166,"byte_end":3018197,"line_start":1367,"line_end":1367,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3018198,"byte_end":3018247,"line_start":1368,"line_end":1368,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11066},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019225,"byte_end":3019247,"line_start":1399,"line_end":1399,"column_start":15,"column_end":37},"name":"_mm256_permute2f128_ps","qualname":"::core_arch::x86::avx::_mm256_permute2f128_ps","value":"fn (a: __m256, b: __m256, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 256 bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) selected by `imm8` from `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019029,"byte_end":3019038,"line_start":1394,"line_end":1394,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019039,"byte_end":3019072,"line_start":1395,"line_end":1395,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019129,"byte_end":3019160,"line_start":1397,"line_end":1397,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019161,"byte_end":3019210,"line_start":1398,"line_end":1398,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11070},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019891,"byte_end":3019913,"line_start":1417,"line_end":1417,"column_start":15,"column_end":37},"name":"_mm256_permute2f128_pd","qualname":"::core_arch::x86::avx::_mm256_permute2f128_pd","value":"fn (a: __m256d, b: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 256 bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) selected by `imm8` from `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019694,"byte_end":3019703,"line_start":1412,"line_end":1412,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019704,"byte_end":3019737,"line_start":1413,"line_end":1413,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019795,"byte_end":3019826,"line_start":1415,"line_end":1415,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3019827,"byte_end":3019876,"line_start":1416,"line_end":1416,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11074},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3020517,"byte_end":3020542,"line_start":1435,"line_end":1435,"column_start":15,"column_end":40},"name":"_mm256_permute2f128_si256","qualname":"::core_arch::x86::avx::_mm256_permute2f128_si256","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 258-bits (composed of integer data) selected by `imm8`\n from `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3020320,"byte_end":3020329,"line_start":1430,"line_end":1430,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3020330,"byte_end":3020363,"line_start":1431,"line_end":1431,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3020421,"byte_end":3020452,"line_start":1433,"line_end":1433,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3020453,"byte_end":3020502,"line_start":1434,"line_end":1434,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11078},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021252,"byte_end":3021271,"line_start":1456,"line_end":1456,"column_start":15,"column_end":34},"name":"_mm256_broadcast_ss","qualname":"::core_arch::x86::avx::_mm256_broadcast_ss","value":"fn (f: &f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts a single-precision (32-bit) floating-point element from memory\n to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021053,"byte_end":3021062,"line_start":1451,"line_end":1451,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021063,"byte_end":3021096,"line_start":1452,"line_end":1452,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021143,"byte_end":3021192,"line_start":1454,"line_end":1454,"column_start":1,"column_end":50}},{"value":"allow(clippy::trivially_copy_pass_by_ref)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021193,"byte_end":3021237,"line_start":1455,"line_end":1455,"column_start":1,"column_end":45}}]},{"kind":"Function","id":{"krate":0,"index":11080},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021757,"byte_end":3021773,"line_start":1469,"line_end":1469,"column_start":15,"column_end":31},"name":"_mm_broadcast_ss","qualname":"::core_arch::x86::avx::_mm_broadcast_ss","value":"fn (f: &f32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts a single-precision (32-bit) floating-point element from memory\n to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021558,"byte_end":3021567,"line_start":1464,"line_end":1464,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021568,"byte_end":3021601,"line_start":1465,"line_end":1465,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021648,"byte_end":3021697,"line_start":1467,"line_end":1467,"column_start":1,"column_end":50}},{"value":"allow(clippy::trivially_copy_pass_by_ref)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3021698,"byte_end":3021742,"line_start":1468,"line_end":1468,"column_start":1,"column_end":45}}]},{"kind":"Function","id":{"krate":0,"index":11082},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022259,"byte_end":3022278,"line_start":1482,"line_end":1482,"column_start":15,"column_end":34},"name":"_mm256_broadcast_sd","qualname":"::core_arch::x86::avx::_mm256_broadcast_sd","value":"fn (f: &f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts a double-precision (64-bit) floating-point element from memory\n to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022060,"byte_end":3022069,"line_start":1477,"line_end":1477,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022070,"byte_end":3022103,"line_start":1478,"line_end":1478,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022150,"byte_end":3022199,"line_start":1480,"line_end":1480,"column_start":1,"column_end":50}},{"value":"allow(clippy::trivially_copy_pass_by_ref)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022200,"byte_end":3022244,"line_start":1481,"line_end":1481,"column_start":1,"column_end":45}}]},{"kind":"Function","id":{"krate":0,"index":11084},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022756,"byte_end":3022775,"line_start":1494,"line_end":1494,"column_start":15,"column_end":34},"name":"_mm256_broadcast_ps","qualname":"::core_arch::x86::avx::_mm256_broadcast_ps","value":"fn (a: &__m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 128 bits from memory (composed of 4 packed single-precision\n (32-bit) floating-point elements) to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022600,"byte_end":3022609,"line_start":1490,"line_end":1490,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022610,"byte_end":3022643,"line_start":1491,"line_end":1491,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3022692,"byte_end":3022741,"line_start":1493,"line_end":1493,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11086},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023259,"byte_end":3023278,"line_start":1506,"line_end":1506,"column_start":15,"column_end":34},"name":"_mm256_broadcast_pd","qualname":"::core_arch::x86::avx::_mm256_broadcast_pd","value":"fn (a: &__m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 128 bits from memory (composed of 2 packed double-precision\n (64-bit) floating-point elements) to all elements of the returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023103,"byte_end":3023112,"line_start":1502,"line_end":1502,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023113,"byte_end":3023146,"line_start":1503,"line_end":1503,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023195,"byte_end":3023244,"line_start":1505,"line_end":1505,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11088},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023881,"byte_end":3023901,"line_start":1523,"line_end":1523,"column_start":15,"column_end":35},"name":"_mm256_insertf128_ps","qualname":"::core_arch::x86::avx::_mm256_insertf128_ps","value":"fn (a: __m256, b: __m128, imm8: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, then inserts 128 bits (composed of 4 packed\n single-precision (32-bit) floating-point elements) from `b` into result\n at the location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023643,"byte_end":3023652,"line_start":1515,"line_end":1515,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023653,"byte_end":3023686,"line_start":1516,"line_end":1516,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023785,"byte_end":3023816,"line_start":1521,"line_end":1521,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3023817,"byte_end":3023866,"line_start":1522,"line_end":1522,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11090},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024686,"byte_end":3024706,"line_start":1544,"line_end":1544,"column_start":15,"column_end":35},"name":"_mm256_insertf128_pd","qualname":"::core_arch::x86::avx::_mm256_insertf128_pd","value":"fn (a: __m256d, b: __m128d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, then inserts 128 bits (composed of 2 packed\n double-precision (64-bit) floating-point elements) from `b` into result\n at the location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024448,"byte_end":3024457,"line_start":1536,"line_end":1536,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024458,"byte_end":3024491,"line_start":1537,"line_end":1537,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024590,"byte_end":3024621,"line_start":1542,"line_end":1542,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3024622,"byte_end":3024671,"line_start":1543,"line_end":1543,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11092},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025401,"byte_end":3025424,"line_start":1563,"line_end":1563,"column_start":15,"column_end":38},"name":"_mm256_insertf128_si256","qualname":"::core_arch::x86::avx::_mm256_insertf128_si256","value":"fn (a: __m256i, b: __m128i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, then inserts 128 bits from `b` into result\n at the location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025163,"byte_end":3025172,"line_start":1555,"line_end":1555,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025173,"byte_end":3025206,"line_start":1556,"line_end":1556,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025305,"byte_end":3025336,"line_start":1561,"line_end":1561,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025337,"byte_end":3025386,"line_start":1562,"line_end":1562,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11094},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026133,"byte_end":3026151,"line_start":1581,"line_end":1581,"column_start":15,"column_end":33},"name":"_mm256_insert_epi8","qualname":"::core_arch::x86::avx::_mm256_insert_epi8","value":"fn (a: __m256i, i: i8, index: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, and inserts the 8-bit integer `i` into result\n at the location specified by `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025941,"byte_end":3025950,"line_start":1576,"line_end":1576,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3025951,"byte_end":3025984,"line_start":1577,"line_end":1577,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026037,"byte_end":3026068,"line_start":1579,"line_end":1579,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026069,"byte_end":3026118,"line_start":1580,"line_end":1580,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11096},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026691,"byte_end":3026710,"line_start":1594,"line_end":1594,"column_start":15,"column_end":34},"name":"_mm256_insert_epi16","qualname":"::core_arch::x86::avx::_mm256_insert_epi16","value":"fn (a: __m256i, i: i16, index: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, and inserts the 16-bit integer `i` into result\n at the location specified by `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026499,"byte_end":3026508,"line_start":1589,"line_end":1589,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026509,"byte_end":3026542,"line_start":1590,"line_end":1590,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026595,"byte_end":3026626,"line_start":1592,"line_end":1592,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3026627,"byte_end":3026676,"line_start":1593,"line_end":1593,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11098},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027252,"byte_end":3027271,"line_start":1607,"line_end":1607,"column_start":15,"column_end":34},"name":"_mm256_insert_epi32","qualname":"::core_arch::x86::avx::_mm256_insert_epi32","value":"fn (a: __m256i, i: i32, index: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, and inserts the 32-bit integer `i` into result\n at the location specified by `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027060,"byte_end":3027069,"line_start":1602,"line_end":1602,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027070,"byte_end":3027103,"line_start":1603,"line_end":1603,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027156,"byte_end":3027187,"line_start":1605,"line_end":1605,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027188,"byte_end":3027237,"line_start":1606,"line_end":1606,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11100},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027941,"byte_end":3027955,"line_start":1622,"line_end":1622,"column_start":15,"column_end":29},"name":"_mm256_load_pd","qualname":"::core_arch::x86::avx::_mm256_load_pd","value":"fn (mem_addr: *const f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) from memory into result.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027729,"byte_end":3027738,"line_start":1617,"line_end":1617,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027739,"byte_end":3027772,"line_start":1618,"line_end":1618,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027840,"byte_end":3027889,"line_start":1620,"line_end":1620,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3027890,"byte_end":3027926,"line_start":1621,"line_end":1621,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":11102},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028584,"byte_end":3028599,"line_start":1637,"line_end":1637,"column_start":15,"column_end":30},"name":"_mm256_store_pd","qualname":"::core_arch::x86::avx::_mm256_store_pd","value":"fn (mem_addr: *const f64, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028372,"byte_end":3028381,"line_start":1632,"line_end":1632,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028382,"byte_end":3028415,"line_start":1633,"line_end":1633,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028483,"byte_end":3028532,"line_start":1635,"line_end":1635,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3028533,"byte_end":3028569,"line_start":1636,"line_end":1636,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":11104},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029207,"byte_end":3029221,"line_start":1652,"line_end":1652,"column_start":15,"column_end":29},"name":"_mm256_load_ps","qualname":"::core_arch::x86::avx::_mm256_load_ps","value":"fn (mem_addr: *const f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) from memory into result.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029021,"byte_end":3029030,"line_start":1647,"line_end":1647,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029031,"byte_end":3029064,"line_start":1648,"line_end":1648,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029106,"byte_end":3029155,"line_start":1650,"line_end":1650,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029156,"byte_end":3029192,"line_start":1651,"line_end":1651,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":11106},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029822,"byte_end":3029837,"line_start":1667,"line_end":1667,"column_start":15,"column_end":30},"name":"_mm256_store_ps","qualname":"::core_arch::x86::avx::_mm256_store_ps","value":"fn (mem_addr: *const f32, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029636,"byte_end":3029645,"line_start":1662,"line_end":1662,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029646,"byte_end":3029679,"line_start":1663,"line_end":1663,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029721,"byte_end":3029770,"line_start":1665,"line_end":1665,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3029771,"byte_end":3029807,"line_start":1666,"line_end":1666,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":11108},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030395,"byte_end":3030410,"line_start":1680,"line_end":1680,"column_start":15,"column_end":30},"name":"_mm256_loadu_pd","qualname":"::core_arch::x86::avx::_mm256_loadu_pd","value":"fn (mem_addr: *const f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) from memory into result.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030220,"byte_end":3030229,"line_start":1676,"line_end":1676,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030230,"byte_end":3030263,"line_start":1677,"line_end":1677,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030331,"byte_end":3030380,"line_start":1679,"line_end":1679,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11110},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031128,"byte_end":3031144,"line_start":1699,"line_end":1699,"column_start":15,"column_end":31},"name":"_mm256_storeu_pd","qualname":"::core_arch::x86::avx::_mm256_storeu_pd","value":"fn (mem_addr: *mut f64, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits (composed of 4 packed double-precision (64-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030953,"byte_end":3030962,"line_start":1695,"line_end":1695,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3030963,"byte_end":3030996,"line_start":1696,"line_end":1696,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031064,"byte_end":3031113,"line_start":1698,"line_end":1698,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11112},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031669,"byte_end":3031684,"line_start":1712,"line_end":1712,"column_start":15,"column_end":30},"name":"_mm256_loadu_ps","qualname":"::core_arch::x86::avx::_mm256_loadu_ps","value":"fn (mem_addr: *const f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) from memory into result.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031520,"byte_end":3031529,"line_start":1708,"line_end":1708,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031530,"byte_end":3031563,"line_start":1709,"line_end":1709,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3031605,"byte_end":3031654,"line_start":1711,"line_end":1711,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11114},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032373,"byte_end":3032389,"line_start":1731,"line_end":1731,"column_start":15,"column_end":31},"name":"_mm256_storeu_ps","qualname":"::core_arch::x86::avx::_mm256_storeu_ps","value":"fn (mem_addr: *mut f32, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits (composed of 8 packed single-precision (32-bit)\n floating-point elements) from `a` into memory.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032224,"byte_end":3032233,"line_start":1727,"line_end":1727,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032234,"byte_end":3032267,"line_start":1728,"line_end":1728,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032309,"byte_end":3032358,"line_start":1730,"line_end":1730,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11116},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032918,"byte_end":3032935,"line_start":1744,"line_end":1744,"column_start":15,"column_end":32},"name":"_mm256_load_si256","qualname":"::core_arch::x86::avx::_mm256_load_si256","value":"fn (mem_addr: *const __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits of integer data from memory into result.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032743,"byte_end":3032752,"line_start":1740,"line_end":1740,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032753,"byte_end":3032786,"line_start":1741,"line_end":1741,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3032854,"byte_end":3032903,"line_start":1743,"line_end":1743,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11118},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033453,"byte_end":3033471,"line_start":1757,"line_end":1757,"column_start":15,"column_end":33},"name":"_mm256_store_si256","qualname":"::core_arch::x86::avx::_mm256_store_si256","value":"fn (mem_addr: *mut __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits of integer data from `a` into memory.\n `mem_addr` must be aligned on a 32-byte boundary or a\n general-protection exception may be generated.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033278,"byte_end":3033287,"line_start":1753,"line_end":1753,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033288,"byte_end":3033321,"line_start":1754,"line_end":1754,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033389,"byte_end":3033438,"line_start":1756,"line_end":1756,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11120},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033957,"byte_end":3033975,"line_start":1769,"line_end":1769,"column_start":15,"column_end":33},"name":"_mm256_loadu_si256","qualname":"::core_arch::x86::avx::_mm256_loadu_si256","value":"fn (mem_addr: *const __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits of integer data from memory into result.\n `mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033782,"byte_end":3033791,"line_start":1765,"line_end":1765,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033792,"byte_end":3033825,"line_start":1766,"line_end":1766,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3033893,"byte_end":3033942,"line_start":1768,"line_end":1768,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11122},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3034643,"byte_end":3034662,"line_start":1787,"line_end":1787,"column_start":15,"column_end":34},"name":"_mm256_storeu_si256","qualname":"::core_arch::x86::avx::_mm256_storeu_si256","value":"fn (mem_addr: *mut __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores 256-bits of integer data from `a` into memory.\n \t`mem_addr` does not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3034468,"byte_end":3034477,"line_start":1783,"line_end":1783,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3034478,"byte_end":3034511,"line_start":1784,"line_end":1784,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3034579,"byte_end":3034628,"line_start":1786,"line_end":1786,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11124},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035224,"byte_end":3035242,"line_start":1800,"line_end":1800,"column_start":15,"column_end":33},"name":"_mm256_maskload_pd","qualname":"::core_arch::x86::avx::_mm256_maskload_pd","value":"fn (mem_addr: *const f64, mask: __m256i) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Loads packed double-precision (64-bit) floating-point elements from memory\n into result using `mask` (elements are zeroed out when the high bit of the\n corresponding element is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035072,"byte_end":3035081,"line_start":1796,"line_end":1796,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035082,"byte_end":3035115,"line_start":1797,"line_end":1797,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035160,"byte_end":3035209,"line_start":1799,"line_end":1799,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11126},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035733,"byte_end":3035752,"line_start":1812,"line_end":1812,"column_start":15,"column_end":34},"name":"_mm256_maskstore_pd","qualname":"::core_arch::x86::avx::_mm256_maskstore_pd","value":"fn (mem_addr: *mut f64, mask: __m256i, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed double-precision (64-bit) floating-point elements from `a`\n into memory using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035581,"byte_end":3035590,"line_start":1808,"line_end":1808,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035591,"byte_end":3035624,"line_start":1809,"line_end":1809,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3035669,"byte_end":3035718,"line_start":1811,"line_end":1811,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11128},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036331,"byte_end":3036346,"line_start":1825,"line_end":1825,"column_start":15,"column_end":30},"name":"_mm_maskload_pd","qualname":"::core_arch::x86::avx::_mm_maskload_pd","value":"fn (mem_addr: *const f64, mask: __m128i) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Loads packed double-precision (64-bit) floating-point elements from memory\n into result using `mask` (elements are zeroed out when the high bit of the\n corresponding element is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036179,"byte_end":3036188,"line_start":1821,"line_end":1821,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036189,"byte_end":3036222,"line_start":1822,"line_end":1822,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036267,"byte_end":3036316,"line_start":1824,"line_end":1824,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11130},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036831,"byte_end":3036847,"line_start":1837,"line_end":1837,"column_start":15,"column_end":31},"name":"_mm_maskstore_pd","qualname":"::core_arch::x86::avx::_mm_maskstore_pd","value":"fn (mem_addr: *mut f64, mask: __m128i, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed double-precision (64-bit) floating-point elements from `a`\n into memory using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036679,"byte_end":3036688,"line_start":1833,"line_end":1833,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036689,"byte_end":3036722,"line_start":1834,"line_end":1834,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3036767,"byte_end":3036816,"line_start":1836,"line_end":1836,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11132},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037426,"byte_end":3037444,"line_start":1850,"line_end":1850,"column_start":15,"column_end":33},"name":"_mm256_maskload_ps","qualname":"::core_arch::x86::avx::_mm256_maskload_ps","value":"fn (mem_addr: *const f32, mask: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Loads packed single-precision (32-bit) floating-point elements from memory\n into result using `mask` (elements are zeroed out when the high bit of the\n corresponding element is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037274,"byte_end":3037283,"line_start":1846,"line_end":1846,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037284,"byte_end":3037317,"line_start":1847,"line_end":1847,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037362,"byte_end":3037411,"line_start":1849,"line_end":1849,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11134},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037934,"byte_end":3037953,"line_start":1862,"line_end":1862,"column_start":15,"column_end":34},"name":"_mm256_maskstore_ps","qualname":"::core_arch::x86::avx::_mm256_maskstore_ps","value":"fn (mem_addr: *mut f32, mask: __m256i, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed single-precision (32-bit) floating-point elements from `a`\n into memory using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037782,"byte_end":3037791,"line_start":1858,"line_end":1858,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037792,"byte_end":3037825,"line_start":1859,"line_end":1859,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3037870,"byte_end":3037919,"line_start":1861,"line_end":1861,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11136},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038531,"byte_end":3038546,"line_start":1875,"line_end":1875,"column_start":15,"column_end":30},"name":"_mm_maskload_ps","qualname":"::core_arch::x86::avx::_mm_maskload_ps","value":"fn (mem_addr: *const f32, mask: __m128i) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Loads packed single-precision (32-bit) floating-point elements from memory\n into result using `mask` (elements are zeroed out when the high bit of the\n corresponding element is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038379,"byte_end":3038388,"line_start":1871,"line_end":1871,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038389,"byte_end":3038422,"line_start":1872,"line_end":1872,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038467,"byte_end":3038516,"line_start":1874,"line_end":1874,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11138},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039030,"byte_end":3039046,"line_start":1887,"line_end":1887,"column_start":15,"column_end":31},"name":"_mm_maskstore_ps","qualname":"::core_arch::x86::avx::_mm_maskstore_ps","value":"fn (mem_addr: *mut f32, mask: __m128i, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed single-precision (32-bit) floating-point elements from `a`\n into memory using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038878,"byte_end":3038887,"line_start":1883,"line_end":1883,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038888,"byte_end":3038921,"line_start":1884,"line_end":1884,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3038966,"byte_end":3039015,"line_start":1886,"line_end":1886,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11140},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039541,"byte_end":3039559,"line_start":1899,"line_end":1899,"column_start":15,"column_end":33},"name":"_mm256_movehdup_ps","qualname":"::core_arch::x86::avx::_mm256_movehdup_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Duplicate odd-indexed single-precision (32-bit) floating-point elements\n from `a`, and returns the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039390,"byte_end":3039399,"line_start":1895,"line_end":1895,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039400,"byte_end":3039433,"line_start":1896,"line_end":1896,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039477,"byte_end":3039526,"line_start":1898,"line_end":1898,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11142},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040022,"byte_end":3040040,"line_start":1911,"line_end":1911,"column_start":15,"column_end":33},"name":"_mm256_moveldup_ps","qualname":"::core_arch::x86::avx::_mm256_moveldup_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Duplicate even-indexed single-precision (32-bit) floating-point elements\n from `a`, and returns the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039871,"byte_end":3039880,"line_start":1907,"line_end":1907,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039881,"byte_end":3039914,"line_start":1908,"line_end":1908,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3039958,"byte_end":3040007,"line_start":1910,"line_end":1910,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11144},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040501,"byte_end":3040518,"line_start":1923,"line_end":1923,"column_start":15,"column_end":32},"name":"_mm256_movedup_pd","qualname":"::core_arch::x86::avx::_mm256_movedup_pd","value":"fn (a: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Duplicate even-indexed double-precision (64-bit) floating-point elements\n from \"a\", and returns the results.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040351,"byte_end":3040360,"line_start":1919,"line_end":1919,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040361,"byte_end":3040394,"line_start":1920,"line_end":1920,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040437,"byte_end":3040486,"line_start":1922,"line_end":1922,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11146},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041035,"byte_end":3041053,"line_start":1936,"line_end":1936,"column_start":15,"column_end":33},"name":"_mm256_lddqu_si256","qualname":"::core_arch::x86::avx::_mm256_lddqu_si256","value":"fn (mem_addr: *const __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads 256-bits of integer data from unaligned memory into result.\n This intrinsic may perform better than `_mm256_loadu_si256` when the\n data crosses a cache line boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040887,"byte_end":3040896,"line_start":1932,"line_end":1932,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040897,"byte_end":3040930,"line_start":1933,"line_end":1933,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3040971,"byte_end":3041020,"line_start":1935,"line_end":1935,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11148},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041618,"byte_end":3041637,"line_start":1949,"line_end":1949,"column_start":15,"column_end":34},"name":"_mm256_stream_si256","qualname":"::core_arch::x86::avx::_mm256_stream_si256","value":"fn (mem_addr: *mut __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves integer data from a 256-bit integer vector to a 32-byte\n aligned memory location. To minimize caching, the data is flagged as\n non-temporal (unlikely to be used again soon)","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041450,"byte_end":3041459,"line_start":1945,"line_end":1945,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041460,"byte_end":3041493,"line_start":1946,"line_end":1946,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3041554,"byte_end":3041603,"line_start":1948,"line_end":1948,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11150},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042260,"byte_end":3042276,"line_start":1963,"line_end":1963,"column_start":15,"column_end":31},"name":"_mm256_stream_pd","qualname":"::core_arch::x86::avx::_mm256_stream_pd","value":"fn (mem_addr: *mut f64, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves double-precision values from a 256-bit vector of `[4 x double]`\n to a 32-byte aligned memory location. To minimize caching, the data is\n flagged as non-temporal (unlikely to be used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042055,"byte_end":3042064,"line_start":1958,"line_end":1958,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042065,"byte_end":3042098,"line_start":1959,"line_end":1959,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042159,"byte_end":3042208,"line_start":1961,"line_end":1961,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042209,"byte_end":3042245,"line_start":1962,"line_end":1962,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":11152},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042911,"byte_end":3042927,"line_start":1978,"line_end":1978,"column_start":15,"column_end":31},"name":"_mm256_stream_ps","qualname":"::core_arch::x86::avx::_mm256_stream_ps","value":"fn (mem_addr: *mut f32, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Moves single-precision floating point values from a 256-bit vector\n of `[8 x float]` to a 32-byte aligned memory location. To minimize\n caching, the data is flagged as non-temporal (unlikely to be used again\n soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042724,"byte_end":3042733,"line_start":1973,"line_end":1973,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042734,"byte_end":3042767,"line_start":1974,"line_end":1974,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042810,"byte_end":3042859,"line_start":1976,"line_end":1976,"column_start":1,"column_end":50}},{"value":"allow(clippy::cast_ptr_alignment)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3042860,"byte_end":3042896,"line_start":1977,"line_end":1977,"column_start":1,"column_end":37}}]},{"kind":"Function","id":{"krate":0,"index":11154},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043504,"byte_end":3043517,"line_start":1991,"line_end":1991,"column_start":15,"column_end":28},"name":"_mm256_rcp_ps","qualname":"::core_arch::x86::avx::_mm256_rcp_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the approximate reciprocal of packed single-precision (32-bit)\n floating-point elements in `a`, and returns the results. The maximum\n relative error for this approximation is less than 1.5*2^-12.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043356,"byte_end":3043365,"line_start":1987,"line_end":1987,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043366,"byte_end":3043399,"line_start":1988,"line_end":1988,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043440,"byte_end":3043489,"line_start":1990,"line_end":1990,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11156},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044051,"byte_end":3044066,"line_start":2004,"line_end":2004,"column_start":15,"column_end":30},"name":"_mm256_rsqrt_ps","qualname":"::core_arch::x86::avx::_mm256_rsqrt_ps","value":"fn (a: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Computes the approximate reciprocal square root of packed single-precision\n (32-bit) floating-point elements in `a`, and returns the results.\n The maximum relative error for this approximation is less than 1.5*2^-12.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043901,"byte_end":3043910,"line_start":2000,"line_end":2000,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043911,"byte_end":3043944,"line_start":2001,"line_end":2001,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3043987,"byte_end":3044036,"line_start":2003,"line_end":2003,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11158},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044516,"byte_end":3044534,"line_start":2016,"line_end":2016,"column_start":15,"column_end":33},"name":"_mm256_unpackhi_pd","qualname":"::core_arch::x86::avx::_mm256_unpackhi_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave double-precision (64-bit) floating-point elements\n from the high half of each 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044365,"byte_end":3044374,"line_start":2012,"line_end":2012,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044375,"byte_end":3044408,"line_start":2013,"line_end":2013,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044452,"byte_end":3044501,"line_start":2015,"line_end":2015,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11160},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045020,"byte_end":3045038,"line_start":2028,"line_end":2028,"column_start":15,"column_end":33},"name":"_mm256_unpackhi_ps","qualname":"::core_arch::x86::avx::_mm256_unpackhi_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave single-precision (32-bit) floating-point elements\n from the high half of each 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044869,"byte_end":3044878,"line_start":2024,"line_end":2024,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044879,"byte_end":3044912,"line_start":2025,"line_end":2025,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3044956,"byte_end":3045005,"line_start":2027,"line_end":2027,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11162},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045536,"byte_end":3045554,"line_start":2040,"line_end":2040,"column_start":15,"column_end":33},"name":"_mm256_unpacklo_pd","qualname":"::core_arch::x86::avx::_mm256_unpacklo_pd","value":"fn (a: __m256d, b: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave double-precision (64-bit) floating-point elements\n from the low half of each 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045385,"byte_end":3045394,"line_start":2036,"line_end":2036,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045395,"byte_end":3045428,"line_start":2037,"line_end":2037,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045472,"byte_end":3045521,"line_start":2039,"line_end":2039,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11164},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046039,"byte_end":3046057,"line_start":2052,"line_end":2052,"column_start":15,"column_end":33},"name":"_mm256_unpacklo_ps","qualname":"::core_arch::x86::avx::_mm256_unpacklo_ps","value":"fn (a: __m256, b: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave single-precision (32-bit) floating-point elements\n from the low half of each 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045888,"byte_end":3045897,"line_start":2048,"line_end":2048,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045898,"byte_end":3045931,"line_start":2049,"line_end":2049,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3045975,"byte_end":3046024,"line_start":2051,"line_end":2051,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11166},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046721,"byte_end":3046739,"line_start":2066,"line_end":2066,"column_start":15,"column_end":33},"name":"_mm256_testz_si256","qualname":"::core_arch::x86::avx::_mm256_testz_si256","value":"fn (a: __m256i, b: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing integer data) in `a` and\n `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0.\n Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if\n the result is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046573,"byte_end":3046582,"line_start":2062,"line_end":2062,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046583,"byte_end":3046616,"line_start":2063,"line_end":2063,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3046657,"byte_end":3046706,"line_start":2065,"line_end":2065,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11168},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047392,"byte_end":3047410,"line_start":2080,"line_end":2080,"column_start":15,"column_end":33},"name":"_mm256_testc_si256","qualname":"::core_arch::x86::avx::_mm256_testc_si256","value":"fn (a: __m256i, b: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing integer data) in `a` and\n `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0.\n Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if\n the result is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047244,"byte_end":3047253,"line_start":2076,"line_end":2076,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047254,"byte_end":3047287,"line_start":2077,"line_end":2077,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047328,"byte_end":3047377,"line_start":2079,"line_end":2079,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11170},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048118,"byte_end":3048138,"line_start":2095,"line_end":2095,"column_start":15,"column_end":35},"name":"_mm256_testnzc_si256","qualname":"::core_arch::x86::avx::_mm256_testnzc_si256","value":"fn (a: __m256i, b: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing integer data) in `a` and\n `b`, and set `ZF` to 1 if the result is zero, otherwise set `ZF` to 0.\n Computes the bitwise NOT of `a` and then AND with `b`, and set `CF` to 1 if\n the result is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and\n `CF` values are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047970,"byte_end":3047979,"line_start":2091,"line_end":2091,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3047980,"byte_end":3048013,"line_start":2092,"line_end":2092,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048054,"byte_end":3048103,"line_start":2094,"line_end":2094,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11172},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049015,"byte_end":3049030,"line_start":2112,"line_end":2112,"column_start":15,"column_end":30},"name":"_mm256_testz_pd","qualname":"::core_arch::x86::avx::_mm256_testz_pd","value":"fn (a: __m256d, b: __m256d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048866,"byte_end":3048875,"line_start":2108,"line_end":2108,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048876,"byte_end":3048909,"line_start":2109,"line_end":2109,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3048951,"byte_end":3049000,"line_start":2111,"line_end":2111,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11174},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049885,"byte_end":3049900,"line_start":2129,"line_end":2129,"column_start":15,"column_end":30},"name":"_mm256_testc_pd","qualname":"::core_arch::x86::avx::_mm256_testc_pd","value":"fn (a: __m256d, b: __m256d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049736,"byte_end":3049745,"line_start":2125,"line_end":2125,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049746,"byte_end":3049779,"line_start":2126,"line_end":2126,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3049821,"byte_end":3049870,"line_start":2128,"line_end":2128,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11176},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050810,"byte_end":3050827,"line_start":2147,"line_end":2147,"column_start":15,"column_end":32},"name":"_mm256_testnzc_pd","qualname":"::core_arch::x86::avx::_mm256_testnzc_pd","value":"fn (a: __m256d, b: __m256d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values\n are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050661,"byte_end":3050670,"line_start":2143,"line_end":2143,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050671,"byte_end":3050704,"line_start":2144,"line_end":2144,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3050746,"byte_end":3050795,"line_start":2146,"line_end":2146,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11178},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051681,"byte_end":3051693,"line_start":2164,"line_end":2164,"column_start":15,"column_end":27},"name":"_mm_testz_pd","qualname":"::core_arch::x86::avx::_mm_testz_pd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051532,"byte_end":3051541,"line_start":2160,"line_end":2160,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051542,"byte_end":3051575,"line_start":2161,"line_end":2161,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3051617,"byte_end":3051666,"line_start":2163,"line_end":2163,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11180},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052542,"byte_end":3052554,"line_start":2181,"line_end":2181,"column_start":15,"column_end":27},"name":"_mm_testc_pd","qualname":"::core_arch::x86::avx::_mm_testc_pd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052393,"byte_end":3052402,"line_start":2177,"line_end":2177,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052403,"byte_end":3052436,"line_start":2178,"line_end":2178,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3052478,"byte_end":3052527,"line_start":2180,"line_end":2180,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11182},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053458,"byte_end":3053472,"line_start":2199,"line_end":2199,"column_start":15,"column_end":29},"name":"_mm_testnzc_pd","qualname":"::core_arch::x86::avx::_mm_testnzc_pd","value":"fn (a: __m128d, b: __m128d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing double-precision (64-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 64-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 64-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values\n are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053309,"byte_end":3053318,"line_start":2195,"line_end":2195,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053319,"byte_end":3053352,"line_start":2196,"line_end":2196,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3053394,"byte_end":3053443,"line_start":2198,"line_end":2198,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11184},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054326,"byte_end":3054341,"line_start":2216,"line_end":2216,"column_start":15,"column_end":30},"name":"_mm256_testz_ps","qualname":"::core_arch::x86::avx::_mm256_testz_ps","value":"fn (a: __m256, b: __m256) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054177,"byte_end":3054186,"line_start":2212,"line_end":2212,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054187,"byte_end":3054220,"line_start":2213,"line_end":2213,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3054262,"byte_end":3054311,"line_start":2215,"line_end":2215,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11186},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055194,"byte_end":3055209,"line_start":2233,"line_end":2233,"column_start":15,"column_end":30},"name":"_mm256_testc_ps","qualname":"::core_arch::x86::avx::_mm256_testc_ps","value":"fn (a: __m256, b: __m256) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055045,"byte_end":3055054,"line_start":2229,"line_end":2229,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055055,"byte_end":3055088,"line_start":2230,"line_end":2230,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055130,"byte_end":3055179,"line_start":2232,"line_end":2232,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11188},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056117,"byte_end":3056134,"line_start":2251,"line_end":2251,"column_start":15,"column_end":32},"name":"_mm256_testnzc_ps","qualname":"::core_arch::x86::avx::_mm256_testnzc_ps","value":"fn (a: __m256, b: __m256) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 256-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values\n are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055968,"byte_end":3055977,"line_start":2247,"line_end":2247,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3055978,"byte_end":3056011,"line_start":2248,"line_end":2248,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056053,"byte_end":3056102,"line_start":2250,"line_end":2250,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11190},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056986,"byte_end":3056998,"line_start":2268,"line_end":2268,"column_start":15,"column_end":27},"name":"_mm_testz_ps","qualname":"::core_arch::x86::avx::_mm_testz_ps","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `ZF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056837,"byte_end":3056846,"line_start":2264,"line_end":2264,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056847,"byte_end":3056880,"line_start":2265,"line_end":2265,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3056922,"byte_end":3056971,"line_start":2267,"line_end":2267,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11192},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3057845,"byte_end":3057857,"line_start":2285,"line_end":2285,"column_start":15,"column_end":27},"name":"_mm_testc_ps","qualname":"::core_arch::x86::avx::_mm_testc_ps","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return the `CF` value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3057696,"byte_end":3057705,"line_start":2281,"line_end":2281,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3057706,"byte_end":3057739,"line_start":2282,"line_end":2282,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3057781,"byte_end":3057830,"line_start":2284,"line_end":2284,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11194},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058759,"byte_end":3058773,"line_start":2303,"line_end":2303,"column_start":15,"column_end":29},"name":"_mm_testnzc_ps","qualname":"::core_arch::x86::avx::_mm_testnzc_ps","value":"fn (a: __m128, b: __m128) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 128 bits (representing single-precision (32-bit)\n floating-point elements) in `a` and `b`, producing an intermediate 128-bit\n value, and set `ZF` to 1 if the sign bit of each 32-bit element in the\n intermediate value is zero, otherwise set `ZF` to 0. Compute the bitwise\n NOT of `a` and then AND with `b`, producing an intermediate value, and set\n `CF` to 1 if the sign bit of each 32-bit element in the intermediate value\n is zero, otherwise set `CF` to 0. Return 1 if both the `ZF` and `CF` values\n are zero, otherwise return 0.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058610,"byte_end":3058619,"line_start":2299,"line_end":2299,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058620,"byte_end":3058653,"line_start":2300,"line_end":2300,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3058695,"byte_end":3058744,"line_start":2302,"line_end":2302,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11196},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3059265,"byte_end":3059283,"line_start":2316,"line_end":2316,"column_start":15,"column_end":33},"name":"_mm256_movemask_pd","qualname":"::core_arch::x86::avx::_mm256_movemask_pd","value":"fn (a: __m256d) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Sets each bit of the returned mask based on the most significant bit of the\n corresponding packed double-precision (64-bit) floating-point element in\n `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3059114,"byte_end":3059123,"line_start":2312,"line_end":2312,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3059124,"byte_end":3059157,"line_start":2313,"line_end":2313,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3059201,"byte_end":3059250,"line_start":2315,"line_end":2315,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11198},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3059763,"byte_end":3059781,"line_start":2329,"line_end":2329,"column_start":15,"column_end":33},"name":"_mm256_movemask_ps","qualname":"::core_arch::x86::avx::_mm256_movemask_ps","value":"fn (a: __m256) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Sets each bit of the returned mask based on the most significant bit of the\n corresponding packed single-precision (32-bit) floating-point element in\n `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3059612,"byte_end":3059621,"line_start":2325,"line_end":2325,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3059622,"byte_end":3059655,"line_start":2326,"line_end":2326,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3059699,"byte_end":3059748,"line_start":2328,"line_end":2328,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11200},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060181,"byte_end":3060198,"line_start":2340,"line_end":2340,"column_start":15,"column_end":32},"name":"_mm256_setzero_pd","qualname":"::core_arch::x86::avx::_mm256_setzero_pd","value":"fn () -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m256d with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060008,"byte_end":3060017,"line_start":2336,"line_end":2336,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060018,"byte_end":3060051,"line_start":2337,"line_end":2337,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060117,"byte_end":3060166,"line_start":2339,"line_end":2339,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11202},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060572,"byte_end":3060589,"line_start":2351,"line_end":2351,"column_start":15,"column_end":32},"name":"_mm256_setzero_ps","qualname":"::core_arch::x86::avx::_mm256_setzero_ps","value":"fn () -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m256 with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060424,"byte_end":3060433,"line_start":2347,"line_end":2347,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060434,"byte_end":3060467,"line_start":2348,"line_end":2348,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060508,"byte_end":3060557,"line_start":2350,"line_end":2350,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11204},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060964,"byte_end":3060984,"line_start":2362,"line_end":2362,"column_start":15,"column_end":35},"name":"_mm256_setzero_si256","qualname":"::core_arch::x86::avx::_mm256_setzero_si256","value":"fn () -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m256i with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060818,"byte_end":3060827,"line_start":2358,"line_end":2358,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060828,"byte_end":3060861,"line_start":2359,"line_end":2359,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3060900,"byte_end":3060949,"line_start":2361,"line_end":2361,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11206},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061461,"byte_end":3061474,"line_start":2375,"line_end":2375,"column_start":15,"column_end":28},"name":"_mm256_set_pd","qualname":"::core_arch::x86::avx::_mm256_set_pd","value":"fn (a: f64, b: f64, c: f64, d: f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed double-precision (64-bit) floating-point elements in returned\n vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061256,"byte_end":3061265,"line_start":2370,"line_end":2370,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061266,"byte_end":3061299,"line_start":2371,"line_end":2371,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061397,"byte_end":3061446,"line_start":2374,"line_end":2374,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11208},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061943,"byte_end":3061956,"line_start":2387,"line_end":2387,"column_start":15,"column_end":28},"name":"_mm256_set_ps","qualname":"::core_arch::x86::avx::_mm256_set_ps","value":"fn (a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Sets packed single-precision (32-bit) floating-point elements in returned\n vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061783,"byte_end":3061792,"line_start":2383,"line_end":2383,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061793,"byte_end":3061826,"line_start":2384,"line_end":2384,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3061879,"byte_end":3061928,"line_start":2386,"line_end":2386,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11210},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062487,"byte_end":3062502,"line_start":2408,"line_end":2408,"column_start":15,"column_end":30},"name":"_mm256_set_epi8","qualname":"::core_arch::x86::avx::_mm256_set_epi8","value":"fn (e00: i8, e01: i8, e02: i8, e03: i8, e04: i8, e05: i8, e06: i8, e07: i8, e08: i8, e09: i8, e10: i8, e11: i8, e12: i8, e13: i8, e14: i8, e15: i8, e16: i8, e17: i8, e18: i8, e19: i8, e20: i8, e21: i8, e22: i8, e23: i8, e24: i8, e25: i8, e26: i8, e27: i8, e28: i8, e29: i8, e30: i8, e31: i8) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062327,"byte_end":3062336,"line_start":2404,"line_end":2404,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062337,"byte_end":3062370,"line_start":2405,"line_end":2405,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3062423,"byte_end":3062472,"line_start":2407,"line_end":2407,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11212},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063533,"byte_end":3063549,"line_start":2458,"line_end":2458,"column_start":15,"column_end":31},"name":"_mm256_set_epi16","qualname":"::core_arch::x86::avx::_mm256_set_epi16","value":"fn (e00: i16, e01: i16, e02: i16, e03: i16, e04: i16, e05: i16, e06: i16, e07: i16, e08: i16, e09: i16, e10: i16, e11: i16, e12: i16, e13: i16, e14: i16, e15: i16) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers in returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063373,"byte_end":3063382,"line_start":2454,"line_end":2454,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063383,"byte_end":3063416,"line_start":2455,"line_end":2455,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3063469,"byte_end":3063518,"line_start":2457,"line_end":2457,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11214},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064309,"byte_end":3064325,"line_start":2492,"line_end":2492,"column_start":15,"column_end":31},"name":"_mm256_set_epi32","qualname":"::core_arch::x86::avx::_mm256_set_epi32","value":"fn (e0: i32, e1: i32, e2: i32, e3: i32, e4: i32, e5: i32, e6: i32, e7: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064149,"byte_end":3064158,"line_start":2488,"line_end":2488,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064159,"byte_end":3064192,"line_start":2489,"line_end":2489,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064245,"byte_end":3064294,"line_start":2491,"line_end":2491,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11216},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064858,"byte_end":3064875,"line_start":2512,"line_end":2512,"column_start":15,"column_end":32},"name":"_mm256_set_epi64x","qualname":"::core_arch::x86::avx::_mm256_set_epi64x","value":"fn (a: i64, b: i64, c: i64, d: i64) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 64-bit integers in returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064698,"byte_end":3064707,"line_start":2508,"line_end":2508,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064708,"byte_end":3064741,"line_start":2509,"line_end":2509,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3064794,"byte_end":3064843,"line_start":2511,"line_end":2511,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11218},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065366,"byte_end":3065380,"line_start":2524,"line_end":2524,"column_start":15,"column_end":29},"name":"_mm256_setr_pd","qualname":"::core_arch::x86::avx::_mm256_setr_pd","value":"fn (a: f64, b: f64, c: f64, d: f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed double-precision (64-bit) floating-point elements in returned\n vector with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065206,"byte_end":3065215,"line_start":2520,"line_end":2520,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065216,"byte_end":3065249,"line_start":2521,"line_end":2521,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065302,"byte_end":3065351,"line_start":2523,"line_end":2523,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11220},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065860,"byte_end":3065874,"line_start":2536,"line_end":2536,"column_start":15,"column_end":29},"name":"_mm256_setr_ps","qualname":"::core_arch::x86::avx::_mm256_setr_ps","value":"fn (a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Sets packed single-precision (32-bit) floating-point elements in returned\n vector with the supplied values in reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065700,"byte_end":3065709,"line_start":2532,"line_end":2532,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065710,"byte_end":3065743,"line_start":2533,"line_end":2533,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3065796,"byte_end":3065845,"line_start":2535,"line_end":2535,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11222},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066398,"byte_end":3066414,"line_start":2557,"line_end":2557,"column_start":15,"column_end":31},"name":"_mm256_setr_epi8","qualname":"::core_arch::x86::avx::_mm256_setr_epi8","value":"fn (e00: i8, e01: i8, e02: i8, e03: i8, e04: i8, e05: i8, e06: i8, e07: i8, e08: i8, e09: i8, e10: i8, e11: i8, e12: i8, e13: i8, e14: i8, e15: i8, e16: i8, e17: i8, e18: i8, e19: i8, e20: i8, e21: i8, e22: i8, e23: i8, e24: i8, e25: i8, e26: i8, e27: i8, e28: i8, e29: i8, e30: i8, e31: i8) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066238,"byte_end":3066247,"line_start":2553,"line_end":2553,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066248,"byte_end":3066281,"line_start":2554,"line_end":2554,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3066334,"byte_end":3066383,"line_start":2556,"line_end":2556,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11224},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067472,"byte_end":3067489,"line_start":2608,"line_end":2608,"column_start":15,"column_end":32},"name":"_mm256_setr_epi16","qualname":"::core_arch::x86::avx::_mm256_setr_epi16","value":"fn (e00: i16, e01: i16, e02: i16, e03: i16, e04: i16, e05: i16, e06: i16, e07: i16, e08: i16, e09: i16, e10: i16, e11: i16, e12: i16, e13: i16, e14: i16, e15: i16) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067312,"byte_end":3067321,"line_start":2604,"line_end":2604,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067322,"byte_end":3067355,"line_start":2605,"line_end":2605,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3067408,"byte_end":3067457,"line_start":2607,"line_end":2607,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11226},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068276,"byte_end":3068293,"line_start":2643,"line_end":2643,"column_start":15,"column_end":32},"name":"_mm256_setr_epi32","qualname":"::core_arch::x86::avx::_mm256_setr_epi32","value":"fn (e0: i32, e1: i32, e2: i32, e3: i32, e4: i32, e5: i32, e6: i32, e7: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068116,"byte_end":3068125,"line_start":2639,"line_end":2639,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068126,"byte_end":3068159,"line_start":2640,"line_end":2640,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068212,"byte_end":3068261,"line_start":2642,"line_end":2642,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11228},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068852,"byte_end":3068870,"line_start":2664,"line_end":2664,"column_start":15,"column_end":33},"name":"_mm256_setr_epi64x","qualname":"::core_arch::x86::avx::_mm256_setr_epi64x","value":"fn (a: i64, b: i64, c: i64, d: i64) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 64-bit integers in returned vector with the supplied values in\n reverse order.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068692,"byte_end":3068701,"line_start":2660,"line_end":2660,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068702,"byte_end":3068735,"line_start":2661,"line_end":2661,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3068788,"byte_end":3068837,"line_start":2663,"line_end":2663,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11230},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069338,"byte_end":3069352,"line_start":2676,"line_end":2676,"column_start":15,"column_end":29},"name":"_mm256_set1_pd","qualname":"::core_arch::x86::avx::_mm256_set1_pd","value":"fn (a: f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts double-precision (64-bit) floating-point value `a` to all\n elements of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069178,"byte_end":3069187,"line_start":2672,"line_end":2672,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069188,"byte_end":3069221,"line_start":2673,"line_end":2673,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069274,"byte_end":3069323,"line_start":2675,"line_end":2675,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11232},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069789,"byte_end":3069803,"line_start":2688,"line_end":2688,"column_start":15,"column_end":29},"name":"_mm256_set1_ps","qualname":"::core_arch::x86::avx::_mm256_set1_ps","value":"fn (a: f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts single-precision (32-bit) floating-point value `a` to all\n elements of returned vector.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069629,"byte_end":3069638,"line_start":2684,"line_end":2684,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069639,"byte_end":3069672,"line_start":2685,"line_end":2685,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3069725,"byte_end":3069774,"line_start":2687,"line_end":2687,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11234},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070354,"byte_end":3070370,"line_start":2702,"line_end":2702,"column_start":15,"column_end":31},"name":"_mm256_set1_epi8","qualname":"::core_arch::x86::avx::_mm256_set1_epi8","value":"fn (a: i8) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 8-bit integer `a` to all elements of returned vector.\n This intrinsic may generate the `vpbroadcastb`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070108,"byte_end":3070117,"line_start":2696,"line_end":2696,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070118,"byte_end":3070151,"line_start":2697,"line_end":2697,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070290,"byte_end":3070339,"line_start":2701,"line_end":2701,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11236},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071063,"byte_end":3071080,"line_start":2722,"line_end":2722,"column_start":15,"column_end":32},"name":"_mm256_set1_epi16","qualname":"::core_arch::x86::avx::_mm256_set1_epi16","value":"fn (a: i16) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 16-bit integer `a` to all all elements of returned vector.\n This intrinsic may generate the `vpbroadcastw`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070815,"byte_end":3070824,"line_start":2716,"line_end":2716,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070825,"byte_end":3070858,"line_start":2717,"line_end":2717,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3070999,"byte_end":3071048,"line_start":2721,"line_end":2721,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11238},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071575,"byte_end":3071592,"line_start":2734,"line_end":2734,"column_start":15,"column_end":32},"name":"_mm256_set1_epi32","qualname":"::core_arch::x86::avx::_mm256_set1_epi32","value":"fn (a: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 32-bit integer `a` to all elements of returned vector.\n This intrinsic may generate the `vpbroadcastd`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071415,"byte_end":3071424,"line_start":2730,"line_end":2730,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071425,"byte_end":3071458,"line_start":2731,"line_end":2731,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071511,"byte_end":3071560,"line_start":2733,"line_end":2733,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11240},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072153,"byte_end":3072171,"line_start":2748,"line_end":2748,"column_start":15,"column_end":33},"name":"_mm256_set1_epi64x","qualname":"::core_arch::x86::avx::_mm256_set1_epi64x","value":"fn (a: i64) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 64-bit integer `a` to all elements of returned vector.\n This intrinsic may generate the `vpbroadcastq`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071904,"byte_end":3071913,"line_start":2742,"line_end":2742,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3071914,"byte_end":3071947,"line_start":2743,"line_end":2743,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072089,"byte_end":3072138,"line_start":2747,"line_end":2747,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11242},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072620,"byte_end":3072636,"line_start":2760,"line_end":2760,"column_start":15,"column_end":31},"name":"_mm256_castpd_ps","qualname":"::core_arch::x86::avx::_mm256_castpd_ps","value":"fn (a: __m256d) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Cast vector of type __m256d to type __m256.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072396,"byte_end":3072405,"line_start":2755,"line_end":2755,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072406,"byte_end":3072439,"line_start":2756,"line_end":2756,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072556,"byte_end":3072605,"line_start":2759,"line_end":2759,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11244},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073070,"byte_end":3073086,"line_start":2772,"line_end":2772,"column_start":15,"column_end":31},"name":"_mm256_castps_pd","qualname":"::core_arch::x86::avx::_mm256_castps_pd","value":"fn (a: __m256) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Cast vector of type __m256 to type __m256d.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072846,"byte_end":3072855,"line_start":2767,"line_end":2767,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3072856,"byte_end":3072889,"line_start":2768,"line_end":2768,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073006,"byte_end":3073055,"line_start":2771,"line_end":2771,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11246},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073524,"byte_end":3073543,"line_start":2784,"line_end":2784,"column_start":15,"column_end":34},"name":"_mm256_castps_si256","qualname":"::core_arch::x86::avx::_mm256_castps_si256","value":"fn (a: __m256) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256 to type __m256i.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073300,"byte_end":3073309,"line_start":2779,"line_end":2779,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073310,"byte_end":3073343,"line_start":2780,"line_end":2780,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073460,"byte_end":3073509,"line_start":2783,"line_end":2783,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11248},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073981,"byte_end":3074000,"line_start":2796,"line_end":2796,"column_start":15,"column_end":34},"name":"_mm256_castsi256_ps","qualname":"::core_arch::x86::avx::_mm256_castsi256_ps","value":"fn (a: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256i to type __m256.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073757,"byte_end":3073766,"line_start":2791,"line_end":2791,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073767,"byte_end":3073800,"line_start":2792,"line_end":2792,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3073917,"byte_end":3073966,"line_start":2795,"line_end":2795,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11250},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074439,"byte_end":3074458,"line_start":2808,"line_end":2808,"column_start":15,"column_end":34},"name":"_mm256_castpd_si256","qualname":"::core_arch::x86::avx::_mm256_castpd_si256","value":"fn (a: __m256d) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256d to type __m256i.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074215,"byte_end":3074224,"line_start":2803,"line_end":2803,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074225,"byte_end":3074258,"line_start":2804,"line_end":2804,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074375,"byte_end":3074424,"line_start":2807,"line_end":2807,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11252},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074898,"byte_end":3074917,"line_start":2820,"line_end":2820,"column_start":15,"column_end":34},"name":"_mm256_castsi256_pd","qualname":"::core_arch::x86::avx::_mm256_castsi256_pd","value":"fn (a: __m256i) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256i to type __m256d.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074674,"byte_end":3074683,"line_start":2815,"line_end":2815,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074684,"byte_end":3074717,"line_start":2816,"line_end":2816,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3074834,"byte_end":3074883,"line_start":2819,"line_end":2819,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11254},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075358,"byte_end":3075380,"line_start":2832,"line_end":2832,"column_start":15,"column_end":37},"name":"_mm256_castps256_ps128","qualname":"::core_arch::x86::avx::_mm256_castps256_ps128","value":"fn (a: __m256) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256 to type __m128.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075134,"byte_end":3075143,"line_start":2827,"line_end":2827,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075144,"byte_end":3075177,"line_start":2828,"line_end":2828,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075294,"byte_end":3075343,"line_start":2831,"line_end":2831,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11256},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075842,"byte_end":3075864,"line_start":2844,"line_end":2844,"column_start":15,"column_end":37},"name":"_mm256_castpd256_pd128","qualname":"::core_arch::x86::avx::_mm256_castpd256_pd128","value":"fn (a: __m256d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256d to type __m128d.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075618,"byte_end":3075627,"line_start":2839,"line_end":2839,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075628,"byte_end":3075661,"line_start":2840,"line_end":2840,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3075778,"byte_end":3075827,"line_start":2843,"line_end":2843,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11258},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076322,"byte_end":3076344,"line_start":2856,"line_end":2856,"column_start":15,"column_end":37},"name":"_mm256_castsi256_si128","qualname":"::core_arch::x86::avx::_mm256_castsi256_si128","value":"fn (a: __m256i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m256i to type __m128i.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076098,"byte_end":3076107,"line_start":2851,"line_end":2851,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076108,"byte_end":3076141,"line_start":2852,"line_end":2852,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076258,"byte_end":3076307,"line_start":2855,"line_end":2855,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11260},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076915,"byte_end":3076937,"line_start":2871,"line_end":2871,"column_start":15,"column_end":37},"name":"_mm256_castps128_ps256","qualname":"::core_arch::x86::avx::_mm256_castps128_ps256","value":"fn (a: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m128 to type __m256;\n the upper 128 bits of the result are undefined.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076691,"byte_end":3076700,"line_start":2866,"line_end":2866,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076701,"byte_end":3076734,"line_start":2867,"line_end":2867,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3076851,"byte_end":3076900,"line_start":2870,"line_end":2870,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11262},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077526,"byte_end":3077548,"line_start":2885,"line_end":2885,"column_start":15,"column_end":37},"name":"_mm256_castpd128_pd256","qualname":"::core_arch::x86::avx::_mm256_castpd128_pd256","value":"fn (a: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m128d to type __m256d;\n the upper 128 bits of the result are undefined.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077302,"byte_end":3077311,"line_start":2880,"line_end":2880,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077312,"byte_end":3077345,"line_start":2881,"line_end":2881,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077462,"byte_end":3077511,"line_start":2884,"line_end":2884,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11264},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078113,"byte_end":3078135,"line_start":2899,"line_end":2899,"column_start":15,"column_end":37},"name":"_mm256_castsi128_si256","qualname":"::core_arch::x86::avx::_mm256_castsi128_si256","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Casts vector of type __m128i to type __m256i;\n the upper 128 bits of the result are undefined.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077889,"byte_end":3077898,"line_start":2894,"line_end":2894,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3077899,"byte_end":3077932,"line_start":2895,"line_end":2895,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078049,"byte_end":3078098,"line_start":2898,"line_end":2898,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11266},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078887,"byte_end":3078909,"line_start":2916,"line_end":2916,"column_start":15,"column_end":37},"name":"_mm256_zextps128_ps256","qualname":"::core_arch::x86::avx::_mm256_zextps128_ps256","value":"fn (a: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 256-bit floating-point vector of `[8 x float]` from a\n 128-bit floating-point vector of `[4 x float]`. The lower 128 bits contain\n the value of the source vector. The upper 128 bits are set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078659,"byte_end":3078668,"line_start":2911,"line_end":2911,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078669,"byte_end":3078706,"line_start":2912,"line_end":2912,"column_start":1,"column_end":38}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3078823,"byte_end":3078872,"line_start":2915,"line_end":2915,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11268},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079527,"byte_end":3079549,"line_start":2930,"line_end":2930,"column_start":15,"column_end":37},"name":"_mm256_zextsi128_si256","qualname":"::core_arch::x86::avx::_mm256_zextsi128_si256","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 256-bit integer vector from a 128-bit integer vector.\n The lower 128 bits contain the value of the source vector. The upper\n 128 bits are set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079298,"byte_end":3079307,"line_start":2925,"line_end":2925,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079308,"byte_end":3079346,"line_start":2926,"line_end":2926,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3079463,"byte_end":3079512,"line_start":2929,"line_end":2929,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11270},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080288,"byte_end":3080310,"line_start":2947,"line_end":2947,"column_start":15,"column_end":37},"name":"_mm256_zextpd128_pd256","qualname":"::core_arch::x86::avx::_mm256_zextpd128_pd256","value":"fn (a: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 256-bit floating-point vector of `[4 x double]` from a\n 128-bit floating-point vector of `[2 x double]`. The lower 128 bits\n contain the value of the source vector. The upper 128 bits are set\n to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080059,"byte_end":3080068,"line_start":2942,"line_end":2942,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080069,"byte_end":3080107,"line_start":2943,"line_end":2943,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080224,"byte_end":3080273,"line_start":2946,"line_end":2946,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11272},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080733,"byte_end":3080752,"line_start":2958,"line_end":2958,"column_start":15,"column_end":34},"name":"_mm256_undefined_ps","qualname":"::core_arch::x86::avx::_mm256_undefined_ps","value":"fn () -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type `__m256` with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080573,"byte_end":3080582,"line_start":2954,"line_end":2954,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080583,"byte_end":3080616,"line_start":2955,"line_end":2955,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3080669,"byte_end":3080718,"line_start":2957,"line_end":2957,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11274},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081229,"byte_end":3081248,"line_start":2970,"line_end":2970,"column_start":15,"column_end":34},"name":"_mm256_undefined_pd","qualname":"::core_arch::x86::avx::_mm256_undefined_pd","value":"fn () -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type `__m256d` with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081069,"byte_end":3081078,"line_start":2966,"line_end":2966,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081079,"byte_end":3081112,"line_start":2967,"line_end":2967,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081165,"byte_end":3081214,"line_start":2969,"line_end":2969,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11276},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081729,"byte_end":3081751,"line_start":2982,"line_end":2982,"column_start":15,"column_end":37},"name":"_mm256_undefined_si256","qualname":"::core_arch::x86::avx::_mm256_undefined_si256","value":"fn () -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type __m256i with undefined elements.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081569,"byte_end":3081578,"line_start":2978,"line_end":2978,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081579,"byte_end":3081612,"line_start":2979,"line_end":2979,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3081665,"byte_end":3081714,"line_start":2981,"line_end":2981,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11278},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082223,"byte_end":3082238,"line_start":2994,"line_end":2994,"column_start":15,"column_end":30},"name":"_mm256_set_m128","qualname":"::core_arch::x86::avx::_mm256_set_m128","value":"fn (hi: __m128, lo: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256 returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082070,"byte_end":3082079,"line_start":2990,"line_end":2990,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082080,"byte_end":3082113,"line_start":2991,"line_end":2991,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082159,"byte_end":3082208,"line_start":2993,"line_end":2993,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11280},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082666,"byte_end":3082682,"line_start":3005,"line_end":3005,"column_start":15,"column_end":31},"name":"_mm256_set_m128d","qualname":"::core_arch::x86::avx::_mm256_set_m128d","value":"fn (hi: __m128d, lo: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256d returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082513,"byte_end":3082522,"line_start":3001,"line_end":3001,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082523,"byte_end":3082556,"line_start":3002,"line_end":3002,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3082602,"byte_end":3082651,"line_start":3004,"line_end":3004,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11282},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083172,"byte_end":3083188,"line_start":3018,"line_end":3018,"column_start":15,"column_end":31},"name":"_mm256_set_m128i","qualname":"::core_arch::x86::avx::_mm256_set_m128i","value":"fn (hi: __m128i, lo: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256i returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083019,"byte_end":3083028,"line_start":3014,"line_end":3014,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083029,"byte_end":3083062,"line_start":3015,"line_end":3015,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083108,"byte_end":3083157,"line_start":3017,"line_end":3017,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11284},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083677,"byte_end":3083693,"line_start":3031,"line_end":3031,"column_start":15,"column_end":31},"name":"_mm256_setr_m128","qualname":"::core_arch::x86::avx::_mm256_setr_m128","value":"fn (lo: __m128, hi: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256 returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083524,"byte_end":3083533,"line_start":3027,"line_end":3027,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083534,"byte_end":3083567,"line_start":3028,"line_end":3028,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083613,"byte_end":3083662,"line_start":3030,"line_end":3030,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11286},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084098,"byte_end":3084115,"line_start":3042,"line_end":3042,"column_start":15,"column_end":32},"name":"_mm256_setr_m128d","qualname":"::core_arch::x86::avx::_mm256_setr_m128d","value":"fn (lo: __m128d, hi: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256d returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083945,"byte_end":3083954,"line_start":3038,"line_end":3038,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3083955,"byte_end":3083988,"line_start":3039,"line_end":3039,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084034,"byte_end":3084083,"line_start":3041,"line_end":3041,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11288},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084524,"byte_end":3084541,"line_start":3053,"line_end":3053,"column_start":15,"column_end":32},"name":"_mm256_setr_m128i","qualname":"::core_arch::x86::avx::_mm256_setr_m128i","value":"fn (lo: __m128i, hi: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed __m256i returned vector with the supplied values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084371,"byte_end":3084380,"line_start":3049,"line_end":3049,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084381,"byte_end":3084414,"line_start":3050,"line_end":3050,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084460,"byte_end":3084509,"line_start":3052,"line_end":3052,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11290},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085138,"byte_end":3085156,"line_start":3067,"line_end":3067,"column_start":15,"column_end":33},"name":"_mm256_loadu2_m128","qualname":"::core_arch::x86::avx::_mm256_loadu2_m128","value":"fn (hiaddr: *const f32, loaddr: *const f32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Loads two 128-bit values (composed of 4 packed single-precision (32-bit)\n floating-point elements) from memory, and combine them into a 256-bit\n value.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084974,"byte_end":3084983,"line_start":3063,"line_end":3063,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3084984,"byte_end":3085021,"line_start":3064,"line_end":3064,"column_start":1,"column_end":38}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085074,"byte_end":3085123,"line_start":3066,"line_end":3066,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11292},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085850,"byte_end":3085869,"line_start":3082,"line_end":3082,"column_start":15,"column_end":34},"name":"_mm256_loadu2_m128d","qualname":"::core_arch::x86::avx::_mm256_loadu2_m128d","value":"fn (hiaddr: *const f64, loaddr: *const f64) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Loads two 128-bit values (composed of 2 packed double-precision (64-bit)\n floating-point elements) from memory, and combine them into a 256-bit\n value.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085685,"byte_end":3085694,"line_start":3078,"line_end":3078,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085695,"byte_end":3085733,"line_start":3079,"line_end":3079,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3085786,"byte_end":3085835,"line_start":3081,"line_end":3081,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11294},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086514,"byte_end":3086533,"line_start":3096,"line_end":3096,"column_start":15,"column_end":34},"name":"_mm256_loadu2_m128i","qualname":"::core_arch::x86::avx::_mm256_loadu2_m128i","value":"fn (hiaddr: *const __m128i, loaddr: *const __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads two 128-bit values (composed of integer data) from memory, and combine\n them into a 256-bit value.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086349,"byte_end":3086358,"line_start":3092,"line_end":3092,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086359,"byte_end":3086397,"line_start":3093,"line_end":3093,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3086450,"byte_end":3086499,"line_start":3095,"line_end":3095,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11296},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087265,"byte_end":3087284,"line_start":3111,"line_end":3111,"column_start":15,"column_end":34},"name":"_mm256_storeu2_m128","qualname":"::core_arch::x86::avx::_mm256_storeu2_m128","value":"fn (hiaddr: *mut f32, loaddr: *mut f32, a: __m256) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the high and low 128-bit halves (each composed of 4 packed\n single-precision (32-bit) floating-point elements) from `a` into memory two\n different 128-bit locations.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087101,"byte_end":3087110,"line_start":3107,"line_end":3107,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087111,"byte_end":3087148,"line_start":3108,"line_end":3108,"column_start":1,"column_end":38}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087201,"byte_end":3087250,"line_start":3110,"line_end":3110,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11298},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088030,"byte_end":3088050,"line_start":3128,"line_end":3128,"column_start":15,"column_end":35},"name":"_mm256_storeu2_m128d","qualname":"::core_arch::x86::avx::_mm256_storeu2_m128d","value":"fn (hiaddr: *mut f64, loaddr: *mut f64, a: __m256d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the high and low 128-bit halves (each composed of 2 packed\n double-precision (64-bit) floating-point elements) from `a` into memory two\n different 128-bit locations.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087865,"byte_end":3087874,"line_start":3124,"line_end":3124,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087875,"byte_end":3087913,"line_start":3125,"line_end":3125,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3087966,"byte_end":3088015,"line_start":3127,"line_end":3127,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11300},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088747,"byte_end":3088767,"line_start":3144,"line_end":3144,"column_start":15,"column_end":35},"name":"_mm256_storeu2_m128i","qualname":"::core_arch::x86::avx::_mm256_storeu2_m128i","value":"fn (hiaddr: *mut __m128i, loaddr: *mut __m128i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores the high and low 128-bit halves (each composed of integer data) from\n `a` into memory two different 128-bit locations.\n `hiaddr` and `loaddr` do not need to be aligned on any particular boundary.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088582,"byte_end":3088591,"line_start":3140,"line_end":3140,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx,sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088592,"byte_end":3088630,"line_start":3141,"line_end":3141,"column_start":1,"column_end":39}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3088683,"byte_end":3088732,"line_start":3143,"line_end":3143,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11302},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089322,"byte_end":3089338,"line_start":3158,"line_end":3158,"column_start":15,"column_end":31},"name":"_mm256_cvtss_f32","qualname":"::core_arch::x86::avx::_mm256_cvtss_f32","value":"fn (a: __m256) -> f32","parent":null,"children":[],"decl_id":null,"docs":" Returns the first element of the input vector of `[8 x float]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089167,"byte_end":3089176,"line_start":3154,"line_end":3154,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089177,"byte_end":3089210,"line_start":3155,"line_end":3155,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx.rs","byte_start":3089258,"byte_end":3089307,"line_start":3157,"line_end":3157,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11322},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155180,"byte_end":3155196,"line_start":36,"line_end":36,"column_start":15,"column_end":31},"name":"_mm256_abs_epi32","qualname":"::core_arch::x86::avx2::_mm256_abs_epi32","value":"fn (a: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute values of packed 32-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155031,"byte_end":3155040,"line_start":32,"line_end":32,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155041,"byte_end":3155075,"line_start":33,"line_end":33,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155116,"byte_end":3155165,"line_start":35,"line_end":35,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11324},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155593,"byte_end":3155609,"line_start":47,"line_end":47,"column_start":15,"column_end":31},"name":"_mm256_abs_epi16","qualname":"::core_arch::x86::avx2::_mm256_abs_epi16","value":"fn (a: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute values of packed 16-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155444,"byte_end":3155453,"line_start":43,"line_end":43,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155454,"byte_end":3155488,"line_start":44,"line_end":44,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155529,"byte_end":3155578,"line_start":46,"line_end":46,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11326},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156005,"byte_end":3156020,"line_start":58,"line_end":58,"column_start":15,"column_end":30},"name":"_mm256_abs_epi8","qualname":"::core_arch::x86::avx2::_mm256_abs_epi8","value":"fn (a: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute values of packed 8-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155856,"byte_end":3155865,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155866,"byte_end":3155900,"line_start":55,"line_end":55,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3155941,"byte_end":3155990,"line_start":57,"line_end":57,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11328},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156398,"byte_end":3156414,"line_start":69,"line_end":69,"column_start":15,"column_end":31},"name":"_mm256_add_epi64","qualname":"::core_arch::x86::avx2::_mm256_add_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 64-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156249,"byte_end":3156258,"line_start":65,"line_end":65,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156259,"byte_end":3156293,"line_start":66,"line_end":66,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156334,"byte_end":3156383,"line_start":68,"line_end":68,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11330},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156821,"byte_end":3156837,"line_start":80,"line_end":80,"column_start":15,"column_end":31},"name":"_mm256_add_epi32","qualname":"::core_arch::x86::avx2::_mm256_add_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 32-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156672,"byte_end":3156681,"line_start":76,"line_end":76,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156682,"byte_end":3156716,"line_start":77,"line_end":77,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3156757,"byte_end":3156806,"line_start":79,"line_end":79,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11332},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157244,"byte_end":3157260,"line_start":91,"line_end":91,"column_start":15,"column_end":31},"name":"_mm256_add_epi16","qualname":"::core_arch::x86::avx2::_mm256_add_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157095,"byte_end":3157104,"line_start":87,"line_end":87,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157105,"byte_end":3157139,"line_start":88,"line_end":88,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157180,"byte_end":3157229,"line_start":90,"line_end":90,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11334},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157667,"byte_end":3157682,"line_start":102,"line_end":102,"column_start":15,"column_end":30},"name":"_mm256_add_epi8","qualname":"::core_arch::x86::avx2::_mm256_add_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157518,"byte_end":3157527,"line_start":98,"line_end":98,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157528,"byte_end":3157562,"line_start":99,"line_end":99,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157603,"byte_end":3157652,"line_start":101,"line_end":101,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11336},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158106,"byte_end":3158122,"line_start":113,"line_end":113,"column_start":15,"column_end":31},"name":"_mm256_adds_epi8","qualname":"::core_arch::x86::avx2::_mm256_adds_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157956,"byte_end":3157965,"line_start":109,"line_end":109,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3157966,"byte_end":3158000,"line_start":110,"line_end":110,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158042,"byte_end":3158091,"line_start":112,"line_end":112,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11338},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158546,"byte_end":3158563,"line_start":124,"line_end":124,"column_start":15,"column_end":32},"name":"_mm256_adds_epi16","qualname":"::core_arch::x86::avx2::_mm256_adds_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158396,"byte_end":3158405,"line_start":120,"line_end":120,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158406,"byte_end":3158440,"line_start":121,"line_end":121,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158482,"byte_end":3158531,"line_start":123,"line_end":123,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11340},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158997,"byte_end":3159013,"line_start":135,"line_end":135,"column_start":15,"column_end":31},"name":"_mm256_adds_epu8","qualname":"::core_arch::x86::avx2::_mm256_adds_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 8-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158846,"byte_end":3158855,"line_start":131,"line_end":131,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158856,"byte_end":3158890,"line_start":132,"line_end":132,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3158933,"byte_end":3158982,"line_start":134,"line_end":134,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11342},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3159448,"byte_end":3159465,"line_start":146,"line_end":146,"column_start":15,"column_end":32},"name":"_mm256_adds_epu16","qualname":"::core_arch::x86::avx2::_mm256_adds_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 16-bit integers in `a` and `b` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3159297,"byte_end":3159306,"line_start":142,"line_end":142,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3159307,"byte_end":3159341,"line_start":143,"line_end":143,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3159384,"byte_end":3159433,"line_start":145,"line_end":145,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11344},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3160029,"byte_end":3160047,"line_start":159,"line_end":159,"column_start":15,"column_end":33},"name":"_mm256_alignr_epi8","qualname":"::core_arch::x86::avx2::_mm256_alignr_epi8","value":"fn (a: __m256i, b: __m256i, n: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Concatenates pairs of 16-byte blocks in `a` and `b` into a 32-byte temporary\n result, shifts the result right by `n` bytes, and returns the low 16 bytes.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3159839,"byte_end":3159848,"line_start":154,"line_end":154,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3159849,"byte_end":3159883,"line_start":155,"line_end":155,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3159933,"byte_end":3159964,"line_start":157,"line_end":157,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3159965,"byte_end":3160014,"line_start":158,"line_end":158,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11346},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3165104,"byte_end":3165120,"line_start":319,"line_end":319,"column_start":15,"column_end":31},"name":"_mm256_and_si256","qualname":"::core_arch::x86::avx2::_mm256_and_si256","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise AND of 256 bits (representing integer data)\n in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3164955,"byte_end":3164964,"line_start":315,"line_end":315,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3164965,"byte_end":3164999,"line_start":316,"line_end":316,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3165040,"byte_end":3165089,"line_start":318,"line_end":318,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11348},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3165586,"byte_end":3165605,"line_start":331,"line_end":331,"column_start":15,"column_end":34},"name":"_mm256_andnot_si256","qualname":"::core_arch::x86::avx2::_mm256_andnot_si256","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise NOT of 256 bits (representing integer data)\n in `a` and then AND with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3165436,"byte_end":3165445,"line_start":327,"line_end":327,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3165446,"byte_end":3165480,"line_start":328,"line_end":328,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3165522,"byte_end":3165571,"line_start":330,"line_end":330,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11350},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166120,"byte_end":3166136,"line_start":346,"line_end":346,"column_start":15,"column_end":31},"name":"_mm256_avg_epu16","qualname":"::core_arch::x86::avx2::_mm256_avg_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Averages packed unsigned 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3165971,"byte_end":3165980,"line_start":342,"line_end":342,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3165981,"byte_end":3166015,"line_start":343,"line_end":343,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166056,"byte_end":3166105,"line_start":345,"line_end":345,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11352},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166553,"byte_end":3166568,"line_start":357,"line_end":357,"column_start":15,"column_end":30},"name":"_mm256_avg_epu8","qualname":"::core_arch::x86::avx2::_mm256_avg_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Averages packed unsigned 8-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166404,"byte_end":3166413,"line_start":353,"line_end":353,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166414,"byte_end":3166448,"line_start":354,"line_end":354,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166489,"byte_end":3166538,"line_start":356,"line_end":356,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11354},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3167045,"byte_end":3167060,"line_start":369,"line_end":369,"column_start":15,"column_end":30},"name":"_mm_blend_epi32","qualname":"::core_arch::x86::avx2::_mm_blend_epi32","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Blends packed 32-bit integers from `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166852,"byte_end":3166861,"line_start":364,"line_end":364,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166862,"byte_end":3166896,"line_start":365,"line_end":365,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166949,"byte_end":3166980,"line_start":367,"line_end":367,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3166981,"byte_end":3167030,"line_start":368,"line_end":368,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11360},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3168231,"byte_end":3168249,"line_start":405,"line_end":405,"column_start":15,"column_end":33},"name":"_mm256_blend_epi32","qualname":"::core_arch::x86::avx2::_mm256_blend_epi32","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Blends packed 32-bit integers from `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3168038,"byte_end":3168047,"line_start":400,"line_end":400,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3168048,"byte_end":3168082,"line_start":401,"line_end":401,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3168135,"byte_end":3168166,"line_start":403,"line_end":403,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3168167,"byte_end":3168216,"line_start":404,"line_end":404,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11370},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3170366,"byte_end":3170384,"line_start":470,"line_end":470,"column_start":15,"column_end":33},"name":"_mm256_blend_epi16","qualname":"::core_arch::x86::avx2::_mm256_blend_epi16","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Blends packed 16-bit integers from `a` and `b` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3170173,"byte_end":3170182,"line_start":465,"line_end":465,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3170183,"byte_end":3170217,"line_start":466,"line_end":466,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3170270,"byte_end":3170301,"line_start":468,"line_end":468,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3170302,"byte_end":3170351,"line_start":469,"line_end":469,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11380},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3173587,"byte_end":3173605,"line_start":574,"line_end":574,"column_start":15,"column_end":33},"name":"_mm256_blendv_epi8","qualname":"::core_arch::x86::avx2::_mm256_blendv_epi8","value":"fn (a: __m256i, b: __m256i, mask: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Blends packed 8-bit integers from `a` and `b` using `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3173435,"byte_end":3173444,"line_start":570,"line_end":570,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3173445,"byte_end":3173479,"line_start":571,"line_end":571,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3173523,"byte_end":3173572,"line_start":573,"line_end":573,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11382},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3174109,"byte_end":3174128,"line_start":586,"line_end":586,"column_start":15,"column_end":34},"name":"_mm_broadcastb_epi8","qualname":"::core_arch::x86::avx2::_mm_broadcastb_epi8","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 8-bit integer from `a` to all elements of\n the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3173954,"byte_end":3173963,"line_start":582,"line_end":582,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3173964,"byte_end":3173998,"line_start":583,"line_end":583,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3174045,"byte_end":3174094,"line_start":585,"line_end":585,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11384},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3174680,"byte_end":3174702,"line_start":600,"line_end":600,"column_start":15,"column_end":37},"name":"_mm256_broadcastb_epi8","qualname":"::core_arch::x86::avx2::_mm256_broadcastb_epi8","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 8-bit integer from `a` to all elements of\n the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3174525,"byte_end":3174534,"line_start":596,"line_end":596,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3174535,"byte_end":3174569,"line_start":597,"line_end":597,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3174616,"byte_end":3174665,"line_start":599,"line_end":599,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11386},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3175358,"byte_end":3175378,"line_start":616,"line_end":616,"column_start":15,"column_end":35},"name":"_mm_broadcastd_epi32","qualname":"::core_arch::x86::avx2::_mm_broadcastd_epi32","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 32-bit integer from `a` to all elements of\n the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3175203,"byte_end":3175212,"line_start":612,"line_end":612,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3175213,"byte_end":3175247,"line_start":613,"line_end":613,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3175294,"byte_end":3175343,"line_start":615,"line_end":615,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11388},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3176036,"byte_end":3176059,"line_start":632,"line_end":632,"column_start":15,"column_end":38},"name":"_mm256_broadcastd_epi32","qualname":"::core_arch::x86::avx2::_mm256_broadcastd_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 32-bit integer from `a` to all elements of\n the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3175881,"byte_end":3175890,"line_start":628,"line_end":628,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3175891,"byte_end":3175925,"line_start":629,"line_end":629,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3175972,"byte_end":3176021,"line_start":631,"line_end":631,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11390},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3176608,"byte_end":3176628,"line_start":646,"line_end":646,"column_start":15,"column_end":35},"name":"_mm_broadcastq_epi64","qualname":"::core_arch::x86::avx2::_mm_broadcastq_epi64","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 64-bit integer from `a` to all elements of\n the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3176453,"byte_end":3176462,"line_start":642,"line_end":642,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3176463,"byte_end":3176497,"line_start":643,"line_end":643,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3176544,"byte_end":3176593,"line_start":645,"line_end":645,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11392},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3177284,"byte_end":3177307,"line_start":662,"line_end":662,"column_start":15,"column_end":38},"name":"_mm256_broadcastq_epi64","qualname":"::core_arch::x86::avx2::_mm256_broadcastq_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 64-bit integer from `a` to all elements of\n the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3177129,"byte_end":3177138,"line_start":658,"line_end":658,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3177139,"byte_end":3177173,"line_start":659,"line_end":659,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3177220,"byte_end":3177269,"line_start":661,"line_end":661,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11394},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3177877,"byte_end":3177895,"line_start":676,"line_end":676,"column_start":15,"column_end":33},"name":"_mm_broadcastsd_pd","qualname":"::core_arch::x86::avx2::_mm_broadcastsd_pd","value":"fn (a: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low double-precision (64-bit) floating-point element\n from `a` to all elements of the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3177726,"byte_end":3177735,"line_start":672,"line_end":672,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3177736,"byte_end":3177770,"line_start":673,"line_end":673,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3177813,"byte_end":3177862,"line_start":675,"line_end":675,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11396},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3178384,"byte_end":3178405,"line_start":688,"line_end":688,"column_start":15,"column_end":36},"name":"_mm256_broadcastsd_pd","qualname":"::core_arch::x86::avx2::_mm256_broadcastsd_pd","value":"fn (a: __m128d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low double-precision (64-bit) floating-point element\n from `a` to all elements of the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3178229,"byte_end":3178238,"line_start":684,"line_end":684,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3178239,"byte_end":3178273,"line_start":685,"line_end":685,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3178320,"byte_end":3178369,"line_start":687,"line_end":687,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11398},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3178916,"byte_end":3178943,"line_start":701,"line_end":701,"column_start":15,"column_end":42},"name":"_mm256_broadcastsi128_si256","qualname":"::core_arch::x86::avx2::_mm256_broadcastsi128_si256","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 128 bits of integer data from a to all 128-bit lanes in\n the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3178807,"byte_end":3178816,"line_start":698,"line_end":698,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3178817,"byte_end":3178851,"line_start":699,"line_end":699,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3178852,"byte_end":3178901,"line_start":700,"line_end":700,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11400},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3179519,"byte_end":3179537,"line_start":715,"line_end":715,"column_start":15,"column_end":33},"name":"_mm_broadcastss_ps","qualname":"::core_arch::x86::avx2::_mm_broadcastss_ps","value":"fn (a: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low single-precision (32-bit) floating-point element\n from `a` to all elements of the 128-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3179364,"byte_end":3179373,"line_start":711,"line_end":711,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3179374,"byte_end":3179408,"line_start":712,"line_end":712,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3179455,"byte_end":3179504,"line_start":714,"line_end":714,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11402},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3180024,"byte_end":3180045,"line_start":727,"line_end":727,"column_start":15,"column_end":36},"name":"_mm256_broadcastss_ps","qualname":"::core_arch::x86::avx2::_mm256_broadcastss_ps","value":"fn (a: __m128) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low single-precision (32-bit) floating-point element\n from `a` to all elements of the 256-bit returned value.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3179869,"byte_end":3179878,"line_start":723,"line_end":723,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3179879,"byte_end":3179913,"line_start":724,"line_end":724,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3179960,"byte_end":3180009,"line_start":726,"line_end":726,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11404},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3180501,"byte_end":3180521,"line_start":739,"line_end":739,"column_start":15,"column_end":35},"name":"_mm_broadcastw_epi16","qualname":"::core_arch::x86::avx2::_mm_broadcastw_epi16","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 16-bit integer from a to all elements of\n the 128-bit returned value","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3180346,"byte_end":3180355,"line_start":735,"line_end":735,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3180356,"byte_end":3180390,"line_start":736,"line_end":736,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3180437,"byte_end":3180486,"line_start":738,"line_end":738,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11406},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181070,"byte_end":3181093,"line_start":753,"line_end":753,"column_start":15,"column_end":38},"name":"_mm256_broadcastw_epi16","qualname":"::core_arch::x86::avx2::_mm256_broadcastw_epi16","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts the low packed 16-bit integer from a to all elements of\n the 256-bit returned value","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3180915,"byte_end":3180924,"line_start":749,"line_end":749,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3180925,"byte_end":3180959,"line_start":750,"line_end":750,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181006,"byte_end":3181055,"line_start":752,"line_end":752,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11408},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181599,"byte_end":3181617,"line_start":766,"line_end":766,"column_start":15,"column_end":33},"name":"_mm256_cmpeq_epi64","qualname":"::core_arch::x86::avx2::_mm256_cmpeq_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 64-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181448,"byte_end":3181457,"line_start":762,"line_end":762,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181458,"byte_end":3181492,"line_start":763,"line_end":763,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181535,"byte_end":3181584,"line_start":765,"line_end":765,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11410},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182056,"byte_end":3182074,"line_start":777,"line_end":777,"column_start":15,"column_end":33},"name":"_mm256_cmpeq_epi32","qualname":"::core_arch::x86::avx2::_mm256_cmpeq_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181905,"byte_end":3181914,"line_start":773,"line_end":773,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181915,"byte_end":3181949,"line_start":774,"line_end":774,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3181992,"byte_end":3182041,"line_start":776,"line_end":776,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11412},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182513,"byte_end":3182531,"line_start":788,"line_end":788,"column_start":15,"column_end":33},"name":"_mm256_cmpeq_epi16","qualname":"::core_arch::x86::avx2::_mm256_cmpeq_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182362,"byte_end":3182371,"line_start":784,"line_end":784,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182372,"byte_end":3182406,"line_start":785,"line_end":785,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182449,"byte_end":3182498,"line_start":787,"line_end":787,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11414},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182971,"byte_end":3182988,"line_start":799,"line_end":799,"column_start":15,"column_end":32},"name":"_mm256_cmpeq_epi8","qualname":"::core_arch::x86::avx2::_mm256_cmpeq_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for equality.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182820,"byte_end":3182829,"line_start":795,"line_end":795,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182830,"byte_end":3182864,"line_start":796,"line_end":796,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3182907,"byte_end":3182956,"line_start":798,"line_end":798,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11416},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3183431,"byte_end":3183449,"line_start":810,"line_end":810,"column_start":15,"column_end":33},"name":"_mm256_cmpgt_epi64","qualname":"::core_arch::x86::avx2::_mm256_cmpgt_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 64-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3183280,"byte_end":3183289,"line_start":806,"line_end":806,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3183290,"byte_end":3183324,"line_start":807,"line_end":807,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3183367,"byte_end":3183416,"line_start":809,"line_end":809,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11418},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3183892,"byte_end":3183910,"line_start":821,"line_end":821,"column_start":15,"column_end":33},"name":"_mm256_cmpgt_epi32","qualname":"::core_arch::x86::avx2::_mm256_cmpgt_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3183741,"byte_end":3183750,"line_start":817,"line_end":817,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3183751,"byte_end":3183785,"line_start":818,"line_end":818,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3183828,"byte_end":3183877,"line_start":820,"line_end":820,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11420},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3184353,"byte_end":3184371,"line_start":832,"line_end":832,"column_start":15,"column_end":33},"name":"_mm256_cmpgt_epi16","qualname":"::core_arch::x86::avx2::_mm256_cmpgt_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3184202,"byte_end":3184211,"line_start":828,"line_end":828,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3184212,"byte_end":3184246,"line_start":829,"line_end":829,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3184289,"byte_end":3184338,"line_start":831,"line_end":831,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11422},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3184815,"byte_end":3184832,"line_start":843,"line_end":843,"column_start":15,"column_end":32},"name":"_mm256_cmpgt_epi8","qualname":"::core_arch::x86::avx2::_mm256_cmpgt_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b` for greater-than.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3184664,"byte_end":3184673,"line_start":839,"line_end":839,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3184674,"byte_end":3184708,"line_start":840,"line_end":840,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3184751,"byte_end":3184800,"line_start":842,"line_end":842,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11424},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3185262,"byte_end":3185283,"line_start":854,"line_end":854,"column_start":15,"column_end":36},"name":"_mm256_cvtepi16_epi32","qualname":"::core_arch::x86::avx2::_mm256_cvtepi16_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 16-bit integers to 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3185110,"byte_end":3185119,"line_start":850,"line_end":850,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3185120,"byte_end":3185154,"line_start":851,"line_end":851,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3185198,"byte_end":3185247,"line_start":853,"line_end":853,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11426},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3185689,"byte_end":3185710,"line_start":865,"line_end":865,"column_start":15,"column_end":36},"name":"_mm256_cvtepi16_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepi16_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 16-bit integers to 64-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3185537,"byte_end":3185546,"line_start":861,"line_end":861,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3185547,"byte_end":3185581,"line_start":862,"line_end":862,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3185625,"byte_end":3185674,"line_start":864,"line_end":864,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11428},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186189,"byte_end":3186210,"line_start":878,"line_end":878,"column_start":15,"column_end":36},"name":"_mm256_cvtepi32_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepi32_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 32-bit integers to 64-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186037,"byte_end":3186046,"line_start":874,"line_end":874,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186047,"byte_end":3186081,"line_start":875,"line_end":875,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186125,"byte_end":3186174,"line_start":877,"line_end":877,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11430},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186614,"byte_end":3186634,"line_start":889,"line_end":889,"column_start":15,"column_end":35},"name":"_mm256_cvtepi8_epi16","qualname":"::core_arch::x86::avx2::_mm256_cvtepi8_epi16","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 8-bit integers to 16-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186462,"byte_end":3186471,"line_start":885,"line_end":885,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186472,"byte_end":3186506,"line_start":886,"line_end":886,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186550,"byte_end":3186599,"line_start":888,"line_end":888,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11432},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3187039,"byte_end":3187059,"line_start":900,"line_end":900,"column_start":15,"column_end":35},"name":"_mm256_cvtepi8_epi32","qualname":"::core_arch::x86::avx2::_mm256_cvtepi8_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 8-bit integers to 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186887,"byte_end":3186896,"line_start":896,"line_end":896,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186897,"byte_end":3186931,"line_start":897,"line_end":897,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3186975,"byte_end":3187024,"line_start":899,"line_end":899,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11434},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3187547,"byte_end":3187567,"line_start":913,"line_end":913,"column_start":15,"column_end":35},"name":"_mm256_cvtepi8_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepi8_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Sign-extend 8-bit integers to 64-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3187395,"byte_end":3187404,"line_start":909,"line_end":909,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3187405,"byte_end":3187439,"line_start":910,"line_end":910,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3187483,"byte_end":3187532,"line_start":912,"line_end":912,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11436},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3188114,"byte_end":3188135,"line_start":927,"line_end":927,"column_start":15,"column_end":36},"name":"_mm256_cvtepu16_epi32","qualname":"::core_arch::x86::avx2::_mm256_cvtepu16_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zeroes extend packed unsigned 16-bit integers in `a` to packed 32-bit\n integers, and stores the results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3187962,"byte_end":3187971,"line_start":923,"line_end":923,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3187972,"byte_end":3188006,"line_start":924,"line_end":924,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3188050,"byte_end":3188099,"line_start":926,"line_end":926,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11438},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3188619,"byte_end":3188640,"line_start":939,"line_end":939,"column_start":15,"column_end":36},"name":"_mm256_cvtepu16_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepu16_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend the lower four unsigned 16-bit integers in `a` to 64-bit\n integers. The upper four elements of `a` are unused.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3188467,"byte_end":3188476,"line_start":935,"line_end":935,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3188477,"byte_end":3188511,"line_start":936,"line_end":936,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3188555,"byte_end":3188604,"line_start":938,"line_end":938,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11440},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3189135,"byte_end":3189156,"line_start":952,"line_end":952,"column_start":15,"column_end":36},"name":"_mm256_cvtepu32_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepu32_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend unsigned 32-bit integers in `a` to 64-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3188983,"byte_end":3188992,"line_start":948,"line_end":948,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3188993,"byte_end":3189027,"line_start":949,"line_end":949,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3189071,"byte_end":3189120,"line_start":951,"line_end":951,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11442},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3189576,"byte_end":3189596,"line_start":963,"line_end":963,"column_start":15,"column_end":35},"name":"_mm256_cvtepu8_epi16","qualname":"::core_arch::x86::avx2::_mm256_cvtepu8_epi16","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend unsigned 8-bit integers in `a` to 16-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3189424,"byte_end":3189433,"line_start":959,"line_end":959,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3189434,"byte_end":3189468,"line_start":960,"line_end":960,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3189512,"byte_end":3189561,"line_start":962,"line_end":962,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11444},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3190081,"byte_end":3190101,"line_start":975,"line_end":975,"column_start":15,"column_end":35},"name":"_mm256_cvtepu8_epi32","qualname":"::core_arch::x86::avx2::_mm256_cvtepu8_epi32","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend the lower eight unsigned 8-bit integers in `a` to 32-bit\n integers. The upper eight elements of `a` are unused.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3189929,"byte_end":3189938,"line_start":971,"line_end":971,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3189939,"byte_end":3189973,"line_start":972,"line_end":972,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3190017,"byte_end":3190066,"line_start":974,"line_end":974,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11446},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3190669,"byte_end":3190689,"line_start":989,"line_end":989,"column_start":15,"column_end":35},"name":"_mm256_cvtepu8_epi64","qualname":"::core_arch::x86::avx2::_mm256_cvtepu8_epi64","value":"fn (a: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Zero-extend the lower four unsigned 8-bit integers in `a` to 64-bit\n integers. The upper twelve elements of `a` are unused.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3190517,"byte_end":3190526,"line_start":985,"line_end":985,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3190527,"byte_end":3190561,"line_start":986,"line_end":986,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3190605,"byte_end":3190654,"line_start":988,"line_end":988,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11448},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191277,"byte_end":3191301,"line_start":1006,"line_end":1006,"column_start":15,"column_end":39},"name":"_mm256_extracti128_si256","qualname":"::core_arch::x86::avx2::_mm256_extracti128_si256","value":"fn (a: __m256i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Extracts 128 bits (of integer data) from `a` selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191037,"byte_end":3191046,"line_start":998,"line_end":998,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191047,"byte_end":3191081,"line_start":999,"line_end":999,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191181,"byte_end":3191212,"line_start":1004,"line_end":1004,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191213,"byte_end":3191262,"line_start":1005,"line_end":1005,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11450},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191907,"byte_end":3191924,"line_start":1023,"line_end":1023,"column_start":15,"column_end":32},"name":"_mm256_hadd_epi16","qualname":"::core_arch::x86::avx2::_mm256_hadd_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191757,"byte_end":3191766,"line_start":1019,"line_end":1019,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191767,"byte_end":3191801,"line_start":1020,"line_end":1020,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3191843,"byte_end":3191892,"line_start":1022,"line_end":1022,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11452},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3192357,"byte_end":3192374,"line_start":1034,"line_end":1034,"column_start":15,"column_end":32},"name":"_mm256_hadd_epi32","qualname":"::core_arch::x86::avx2::_mm256_hadd_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of 32-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3192207,"byte_end":3192216,"line_start":1030,"line_end":1030,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3192217,"byte_end":3192251,"line_start":1031,"line_end":1031,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3192293,"byte_end":3192342,"line_start":1033,"line_end":1033,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11454},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3192828,"byte_end":3192846,"line_start":1046,"line_end":1046,"column_start":15,"column_end":33},"name":"_mm256_hadds_epi16","qualname":"::core_arch::x86::avx2::_mm256_hadds_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally adds adjacent pairs of 16-bit integers in `a` and `b`\n using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3192677,"byte_end":3192686,"line_start":1042,"line_end":1042,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3192687,"byte_end":3192721,"line_start":1043,"line_end":1043,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3192764,"byte_end":3192813,"line_start":1045,"line_end":1045,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11456},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3193284,"byte_end":3193301,"line_start":1057,"line_end":1057,"column_start":15,"column_end":32},"name":"_mm256_hsub_epi16","qualname":"::core_arch::x86::avx2::_mm256_hsub_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3193134,"byte_end":3193143,"line_start":1053,"line_end":1053,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3193144,"byte_end":3193178,"line_start":1054,"line_end":1054,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3193220,"byte_end":3193269,"line_start":1056,"line_end":1056,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11458},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3193738,"byte_end":3193755,"line_start":1068,"line_end":1068,"column_start":15,"column_end":32},"name":"_mm256_hsub_epi32","qualname":"::core_arch::x86::avx2::_mm256_hsub_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract adjacent pairs of 32-bit integers in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3193588,"byte_end":3193597,"line_start":1064,"line_end":1064,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3193598,"byte_end":3193632,"line_start":1065,"line_end":1065,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3193674,"byte_end":3193723,"line_start":1067,"line_end":1067,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11460},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194213,"byte_end":3194231,"line_start":1080,"line_end":1080,"column_start":15,"column_end":33},"name":"_mm256_hsubs_epi16","qualname":"::core_arch::x86::avx2::_mm256_hsubs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Horizontally subtract adjacent pairs of 16-bit integers in `a` and `b`\n using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194062,"byte_end":3194071,"line_start":1076,"line_end":1076,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194072,"byte_end":3194106,"line_start":1077,"line_end":1077,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194149,"byte_end":3194198,"line_start":1079,"line_end":1079,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11462},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194759,"byte_end":3194778,"line_start":1094,"line_end":1094,"column_start":15,"column_end":34},"name":"_mm_i32gather_epi32","qualname":"::core_arch::x86::avx2::_mm_i32gather_epi32","value":"fn (slice: *const i32, offsets: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194563,"byte_end":3194572,"line_start":1089,"line_end":1089,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194573,"byte_end":3194607,"line_start":1090,"line_end":1090,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194663,"byte_end":3194694,"line_start":1092,"line_end":1092,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3194695,"byte_end":3194744,"line_start":1093,"line_end":1093,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11466},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3195710,"byte_end":3195734,"line_start":1119,"line_end":1119,"column_start":15,"column_end":39},"name":"_mm_mask_i32gather_epi32","qualname":"::core_arch::x86::avx2::_mm_mask_i32gather_epi32","value":"fn (src: __m128i, slice: *const i32, offsets: __m128i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3195514,"byte_end":3195523,"line_start":1114,"line_end":1114,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3195524,"byte_end":3195558,"line_start":1115,"line_end":1115,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3195614,"byte_end":3195645,"line_start":1117,"line_end":1117,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3195646,"byte_end":3195695,"line_start":1118,"line_end":1118,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11470},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3196606,"byte_end":3196628,"line_start":1149,"line_end":1149,"column_start":15,"column_end":37},"name":"_mm256_i32gather_epi32","qualname":"::core_arch::x86::avx2::_mm256_i32gather_epi32","value":"fn (slice: *const i32, offsets: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3196410,"byte_end":3196419,"line_start":1144,"line_end":1144,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3196420,"byte_end":3196454,"line_start":1145,"line_end":1145,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3196510,"byte_end":3196541,"line_start":1147,"line_end":1147,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3196542,"byte_end":3196591,"line_start":1148,"line_end":1148,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11474},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3197570,"byte_end":3197597,"line_start":1174,"line_end":1174,"column_start":15,"column_end":42},"name":"_mm256_mask_i32gather_epi32","qualname":"::core_arch::x86::avx2::_mm256_mask_i32gather_epi32","value":"fn (src: __m256i, slice: *const i32, offsets: __m256i, mask: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3197374,"byte_end":3197383,"line_start":1169,"line_end":1169,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3197384,"byte_end":3197418,"line_start":1170,"line_end":1170,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3197474,"byte_end":3197505,"line_start":1172,"line_end":1172,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3197506,"byte_end":3197555,"line_start":1173,"line_end":1173,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11478},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3198464,"byte_end":3198480,"line_start":1204,"line_end":1204,"column_start":15,"column_end":31},"name":"_mm_i32gather_ps","qualname":"::core_arch::x86::avx2::_mm_i32gather_ps","value":"fn (slice: *const f32, offsets: __m128i, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3198268,"byte_end":3198277,"line_start":1199,"line_end":1199,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3198278,"byte_end":3198312,"line_start":1200,"line_end":1200,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3198368,"byte_end":3198399,"line_start":1202,"line_end":1202,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3198400,"byte_end":3198449,"line_start":1203,"line_end":1203,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11482},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199357,"byte_end":3199378,"line_start":1228,"line_end":1228,"column_start":15,"column_end":36},"name":"_mm_mask_i32gather_ps","qualname":"::core_arch::x86::avx2::_mm_mask_i32gather_ps","value":"fn (src: __m128, slice: *const f32, offsets: __m128i, mask: __m128, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199161,"byte_end":3199170,"line_start":1223,"line_end":1223,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199171,"byte_end":3199205,"line_start":1224,"line_end":1224,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199261,"byte_end":3199292,"line_start":1226,"line_end":1226,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199293,"byte_end":3199342,"line_start":1227,"line_end":1227,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11486},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200157,"byte_end":3200176,"line_start":1255,"line_end":1255,"column_start":15,"column_end":34},"name":"_mm256_i32gather_ps","qualname":"::core_arch::x86::avx2::_mm256_i32gather_ps","value":"fn (slice: *const f32, offsets: __m256i, scale: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199961,"byte_end":3199970,"line_start":1250,"line_end":1250,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3199971,"byte_end":3200005,"line_start":1251,"line_end":1251,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200061,"byte_end":3200092,"line_start":1253,"line_end":1253,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200093,"byte_end":3200142,"line_start":1254,"line_end":1254,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11490},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201063,"byte_end":3201087,"line_start":1279,"line_end":1279,"column_start":15,"column_end":39},"name":"_mm256_mask_i32gather_ps","qualname":"::core_arch::x86::avx2::_mm256_mask_i32gather_ps","value":"fn (src: __m256, slice: *const f32, offsets: __m256i, mask: __m256, scale: i32) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200867,"byte_end":3200876,"line_start":1274,"line_end":1274,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200877,"byte_end":3200911,"line_start":1275,"line_end":1275,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200967,"byte_end":3200998,"line_start":1277,"line_end":1277,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3200999,"byte_end":3201048,"line_start":1278,"line_end":1278,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11494},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201867,"byte_end":3201886,"line_start":1306,"line_end":1306,"column_start":15,"column_end":34},"name":"_mm_i32gather_epi64","qualname":"::core_arch::x86::avx2::_mm_i32gather_epi64","value":"fn (slice: *const i64, offsets: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201671,"byte_end":3201680,"line_start":1301,"line_end":1301,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201681,"byte_end":3201715,"line_start":1302,"line_end":1302,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201771,"byte_end":3201802,"line_start":1304,"line_end":1304,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3201803,"byte_end":3201852,"line_start":1305,"line_end":1305,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11498},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202819,"byte_end":3202843,"line_start":1331,"line_end":1331,"column_start":15,"column_end":39},"name":"_mm_mask_i32gather_epi64","qualname":"::core_arch::x86::avx2::_mm_mask_i32gather_epi64","value":"fn (src: __m128i, slice: *const i64, offsets: __m128i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202623,"byte_end":3202632,"line_start":1326,"line_end":1326,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202633,"byte_end":3202667,"line_start":1327,"line_end":1327,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202723,"byte_end":3202754,"line_start":1329,"line_end":1329,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3202755,"byte_end":3202804,"line_start":1330,"line_end":1330,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11502},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203715,"byte_end":3203737,"line_start":1361,"line_end":1361,"column_start":15,"column_end":37},"name":"_mm256_i32gather_epi64","qualname":"::core_arch::x86::avx2::_mm256_i32gather_epi64","value":"fn (slice: *const i64, offsets: __m128i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203519,"byte_end":3203528,"line_start":1356,"line_end":1356,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203529,"byte_end":3203563,"line_start":1357,"line_end":1357,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203619,"byte_end":3203650,"line_start":1359,"line_end":1359,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3203651,"byte_end":3203700,"line_start":1360,"line_end":1360,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11506},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204680,"byte_end":3204707,"line_start":1386,"line_end":1386,"column_start":15,"column_end":42},"name":"_mm256_mask_i32gather_epi64","qualname":"::core_arch::x86::avx2::_mm256_mask_i32gather_epi64","value":"fn (src: __m256i, slice: *const i64, offsets: __m128i, mask: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204484,"byte_end":3204493,"line_start":1381,"line_end":1381,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204494,"byte_end":3204528,"line_start":1382,"line_end":1382,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204584,"byte_end":3204615,"line_start":1384,"line_end":1384,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3204616,"byte_end":3204665,"line_start":1385,"line_end":1385,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11510},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3205574,"byte_end":3205590,"line_start":1416,"line_end":1416,"column_start":15,"column_end":31},"name":"_mm_i32gather_pd","qualname":"::core_arch::x86::avx2::_mm_i32gather_pd","value":"fn (slice: *const f64, offsets: __m128i, scale: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3205378,"byte_end":3205387,"line_start":1411,"line_end":1411,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3205388,"byte_end":3205422,"line_start":1412,"line_end":1412,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3205478,"byte_end":3205509,"line_start":1414,"line_end":1414,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3205510,"byte_end":3205559,"line_start":1415,"line_end":1415,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11514},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3206468,"byte_end":3206489,"line_start":1440,"line_end":1440,"column_start":15,"column_end":36},"name":"_mm_mask_i32gather_pd","qualname":"::core_arch::x86::avx2::_mm_mask_i32gather_pd","value":"fn (src: __m128d, slice: *const f64, offsets: __m128i, mask: __m128d, scale: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3206272,"byte_end":3206281,"line_start":1435,"line_end":1435,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3206282,"byte_end":3206316,"line_start":1436,"line_end":1436,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3206372,"byte_end":3206403,"line_start":1438,"line_end":1438,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3206404,"byte_end":3206453,"line_start":1439,"line_end":1439,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11518},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3207271,"byte_end":3207290,"line_start":1467,"line_end":1467,"column_start":15,"column_end":34},"name":"_mm256_i32gather_pd","qualname":"::core_arch::x86::avx2::_mm256_i32gather_pd","value":"fn (slice: *const f64, offsets: __m128i, scale: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3207075,"byte_end":3207084,"line_start":1462,"line_end":1462,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3207085,"byte_end":3207119,"line_start":1463,"line_end":1463,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3207175,"byte_end":3207206,"line_start":1465,"line_end":1465,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3207207,"byte_end":3207256,"line_start":1466,"line_end":1466,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11522},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3208178,"byte_end":3208202,"line_start":1491,"line_end":1491,"column_start":15,"column_end":39},"name":"_mm256_mask_i32gather_pd","qualname":"::core_arch::x86::avx2::_mm256_mask_i32gather_pd","value":"fn (src: __m256d, slice: *const f64, offsets: __m128i, mask: __m256d, scale: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3207982,"byte_end":3207991,"line_start":1486,"line_end":1486,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3207992,"byte_end":3208026,"line_start":1487,"line_end":1487,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3208082,"byte_end":3208113,"line_start":1489,"line_end":1489,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3208114,"byte_end":3208163,"line_start":1490,"line_end":1490,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11526},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3208985,"byte_end":3209004,"line_start":1518,"line_end":1518,"column_start":15,"column_end":34},"name":"_mm_i64gather_epi32","qualname":"::core_arch::x86::avx2::_mm_i64gather_epi32","value":"fn (slice: *const i32, offsets: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3208789,"byte_end":3208798,"line_start":1513,"line_end":1513,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3208799,"byte_end":3208833,"line_start":1514,"line_end":1514,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3208889,"byte_end":3208920,"line_start":1516,"line_end":1516,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3208921,"byte_end":3208970,"line_start":1517,"line_end":1517,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11530},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209937,"byte_end":3209961,"line_start":1543,"line_end":1543,"column_start":15,"column_end":39},"name":"_mm_mask_i64gather_epi32","qualname":"::core_arch::x86::avx2::_mm_mask_i64gather_epi32","value":"fn (src: __m128i, slice: *const i32, offsets: __m128i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209741,"byte_end":3209750,"line_start":1538,"line_end":1538,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209751,"byte_end":3209785,"line_start":1539,"line_end":1539,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209841,"byte_end":3209872,"line_start":1541,"line_end":1541,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3209873,"byte_end":3209922,"line_start":1542,"line_end":1542,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11534},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210833,"byte_end":3210855,"line_start":1573,"line_end":1573,"column_start":15,"column_end":37},"name":"_mm256_i64gather_epi32","qualname":"::core_arch::x86::avx2::_mm256_i64gather_epi32","value":"fn (slice: *const i32, offsets: __m256i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210637,"byte_end":3210646,"line_start":1568,"line_end":1568,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210647,"byte_end":3210681,"line_start":1569,"line_end":1569,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210737,"byte_end":3210768,"line_start":1571,"line_end":1571,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3210769,"byte_end":3210818,"line_start":1572,"line_end":1572,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11538},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211792,"byte_end":3211819,"line_start":1598,"line_end":1598,"column_start":15,"column_end":42},"name":"_mm256_mask_i64gather_epi32","qualname":"::core_arch::x86::avx2::_mm256_mask_i64gather_epi32","value":"fn (src: __m128i, slice: *const i32, offsets: __m256i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211596,"byte_end":3211605,"line_start":1593,"line_end":1593,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211606,"byte_end":3211640,"line_start":1594,"line_end":1594,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211696,"byte_end":3211727,"line_start":1596,"line_end":1596,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3211728,"byte_end":3211777,"line_start":1597,"line_end":1597,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11542},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212686,"byte_end":3212702,"line_start":1628,"line_end":1628,"column_start":15,"column_end":31},"name":"_mm_i64gather_ps","qualname":"::core_arch::x86::avx2::_mm_i64gather_ps","value":"fn (slice: *const f32, offsets: __m128i, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212490,"byte_end":3212499,"line_start":1623,"line_end":1623,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212500,"byte_end":3212534,"line_start":1624,"line_end":1624,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212590,"byte_end":3212621,"line_start":1626,"line_end":1626,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3212622,"byte_end":3212671,"line_start":1627,"line_end":1627,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11546},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3213579,"byte_end":3213600,"line_start":1652,"line_end":1652,"column_start":15,"column_end":36},"name":"_mm_mask_i64gather_ps","qualname":"::core_arch::x86::avx2::_mm_mask_i64gather_ps","value":"fn (src: __m128, slice: *const f32, offsets: __m128i, mask: __m128, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3213383,"byte_end":3213392,"line_start":1647,"line_end":1647,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3213393,"byte_end":3213427,"line_start":1648,"line_end":1648,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3213483,"byte_end":3213514,"line_start":1650,"line_end":1650,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3213515,"byte_end":3213564,"line_start":1651,"line_end":1651,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11550},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214379,"byte_end":3214398,"line_start":1679,"line_end":1679,"column_start":15,"column_end":34},"name":"_mm256_i64gather_ps","qualname":"::core_arch::x86::avx2::_mm256_i64gather_ps","value":"fn (slice: *const f32, offsets: __m256i, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214183,"byte_end":3214192,"line_start":1674,"line_end":1674,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214193,"byte_end":3214227,"line_start":1675,"line_end":1675,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214283,"byte_end":3214314,"line_start":1677,"line_end":1677,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3214315,"byte_end":3214364,"line_start":1678,"line_end":1678,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11554},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215279,"byte_end":3215303,"line_start":1703,"line_end":1703,"column_start":15,"column_end":39},"name":"_mm256_mask_i64gather_ps","qualname":"::core_arch::x86::avx2::_mm256_mask_i64gather_ps","value":"fn (src: __m128, slice: *const f32, offsets: __m256i, mask: __m128, scale: i32) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215083,"byte_end":3215092,"line_start":1698,"line_end":1698,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215093,"byte_end":3215127,"line_start":1699,"line_end":1699,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215183,"byte_end":3215214,"line_start":1701,"line_end":1701,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215215,"byte_end":3215264,"line_start":1702,"line_end":1702,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11558},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3216083,"byte_end":3216102,"line_start":1730,"line_end":1730,"column_start":15,"column_end":34},"name":"_mm_i64gather_epi64","qualname":"::core_arch::x86::avx2::_mm_i64gather_epi64","value":"fn (slice: *const i64, offsets: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215887,"byte_end":3215896,"line_start":1725,"line_end":1725,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215897,"byte_end":3215931,"line_start":1726,"line_end":1726,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3215987,"byte_end":3216018,"line_start":1728,"line_end":1728,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3216019,"byte_end":3216068,"line_start":1729,"line_end":1729,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11562},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3217035,"byte_end":3217059,"line_start":1755,"line_end":1755,"column_start":15,"column_end":39},"name":"_mm_mask_i64gather_epi64","qualname":"::core_arch::x86::avx2::_mm_mask_i64gather_epi64","value":"fn (src: __m128i, slice: *const i64, offsets: __m128i, mask: __m128i, scale: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3216839,"byte_end":3216848,"line_start":1750,"line_end":1750,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3216849,"byte_end":3216883,"line_start":1751,"line_end":1751,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3216939,"byte_end":3216970,"line_start":1753,"line_end":1753,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3216971,"byte_end":3217020,"line_start":1754,"line_end":1754,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11566},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3217931,"byte_end":3217953,"line_start":1785,"line_end":1785,"column_start":15,"column_end":37},"name":"_mm256_i64gather_epi64","qualname":"::core_arch::x86::avx2::_mm256_i64gather_epi64","value":"fn (slice: *const i64, offsets: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3217735,"byte_end":3217744,"line_start":1780,"line_end":1780,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3217745,"byte_end":3217779,"line_start":1781,"line_end":1781,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3217835,"byte_end":3217866,"line_start":1783,"line_end":1783,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3217867,"byte_end":3217916,"line_start":1784,"line_end":1784,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11570},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218896,"byte_end":3218923,"line_start":1810,"line_end":1810,"column_start":15,"column_end":42},"name":"_mm256_mask_i64gather_epi64","qualname":"::core_arch::x86::avx2::_mm256_mask_i64gather_epi64","value":"fn (src: __m256i, slice: *const i64, offsets: __m256i, mask: __m256i, scale: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218700,"byte_end":3218709,"line_start":1805,"line_end":1805,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218710,"byte_end":3218744,"line_start":1806,"line_end":1806,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218800,"byte_end":3218831,"line_start":1808,"line_end":1808,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3218832,"byte_end":3218881,"line_start":1809,"line_end":1809,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11574},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219790,"byte_end":3219806,"line_start":1840,"line_end":1840,"column_start":15,"column_end":31},"name":"_mm_i64gather_pd","qualname":"::core_arch::x86::avx2::_mm_i64gather_pd","value":"fn (slice: *const f64, offsets: __m128i, scale: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219594,"byte_end":3219603,"line_start":1835,"line_end":1835,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219604,"byte_end":3219638,"line_start":1836,"line_end":1836,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219694,"byte_end":3219725,"line_start":1838,"line_end":1838,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3219726,"byte_end":3219775,"line_start":1839,"line_end":1839,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11578},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220684,"byte_end":3220705,"line_start":1864,"line_end":1864,"column_start":15,"column_end":36},"name":"_mm_mask_i64gather_pd","qualname":"::core_arch::x86::avx2::_mm_mask_i64gather_pd","value":"fn (src: __m128d, slice: *const f64, offsets: __m128i, mask: __m128d, scale: i32) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220488,"byte_end":3220497,"line_start":1859,"line_end":1859,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220498,"byte_end":3220532,"line_start":1860,"line_end":1860,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220588,"byte_end":3220619,"line_start":1862,"line_end":1862,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3220620,"byte_end":3220669,"line_start":1863,"line_end":1863,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11582},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221487,"byte_end":3221506,"line_start":1891,"line_end":1891,"column_start":15,"column_end":34},"name":"_mm256_i64gather_pd","qualname":"::core_arch::x86::avx2::_mm256_i64gather_pd","value":"fn (slice: *const f64, offsets: __m256i, scale: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221291,"byte_end":3221300,"line_start":1886,"line_end":1886,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221301,"byte_end":3221335,"line_start":1887,"line_end":1887,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221391,"byte_end":3221422,"line_start":1889,"line_end":1889,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3221423,"byte_end":3221472,"line_start":1890,"line_end":1890,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11586},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222394,"byte_end":3222418,"line_start":1915,"line_end":1915,"column_start":15,"column_end":39},"name":"_mm256_mask_i64gather_pd","qualname":"::core_arch::x86::avx2::_mm256_mask_i64gather_pd","value":"fn (src: __m256d, slice: *const f64, offsets: __m256i, mask: __m256d, scale: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Returns values from `slice` at offsets determined by `offsets * scale`,\n where\n `scale` is between 1 and 8. If mask is set, load the value from `src` in\n that position instead.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222198,"byte_end":3222207,"line_start":1910,"line_end":1910,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222208,"byte_end":3222242,"line_start":1911,"line_end":1911,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(4)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222298,"byte_end":3222329,"line_start":1913,"line_end":1913,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3222330,"byte_end":3222379,"line_start":1914,"line_end":1914,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11590},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223244,"byte_end":3223267,"line_start":1944,"line_end":1944,"column_start":15,"column_end":38},"name":"_mm256_inserti128_si256","qualname":"::core_arch::x86::avx2::_mm256_inserti128_si256","value":"fn (a: __m256i, b: __m128i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to `dst`, then insert 128 bits (of integer data) from `b` at the\n location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223005,"byte_end":3223014,"line_start":1936,"line_end":1936,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223015,"byte_end":3223049,"line_start":1937,"line_end":1937,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223148,"byte_end":3223179,"line_start":1942,"line_end":1942,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223180,"byte_end":3223229,"line_start":1943,"line_end":1943,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11592},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224008,"byte_end":3224025,"line_start":1963,"line_end":1963,"column_start":15,"column_end":32},"name":"_mm256_madd_epi16","qualname":"::core_arch::x86::avx2::_mm256_madd_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed signed 16-bit integers in `a` and `b`, producing\n intermediate signed 32-bit integers. Horizontally add adjacent pairs\n of intermediate 32-bit integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223857,"byte_end":3223866,"line_start":1959,"line_end":1959,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223867,"byte_end":3223901,"line_start":1960,"line_end":1960,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3223944,"byte_end":3223993,"line_start":1962,"line_end":1962,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11594},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224640,"byte_end":3224660,"line_start":1977,"line_end":1977,"column_start":15,"column_end":35},"name":"_mm256_maddubs_epi16","qualname":"::core_arch::x86::avx2::_mm256_maddubs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Vertically multiplies each unsigned 8-bit integer from `a` with the\n corresponding signed 8-bit integer from `b`, producing intermediate\n signed 16-bit integers. Horizontally add adjacent pairs of intermediate\n signed 16-bit integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224487,"byte_end":3224496,"line_start":1973,"line_end":1973,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224497,"byte_end":3224531,"line_start":1974,"line_end":1974,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3224576,"byte_end":3224625,"line_start":1976,"line_end":1976,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11596},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225202,"byte_end":3225220,"line_start":1990,"line_end":1990,"column_start":15,"column_end":33},"name":"_mm_maskload_epi32","qualname":"::core_arch::x86::avx2::_mm_maskload_epi32","value":"fn (mem_addr: *const i32, mask: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask`\n (elements are zeroed out when the highest bit is not set in the\n corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225049,"byte_end":3225058,"line_start":1986,"line_end":1986,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225059,"byte_end":3225093,"line_start":1987,"line_end":1987,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225138,"byte_end":3225187,"line_start":1989,"line_end":1989,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11598},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225790,"byte_end":3225811,"line_start":2003,"line_end":2003,"column_start":15,"column_end":36},"name":"_mm256_maskload_epi32","qualname":"::core_arch::x86::avx2::_mm256_maskload_epi32","value":"fn (mem_addr: *const i32, mask: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads packed 32-bit integers from memory pointed by `mem_addr` using `mask`\n (elements are zeroed out when the highest bit is not set in the\n corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225637,"byte_end":3225646,"line_start":1999,"line_end":1999,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225647,"byte_end":3225681,"line_start":2000,"line_end":2000,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3225726,"byte_end":3225775,"line_start":2002,"line_end":2002,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11600},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226381,"byte_end":3226399,"line_start":2016,"line_end":2016,"column_start":15,"column_end":33},"name":"_mm_maskload_epi64","qualname":"::core_arch::x86::avx2::_mm_maskload_epi64","value":"fn (mem_addr: *const i64, mask: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask`\n (elements are zeroed out when the highest bit is not set in the\n corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226228,"byte_end":3226237,"line_start":2012,"line_end":2012,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226238,"byte_end":3226272,"line_start":2013,"line_end":2013,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226317,"byte_end":3226366,"line_start":2015,"line_end":2015,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11602},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226969,"byte_end":3226990,"line_start":2029,"line_end":2029,"column_start":15,"column_end":36},"name":"_mm256_maskload_epi64","qualname":"::core_arch::x86::avx2::_mm256_maskload_epi64","value":"fn (mem_addr: *const i64, mask: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Loads packed 64-bit integers from memory pointed by `mem_addr` using `mask`\n (elements are zeroed out when the highest bit is not set in the\n corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226816,"byte_end":3226825,"line_start":2025,"line_end":2025,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226826,"byte_end":3226860,"line_start":2026,"line_end":2026,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3226905,"byte_end":3226954,"line_start":2028,"line_end":2028,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11604},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227571,"byte_end":3227590,"line_start":2042,"line_end":2042,"column_start":15,"column_end":34},"name":"_mm_maskstore_epi32","qualname":"::core_arch::x86::avx2::_mm_maskstore_epi32","value":"fn (mem_addr: *mut i32, mask: __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed 32-bit integers from `a` into memory pointed by `mem_addr`\n using `mask` (elements are not stored when the highest bit is not set\n in the corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227418,"byte_end":3227427,"line_start":2038,"line_end":2038,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227428,"byte_end":3227462,"line_start":2039,"line_end":2039,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3227507,"byte_end":3227556,"line_start":2041,"line_end":2041,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11606},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228172,"byte_end":3228194,"line_start":2055,"line_end":2055,"column_start":15,"column_end":37},"name":"_mm256_maskstore_epi32","qualname":"::core_arch::x86::avx2::_mm256_maskstore_epi32","value":"fn (mem_addr: *mut i32, mask: __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed 32-bit integers from `a` into memory pointed by `mem_addr`\n using `mask` (elements are not stored when the highest bit is not set\n in the corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228019,"byte_end":3228028,"line_start":2051,"line_end":2051,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228029,"byte_end":3228063,"line_start":2052,"line_end":2052,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228108,"byte_end":3228157,"line_start":2054,"line_end":2054,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11608},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228776,"byte_end":3228795,"line_start":2068,"line_end":2068,"column_start":15,"column_end":34},"name":"_mm_maskstore_epi64","qualname":"::core_arch::x86::avx2::_mm_maskstore_epi64","value":"fn (mem_addr: *mut i64, mask: __m128i, a: __m128i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed 64-bit integers from `a` into memory pointed by `mem_addr`\n using `mask` (elements are not stored when the highest bit is not set\n in the corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228623,"byte_end":3228632,"line_start":2064,"line_end":2064,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228633,"byte_end":3228667,"line_start":2065,"line_end":2065,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3228712,"byte_end":3228761,"line_start":2067,"line_end":2067,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11610},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229377,"byte_end":3229399,"line_start":2081,"line_end":2081,"column_start":15,"column_end":37},"name":"_mm256_maskstore_epi64","qualname":"::core_arch::x86::avx2::_mm256_maskstore_epi64","value":"fn (mem_addr: *mut i64, mask: __m256i, a: __m256i) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores packed 64-bit integers from `a` into memory pointed by `mem_addr`\n using `mask` (elements are not stored when the highest bit is not set\n in the corresponding element).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229224,"byte_end":3229233,"line_start":2077,"line_end":2077,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229234,"byte_end":3229268,"line_start":2078,"line_end":2078,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229313,"byte_end":3229362,"line_start":2080,"line_end":2080,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11612},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229884,"byte_end":3229900,"line_start":2093,"line_end":2093,"column_start":15,"column_end":31},"name":"_mm256_max_epi16","qualname":"::core_arch::x86::avx2::_mm256_max_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b`, and returns the packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229734,"byte_end":3229743,"line_start":2089,"line_end":2089,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229744,"byte_end":3229778,"line_start":2090,"line_end":2090,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3229820,"byte_end":3229869,"line_start":2092,"line_end":2092,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11614},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230355,"byte_end":3230371,"line_start":2105,"line_end":2105,"column_start":15,"column_end":31},"name":"_mm256_max_epi32","qualname":"::core_arch::x86::avx2::_mm256_max_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b`, and returns the packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230205,"byte_end":3230214,"line_start":2101,"line_end":2101,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230215,"byte_end":3230249,"line_start":2102,"line_end":2102,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230291,"byte_end":3230340,"line_start":2104,"line_end":2104,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11616},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230822,"byte_end":3230837,"line_start":2117,"line_end":2117,"column_start":15,"column_end":30},"name":"_mm256_max_epi8","qualname":"::core_arch::x86::avx2::_mm256_max_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b`, and returns the packed\n maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230672,"byte_end":3230681,"line_start":2113,"line_end":2113,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230682,"byte_end":3230716,"line_start":2114,"line_end":2114,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3230758,"byte_end":3230807,"line_start":2116,"line_end":2116,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11618},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231299,"byte_end":3231315,"line_start":2129,"line_end":2129,"column_start":15,"column_end":31},"name":"_mm256_max_epu16","qualname":"::core_arch::x86::avx2::_mm256_max_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 16-bit integers in `a` and `b`, and returns\n the packed maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231149,"byte_end":3231158,"line_start":2125,"line_end":2125,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231159,"byte_end":3231193,"line_start":2126,"line_end":2126,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231235,"byte_end":3231284,"line_start":2128,"line_end":2128,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11620},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231779,"byte_end":3231795,"line_start":2141,"line_end":2141,"column_start":15,"column_end":31},"name":"_mm256_max_epu32","qualname":"::core_arch::x86::avx2::_mm256_max_epu32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 32-bit integers in `a` and `b`, and returns\n the packed maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231629,"byte_end":3231638,"line_start":2137,"line_end":2137,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231639,"byte_end":3231673,"line_start":2138,"line_end":2138,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3231715,"byte_end":3231764,"line_start":2140,"line_end":2140,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11622},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232255,"byte_end":3232270,"line_start":2153,"line_end":2153,"column_start":15,"column_end":30},"name":"_mm256_max_epu8","qualname":"::core_arch::x86::avx2::_mm256_max_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 8-bit integers in `a` and `b`, and returns\n the packed maximum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232105,"byte_end":3232114,"line_start":2149,"line_end":2149,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232115,"byte_end":3232149,"line_start":2150,"line_end":2150,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232191,"byte_end":3232240,"line_start":2152,"line_end":2152,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11624},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232723,"byte_end":3232739,"line_start":2165,"line_end":2165,"column_start":15,"column_end":31},"name":"_mm256_min_epi16","qualname":"::core_arch::x86::avx2::_mm256_min_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 16-bit integers in `a` and `b`, and returns the packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232573,"byte_end":3232582,"line_start":2161,"line_end":2161,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232583,"byte_end":3232617,"line_start":2162,"line_end":2162,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3232659,"byte_end":3232708,"line_start":2164,"line_end":2164,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11626},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233194,"byte_end":3233210,"line_start":2177,"line_end":2177,"column_start":15,"column_end":31},"name":"_mm256_min_epi32","qualname":"::core_arch::x86::avx2::_mm256_min_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 32-bit integers in `a` and `b`, and returns the packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233044,"byte_end":3233053,"line_start":2173,"line_end":2173,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233054,"byte_end":3233088,"line_start":2174,"line_end":2174,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233130,"byte_end":3233179,"line_start":2176,"line_end":2176,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11628},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233661,"byte_end":3233676,"line_start":2189,"line_end":2189,"column_start":15,"column_end":30},"name":"_mm256_min_epi8","qualname":"::core_arch::x86::avx2::_mm256_min_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed 8-bit integers in `a` and `b`, and returns the packed\n minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233511,"byte_end":3233520,"line_start":2185,"line_end":2185,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233521,"byte_end":3233555,"line_start":2186,"line_end":2186,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233597,"byte_end":3233646,"line_start":2188,"line_end":2188,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11630},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234138,"byte_end":3234154,"line_start":2201,"line_end":2201,"column_start":15,"column_end":31},"name":"_mm256_min_epu16","qualname":"::core_arch::x86::avx2::_mm256_min_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 16-bit integers in `a` and `b`, and returns\n the packed minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233988,"byte_end":3233997,"line_start":2197,"line_end":2197,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3233998,"byte_end":3234032,"line_start":2198,"line_end":2198,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234074,"byte_end":3234123,"line_start":2200,"line_end":2200,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11632},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234618,"byte_end":3234634,"line_start":2213,"line_end":2213,"column_start":15,"column_end":31},"name":"_mm256_min_epu32","qualname":"::core_arch::x86::avx2::_mm256_min_epu32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 32-bit integers in `a` and `b`, and returns\n the packed minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234468,"byte_end":3234477,"line_start":2209,"line_end":2209,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234478,"byte_end":3234512,"line_start":2210,"line_end":2210,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234554,"byte_end":3234603,"line_start":2212,"line_end":2212,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11634},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235094,"byte_end":3235109,"line_start":2225,"line_end":2225,"column_start":15,"column_end":30},"name":"_mm256_min_epu8","qualname":"::core_arch::x86::avx2::_mm256_min_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Compares packed unsigned 8-bit integers in `a` and `b`, and returns\n the packed minimum values.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234944,"byte_end":3234953,"line_start":2221,"line_end":2221,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3234954,"byte_end":3234988,"line_start":2222,"line_end":2222,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235030,"byte_end":3235079,"line_start":2224,"line_end":2224,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11636},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235573,"byte_end":3235593,"line_start":2237,"line_end":2237,"column_start":15,"column_end":35},"name":"_mm256_movemask_epi8","qualname":"::core_arch::x86::avx2::_mm256_movemask_epi8","value":"fn (a: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Creates mask from the most significant bit of each 8-bit element in `a`,\n return the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235421,"byte_end":3235430,"line_start":2233,"line_end":2233,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235431,"byte_end":3235465,"line_start":2234,"line_end":2234,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3235509,"byte_end":3235558,"line_start":2236,"line_end":2236,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11638},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236461,"byte_end":3236480,"line_start":2255,"line_end":2255,"column_start":15,"column_end":34},"name":"_mm256_mpsadbw_epu8","qualname":"::core_arch::x86::avx2::_mm256_mpsadbw_epu8","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the sum of absolute differences (SADs) of quadruplets of unsigned\n 8-bit integers in `a` compared to those in `b`, and stores the 16-bit\n results in dst. Eight SADs are performed for each 128-bit lane using one\n quadruplet from `b` and eight quadruplets from `a`. One quadruplet is\n selected from `b` starting at on the offset specified in `imm8`. Eight\n quadruplets are formed from sequential 8-bit integers selected from `a`\n starting at the offset specified in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236268,"byte_end":3236277,"line_start":2250,"line_end":2250,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236278,"byte_end":3236312,"line_start":2251,"line_end":2251,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236365,"byte_end":3236396,"line_start":2253,"line_end":2253,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236397,"byte_end":3236446,"line_start":2254,"line_end":2254,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11642},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237134,"byte_end":3237150,"line_start":2277,"line_end":2277,"column_start":15,"column_end":31},"name":"_mm256_mul_epi32","qualname":"::core_arch::x86::avx2::_mm256_mul_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the low 32-bit integers from each packed 64-bit element in\n `a` and `b`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236984,"byte_end":3236993,"line_start":2273,"line_end":2273,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3236994,"byte_end":3237028,"line_start":2274,"line_end":2274,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237070,"byte_end":3237119,"line_start":2276,"line_end":2276,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11644},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237653,"byte_end":3237669,"line_start":2291,"line_end":2291,"column_start":15,"column_end":31},"name":"_mm256_mul_epu32","qualname":"::core_arch::x86::avx2::_mm256_mul_epu32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the low unsigned 32-bit integers from each packed 64-bit\n element in `a` and `b`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237502,"byte_end":3237511,"line_start":2287,"line_end":2287,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237512,"byte_end":3237546,"line_start":2288,"line_end":2288,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3237589,"byte_end":3237638,"line_start":2290,"line_end":2290,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11646},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238196,"byte_end":3238214,"line_start":2304,"line_end":2304,"column_start":15,"column_end":33},"name":"_mm256_mulhi_epi16","qualname":"::core_arch::x86::avx2::_mm256_mulhi_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 16-bit integers in `a` and `b`, producing\n intermediate 32-bit integers and returning the high 16 bits of the\n intermediate integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238046,"byte_end":3238055,"line_start":2300,"line_end":2300,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238056,"byte_end":3238090,"line_start":2301,"line_end":2301,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238132,"byte_end":3238181,"line_start":2303,"line_end":2303,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11648},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238752,"byte_end":3238770,"line_start":2317,"line_end":2317,"column_start":15,"column_end":33},"name":"_mm256_mulhi_epu16","qualname":"::core_arch::x86::avx2::_mm256_mulhi_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed unsigned 16-bit integers in `a` and `b`, producing\n intermediate 32-bit integers and returning the high 16 bits of the\n intermediate integers.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238601,"byte_end":3238610,"line_start":2313,"line_end":2313,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238611,"byte_end":3238645,"line_start":2314,"line_end":2314,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3238688,"byte_end":3238737,"line_start":2316,"line_end":2316,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11650},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239296,"byte_end":3239314,"line_start":2330,"line_end":2330,"column_start":15,"column_end":33},"name":"_mm256_mullo_epi16","qualname":"::core_arch::x86::avx2::_mm256_mullo_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 16-bit integers in `a` and `b`, producing\n intermediate 32-bit integers, and returns the low 16 bits of the\n intermediate integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239146,"byte_end":3239155,"line_start":2326,"line_end":2326,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239156,"byte_end":3239190,"line_start":2327,"line_end":2327,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239232,"byte_end":3239281,"line_start":2329,"line_end":2329,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11652},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239841,"byte_end":3239859,"line_start":2343,"line_end":2343,"column_start":15,"column_end":33},"name":"_mm256_mullo_epi32","qualname":"::core_arch::x86::avx2::_mm256_mullo_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the packed 32-bit integers in `a` and `b`, producing\n intermediate 64-bit integers, and returns the low 16 bits of the\n intermediate integers","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239691,"byte_end":3239700,"line_start":2339,"line_end":2339,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239701,"byte_end":3239735,"line_start":2340,"line_end":2340,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3239777,"byte_end":3239826,"line_start":2342,"line_end":2342,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11654},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240450,"byte_end":3240469,"line_start":2357,"line_end":2357,"column_start":15,"column_end":34},"name":"_mm256_mulhrs_epi16","qualname":"::core_arch::x86::avx2::_mm256_mulhrs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed 16-bit integers in `a` and `b`, producing\n intermediate signed 32-bit integers. Truncate each intermediate\n integer to the 18 most significant bits, round by adding 1, and\n return bits `[16:1]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240298,"byte_end":3240307,"line_start":2353,"line_end":2353,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240308,"byte_end":3240342,"line_start":2354,"line_end":2354,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240386,"byte_end":3240435,"line_start":2356,"line_end":2356,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11656},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240915,"byte_end":3240930,"line_start":2369,"line_end":2369,"column_start":15,"column_end":30},"name":"_mm256_or_si256","qualname":"::core_arch::x86::avx2::_mm256_or_si256","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise OR of 256 bits (representing integer data) in `a`\n and `b`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240767,"byte_end":3240776,"line_start":2365,"line_end":2365,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240777,"byte_end":3240811,"line_start":2366,"line_end":2366,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3240851,"byte_end":3240900,"line_start":2368,"line_end":2368,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11658},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241399,"byte_end":3241417,"line_start":2381,"line_end":2381,"column_start":15,"column_end":33},"name":"_mm256_packs_epi16","qualname":"::core_arch::x86::avx2::_mm256_packs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using signed saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241247,"byte_end":3241256,"line_start":2377,"line_end":2377,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241257,"byte_end":3241291,"line_start":2378,"line_end":2378,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241335,"byte_end":3241384,"line_start":2380,"line_end":2380,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11660},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241890,"byte_end":3241908,"line_start":2393,"line_end":2393,"column_start":15,"column_end":33},"name":"_mm256_packs_epi32","qualname":"::core_arch::x86::avx2::_mm256_packs_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using signed saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241738,"byte_end":3241747,"line_start":2389,"line_end":2389,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241748,"byte_end":3241782,"line_start":2390,"line_end":2390,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3241826,"byte_end":3241875,"line_start":2392,"line_end":2392,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11662},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242381,"byte_end":3242400,"line_start":2405,"line_end":2405,"column_start":15,"column_end":34},"name":"_mm256_packus_epi16","qualname":"::core_arch::x86::avx2::_mm256_packus_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using unsigned saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242229,"byte_end":3242238,"line_start":2401,"line_end":2401,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242239,"byte_end":3242273,"line_start":2402,"line_end":2402,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242317,"byte_end":3242366,"line_start":2404,"line_end":2404,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11664},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242876,"byte_end":3242895,"line_start":2417,"line_end":2417,"column_start":15,"column_end":34},"name":"_mm256_packus_epi32","qualname":"::core_arch::x86::avx2::_mm256_packus_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using unsigned saturation","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242724,"byte_end":3242733,"line_start":2413,"line_end":2413,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242734,"byte_end":3242768,"line_start":2414,"line_end":2414,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3242812,"byte_end":3242861,"line_start":2416,"line_end":2416,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11666},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243445,"byte_end":3243472,"line_start":2431,"line_end":2431,"column_start":15,"column_end":42},"name":"_mm256_permutevar8x32_epi32","qualname":"::core_arch::x86::avx2::_mm256_permutevar8x32_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Permutes packed 32-bit integers from `a` according to the content of `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243295,"byte_end":3243304,"line_start":2427,"line_end":2427,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243305,"byte_end":3243339,"line_start":2428,"line_end":2428,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243381,"byte_end":3243430,"line_start":2430,"line_end":2430,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11668},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243944,"byte_end":3243968,"line_start":2443,"line_end":2443,"column_start":15,"column_end":39},"name":"_mm256_permute4x64_epi64","qualname":"::core_arch::x86::avx2::_mm256_permute4x64_epi64","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Permutes 64-bit integers from `a` using control mask `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243752,"byte_end":3243761,"line_start":2438,"line_end":2438,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243762,"byte_end":3243796,"line_start":2439,"line_end":2439,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243848,"byte_end":3243879,"line_start":2441,"line_end":2441,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3243880,"byte_end":3243929,"line_start":2442,"line_end":2442,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11678},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245778,"byte_end":3245803,"line_start":2499,"line_end":2499,"column_start":15,"column_end":40},"name":"_mm256_permute2x128_si256","qualname":"::core_arch::x86::avx2::_mm256_permute2x128_si256","value":"fn (a: __m256i, b: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 128-bits of integer data selected by `imm8` from `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245583,"byte_end":3245592,"line_start":2494,"line_end":2494,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245593,"byte_end":3245627,"line_start":2495,"line_end":2495,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245682,"byte_end":3245713,"line_start":2497,"line_end":2497,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3245714,"byte_end":3245763,"line_start":2498,"line_end":2498,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11682},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246463,"byte_end":3246484,"line_start":2519,"line_end":2519,"column_start":15,"column_end":36},"name":"_mm256_permute4x64_pd","qualname":"::core_arch::x86::avx2::_mm256_permute4x64_pd","value":"fn (a: __m256d, imm8: i32) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 64-bit floating-point elements in `a` across lanes using the\n control in `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246271,"byte_end":3246280,"line_start":2514,"line_end":2514,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246281,"byte_end":3246315,"line_start":2515,"line_end":2515,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246367,"byte_end":3246398,"line_start":2517,"line_end":2517,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3246399,"byte_end":3246448,"line_start":2518,"line_end":2518,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11692},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248372,"byte_end":3248396,"line_start":2573,"line_end":2573,"column_start":15,"column_end":39},"name":"_mm256_permutevar8x32_ps","qualname":"::core_arch::x86::avx2::_mm256_permutevar8x32_ps","value":"fn (a: __m256, idx: __m256i) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Shuffles eight 32-bit foating-point elements in `a` across lanes using\n the corresponding 32-bit integer index in `idx`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248222,"byte_end":3248231,"line_start":2569,"line_end":2569,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248232,"byte_end":3248266,"line_start":2570,"line_end":2570,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248308,"byte_end":3248357,"line_start":2572,"line_end":2572,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11694},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3249014,"byte_end":3249029,"line_start":2587,"line_end":2587,"column_start":15,"column_end":30},"name":"_mm256_sad_epu8","qualname":"::core_arch::x86::avx2::_mm256_sad_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute differences of packed unsigned 8-bit integers in `a`\n and `b`, then horizontally sum each consecutive 8 differences to\n produce four unsigned 16-bit integers, and pack these unsigned 16-bit\n integers in the low 16 bits of the 64-bit return value","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248864,"byte_end":3248873,"line_start":2583,"line_end":2583,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248874,"byte_end":3248908,"line_start":2584,"line_end":2584,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3248950,"byte_end":3248999,"line_start":2586,"line_end":2586,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11696},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250336,"byte_end":3250355,"line_start":2626,"line_end":2626,"column_start":15,"column_end":34},"name":"_mm256_shuffle_epi8","qualname":"::core_arch::x86::avx2::_mm256_shuffle_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles bytes from `a` according to the content of `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250186,"byte_end":3250195,"line_start":2622,"line_end":2622,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250196,"byte_end":3250230,"line_start":2623,"line_end":2623,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3250272,"byte_end":3250321,"line_start":2625,"line_end":2625,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11698},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251671,"byte_end":3251691,"line_start":2665,"line_end":2665,"column_start":15,"column_end":35},"name":"_mm256_shuffle_epi32","qualname":"::core_arch::x86::avx2::_mm256_shuffle_epi32","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 32-bit integers in 128-bit lanes of `a` using the control in\n `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251477,"byte_end":3251486,"line_start":2660,"line_end":2660,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251487,"byte_end":3251521,"line_start":2661,"line_end":2661,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251575,"byte_end":3251606,"line_start":2663,"line_end":2663,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3251607,"byte_end":3251656,"line_start":2664,"line_end":2664,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11708},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254394,"byte_end":3254416,"line_start":2743,"line_end":2743,"column_start":15,"column_end":37},"name":"_mm256_shufflehi_epi16","qualname":"::core_arch::x86::avx2::_mm256_shufflehi_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 16-bit integers in the high 64 bits of 128-bit lanes of `a` using\n the control in `imm8`. The low 64 bits of 128-bit lanes of `a` are copied\n to the output.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254201,"byte_end":3254210,"line_start":2738,"line_end":2738,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254211,"byte_end":3254245,"line_start":2739,"line_end":2739,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254298,"byte_end":3254329,"line_start":2741,"line_end":2741,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3254330,"byte_end":3254379,"line_start":2742,"line_end":2742,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11718},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256606,"byte_end":3256628,"line_start":2804,"line_end":2804,"column_start":15,"column_end":37},"name":"_mm256_shufflelo_epi16","qualname":"::core_arch::x86::avx2::_mm256_shufflelo_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shuffles 16-bit integers in the low 64 bits of 128-bit lanes of `a` using\n the control in `imm8`. The high 64 bits of 128-bit lanes of `a` are copied\n to the output.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256413,"byte_end":3256422,"line_start":2799,"line_end":2799,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256423,"byte_end":3256457,"line_start":2800,"line_end":2800,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256510,"byte_end":3256541,"line_start":2802,"line_end":2802,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3256542,"byte_end":3256591,"line_start":2803,"line_end":2803,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11728},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258807,"byte_end":3258824,"line_start":2864,"line_end":2864,"column_start":15,"column_end":32},"name":"_mm256_sign_epi16","qualname":"::core_arch::x86::avx2::_mm256_sign_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 16-bit integers in `a` when the corresponding signed\n 16-bit integer in `b` is negative, and returns the results.\n Results are zeroed out when the corresponding element in `b` is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258657,"byte_end":3258666,"line_start":2860,"line_end":2860,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258667,"byte_end":3258701,"line_start":2861,"line_end":2861,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3258743,"byte_end":3258792,"line_start":2863,"line_end":2863,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11730},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259395,"byte_end":3259412,"line_start":2877,"line_end":2877,"column_start":15,"column_end":32},"name":"_mm256_sign_epi32","qualname":"::core_arch::x86::avx2::_mm256_sign_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 32-bit integers in `a` when the corresponding signed\n 32-bit integer in `b` is negative, and returns the results.\n Results are zeroed out when the corresponding element in `b` is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259245,"byte_end":3259254,"line_start":2873,"line_end":2873,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259255,"byte_end":3259289,"line_start":2874,"line_end":2874,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259331,"byte_end":3259380,"line_start":2876,"line_end":2876,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11732},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259978,"byte_end":3259994,"line_start":2890,"line_end":2890,"column_start":15,"column_end":31},"name":"_mm256_sign_epi8","qualname":"::core_arch::x86::avx2::_mm256_sign_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Negates packed 8-bit integers in `a` when the corresponding signed\n 8-bit integer in `b` is negative, and returns the results.\n Results are zeroed out when the corresponding element in `b` is zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259828,"byte_end":3259837,"line_start":2886,"line_end":2886,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259838,"byte_end":3259872,"line_start":2887,"line_end":2887,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3259914,"byte_end":3259963,"line_start":2889,"line_end":2889,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11734},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260460,"byte_end":3260476,"line_start":2902,"line_end":2902,"column_start":15,"column_end":31},"name":"_mm256_sll_epi16","qualname":"::core_arch::x86::avx2::_mm256_sll_epi16","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` left by `count` while\n shifting in zeros, and returns the result","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260311,"byte_end":3260320,"line_start":2898,"line_end":2898,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260321,"byte_end":3260355,"line_start":2899,"line_end":2899,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260396,"byte_end":3260445,"line_start":2901,"line_end":2901,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11736},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260950,"byte_end":3260966,"line_start":2914,"line_end":2914,"column_start":15,"column_end":31},"name":"_mm256_sll_epi32","qualname":"::core_arch::x86::avx2::_mm256_sll_epi32","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by `count` while\n shifting in zeros, and returns the result","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260801,"byte_end":3260810,"line_start":2910,"line_end":2910,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260811,"byte_end":3260845,"line_start":2911,"line_end":2911,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3260886,"byte_end":3260935,"line_start":2913,"line_end":2913,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11738},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261439,"byte_end":3261455,"line_start":2926,"line_end":2926,"column_start":15,"column_end":31},"name":"_mm256_sll_epi64","qualname":"::core_arch::x86::avx2::_mm256_sll_epi64","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by `count` while\n shifting in zeros, and returns the result","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261290,"byte_end":3261299,"line_start":2922,"line_end":2922,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261300,"byte_end":3261334,"line_start":2923,"line_end":2923,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261375,"byte_end":3261424,"line_start":2925,"line_end":2925,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11740},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261925,"byte_end":3261942,"line_start":2938,"line_end":2938,"column_start":15,"column_end":32},"name":"_mm256_slli_epi16","qualname":"::core_arch::x86::avx2::_mm256_slli_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` left by `imm8` while\n shifting in zeros, return the results;","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261776,"byte_end":3261785,"line_start":2934,"line_end":2934,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261786,"byte_end":3261820,"line_start":2935,"line_end":2935,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3261861,"byte_end":3261910,"line_start":2937,"line_end":2937,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11742},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262397,"byte_end":3262414,"line_start":2950,"line_end":2950,"column_start":15,"column_end":32},"name":"_mm256_slli_epi32","qualname":"::core_arch::x86::avx2::_mm256_slli_epi32","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by `imm8` while\n shifting in zeros, return the results;","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262248,"byte_end":3262257,"line_start":2946,"line_end":2946,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262258,"byte_end":3262292,"line_start":2947,"line_end":2947,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262333,"byte_end":3262382,"line_start":2949,"line_end":2949,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11744},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262868,"byte_end":3262885,"line_start":2962,"line_end":2962,"column_start":15,"column_end":32},"name":"_mm256_slli_epi64","qualname":"::core_arch::x86::avx2::_mm256_slli_epi64","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by `imm8` while\n shifting in zeros, return the results;","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262719,"byte_end":3262728,"line_start":2958,"line_end":2958,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262729,"byte_end":3262763,"line_start":2959,"line_end":2959,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3262804,"byte_end":3262853,"line_start":2961,"line_end":2961,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11746},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263355,"byte_end":3263372,"line_start":2974,"line_end":2974,"column_start":15,"column_end":32},"name":"_mm256_slli_si256","qualname":"::core_arch::x86::avx2::_mm256_slli_si256","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263163,"byte_end":3263172,"line_start":2969,"line_end":2969,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263173,"byte_end":3263207,"line_start":2970,"line_end":2970,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263259,"byte_end":3263290,"line_start":2972,"line_end":2972,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263291,"byte_end":3263340,"line_start":2973,"line_end":2973,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11750},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263971,"byte_end":3263990,"line_start":2992,"line_end":2992,"column_start":15,"column_end":34},"name":"_mm256_bslli_epi128","qualname":"::core_arch::x86::avx2::_mm256_bslli_epi128","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts 128-bit lanes in `a` left by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263779,"byte_end":3263788,"line_start":2987,"line_end":2987,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263789,"byte_end":3263823,"line_start":2988,"line_end":2988,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263875,"byte_end":3263906,"line_start":2990,"line_end":2990,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3263907,"byte_end":3263956,"line_start":2991,"line_end":2991,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11754},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264631,"byte_end":3264645,"line_start":3011,"line_end":3011,"column_start":15,"column_end":29},"name":"_mm_sllv_epi32","qualname":"::core_arch::x86::avx2::_mm_sllv_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by the amount\n specified by the corresponding element in `count` while\n shifting in zeros, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264481,"byte_end":3264490,"line_start":3007,"line_end":3007,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264491,"byte_end":3264525,"line_start":3008,"line_end":3008,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3264567,"byte_end":3264616,"line_start":3010,"line_end":3010,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11756},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265179,"byte_end":3265196,"line_start":3024,"line_end":3024,"column_start":15,"column_end":32},"name":"_mm256_sllv_epi32","qualname":"::core_arch::x86::avx2::_mm256_sllv_epi32","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` left by the amount\n specified by the corresponding element in `count` while\n shifting in zeros, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265029,"byte_end":3265038,"line_start":3020,"line_end":3020,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265039,"byte_end":3265073,"line_start":3021,"line_end":3021,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265115,"byte_end":3265164,"line_start":3023,"line_end":3023,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11758},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265730,"byte_end":3265744,"line_start":3037,"line_end":3037,"column_start":15,"column_end":29},"name":"_mm_sllv_epi64","qualname":"::core_arch::x86::avx2::_mm_sllv_epi64","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by the amount\n specified by the corresponding element in `count` while\n shifting in zeros, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265580,"byte_end":3265589,"line_start":3033,"line_end":3033,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265590,"byte_end":3265624,"line_start":3034,"line_end":3034,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3265666,"byte_end":3265715,"line_start":3036,"line_end":3036,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11760},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266278,"byte_end":3266295,"line_start":3050,"line_end":3050,"column_start":15,"column_end":32},"name":"_mm256_sllv_epi64","qualname":"::core_arch::x86::avx2::_mm256_sllv_epi64","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` left by the amount\n specified by the corresponding element in `count` while\n shifting in zeros, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266128,"byte_end":3266137,"line_start":3046,"line_end":3046,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266138,"byte_end":3266172,"line_start":3047,"line_end":3047,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266214,"byte_end":3266263,"line_start":3049,"line_end":3049,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11762},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266754,"byte_end":3266770,"line_start":3062,"line_end":3062,"column_start":15,"column_end":31},"name":"_mm256_sra_epi16","qualname":"::core_arch::x86::avx2::_mm256_sra_epi16","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `count` while\n shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266605,"byte_end":3266614,"line_start":3058,"line_end":3058,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266615,"byte_end":3266649,"line_start":3059,"line_end":3059,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3266690,"byte_end":3266739,"line_start":3061,"line_end":3061,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11764},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267226,"byte_end":3267242,"line_start":3074,"line_end":3074,"column_start":15,"column_end":31},"name":"_mm256_sra_epi32","qualname":"::core_arch::x86::avx2::_mm256_sra_epi32","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `count` while\n shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267077,"byte_end":3267086,"line_start":3070,"line_end":3070,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267087,"byte_end":3267121,"line_start":3071,"line_end":3071,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267162,"byte_end":3267211,"line_start":3073,"line_end":3073,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11766},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267697,"byte_end":3267714,"line_start":3086,"line_end":3086,"column_start":15,"column_end":32},"name":"_mm256_srai_epi16","qualname":"::core_arch::x86::avx2::_mm256_srai_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `imm8` while\n shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267548,"byte_end":3267557,"line_start":3082,"line_end":3082,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267558,"byte_end":3267592,"line_start":3083,"line_end":3083,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3267633,"byte_end":3267682,"line_start":3085,"line_end":3085,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11768},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268154,"byte_end":3268171,"line_start":3098,"line_end":3098,"column_start":15,"column_end":32},"name":"_mm256_srai_epi32","qualname":"::core_arch::x86::avx2::_mm256_srai_epi32","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `imm8` while\n shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268005,"byte_end":3268014,"line_start":3094,"line_end":3094,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268015,"byte_end":3268049,"line_start":3095,"line_end":3095,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268090,"byte_end":3268139,"line_start":3097,"line_end":3097,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11770},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268662,"byte_end":3268676,"line_start":3110,"line_end":3110,"column_start":15,"column_end":29},"name":"_mm_srav_epi32","qualname":"::core_arch::x86::avx2::_mm_srav_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by the amount specified by the\n corresponding element in `count` while shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268512,"byte_end":3268521,"line_start":3106,"line_end":3106,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268522,"byte_end":3268556,"line_start":3107,"line_end":3107,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3268598,"byte_end":3268647,"line_start":3109,"line_end":3109,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11772},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269187,"byte_end":3269204,"line_start":3122,"line_end":3122,"column_start":15,"column_end":32},"name":"_mm256_srav_epi32","qualname":"::core_arch::x86::avx2::_mm256_srav_epi32","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by the amount specified by the\n corresponding element in `count` while shifting in sign bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269037,"byte_end":3269046,"line_start":3118,"line_end":3118,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269047,"byte_end":3269081,"line_start":3119,"line_end":3119,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269123,"byte_end":3269172,"line_start":3121,"line_end":3121,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11774},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269695,"byte_end":3269712,"line_start":3134,"line_end":3134,"column_start":15,"column_end":32},"name":"_mm256_srli_si256","qualname":"::core_arch::x86::avx2::_mm256_srli_si256","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269503,"byte_end":3269512,"line_start":3129,"line_end":3129,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269513,"byte_end":3269547,"line_start":3130,"line_end":3130,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269599,"byte_end":3269630,"line_start":3132,"line_end":3132,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3269631,"byte_end":3269680,"line_start":3133,"line_end":3133,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11778},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270312,"byte_end":3270331,"line_start":3152,"line_end":3152,"column_start":15,"column_end":34},"name":"_mm256_bsrli_epi128","qualname":"::core_arch::x86::avx2::_mm256_bsrli_epi128","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts 128-bit lanes in `a` right by `imm8` bytes while shifting in zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270120,"byte_end":3270129,"line_start":3147,"line_end":3147,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270130,"byte_end":3270164,"line_start":3148,"line_end":3148,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270216,"byte_end":3270247,"line_start":3150,"line_end":3150,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270248,"byte_end":3270297,"line_start":3151,"line_end":3151,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11782},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270893,"byte_end":3270909,"line_start":3170,"line_end":3170,"column_start":15,"column_end":31},"name":"_mm256_srl_epi16","qualname":"::core_arch::x86::avx2::_mm256_srl_epi16","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270744,"byte_end":3270753,"line_start":3166,"line_end":3166,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270754,"byte_end":3270788,"line_start":3167,"line_end":3167,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3270829,"byte_end":3270878,"line_start":3169,"line_end":3169,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11784},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271361,"byte_end":3271377,"line_start":3182,"line_end":3182,"column_start":15,"column_end":31},"name":"_mm256_srl_epi32","qualname":"::core_arch::x86::avx2::_mm256_srl_epi32","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271212,"byte_end":3271221,"line_start":3178,"line_end":3178,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271222,"byte_end":3271256,"line_start":3179,"line_end":3179,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271297,"byte_end":3271346,"line_start":3181,"line_end":3181,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11786},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271828,"byte_end":3271844,"line_start":3194,"line_end":3194,"column_start":15,"column_end":31},"name":"_mm256_srl_epi64","qualname":"::core_arch::x86::avx2::_mm256_srl_epi64","value":"fn (a: __m256i, count: __m128i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by `count` while shifting in\n zeros.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271679,"byte_end":3271688,"line_start":3190,"line_end":3190,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271689,"byte_end":3271723,"line_start":3191,"line_end":3191,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3271764,"byte_end":3271813,"line_start":3193,"line_end":3193,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11788},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272294,"byte_end":3272311,"line_start":3206,"line_end":3206,"column_start":15,"column_end":32},"name":"_mm256_srli_epi16","qualname":"::core_arch::x86::avx2::_mm256_srli_epi16","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 16-bit integers in `a` right by `imm8` while shifting in\n zeros","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272145,"byte_end":3272154,"line_start":3202,"line_end":3202,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272155,"byte_end":3272189,"line_start":3203,"line_end":3203,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272230,"byte_end":3272279,"line_start":3205,"line_end":3205,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11790},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272746,"byte_end":3272763,"line_start":3218,"line_end":3218,"column_start":15,"column_end":32},"name":"_mm256_srli_epi32","qualname":"::core_arch::x86::avx2::_mm256_srli_epi32","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by `imm8` while shifting in\n zeros","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272597,"byte_end":3272606,"line_start":3214,"line_end":3214,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272607,"byte_end":3272641,"line_start":3215,"line_end":3215,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3272682,"byte_end":3272731,"line_start":3217,"line_end":3217,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11792},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273197,"byte_end":3273214,"line_start":3230,"line_end":3230,"column_start":15,"column_end":32},"name":"_mm256_srli_epi64","qualname":"::core_arch::x86::avx2::_mm256_srli_epi64","value":"fn (a: __m256i, imm8: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by `imm8` while shifting in\n zeros","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273048,"byte_end":3273057,"line_start":3226,"line_end":3226,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273058,"byte_end":3273092,"line_start":3227,"line_end":3227,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273133,"byte_end":3273182,"line_start":3229,"line_end":3229,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11794},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273701,"byte_end":3273715,"line_start":3242,"line_end":3242,"column_start":15,"column_end":29},"name":"_mm_srlv_epi32","qualname":"::core_arch::x86::avx2::_mm_srlv_epi32","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by the amount specified by\n the corresponding element in `count` while shifting in zeros,","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273551,"byte_end":3273560,"line_start":3238,"line_end":3238,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273561,"byte_end":3273595,"line_start":3239,"line_end":3239,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3273637,"byte_end":3273686,"line_start":3241,"line_end":3241,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11796},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274222,"byte_end":3274239,"line_start":3254,"line_end":3254,"column_start":15,"column_end":32},"name":"_mm256_srlv_epi32","qualname":"::core_arch::x86::avx2::_mm256_srlv_epi32","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 32-bit integers in `a` right by the amount specified by\n the corresponding element in `count` while shifting in zeros,","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274072,"byte_end":3274081,"line_start":3250,"line_end":3250,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274082,"byte_end":3274116,"line_start":3251,"line_end":3251,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274158,"byte_end":3274207,"line_start":3253,"line_end":3253,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11798},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274746,"byte_end":3274760,"line_start":3266,"line_end":3266,"column_start":15,"column_end":29},"name":"_mm_srlv_epi64","qualname":"::core_arch::x86::avx2::_mm_srlv_epi64","value":"fn (a: __m128i, count: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by the amount specified by\n the corresponding element in `count` while shifting in zeros,","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274596,"byte_end":3274605,"line_start":3262,"line_end":3262,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274606,"byte_end":3274640,"line_start":3263,"line_end":3263,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3274682,"byte_end":3274731,"line_start":3265,"line_end":3265,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11800},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275267,"byte_end":3275284,"line_start":3278,"line_end":3278,"column_start":15,"column_end":32},"name":"_mm256_srlv_epi64","qualname":"::core_arch::x86::avx2::_mm256_srlv_epi64","value":"fn (a: __m256i, count: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Shifts packed 64-bit integers in `a` right by the amount specified by\n the corresponding element in `count` while shifting in zeros,","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275117,"byte_end":3275126,"line_start":3274,"line_end":3274,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275127,"byte_end":3275161,"line_start":3275,"line_end":3275,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275203,"byte_end":3275252,"line_start":3277,"line_end":3277,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11802},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275790,"byte_end":3275806,"line_start":3291,"line_end":3291,"column_start":15,"column_end":31},"name":"_mm256_sub_epi16","qualname":"::core_arch::x86::avx2::_mm256_sub_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275641,"byte_end":3275650,"line_start":3287,"line_end":3287,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275651,"byte_end":3275685,"line_start":3288,"line_end":3288,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3275726,"byte_end":3275775,"line_start":3290,"line_end":3290,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11804},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276245,"byte_end":3276261,"line_start":3302,"line_end":3302,"column_start":15,"column_end":31},"name":"_mm256_sub_epi32","qualname":"::core_arch::x86::avx2::_mm256_sub_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 32-bit integers in `b` from packed 16-bit integers in `a`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276096,"byte_end":3276105,"line_start":3298,"line_end":3298,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276106,"byte_end":3276140,"line_start":3299,"line_end":3299,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276181,"byte_end":3276230,"line_start":3301,"line_end":3301,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11806},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276698,"byte_end":3276714,"line_start":3313,"line_end":3313,"column_start":15,"column_end":31},"name":"_mm256_sub_epi64","qualname":"::core_arch::x86::avx2::_mm256_sub_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 64-bit integers in `b` from packed 16-bit integers in `a`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276549,"byte_end":3276558,"line_start":3309,"line_end":3309,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276559,"byte_end":3276593,"line_start":3310,"line_end":3310,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3276634,"byte_end":3276683,"line_start":3312,"line_end":3312,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11808},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277149,"byte_end":3277164,"line_start":3324,"line_end":3324,"column_start":15,"column_end":30},"name":"_mm256_sub_epi8","qualname":"::core_arch::x86::avx2::_mm256_sub_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 16-bit integers in `a`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277000,"byte_end":3277009,"line_start":3320,"line_end":3320,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277010,"byte_end":3277044,"line_start":3321,"line_end":3321,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277085,"byte_end":3277134,"line_start":3323,"line_end":3323,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11810},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277625,"byte_end":3277642,"line_start":3336,"line_end":3336,"column_start":15,"column_end":32},"name":"_mm256_subs_epi16","qualname":"::core_arch::x86::avx2::_mm256_subs_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in\n `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277475,"byte_end":3277484,"line_start":3332,"line_end":3332,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277485,"byte_end":3277519,"line_start":3333,"line_end":3333,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277561,"byte_end":3277610,"line_start":3335,"line_end":3335,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11812},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278100,"byte_end":3278116,"line_start":3348,"line_end":3348,"column_start":15,"column_end":31},"name":"_mm256_subs_epi8","qualname":"::core_arch::x86::avx2::_mm256_subs_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in\n `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277950,"byte_end":3277959,"line_start":3344,"line_end":3344,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3277960,"byte_end":3277994,"line_start":3345,"line_end":3345,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278036,"byte_end":3278085,"line_start":3347,"line_end":3347,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11814},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278585,"byte_end":3278602,"line_start":3360,"line_end":3360,"column_start":15,"column_end":32},"name":"_mm256_subs_epu16","qualname":"::core_arch::x86::avx2::_mm256_subs_epu16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 16-bit integers in `b` from packed 16-bit\n integers in `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278434,"byte_end":3278443,"line_start":3356,"line_end":3356,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278444,"byte_end":3278478,"line_start":3357,"line_end":3357,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278521,"byte_end":3278570,"line_start":3359,"line_end":3359,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11816},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279071,"byte_end":3279087,"line_start":3372,"line_end":3372,"column_start":15,"column_end":31},"name":"_mm256_subs_epu8","qualname":"::core_arch::x86::avx2::_mm256_subs_epu8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 8-bit integers in `b` from packed 8-bit\n integers in `a` using saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278920,"byte_end":3278929,"line_start":3368,"line_end":3368,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3278930,"byte_end":3278964,"line_start":3369,"line_end":3369,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3279007,"byte_end":3279056,"line_start":3371,"line_end":3371,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11818},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280643,"byte_end":3280663,"line_start":3419,"line_end":3419,"column_start":15,"column_end":35},"name":"_mm256_unpackhi_epi8","qualname":"::core_arch::x86::avx2::_mm256_unpackhi_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 8-bit integers from the high half of each\n 128-bit lane in `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280490,"byte_end":3280499,"line_start":3415,"line_end":3415,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280500,"byte_end":3280534,"line_start":3416,"line_end":3416,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3280579,"byte_end":3280628,"line_start":3418,"line_end":3418,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11820},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282430,"byte_end":3282450,"line_start":3472,"line_end":3472,"column_start":15,"column_end":35},"name":"_mm256_unpacklo_epi8","qualname":"::core_arch::x86::avx2::_mm256_unpacklo_epi8","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 8-bit integers from the low half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282277,"byte_end":3282286,"line_start":3468,"line_end":3468,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282287,"byte_end":3282321,"line_start":3469,"line_end":3469,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3282366,"byte_end":3282415,"line_start":3471,"line_end":3471,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11822},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283963,"byte_end":3283984,"line_start":3521,"line_end":3521,"column_start":15,"column_end":36},"name":"_mm256_unpackhi_epi16","qualname":"::core_arch::x86::avx2::_mm256_unpackhi_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 16-bit integers from the high half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283810,"byte_end":3283819,"line_start":3517,"line_end":3517,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283820,"byte_end":3283854,"line_start":3518,"line_end":3518,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3283899,"byte_end":3283948,"line_start":3520,"line_end":3520,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11824},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285409,"byte_end":3285430,"line_start":3569,"line_end":3569,"column_start":15,"column_end":36},"name":"_mm256_unpacklo_epi16","qualname":"::core_arch::x86::avx2::_mm256_unpacklo_epi16","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 16-bit integers from the low half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285256,"byte_end":3285265,"line_start":3565,"line_end":3565,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285266,"byte_end":3285300,"line_start":3566,"line_end":3566,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3285345,"byte_end":3285394,"line_start":3568,"line_end":3568,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11826},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286705,"byte_end":3286726,"line_start":3610,"line_end":3610,"column_start":15,"column_end":36},"name":"_mm256_unpackhi_epi32","qualname":"::core_arch::x86::avx2::_mm256_unpackhi_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 32-bit integers from the high half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286553,"byte_end":3286562,"line_start":3606,"line_end":3606,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286563,"byte_end":3286597,"line_start":3607,"line_end":3607,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3286641,"byte_end":3286690,"line_start":3609,"line_end":3609,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11828},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287934,"byte_end":3287955,"line_start":3647,"line_end":3647,"column_start":15,"column_end":36},"name":"_mm256_unpacklo_epi32","qualname":"::core_arch::x86::avx2::_mm256_unpacklo_epi32","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 32-bit integers from the low half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287782,"byte_end":3287791,"line_start":3643,"line_end":3643,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287792,"byte_end":3287826,"line_start":3644,"line_end":3644,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3287870,"byte_end":3287919,"line_start":3646,"line_end":3646,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11830},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3289124,"byte_end":3289145,"line_start":3684,"line_end":3684,"column_start":15,"column_end":36},"name":"_mm256_unpackhi_epi64","qualname":"::core_arch::x86::avx2::_mm256_unpackhi_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 64-bit integers from the high half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288972,"byte_end":3288981,"line_start":3680,"line_end":3680,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3288982,"byte_end":3289016,"line_start":3681,"line_end":3681,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3289060,"byte_end":3289109,"line_start":3683,"line_end":3683,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11832},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290298,"byte_end":3290319,"line_start":3721,"line_end":3721,"column_start":15,"column_end":36},"name":"_mm256_unpacklo_epi64","qualname":"::core_arch::x86::avx2::_mm256_unpacklo_epi64","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Unpacks and interleave 64-bit integers from the low half of each\n 128-bit lane of `a` and `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290146,"byte_end":3290155,"line_start":3717,"line_end":3717,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290156,"byte_end":3290190,"line_start":3718,"line_end":3718,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290234,"byte_end":3290283,"line_start":3720,"line_end":3720,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11834},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290807,"byte_end":3290823,"line_start":3734,"line_end":3734,"column_start":15,"column_end":31},"name":"_mm256_xor_si256","qualname":"::core_arch::x86::avx2::_mm256_xor_si256","value":"fn (a: __m256i, b: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Computes the bitwise XOR of 256 bits (representing integer data)\n in `a` and `b`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290658,"byte_end":3290667,"line_start":3730,"line_end":3730,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290668,"byte_end":3290702,"line_start":3731,"line_end":3731,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3290743,"byte_end":3290792,"line_start":3733,"line_end":3733,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11836},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291430,"byte_end":3291449,"line_start":3749,"line_end":3749,"column_start":15,"column_end":34},"name":"_mm256_extract_epi8","qualname":"::core_arch::x86::avx2::_mm256_extract_epi8","value":"fn (a: __m256i, imm8: i32) -> i8","parent":null,"children":[],"decl_id":null,"docs":" Extracts an 8-bit integer from `a`, selected with `imm8`. Returns a 32-bit\n integer containing the zero-extended integer data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291237,"byte_end":3291246,"line_start":3744,"line_end":3744,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291247,"byte_end":3291281,"line_start":3745,"line_end":3745,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291334,"byte_end":3291365,"line_start":3747,"line_end":3747,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291366,"byte_end":3291415,"line_start":3748,"line_end":3748,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11838},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292071,"byte_end":3292091,"line_start":3765,"line_end":3765,"column_start":15,"column_end":35},"name":"_mm256_extract_epi16","qualname":"::core_arch::x86::avx2::_mm256_extract_epi16","value":"fn (a: __m256i, imm8: i32) -> i16","parent":null,"children":[],"decl_id":null,"docs":" Extracts a 16-bit integer from `a`, selected with `imm8`. Returns a 32-bit\n integer containing the zero-extended integer data.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291878,"byte_end":3291887,"line_start":3760,"line_end":3760,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291888,"byte_end":3291922,"line_start":3761,"line_end":3761,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3291975,"byte_end":3292006,"line_start":3763,"line_end":3763,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292007,"byte_end":3292056,"line_start":3764,"line_end":3764,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11840},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292576,"byte_end":3292596,"line_start":3778,"line_end":3778,"column_start":15,"column_end":35},"name":"_mm256_extract_epi32","qualname":"::core_arch::x86::avx2::_mm256_extract_epi32","value":"fn (a: __m256i, imm8: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Extracts a 32-bit integer from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292383,"byte_end":3292392,"line_start":3773,"line_end":3773,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292393,"byte_end":3292427,"line_start":3774,"line_end":3774,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292480,"byte_end":3292511,"line_start":3776,"line_end":3776,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292512,"byte_end":3292561,"line_start":3777,"line_end":3777,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11842},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293045,"byte_end":3293061,"line_start":3790,"line_end":3790,"column_start":15,"column_end":31},"name":"_mm256_cvtsd_f64","qualname":"::core_arch::x86::avx2::_mm256_cvtsd_f64","value":"fn (a: __m256d) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the first element of the input vector of `[4 x double]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292889,"byte_end":3292898,"line_start":3786,"line_end":3786,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292899,"byte_end":3292933,"line_start":3787,"line_end":3787,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3292981,"byte_end":3293030,"line_start":3789,"line_end":3789,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11844},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293451,"byte_end":3293471,"line_start":3801,"line_end":3801,"column_start":15,"column_end":35},"name":"_mm256_cvtsi256_si32","qualname":"::core_arch::x86::avx2::_mm256_cvtsi256_si32","value":"fn (a: __m256i) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Returns the first element of the input vector of `[8 x i32]`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293296,"byte_end":3293305,"line_start":3797,"line_end":3797,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293306,"byte_end":3293340,"line_start":3798,"line_end":3798,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx2.rs","byte_start":3293387,"byte_end":3293436,"line_start":3800,"line_end":3800,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11854},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3373086,"byte_end":3373098,"line_start":34,"line_end":34,"column_start":15,"column_end":27},"name":"_mm_fmadd_pd","qualname":"::core_arch::x86::fma::_mm_fmadd_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and add the intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3372938,"byte_end":3372947,"line_start":30,"line_end":30,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3372948,"byte_end":3372981,"line_start":31,"line_end":31,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3373022,"byte_end":3373071,"line_start":33,"line_end":33,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11856},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3373588,"byte_end":3373603,"line_start":46,"line_end":46,"column_start":15,"column_end":30},"name":"_mm256_fmadd_pd","qualname":"::core_arch::x86::fma::_mm256_fmadd_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and add the intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3373440,"byte_end":3373449,"line_start":42,"line_end":42,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3373450,"byte_end":3373483,"line_start":43,"line_end":43,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3373524,"byte_end":3373573,"line_start":45,"line_end":45,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11858},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3374093,"byte_end":3374105,"line_start":58,"line_end":58,"column_start":15,"column_end":27},"name":"_mm_fmadd_ps","qualname":"::core_arch::x86::fma::_mm_fmadd_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and add the intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3373945,"byte_end":3373954,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3373955,"byte_end":3373988,"line_start":55,"line_end":55,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3374029,"byte_end":3374078,"line_start":57,"line_end":57,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11860},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3374591,"byte_end":3374606,"line_start":70,"line_end":70,"column_start":15,"column_end":30},"name":"_mm256_fmadd_ps","qualname":"::core_arch::x86::fma::_mm256_fmadd_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and add the intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3374443,"byte_end":3374452,"line_start":66,"line_end":66,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3374453,"byte_end":3374486,"line_start":67,"line_end":67,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3374527,"byte_end":3374576,"line_start":69,"line_end":69,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11862},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3375240,"byte_end":3375252,"line_start":84,"line_end":84,"column_start":15,"column_end":27},"name":"_mm_fmadd_sd","qualname":"::core_arch::x86::fma::_mm_fmadd_sd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower double-precision (64-bit) floating-point elements in\n `a` and `b`, and add the intermediate result to the lower element in `c`.\n Stores the result in the lower element of the returned value, and copy the\n upper element from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3375092,"byte_end":3375101,"line_start":80,"line_end":80,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3375102,"byte_end":3375135,"line_start":81,"line_end":81,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3375176,"byte_end":3375225,"line_start":83,"line_end":83,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11864},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3375890,"byte_end":3375902,"line_start":98,"line_end":98,"column_start":15,"column_end":27},"name":"_mm_fmadd_ss","qualname":"::core_arch::x86::fma::_mm_fmadd_ss","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower single-precision (32-bit) floating-point elements in\n `a` and `b`, and add the intermediate result to the lower element in `c`.\n Stores the result in the lower element of the returned value, and copy the\n 3 upper elements from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3375742,"byte_end":3375751,"line_start":94,"line_end":94,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3375752,"byte_end":3375785,"line_start":95,"line_end":95,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3375826,"byte_end":3375875,"line_start":97,"line_end":97,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11866},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3376427,"byte_end":3376442,"line_start":111,"line_end":111,"column_start":15,"column_end":30},"name":"_mm_fmaddsub_pd","qualname":"::core_arch::x86::fma::_mm_fmaddsub_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and alternatively add and subtract packed elements in `c` to/from\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3376276,"byte_end":3376285,"line_start":107,"line_end":107,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3376286,"byte_end":3376319,"line_start":108,"line_end":108,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3376363,"byte_end":3376412,"line_start":110,"line_end":110,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11868},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3376977,"byte_end":3376995,"line_start":124,"line_end":124,"column_start":15,"column_end":33},"name":"_mm256_fmaddsub_pd","qualname":"::core_arch::x86::fma::_mm256_fmaddsub_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and alternatively add and subtract packed elements in `c` to/from\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3376826,"byte_end":3376835,"line_start":120,"line_end":120,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3376836,"byte_end":3376869,"line_start":121,"line_end":121,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3376913,"byte_end":3376962,"line_start":123,"line_end":123,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11870},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3377530,"byte_end":3377545,"line_start":137,"line_end":137,"column_start":15,"column_end":30},"name":"_mm_fmaddsub_ps","qualname":"::core_arch::x86::fma::_mm_fmaddsub_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and alternatively add and subtract packed elements in `c` to/from\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3377379,"byte_end":3377388,"line_start":133,"line_end":133,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3377389,"byte_end":3377422,"line_start":134,"line_end":134,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3377466,"byte_end":3377515,"line_start":136,"line_end":136,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11872},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3378076,"byte_end":3378094,"line_start":150,"line_end":150,"column_start":15,"column_end":33},"name":"_mm256_fmaddsub_ps","qualname":"::core_arch::x86::fma::_mm256_fmaddsub_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and alternatively add and subtract packed elements in `c` to/from\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3377925,"byte_end":3377934,"line_start":146,"line_end":146,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3377935,"byte_end":3377968,"line_start":147,"line_end":147,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3378012,"byte_end":3378061,"line_start":149,"line_end":149,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11874},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3378590,"byte_end":3378602,"line_start":162,"line_end":162,"column_start":15,"column_end":27},"name":"_mm_fmsub_pd","qualname":"::core_arch::x86::fma::_mm_fmsub_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3378442,"byte_end":3378451,"line_start":158,"line_end":158,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3378452,"byte_end":3378485,"line_start":159,"line_end":159,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3378526,"byte_end":3378575,"line_start":161,"line_end":161,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11876},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3379099,"byte_end":3379114,"line_start":174,"line_end":174,"column_start":15,"column_end":30},"name":"_mm256_fmsub_pd","qualname":"::core_arch::x86::fma::_mm256_fmsub_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3378951,"byte_end":3378960,"line_start":170,"line_end":170,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3378961,"byte_end":3378994,"line_start":171,"line_end":171,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3379035,"byte_end":3379084,"line_start":173,"line_end":173,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11878},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3379616,"byte_end":3379628,"line_start":186,"line_end":186,"column_start":15,"column_end":27},"name":"_mm_fmsub_ps","qualname":"::core_arch::x86::fma::_mm_fmsub_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3379463,"byte_end":3379472,"line_start":182,"line_end":182,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3379473,"byte_end":3379506,"line_start":183,"line_end":183,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3379552,"byte_end":3379601,"line_start":185,"line_end":185,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11880},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3380126,"byte_end":3380141,"line_start":198,"line_end":198,"column_start":15,"column_end":30},"name":"_mm256_fmsub_ps","qualname":"::core_arch::x86::fma::_mm256_fmsub_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3379973,"byte_end":3379982,"line_start":194,"line_end":194,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3379983,"byte_end":3380016,"line_start":195,"line_end":195,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3380062,"byte_end":3380111,"line_start":197,"line_end":197,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11882},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3380781,"byte_end":3380793,"line_start":212,"line_end":212,"column_start":15,"column_end":27},"name":"_mm_fmsub_sd","qualname":"::core_arch::x86::fma::_mm_fmsub_sd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower double-precision (64-bit) floating-point elements in\n `a` and `b`, and subtract the lower element in `c` from the intermediate\n result. Store the result in the lower element of the returned value, and\n copy the upper element from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3380633,"byte_end":3380642,"line_start":208,"line_end":208,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3380643,"byte_end":3380676,"line_start":209,"line_end":209,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3380717,"byte_end":3380766,"line_start":211,"line_end":211,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11884},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3381438,"byte_end":3381450,"line_start":226,"line_end":226,"column_start":15,"column_end":27},"name":"_mm_fmsub_ss","qualname":"::core_arch::x86::fma::_mm_fmsub_ss","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower single-precision (32-bit) floating-point elements in\n `a` and `b`,  and subtract the lower element in `c` from the intermediate\n result. Store the result in the lower element of the returned value, and\n copy the 3 upper elements from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3381290,"byte_end":3381299,"line_start":222,"line_end":222,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3381300,"byte_end":3381333,"line_start":223,"line_end":223,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3381374,"byte_end":3381423,"line_start":225,"line_end":225,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11886},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3381975,"byte_end":3381990,"line_start":239,"line_end":239,"column_start":15,"column_end":30},"name":"_mm_fmsubadd_pd","qualname":"::core_arch::x86::fma::_mm_fmsubadd_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and alternatively subtract and add packed elements in `c` from/to\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3381824,"byte_end":3381833,"line_start":235,"line_end":235,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3381834,"byte_end":3381867,"line_start":236,"line_end":236,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3381911,"byte_end":3381960,"line_start":238,"line_end":238,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11888},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3382525,"byte_end":3382543,"line_start":252,"line_end":252,"column_start":15,"column_end":33},"name":"_mm256_fmsubadd_pd","qualname":"::core_arch::x86::fma::_mm256_fmsubadd_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and alternatively subtract and add packed elements in `c` from/to\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3382374,"byte_end":3382383,"line_start":248,"line_end":248,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3382384,"byte_end":3382417,"line_start":249,"line_end":249,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3382461,"byte_end":3382510,"line_start":251,"line_end":251,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11890},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3383078,"byte_end":3383093,"line_start":265,"line_end":265,"column_start":15,"column_end":30},"name":"_mm_fmsubadd_ps","qualname":"::core_arch::x86::fma::_mm_fmsubadd_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and alternatively subtract and add packed elements in `c` from/to\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3382927,"byte_end":3382936,"line_start":261,"line_end":261,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3382937,"byte_end":3382970,"line_start":262,"line_end":262,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3383014,"byte_end":3383063,"line_start":264,"line_end":264,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11892},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3383624,"byte_end":3383642,"line_start":278,"line_end":278,"column_start":15,"column_end":33},"name":"_mm256_fmsubadd_ps","qualname":"::core_arch::x86::fma::_mm256_fmsubadd_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and alternatively subtract and add packed elements in `c` from/to\n the intermediate result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3383473,"byte_end":3383482,"line_start":274,"line_end":274,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3383483,"byte_end":3383516,"line_start":275,"line_end":275,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3383560,"byte_end":3383609,"line_start":277,"line_end":277,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11894},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3384141,"byte_end":3384154,"line_start":290,"line_end":290,"column_start":15,"column_end":28},"name":"_mm_fnmadd_pd","qualname":"::core_arch::x86::fma::_mm_fnmadd_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and add the negated intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3383992,"byte_end":3384001,"line_start":286,"line_end":286,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3384002,"byte_end":3384035,"line_start":287,"line_end":287,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3384077,"byte_end":3384126,"line_start":289,"line_end":289,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11896},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3384655,"byte_end":3384671,"line_start":302,"line_end":302,"column_start":15,"column_end":31},"name":"_mm256_fnmadd_pd","qualname":"::core_arch::x86::fma::_mm256_fnmadd_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and add the negated intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3384506,"byte_end":3384515,"line_start":298,"line_end":298,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3384516,"byte_end":3384549,"line_start":299,"line_end":299,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3384591,"byte_end":3384640,"line_start":301,"line_end":301,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11898},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3385172,"byte_end":3385185,"line_start":314,"line_end":314,"column_start":15,"column_end":28},"name":"_mm_fnmadd_ps","qualname":"::core_arch::x86::fma::_mm_fnmadd_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and add the negated intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3385023,"byte_end":3385032,"line_start":310,"line_end":310,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3385033,"byte_end":3385066,"line_start":311,"line_end":311,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3385108,"byte_end":3385157,"line_start":313,"line_end":313,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11900},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3385682,"byte_end":3385698,"line_start":326,"line_end":326,"column_start":15,"column_end":31},"name":"_mm256_fnmadd_ps","qualname":"::core_arch::x86::fma::_mm256_fnmadd_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and add the negated intermediate result to packed elements in `c`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3385533,"byte_end":3385542,"line_start":322,"line_end":322,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3385543,"byte_end":3385576,"line_start":323,"line_end":323,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3385618,"byte_end":3385667,"line_start":325,"line_end":325,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11902},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3386342,"byte_end":3386355,"line_start":340,"line_end":340,"column_start":15,"column_end":28},"name":"_mm_fnmadd_sd","qualname":"::core_arch::x86::fma::_mm_fnmadd_sd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower double-precision (64-bit) floating-point elements in\n `a` and `b`, and add the negated intermediate result to the lower element\n in `c`. Store the result in the lower element of the returned value, and\n copy the upper element from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3386193,"byte_end":3386202,"line_start":336,"line_end":336,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3386203,"byte_end":3386236,"line_start":337,"line_end":337,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3386278,"byte_end":3386327,"line_start":339,"line_end":339,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11904},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3387003,"byte_end":3387016,"line_start":354,"line_end":354,"column_start":15,"column_end":28},"name":"_mm_fnmadd_ss","qualname":"::core_arch::x86::fma::_mm_fnmadd_ss","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower single-precision (32-bit) floating-point elements in\n `a` and `b`, and add the negated intermediate result to the lower element\n in `c`. Store the result in the lower element of the returned value, and\n copy the 3 upper elements from `a` to the upper elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3386854,"byte_end":3386863,"line_start":350,"line_end":350,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3386864,"byte_end":3386897,"line_start":351,"line_end":351,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3386939,"byte_end":3386988,"line_start":353,"line_end":353,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11906},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3387521,"byte_end":3387534,"line_start":367,"line_end":367,"column_start":15,"column_end":28},"name":"_mm_fnmsub_pd","qualname":"::core_arch::x86::fma::_mm_fnmsub_pd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the negated intermediate\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3387372,"byte_end":3387381,"line_start":363,"line_end":363,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3387382,"byte_end":3387415,"line_start":364,"line_end":364,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3387457,"byte_end":3387506,"line_start":366,"line_end":366,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11908},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3388046,"byte_end":3388062,"line_start":380,"line_end":380,"column_start":15,"column_end":31},"name":"_mm256_fnmsub_pd","qualname":"::core_arch::x86::fma::_mm256_fnmsub_pd","value":"fn (a: __m256d, b: __m256d, c: __m256d) -> __m256d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed double-precision (64-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the negated intermediate\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3387897,"byte_end":3387906,"line_start":376,"line_end":376,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3387907,"byte_end":3387940,"line_start":377,"line_end":377,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3387982,"byte_end":3388031,"line_start":379,"line_end":379,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11910},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3388574,"byte_end":3388587,"line_start":393,"line_end":393,"column_start":15,"column_end":28},"name":"_mm_fnmsub_ps","qualname":"::core_arch::x86::fma::_mm_fnmsub_ps","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the negated intermediate\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3388425,"byte_end":3388434,"line_start":389,"line_end":389,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3388435,"byte_end":3388468,"line_start":390,"line_end":390,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3388510,"byte_end":3388559,"line_start":392,"line_end":392,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11912},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3389095,"byte_end":3389111,"line_start":406,"line_end":406,"column_start":15,"column_end":31},"name":"_mm256_fnmsub_ps","qualname":"::core_arch::x86::fma::_mm256_fnmsub_ps","value":"fn (a: __m256, b: __m256, c: __m256) -> __m256","parent":null,"children":[],"decl_id":null,"docs":" Multiplies packed single-precision (32-bit) floating-point elements in `a`\n and `b`, and subtract packed elements in `c` from the negated intermediate\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3388946,"byte_end":3388955,"line_start":402,"line_end":402,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3388956,"byte_end":3388989,"line_start":403,"line_end":403,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3389031,"byte_end":3389080,"line_start":405,"line_end":405,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11914},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3389764,"byte_end":3389777,"line_start":421,"line_end":421,"column_start":15,"column_end":28},"name":"_mm_fnmsub_sd","qualname":"::core_arch::x86::fma::_mm_fnmsub_sd","value":"fn (a: __m128d, b: __m128d, c: __m128d) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower double-precision (64-bit) floating-point elements in\n `a` and `b`, and subtract packed elements in `c` from the negated\n intermediate result. Store the result in the lower element of the returned\n value, and copy the upper element from `a` to the upper elements of the\n result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3389615,"byte_end":3389624,"line_start":417,"line_end":417,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3389625,"byte_end":3389658,"line_start":418,"line_end":418,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3389700,"byte_end":3389749,"line_start":420,"line_end":420,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11916},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3390434,"byte_end":3390447,"line_start":436,"line_end":436,"column_start":15,"column_end":28},"name":"_mm_fnmsub_ss","qualname":"::core_arch::x86::fma::_mm_fnmsub_ss","value":"fn (a: __m128, b: __m128, c: __m128) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Multiplies the lower single-precision (32-bit) floating-point elements in\n `a` and `b`, and subtract packed elements in `c` from the negated\n intermediate result. Store the result in the lower element of the\n returned value, and copy the 3 upper elements from `a` to the upper\n elements of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3390285,"byte_end":3390294,"line_start":432,"line_end":432,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3390295,"byte_end":3390328,"line_start":433,"line_end":433,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/fma.rs","byte_start":3390370,"byte_end":3390419,"line_start":435,"line_end":435,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11924},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3405777,"byte_end":3405787,"line_start":32,"line_end":32,"column_start":15,"column_end":25},"name":"_lzcnt_u32","qualname":"::core_arch::x86::abm::_lzcnt_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Counts the leading most significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3405628,"byte_end":3405637,"line_start":28,"line_end":28,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"lzcnt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3405638,"byte_end":3405673,"line_start":29,"line_end":29,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3405713,"byte_end":3405762,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11926},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3406125,"byte_end":3406134,"line_start":43,"line_end":43,"column_start":15,"column_end":24},"name":"_popcnt32","qualname":"::core_arch::x86::abm::_popcnt32","value":"fn (x: i32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Counts the bits that are set.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3405974,"byte_end":3405983,"line_start":39,"line_end":39,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"popcnt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3405984,"byte_end":3406020,"line_start":40,"line_end":40,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/abm.rs","byte_start":3406061,"byte_end":3406110,"line_start":42,"line_end":42,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11932},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3407534,"byte_end":3407544,"line_start":23,"line_end":23,"column_start":15,"column_end":25},"name":"_bextr_u32","qualname":"::core_arch::x86::bmi1::_bextr_u32","value":"fn (a: u32, start: u32, len: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Extracts bits in range [`start`, `start` + `length`) from `a` into\n the least significant bits of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3407386,"byte_end":3407395,"line_start":19,"line_end":19,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3407396,"byte_end":3407430,"line_start":20,"line_end":20,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3407470,"byte_end":3407519,"line_start":22,"line_end":22,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11934},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408169,"byte_end":3408180,"line_start":38,"line_end":38,"column_start":15,"column_end":26},"name":"_bextr2_u32","qualname":"::core_arch::x86::bmi1::_bextr2_u32","value":"fn (a: u32, control: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Extracts bits of `a` specified by `control` into\n the least significant bits of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408021,"byte_end":3408030,"line_start":34,"line_end":34,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408031,"byte_end":3408065,"line_start":35,"line_end":35,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408105,"byte_end":3408154,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11936},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408557,"byte_end":3408566,"line_start":49,"line_end":49,"column_start":15,"column_end":24},"name":"_andn_u32","qualname":"::core_arch::x86::bmi1::_andn_u32","value":"fn (a: u32, b: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Bitwise logical `AND` of inverted `a` with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408410,"byte_end":3408419,"line_start":45,"line_end":45,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408420,"byte_end":3408454,"line_start":46,"line_end":46,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408493,"byte_end":3408542,"line_start":48,"line_end":48,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11938},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408901,"byte_end":3408910,"line_start":60,"line_end":60,"column_start":15,"column_end":24},"name":"_blsi_u32","qualname":"::core_arch::x86::bmi1::_blsi_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Extracts lowest set isolated bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408754,"byte_end":3408763,"line_start":56,"line_end":56,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408764,"byte_end":3408798,"line_start":57,"line_end":57,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3408837,"byte_end":3408886,"line_start":59,"line_end":59,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11940},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409253,"byte_end":3409264,"line_start":71,"line_end":71,"column_start":15,"column_end":26},"name":"_blsmsk_u32","qualname":"::core_arch::x86::bmi1::_blsmsk_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Gets mask up to lowest set bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409104,"byte_end":3409113,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409114,"byte_end":3409148,"line_start":68,"line_end":68,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409189,"byte_end":3409238,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11942},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409639,"byte_end":3409648,"line_start":84,"line_end":84,"column_start":15,"column_end":24},"name":"_blsr_u32","qualname":"::core_arch::x86::bmi1::_blsr_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Resets the lowest set bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409492,"byte_end":3409501,"line_start":80,"line_end":80,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409502,"byte_end":3409536,"line_start":81,"line_end":81,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409575,"byte_end":3409624,"line_start":83,"line_end":83,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11944},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3410088,"byte_end":3410098,"line_start":97,"line_end":97,"column_start":15,"column_end":25},"name":"_tzcnt_u32","qualname":"::core_arch::x86::bmi1::_tzcnt_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Counts the number of trailing least significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409940,"byte_end":3409949,"line_start":93,"line_end":93,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3409950,"byte_end":3409984,"line_start":94,"line_end":94,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3410024,"byte_end":3410073,"line_start":96,"line_end":96,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11946},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3410535,"byte_end":3410547,"line_start":110,"line_end":110,"column_start":15,"column_end":27},"name":"_mm_tzcnt_32","qualname":"::core_arch::x86::bmi1::_mm_tzcnt_32","value":"fn (x: u32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Counts the number of trailing least significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3410387,"byte_end":3410396,"line_start":106,"line_end":106,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3410397,"byte_end":3410431,"line_start":107,"line_end":107,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi1.rs","byte_start":3410471,"byte_end":3410520,"line_start":109,"line_end":109,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11954},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3413678,"byte_end":3413687,"line_start":28,"line_end":28,"column_start":15,"column_end":24},"name":"_mulx_u32","qualname":"::core_arch::x86::bmi2::_mulx_u32","value":"fn (a: u32, b: u32, hi: &mut u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Unsigned multiply without affecting flags.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3413364,"byte_end":3413373,"line_start":22,"line_end":22,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3413579,"byte_end":3413613,"line_start":26,"line_end":26,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3413614,"byte_end":3413663,"line_start":27,"line_end":27,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11956},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414127,"byte_end":3414136,"line_start":41,"line_end":41,"column_start":15,"column_end":24},"name":"_bzhi_u32","qualname":"::core_arch::x86::bmi2::_bzhi_u32","value":"fn (a: u32, index: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Zeroes higher bits of `a` >= `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3413980,"byte_end":3413989,"line_start":37,"line_end":37,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3413990,"byte_end":3414024,"line_start":38,"line_end":38,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414063,"byte_end":3414112,"line_start":40,"line_end":40,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11958},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414562,"byte_end":3414571,"line_start":53,"line_end":53,"column_start":15,"column_end":24},"name":"_pdep_u32","qualname":"::core_arch::x86::bmi2::_pdep_u32","value":"fn (a: u32, mask: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Scatter contiguous low order bits of `a` to the result at the positions\n specified by the `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414415,"byte_end":3414424,"line_start":49,"line_end":49,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414425,"byte_end":3414459,"line_start":50,"line_end":50,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414498,"byte_end":3414547,"line_start":52,"line_end":52,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11960},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3415005,"byte_end":3415014,"line_start":65,"line_end":65,"column_start":15,"column_end":24},"name":"_pext_u32","qualname":"::core_arch::x86::bmi2::_pext_u32","value":"fn (a: u32, mask: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Gathers the bits of `x` specified by the `mask` into the contiguous low\n order bit positions of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414858,"byte_end":3414867,"line_start":61,"line_end":61,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414868,"byte_end":3414902,"line_start":62,"line_end":62,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bmi2.rs","byte_start":3414941,"byte_end":3414990,"line_start":64,"line_end":64,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11980},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418213,"byte_end":3418229,"line_start":41,"line_end":41,"column_start":15,"column_end":31},"name":"_mm_extract_si64","qualname":"::core_arch::x86::sse4a::_mm_extract_si64","value":"fn (x: __m128i, y: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Extracts the bit range specified by `y` from the lower 64 bits of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418064,"byte_end":3418073,"line_start":37,"line_end":37,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4a\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418074,"byte_end":3418109,"line_start":38,"line_end":38,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418149,"byte_end":3418198,"line_start":40,"line_end":40,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11982},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418777,"byte_end":3418792,"line_start":58,"line_end":58,"column_start":15,"column_end":30},"name":"_mm_insert_si64","qualname":"::core_arch::x86::sse4a::_mm_insert_si64","value":"fn (x: __m128i, y: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Inserts the `[length:0]` bits of `y` into `x` at `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418626,"byte_end":3418635,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4a\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418636,"byte_end":3418671,"line_start":55,"line_end":55,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418713,"byte_end":3418762,"line_start":57,"line_end":57,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11984},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3419077,"byte_end":3419090,"line_start":67,"line_end":67,"column_start":15,"column_end":28},"name":"_mm_stream_sd","qualname":"::core_arch::x86::sse4a::_mm_stream_sd","value":"fn (p: *mut f64, a: __m128d) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Non-temporal store of `a.0` into `p`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418926,"byte_end":3418935,"line_start":63,"line_end":63,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4a\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3418936,"byte_end":3418971,"line_start":64,"line_end":64,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3419013,"byte_end":3419062,"line_start":66,"line_end":66,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11986},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3419333,"byte_end":3419346,"line_start":76,"line_end":76,"column_start":15,"column_end":28},"name":"_mm_stream_ss","qualname":"::core_arch::x86::sse4a::_mm_stream_ss","value":"fn (p: *mut f32, a: __m128) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Non-temporal store of `a.0` into `p`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3419182,"byte_end":3419191,"line_start":72,"line_end":72,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4a\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3419192,"byte_end":3419227,"line_start":73,"line_end":73,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sse4a.rs","byte_start":3419269,"byte_end":3419318,"line_start":75,"line_end":75,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11992},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424119,"byte_end":3424131,"line_start":74,"line_end":74,"column_start":15,"column_end":27},"name":"_blcfill_u32","qualname":"::core_arch::x86::tbm::_blcfill_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Clears all bits below the least significant zero bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3423970,"byte_end":3423979,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3423980,"byte_end":3424013,"line_start":71,"line_end":71,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424055,"byte_end":3424104,"line_start":73,"line_end":73,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11994},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424518,"byte_end":3424530,"line_start":86,"line_end":86,"column_start":15,"column_end":27},"name":"_blcfill_u64","qualname":"::core_arch::x86::tbm::_blcfill_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Clears all bits below the least significant zero bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424302,"byte_end":3424311,"line_start":81,"line_end":81,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424312,"byte_end":3424345,"line_start":82,"line_end":82,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424387,"byte_end":3424419,"line_start":84,"line_end":84,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424454,"byte_end":3424503,"line_start":85,"line_end":85,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11996},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424856,"byte_end":3424865,"line_start":97,"line_end":97,"column_start":15,"column_end":24},"name":"_blci_u32","qualname":"::core_arch::x86::tbm::_blci_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits of `x` to 1 except for the least significant zero bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424710,"byte_end":3424719,"line_start":93,"line_end":93,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424720,"byte_end":3424753,"line_start":94,"line_end":94,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3424792,"byte_end":3424841,"line_start":96,"line_end":96,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":11998},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425259,"byte_end":3425268,"line_start":109,"line_end":109,"column_start":15,"column_end":24},"name":"_blci_u64","qualname":"::core_arch::x86::tbm::_blci_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits of `x` to 1 except for the least significant zero bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425046,"byte_end":3425055,"line_start":104,"line_end":104,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425056,"byte_end":3425089,"line_start":105,"line_end":105,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425128,"byte_end":3425160,"line_start":107,"line_end":107,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425195,"byte_end":3425244,"line_start":108,"line_end":108,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12000},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425596,"byte_end":3425606,"line_start":120,"line_end":120,"column_start":15,"column_end":25},"name":"_blcic_u32","qualname":"::core_arch::x86::tbm::_blcic_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x` and clears all other bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425449,"byte_end":3425458,"line_start":116,"line_end":116,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425459,"byte_end":3425492,"line_start":117,"line_end":117,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425532,"byte_end":3425581,"line_start":119,"line_end":119,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12002},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426001,"byte_end":3426011,"line_start":132,"line_end":132,"column_start":15,"column_end":25},"name":"_blcic_u64","qualname":"::core_arch::x86::tbm::_blcic_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x` and clears all other bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425787,"byte_end":3425796,"line_start":127,"line_end":127,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425797,"byte_end":3425830,"line_start":128,"line_end":128,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425870,"byte_end":3425902,"line_start":130,"line_end":130,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3425937,"byte_end":3425986,"line_start":131,"line_end":131,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12004},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426358,"byte_end":3426369,"line_start":144,"line_end":144,"column_start":15,"column_end":26},"name":"_blcmsk_u32","qualname":"::core_arch::x86::tbm::_blcmsk_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x` and clears all bits above\n that bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426210,"byte_end":3426219,"line_start":140,"line_end":140,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426220,"byte_end":3426253,"line_start":141,"line_end":141,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426294,"byte_end":3426343,"line_start":143,"line_end":143,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12006},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426782,"byte_end":3426793,"line_start":157,"line_end":157,"column_start":15,"column_end":26},"name":"_blcmsk_u64","qualname":"::core_arch::x86::tbm::_blcmsk_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x` and clears all bits above\n that bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426567,"byte_end":3426576,"line_start":152,"line_end":152,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426577,"byte_end":3426610,"line_start":153,"line_end":153,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426651,"byte_end":3426683,"line_start":155,"line_end":155,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426718,"byte_end":3426767,"line_start":156,"line_end":156,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12008},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427092,"byte_end":3427101,"line_start":168,"line_end":168,"column_start":15,"column_end":24},"name":"_blcs_u32","qualname":"::core_arch::x86::tbm::_blcs_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426946,"byte_end":3426955,"line_start":164,"line_end":164,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3426956,"byte_end":3426989,"line_start":165,"line_end":165,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427028,"byte_end":3427077,"line_start":167,"line_end":167,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12010},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427467,"byte_end":3427476,"line_start":180,"line_end":180,"column_start":15,"column_end":24},"name":"_blcs_u64","qualname":"::core_arch::x86::tbm::_blcs_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets the least significant zero bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427254,"byte_end":3427263,"line_start":175,"line_end":175,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427264,"byte_end":3427297,"line_start":176,"line_end":176,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427336,"byte_end":3427368,"line_start":178,"line_end":178,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427403,"byte_end":3427452,"line_start":179,"line_end":179,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12012},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427791,"byte_end":3427803,"line_start":191,"line_end":191,"column_start":15,"column_end":27},"name":"_blsfill_u32","qualname":"::core_arch::x86::tbm::_blsfill_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits of `x` below the least significant one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427642,"byte_end":3427651,"line_start":187,"line_end":187,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427652,"byte_end":3427685,"line_start":188,"line_end":188,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427727,"byte_end":3427776,"line_start":190,"line_end":190,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12014},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428187,"byte_end":3428199,"line_start":203,"line_end":203,"column_start":15,"column_end":27},"name":"_blsfill_u64","qualname":"::core_arch::x86::tbm::_blsfill_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits of `x` below the least significant one.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427971,"byte_end":3427980,"line_start":198,"line_end":198,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3427981,"byte_end":3428014,"line_start":199,"line_end":199,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428056,"byte_end":3428088,"line_start":201,"line_end":201,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428123,"byte_end":3428172,"line_start":202,"line_end":202,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12016},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428514,"byte_end":3428524,"line_start":214,"line_end":214,"column_start":15,"column_end":25},"name":"_blsic_u32","qualname":"::core_arch::x86::tbm::_blsic_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Clears least significant bit and sets all other bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428367,"byte_end":3428376,"line_start":210,"line_end":210,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428377,"byte_end":3428410,"line_start":211,"line_end":211,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428450,"byte_end":3428499,"line_start":213,"line_end":213,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12018},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428907,"byte_end":3428917,"line_start":226,"line_end":226,"column_start":15,"column_end":25},"name":"_blsic_u64","qualname":"::core_arch::x86::tbm::_blsic_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Clears least significant bit and sets all other bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428693,"byte_end":3428702,"line_start":221,"line_end":221,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428703,"byte_end":3428736,"line_start":222,"line_end":222,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428776,"byte_end":3428808,"line_start":224,"line_end":224,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3428843,"byte_end":3428892,"line_start":225,"line_end":225,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12020},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429274,"byte_end":3429285,"line_start":238,"line_end":238,"column_start":15,"column_end":26},"name":"_t1mskc_u32","qualname":"::core_arch::x86::tbm::_t1mskc_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Clears all bits below the least significant zero of `x` and sets all other\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429126,"byte_end":3429135,"line_start":234,"line_end":234,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429136,"byte_end":3429169,"line_start":235,"line_end":235,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429210,"byte_end":3429259,"line_start":237,"line_end":237,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12022},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429709,"byte_end":3429720,"line_start":251,"line_end":251,"column_start":15,"column_end":26},"name":"_t1mskc_u64","qualname":"::core_arch::x86::tbm::_t1mskc_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Clears all bits below the least significant zero of `x` and sets all other\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429494,"byte_end":3429503,"line_start":246,"line_end":246,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429504,"byte_end":3429537,"line_start":247,"line_end":247,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429578,"byte_end":3429610,"line_start":249,"line_end":249,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429645,"byte_end":3429694,"line_start":250,"line_end":250,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12024},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3430072,"byte_end":3430082,"line_start":263,"line_end":263,"column_start":15,"column_end":25},"name":"_tzmsk_u32","qualname":"::core_arch::x86::tbm::_tzmsk_u32","value":"fn (x: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits below the least significant one of `x` and clears all other\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429925,"byte_end":3429934,"line_start":259,"line_end":259,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3429935,"byte_end":3429968,"line_start":260,"line_end":260,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3430008,"byte_end":3430057,"line_start":262,"line_end":262,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12026},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3430501,"byte_end":3430511,"line_start":276,"line_end":276,"column_start":15,"column_end":25},"name":"_tzmsk_u64","qualname":"::core_arch::x86::tbm::_tzmsk_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Sets all bits below the least significant one of `x` and clears all other\n bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3430287,"byte_end":3430296,"line_start":271,"line_end":271,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"tbm\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3430297,"byte_end":3430330,"line_start":272,"line_end":272,"column_start":1,"column_end":34}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3430370,"byte_end":3430402,"line_start":274,"line_end":274,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/tbm.rs","byte_start":3430437,"byte_end":3430486,"line_start":275,"line_end":275,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12042},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3436993,"byte_end":3437009,"line_start":25,"line_end":25,"column_start":15,"column_end":31},"name":"_mm_setzero_si64","qualname":"::core_arch::x86::mmx::_mm_setzero_si64","value":"fn () -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Constructs a 64-bit integer vector initialized to zero.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3436747,"byte_end":3436756,"line_start":20,"line_end":20,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3436757,"byte_end":3436790,"line_start":21,"line_end":21,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12044},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437191,"byte_end":3437202,"line_start":33,"line_end":33,"column_start":15,"column_end":26},"name":"_mm_add_pi8","qualname":"::core_arch::x86::mmx::_mm_add_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437094,"byte_end":3437103,"line_start":30,"line_end":30,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437104,"byte_end":3437137,"line_start":31,"line_end":31,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12046},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437397,"byte_end":3437405,"line_start":41,"line_end":41,"column_start":15,"column_end":23},"name":"_m_paddb","qualname":"::core_arch::x86::mmx::_m_paddb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437300,"byte_end":3437309,"line_start":38,"line_end":38,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437310,"byte_end":3437343,"line_start":39,"line_end":39,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12048},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437607,"byte_end":3437619,"line_start":49,"line_end":49,"column_start":15,"column_end":27},"name":"_mm_add_pi16","qualname":"::core_arch::x86::mmx::_mm_add_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437510,"byte_end":3437519,"line_start":46,"line_end":46,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437520,"byte_end":3437553,"line_start":47,"line_end":47,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12050},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437815,"byte_end":3437823,"line_start":57,"line_end":57,"column_start":15,"column_end":23},"name":"_m_paddw","qualname":"::core_arch::x86::mmx::_m_paddw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437718,"byte_end":3437727,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437728,"byte_end":3437761,"line_start":55,"line_end":55,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12052},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438026,"byte_end":3438038,"line_start":65,"line_end":65,"column_start":15,"column_end":27},"name":"_mm_add_pi32","qualname":"::core_arch::x86::mmx::_mm_add_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 32-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437929,"byte_end":3437938,"line_start":62,"line_end":62,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3437939,"byte_end":3437972,"line_start":63,"line_end":63,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12054},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438234,"byte_end":3438242,"line_start":73,"line_end":73,"column_start":15,"column_end":23},"name":"_m_paddd","qualname":"::core_arch::x86::mmx::_m_paddd","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 32-bit integers in `a` and `b`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438137,"byte_end":3438146,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438147,"byte_end":3438180,"line_start":71,"line_end":71,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12056},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438462,"byte_end":3438474,"line_start":81,"line_end":81,"column_start":15,"column_end":27},"name":"_mm_adds_pi8","qualname":"::core_arch::x86::mmx::_mm_adds_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438364,"byte_end":3438373,"line_start":78,"line_end":78,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438374,"byte_end":3438407,"line_start":79,"line_end":79,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12058},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438688,"byte_end":3438697,"line_start":89,"line_end":89,"column_start":15,"column_end":24},"name":"_m_paddsb","qualname":"::core_arch::x86::mmx::_m_paddsb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 8-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438590,"byte_end":3438599,"line_start":86,"line_end":86,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438600,"byte_end":3438633,"line_start":87,"line_end":87,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12060},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438918,"byte_end":3438931,"line_start":97,"line_end":97,"column_start":15,"column_end":28},"name":"_mm_adds_pi16","qualname":"::core_arch::x86::mmx::_mm_adds_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438820,"byte_end":3438829,"line_start":94,"line_end":94,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3438830,"byte_end":3438863,"line_start":95,"line_end":95,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12062},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439146,"byte_end":3439155,"line_start":105,"line_end":105,"column_start":15,"column_end":24},"name":"_m_paddsw","qualname":"::core_arch::x86::mmx::_m_paddsw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed 16-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439048,"byte_end":3439057,"line_start":102,"line_end":102,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439058,"byte_end":3439091,"line_start":103,"line_end":103,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12064},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439386,"byte_end":3439398,"line_start":113,"line_end":113,"column_start":15,"column_end":27},"name":"_mm_adds_pu8","qualname":"::core_arch::x86::mmx::_mm_adds_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 8-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439287,"byte_end":3439296,"line_start":110,"line_end":110,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439297,"byte_end":3439330,"line_start":111,"line_end":111,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12066},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439623,"byte_end":3439633,"line_start":121,"line_end":121,"column_start":15,"column_end":25},"name":"_m_paddusb","qualname":"::core_arch::x86::mmx::_m_paddusb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 8-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439524,"byte_end":3439533,"line_start":118,"line_end":118,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439534,"byte_end":3439567,"line_start":119,"line_end":119,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12068},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439864,"byte_end":3439877,"line_start":129,"line_end":129,"column_start":15,"column_end":28},"name":"_mm_adds_pu16","qualname":"::core_arch::x86::mmx::_mm_adds_pu16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 16-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439765,"byte_end":3439774,"line_start":126,"line_end":126,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3439775,"byte_end":3439808,"line_start":127,"line_end":127,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12070},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440103,"byte_end":3440113,"line_start":137,"line_end":137,"column_start":15,"column_end":25},"name":"_m_paddusw","qualname":"::core_arch::x86::mmx::_m_paddusw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Adds packed unsigned 16-bit integers in `a` and `b` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440004,"byte_end":3440013,"line_start":134,"line_end":134,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440014,"byte_end":3440047,"line_start":135,"line_end":135,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12072},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440346,"byte_end":3440357,"line_start":145,"line_end":145,"column_start":15,"column_end":26},"name":"_mm_sub_pi8","qualname":"::core_arch::x86::mmx::_mm_sub_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440249,"byte_end":3440258,"line_start":142,"line_end":142,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440259,"byte_end":3440292,"line_start":143,"line_end":143,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12074},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440582,"byte_end":3440590,"line_start":153,"line_end":153,"column_start":15,"column_end":23},"name":"_m_psubb","qualname":"::core_arch::x86::mmx::_m_psubb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440485,"byte_end":3440494,"line_start":150,"line_end":150,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440495,"byte_end":3440528,"line_start":151,"line_end":151,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12076},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440823,"byte_end":3440835,"line_start":161,"line_end":161,"column_start":15,"column_end":27},"name":"_mm_sub_pi16","qualname":"::core_arch::x86::mmx::_mm_sub_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440726,"byte_end":3440735,"line_start":158,"line_end":158,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440736,"byte_end":3440769,"line_start":159,"line_end":159,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12078},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441062,"byte_end":3441070,"line_start":169,"line_end":169,"column_start":15,"column_end":23},"name":"_m_psubw","qualname":"::core_arch::x86::mmx::_m_psubw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440965,"byte_end":3440974,"line_start":166,"line_end":166,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3440975,"byte_end":3441008,"line_start":167,"line_end":167,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12080},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441304,"byte_end":3441316,"line_start":177,"line_end":177,"column_start":15,"column_end":27},"name":"_mm_sub_pi32","qualname":"::core_arch::x86::mmx::_mm_sub_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441207,"byte_end":3441216,"line_start":174,"line_end":174,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441217,"byte_end":3441250,"line_start":175,"line_end":175,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12082},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441543,"byte_end":3441551,"line_start":185,"line_end":185,"column_start":15,"column_end":23},"name":"_m_psubd","qualname":"::core_arch::x86::mmx::_m_psubd","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 32-bit integers in `b` from packed 32-bit integers in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441446,"byte_end":3441455,"line_start":182,"line_end":182,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441456,"byte_end":3441489,"line_start":183,"line_end":183,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12084},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441805,"byte_end":3441817,"line_start":194,"line_end":194,"column_start":15,"column_end":27},"name":"_mm_subs_pi8","qualname":"::core_arch::x86::mmx::_mm_subs_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`\n using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441707,"byte_end":3441716,"line_start":191,"line_end":191,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441717,"byte_end":3441750,"line_start":192,"line_end":192,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12086},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442065,"byte_end":3442074,"line_start":203,"line_end":203,"column_start":15,"column_end":24},"name":"_m_psubsb","qualname":"::core_arch::x86::mmx::_m_psubsb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 8-bit integers in `b` from packed 8-bit integers in `a`\n using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441967,"byte_end":3441976,"line_start":200,"line_end":200,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3441977,"byte_end":3442010,"line_start":201,"line_end":201,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12088},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442330,"byte_end":3442343,"line_start":212,"line_end":212,"column_start":15,"column_end":28},"name":"_mm_subs_pi16","qualname":"::core_arch::x86::mmx::_mm_subs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`\n using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442232,"byte_end":3442241,"line_start":209,"line_end":209,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442242,"byte_end":3442275,"line_start":210,"line_end":210,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12090},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442593,"byte_end":3442602,"line_start":221,"line_end":221,"column_start":15,"column_end":24},"name":"_m_psubsw","qualname":"::core_arch::x86::mmx::_m_psubsw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed 16-bit integers in `b` from packed 16-bit integers in `a`\n using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442495,"byte_end":3442504,"line_start":218,"line_end":218,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442505,"byte_end":3442538,"line_start":219,"line_end":219,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12092},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442876,"byte_end":3442888,"line_start":230,"line_end":230,"column_start":15,"column_end":27},"name":"_mm_subs_pu8","qualname":"::core_arch::x86::mmx::_mm_subs_pu8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit\n integers in `a` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442777,"byte_end":3442786,"line_start":227,"line_end":227,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3442787,"byte_end":3442820,"line_start":228,"line_end":228,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12094},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443156,"byte_end":3443166,"line_start":239,"line_end":239,"column_start":15,"column_end":25},"name":"_m_psubusb","qualname":"::core_arch::x86::mmx::_m_psubusb","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 8-bit integers in `b` from packed unsigned 8-bit\n integers in `a` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443057,"byte_end":3443066,"line_start":236,"line_end":236,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443067,"byte_end":3443100,"line_start":237,"line_end":237,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12096},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443441,"byte_end":3443454,"line_start":248,"line_end":248,"column_start":15,"column_end":28},"name":"_mm_subs_pu16","qualname":"::core_arch::x86::mmx::_mm_subs_pu16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 16-bit integers in `b` from packed unsigned\n 16-bit integers in `a` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443342,"byte_end":3443351,"line_start":245,"line_end":245,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443352,"byte_end":3443385,"line_start":246,"line_end":246,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12098},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443724,"byte_end":3443734,"line_start":257,"line_end":257,"column_start":15,"column_end":25},"name":"_m_psubusw","qualname":"::core_arch::x86::mmx::_m_psubusw","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Subtract packed unsigned 16-bit integers in `b` from packed unsigned\n 16-bit integers in `a` using saturation.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443625,"byte_end":3443634,"line_start":254,"line_end":254,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3443635,"byte_end":3443668,"line_start":255,"line_end":255,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12100},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444123,"byte_end":3444137,"line_start":269,"line_end":269,"column_start":15,"column_end":29},"name":"_mm_packs_pi16","qualname":"::core_arch::x86::mmx::_mm_packs_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 16-bit integers from `a` and `b` to packed 8-bit integers\n using signed saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444023,"byte_end":3444032,"line_start":266,"line_end":266,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444033,"byte_end":3444066,"line_start":267,"line_end":267,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12102},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444522,"byte_end":3444536,"line_start":281,"line_end":281,"column_start":15,"column_end":29},"name":"_mm_packs_pi32","qualname":"::core_arch::x86::mmx::_mm_packs_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Converts packed 32-bit integers from `a` and `b` to packed 16-bit integers\n using signed saturation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444422,"byte_end":3444431,"line_start":278,"line_end":278,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444432,"byte_end":3444465,"line_start":279,"line_end":279,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12104},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444830,"byte_end":3444843,"line_start":290,"line_end":290,"column_start":15,"column_end":28},"name":"_mm_cmpgt_pi8","qualname":"::core_arch::x86::mmx::_mm_cmpgt_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares whether each element of `a` is greater than the corresponding\n element of `b` returning `0` for `false` and `-1` for `true`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444731,"byte_end":3444740,"line_start":287,"line_end":287,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3444741,"byte_end":3444774,"line_start":288,"line_end":288,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12106},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445136,"byte_end":3445150,"line_start":299,"line_end":299,"column_start":15,"column_end":29},"name":"_mm_cmpgt_pi16","qualname":"::core_arch::x86::mmx::_mm_cmpgt_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares whether each element of `a` is greater than the corresponding\n element of `b` returning `0` for `false` and `-1` for `true`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445037,"byte_end":3445046,"line_start":296,"line_end":296,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445047,"byte_end":3445080,"line_start":297,"line_end":297,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12108},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445443,"byte_end":3445457,"line_start":308,"line_end":308,"column_start":15,"column_end":29},"name":"_mm_cmpgt_pi32","qualname":"::core_arch::x86::mmx::_mm_cmpgt_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Compares whether each element of `a` is greater than the corresponding\n element of `b` returning `0` for `false` and `-1` for `true`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445344,"byte_end":3445353,"line_start":305,"line_end":305,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445354,"byte_end":3445387,"line_start":306,"line_end":306,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12110},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445765,"byte_end":3445782,"line_start":317,"line_end":317,"column_start":15,"column_end":32},"name":"_mm_unpackhi_pi16","qualname":"::core_arch::x86::mmx::_mm_unpackhi_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the upper two elements from two `i16x4` vectors and interleaves\n them into the result: `[a.2, b.2, a.3, b.3]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445636,"byte_end":3445645,"line_start":314,"line_end":314,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445646,"byte_end":3445679,"line_start":315,"line_end":315,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12112},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446084,"byte_end":3446100,"line_start":326,"line_end":326,"column_start":15,"column_end":31},"name":"_mm_unpackhi_pi8","qualname":"::core_arch::x86::mmx::_mm_unpackhi_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the upper four elements from two `i8x8` vectors and interleaves\n them into the result: `[a.4, b.4, a.5, b.5, a.6, b.6, a.7, b.7]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445983,"byte_end":3445992,"line_start":323,"line_end":323,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3445993,"byte_end":3446026,"line_start":324,"line_end":324,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12114},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446402,"byte_end":3446418,"line_start":335,"line_end":335,"column_start":15,"column_end":31},"name":"_mm_unpacklo_pi8","qualname":"::core_arch::x86::mmx::_mm_unpacklo_pi8","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the lower four elements from two `i8x8` vectors and interleaves\n them into the result: `[a.0, b.0, a.1, b.1, a.2, b.2, a.3, b.3]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446301,"byte_end":3446310,"line_start":332,"line_end":332,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446311,"byte_end":3446344,"line_start":333,"line_end":333,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12116},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446697,"byte_end":3446714,"line_start":344,"line_end":344,"column_start":15,"column_end":32},"name":"_mm_unpacklo_pi16","qualname":"::core_arch::x86::mmx::_mm_unpacklo_pi16","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the lower two elements from two `i16x4` vectors and interleaves\n them into the result: `[a.0 b.0 a.1 b.1]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446596,"byte_end":3446605,"line_start":341,"line_end":341,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446606,"byte_end":3446639,"line_start":342,"line_end":342,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12118},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446981,"byte_end":3446998,"line_start":353,"line_end":353,"column_start":15,"column_end":32},"name":"_mm_unpackhi_pi32","qualname":"::core_arch::x86::mmx::_mm_unpackhi_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the upper element from two `i32x2` vectors and interleaves them\n into the result: `[a.1, b.1]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446880,"byte_end":3446889,"line_start":350,"line_end":350,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3446890,"byte_end":3446923,"line_start":351,"line_end":351,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12120},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447265,"byte_end":3447282,"line_start":362,"line_end":362,"column_start":15,"column_end":32},"name":"_mm_unpacklo_pi32","qualname":"::core_arch::x86::mmx::_mm_unpacklo_pi32","value":"fn (a: __m64, b: __m64) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Unpacks the lower element from two `i32x2` vectors and interleaves them\n into the result: `[a.0, b.0]`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447164,"byte_end":3447173,"line_start":359,"line_end":359,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447174,"byte_end":3447207,"line_start":360,"line_end":360,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12122},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447460,"byte_end":3447472,"line_start":369,"line_end":369,"column_start":15,"column_end":27},"name":"_mm_set_pi16","qualname":"::core_arch::x86::mmx::_mm_set_pi16","value":"fn (e3: i16, e2: i16, e1: i16, e0: i16) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers in dst with the supplied values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447402,"byte_end":3447411,"line_start":367,"line_end":367,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447412,"byte_end":3447445,"line_start":368,"line_end":368,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12124},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447680,"byte_end":3447692,"line_start":376,"line_end":376,"column_start":15,"column_end":27},"name":"_mm_set_pi32","qualname":"::core_arch::x86::mmx::_mm_set_pi32","value":"fn (e1: i32, e0: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in dst with the supplied values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447622,"byte_end":3447631,"line_start":374,"line_end":374,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447632,"byte_end":3447665,"line_start":375,"line_end":375,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12126},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447873,"byte_end":3447884,"line_start":383,"line_end":383,"column_start":15,"column_end":26},"name":"_mm_set_pi8","qualname":"::core_arch::x86::mmx::_mm_set_pi8","value":"fn (e7: i8, e6: i8, e5: i8, e4: i8, e3: i8, e2: i8, e1: i8, e0: i8) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers in dst with the supplied values.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447815,"byte_end":3447824,"line_start":381,"line_end":381,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3447825,"byte_end":3447858,"line_start":382,"line_end":382,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12128},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448130,"byte_end":3448143,"line_start":390,"line_end":390,"column_start":15,"column_end":28},"name":"_mm_set1_pi16","qualname":"::core_arch::x86::mmx::_mm_set1_pi16","value":"fn (a: i16) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 16-bit integer a to all all elements of dst.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448072,"byte_end":3448081,"line_start":388,"line_end":388,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448082,"byte_end":3448115,"line_start":389,"line_end":389,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12130},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448314,"byte_end":3448327,"line_start":397,"line_end":397,"column_start":15,"column_end":28},"name":"_mm_set1_pi32","qualname":"::core_arch::x86::mmx::_mm_set1_pi32","value":"fn (a: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 32-bit integer a to all all elements of dst.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448256,"byte_end":3448265,"line_start":395,"line_end":395,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448266,"byte_end":3448299,"line_start":396,"line_end":396,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12132},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448491,"byte_end":3448503,"line_start":404,"line_end":404,"column_start":15,"column_end":27},"name":"_mm_set1_pi8","qualname":"::core_arch::x86::mmx::_mm_set1_pi8","value":"fn (a: i8) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Broadcasts 8-bit integer a to all all elements of dst.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448433,"byte_end":3448442,"line_start":402,"line_end":402,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448443,"byte_end":3448476,"line_start":403,"line_end":403,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12134},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448710,"byte_end":3448723,"line_start":412,"line_end":412,"column_start":15,"column_end":28},"name":"_mm_setr_pi16","qualname":"::core_arch::x86::mmx::_mm_setr_pi16","value":"fn (e0: i16, e1: i16, e2: i16, e3: i16) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 16-bit integers in dst with the supplied values in reverse\n order.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448652,"byte_end":3448661,"line_start":410,"line_end":410,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448662,"byte_end":3448695,"line_start":411,"line_end":411,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12136},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448960,"byte_end":3448973,"line_start":420,"line_end":420,"column_start":15,"column_end":28},"name":"_mm_setr_pi32","qualname":"::core_arch::x86::mmx::_mm_setr_pi32","value":"fn (e0: i32, e1: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in dst with the supplied values in reverse\n order.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448902,"byte_end":3448911,"line_start":418,"line_end":418,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3448912,"byte_end":3448945,"line_start":419,"line_end":419,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12138},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449179,"byte_end":3449191,"line_start":427,"line_end":427,"column_start":15,"column_end":27},"name":"_mm_setr_pi8","qualname":"::core_arch::x86::mmx::_mm_setr_pi8","value":"fn (e0: i8, e1: i8, e2: i8, e3: i8, e4: i8, e5: i8, e6: i8, e7: i8) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 8-bit integers in dst with the supplied values in reverse order.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449121,"byte_end":3449130,"line_start":425,"line_end":425,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449131,"byte_end":3449164,"line_start":426,"line_end":426,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12140},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449642,"byte_end":3449651,"line_start":446,"line_end":446,"column_start":15,"column_end":24},"name":"_mm_empty","qualname":"::core_arch::x86::mmx::_mm_empty","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Empty the MMX state, which marks the x87 FPU registers as available for use\n by x87 instructions. This instruction must be used at the end of all MMX\n technology procedures.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449546,"byte_end":3449555,"line_start":443,"line_end":443,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449556,"byte_end":3449589,"line_start":444,"line_end":444,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12142},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449950,"byte_end":3449958,"line_start":456,"line_end":456,"column_start":15,"column_end":23},"name":"_m_empty","qualname":"::core_arch::x86::mmx::_m_empty","value":"fn () -> ()","parent":null,"children":[],"decl_id":null,"docs":" Empty the MMX state, which marks the x87 FPU registers as available for use\n by x87 instructions. This instruction must be used at the end of all MMX\n technology procedures.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449854,"byte_end":3449863,"line_start":453,"line_end":453,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3449864,"byte_end":3449897,"line_start":454,"line_end":454,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12144},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3450160,"byte_end":3450176,"line_start":464,"line_end":464,"column_start":15,"column_end":31},"name":"_mm_cvtsi32_si64","qualname":"::core_arch::x86::mmx::_mm_cvtsi32_si64","value":"fn (a: i32) -> __m64","parent":null,"children":[],"decl_id":null,"docs":" Copies 32-bit integer `a` to the lower elements of the return value, and zero\n the upper element of the return value.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3450102,"byte_end":3450111,"line_start":462,"line_end":462,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3450112,"byte_end":3450145,"line_start":463,"line_end":463,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12146},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3450333,"byte_end":3450349,"line_start":471,"line_end":471,"column_start":15,"column_end":31},"name":"_mm_cvtsi64_si32","qualname":"::core_arch::x86::mmx::_mm_cvtsi64_si32","value":"fn (a: __m64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Return the lower 32-bit integer in `a`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3450275,"byte_end":3450284,"line_start":469,"line_end":469,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"mmx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mmx.rs","byte_start":3450285,"byte_end":3450318,"line_start":470,"line_end":470,"column_start":1,"column_end":34}}]},{"kind":"Function","id":{"krate":0,"index":12158},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3463105,"byte_end":3463125,"line_start":35,"line_end":35,"column_start":15,"column_end":35},"name":"_mm_clmulepi64_si128","qualname":"::core_arch::x86::pclmulqdq::_mm_clmulepi64_si128","value":"fn (a: __m128i, b: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs a carry-less multiplication of two 64-bit polynomials over the\n finite field GF(2^k).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3462545,"byte_end":3462554,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"pclmulqdq\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3462555,"byte_end":3462594,"line_start":27,"line_end":27,"column_start":1,"column_end":40}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3463009,"byte_end":3463040,"line_start":33,"line_end":33,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/pclmulqdq.rs","byte_start":3463041,"byte_end":3463090,"line_start":34,"line_end":34,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12170},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3466300,"byte_end":3466316,"line_start":38,"line_end":38,"column_start":15,"column_end":31},"name":"_mm_aesdec_si128","qualname":"::core_arch::x86::aes::_mm_aesdec_si128","value":"fn (a: __m128i, round_key: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs one round of an AES decryption flow on data (state) in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3466152,"byte_end":3466161,"line_start":34,"line_end":34,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3466162,"byte_end":3466195,"line_start":35,"line_end":35,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3466236,"byte_end":3466285,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12172},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3466741,"byte_end":3466761,"line_start":49,"line_end":49,"column_start":15,"column_end":35},"name":"_mm_aesdeclast_si128","qualname":"::core_arch::x86::aes::_mm_aesdeclast_si128","value":"fn (a: __m128i, round_key: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the last round of an AES decryption flow on data (state) in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3466589,"byte_end":3466598,"line_start":45,"line_end":45,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3466599,"byte_end":3466632,"line_start":46,"line_end":46,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3466677,"byte_end":3466726,"line_start":48,"line_end":48,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12174},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467177,"byte_end":3467193,"line_start":60,"line_end":60,"column_start":15,"column_end":31},"name":"_mm_aesenc_si128","qualname":"::core_arch::x86::aes::_mm_aesenc_si128","value":"fn (a: __m128i, round_key: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs one round of an AES encryption flow on data (state) in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467029,"byte_end":3467038,"line_start":56,"line_end":56,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467039,"byte_end":3467072,"line_start":57,"line_end":57,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467113,"byte_end":3467162,"line_start":59,"line_end":59,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12176},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467618,"byte_end":3467638,"line_start":71,"line_end":71,"column_start":15,"column_end":35},"name":"_mm_aesenclast_si128","qualname":"::core_arch::x86::aes::_mm_aesenclast_si128","value":"fn (a: __m128i, round_key: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the last round of an AES encryption flow on data (state) in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467466,"byte_end":3467475,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467476,"byte_end":3467509,"line_start":68,"line_end":68,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467554,"byte_end":3467603,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12178},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3468037,"byte_end":3468053,"line_start":82,"line_end":82,"column_start":15,"column_end":31},"name":"_mm_aesimc_si128","qualname":"::core_arch::x86::aes::_mm_aesimc_si128","value":"fn (a: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the `InvMixColumns` transformation on `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467889,"byte_end":3467898,"line_start":78,"line_end":78,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467899,"byte_end":3467932,"line_start":79,"line_end":79,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3467973,"byte_end":3468022,"line_start":81,"line_end":81,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12180},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3468648,"byte_end":3468673,"line_start":98,"line_end":98,"column_start":15,"column_end":40},"name":"_mm_aeskeygenassist_si128","qualname":"::core_arch::x86::aes::_mm_aeskeygenassist_si128","value":"fn (a: __m128i, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Assist in expanding the AES cipher key.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3468449,"byte_end":3468458,"line_start":93,"line_end":93,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"aes\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3468459,"byte_end":3468492,"line_start":94,"line_end":94,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3468552,"byte_end":3468583,"line_start":96,"line_end":96,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/aes.rs","byte_start":3468584,"byte_end":3468633,"line_start":97,"line_end":97,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12190},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3472875,"byte_end":3472889,"line_start":29,"line_end":29,"column_start":15,"column_end":29},"name":"_rdrand16_step","qualname":"::core_arch::x86::rdrand::_rdrand16_step","value":"fn (val: &mut u16) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a hardware generated 16-bit random value and store the result in val.\n Returns 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3472724,"byte_end":3472733,"line_start":25,"line_end":25,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdrand\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3472734,"byte_end":3472770,"line_start":26,"line_end":26,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3472811,"byte_end":3472860,"line_start":28,"line_end":28,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12192},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3473390,"byte_end":3473404,"line_start":43,"line_end":43,"column_start":15,"column_end":29},"name":"_rdrand32_step","qualname":"::core_arch::x86::rdrand::_rdrand32_step","value":"fn (val: &mut u32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a hardware generated 32-bit random value and store the result in val.\n Returns 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3473239,"byte_end":3473248,"line_start":39,"line_end":39,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdrand\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3473249,"byte_end":3473285,"line_start":40,"line_end":40,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3473326,"byte_end":3473375,"line_start":42,"line_end":42,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12194},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3473913,"byte_end":3473927,"line_start":57,"line_end":57,"column_start":15,"column_end":29},"name":"_rdseed16_step","qualname":"::core_arch::x86::rdrand::_rdseed16_step","value":"fn (val: &mut u16) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a 16-bit NIST SP800-90B and SP800-90C compliant random value and store\n in val. Return 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3473762,"byte_end":3473771,"line_start":53,"line_end":53,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdseed\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3473772,"byte_end":3473808,"line_start":54,"line_end":54,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3473849,"byte_end":3473898,"line_start":56,"line_end":56,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12196},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3474436,"byte_end":3474450,"line_start":71,"line_end":71,"column_start":15,"column_end":29},"name":"_rdseed32_step","qualname":"::core_arch::x86::rdrand::_rdseed32_step","value":"fn (val: &mut u32) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a 32-bit NIST SP800-90B and SP800-90C compliant random value and store\n in val. Return 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3474285,"byte_end":3474294,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdseed\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3474295,"byte_end":3474331,"line_start":68,"line_end":68,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/rdrand.rs","byte_start":3474372,"byte_end":3474421,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12214},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3475788,"byte_end":3475806,"line_start":36,"line_end":36,"column_start":15,"column_end":33},"name":"_mm_sha1msg1_epu32","qualname":"::core_arch::x86::sha::_mm_sha1msg1_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs an intermediate calculation for the next four SHA1 message values\n (unsigned 32-bit integers) using previous message values from `a` and `b`,\n and returning the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3475638,"byte_end":3475647,"line_start":32,"line_end":32,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3475648,"byte_end":3475681,"line_start":33,"line_end":33,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3475724,"byte_end":3475773,"line_start":35,"line_end":35,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12216},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3476377,"byte_end":3476395,"line_start":49,"line_end":49,"column_start":15,"column_end":33},"name":"_mm_sha1msg2_epu32","qualname":"::core_arch::x86::sha::_mm_sha1msg2_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the final calculation for the next four SHA1 message values\n (unsigned 32-bit integers) using the intermediate result in `a` and the\n previous message values in `b`, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3476227,"byte_end":3476236,"line_start":45,"line_end":45,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3476237,"byte_end":3476270,"line_start":46,"line_end":46,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3476313,"byte_end":3476362,"line_start":48,"line_end":48,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12218},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3476974,"byte_end":3476993,"line_start":62,"line_end":62,"column_start":15,"column_end":34},"name":"_mm_sha1nexte_epu32","qualname":"::core_arch::x86::sha::_mm_sha1nexte_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Calculate SHA1 state variable E after four rounds of operation from the\n current SHA1 state variable `a`, add that value to the scheduled values\n (unsigned 32-bit integers) in `b`, and returns the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3476823,"byte_end":3476832,"line_start":58,"line_end":58,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3476833,"byte_end":3476866,"line_start":59,"line_end":59,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3476910,"byte_end":3476959,"line_start":61,"line_end":61,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12220},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3477728,"byte_end":3477747,"line_start":78,"line_end":78,"column_start":15,"column_end":34},"name":"_mm_sha1rnds4_epu32","qualname":"::core_arch::x86::sha::_mm_sha1rnds4_epu32","value":"fn (a: __m128i, b: __m128i, func: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs four rounds of SHA1 operation using an initial SHA1 state (A,B,C,D)\n from `a` and some pre-computed sum of the next 4 round message values\n (unsigned 32-bit integers), and state variable E from `b`, and return the\n updated SHA1 state (A,B,C,D). `func` contains the logic functions and round\n constants.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3477535,"byte_end":3477544,"line_start":73,"line_end":73,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3477545,"byte_end":3477578,"line_start":74,"line_end":74,"column_start":1,"column_end":34}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3477632,"byte_end":3477663,"line_start":76,"line_end":76,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3477664,"byte_end":3477713,"line_start":77,"line_end":77,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12224},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3478474,"byte_end":3478494,"line_start":99,"line_end":99,"column_start":15,"column_end":35},"name":"_mm_sha256msg1_epu32","qualname":"::core_arch::x86::sha::_mm_sha256msg1_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs an intermediate calculation for the next four SHA256 message values\n (unsigned 32-bit integers) using previous message values from `a` and `b`,\n and return the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3478322,"byte_end":3478331,"line_start":95,"line_end":95,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3478332,"byte_end":3478365,"line_start":96,"line_end":96,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3478410,"byte_end":3478459,"line_start":98,"line_end":98,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12226},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3479043,"byte_end":3479063,"line_start":112,"line_end":112,"column_start":15,"column_end":35},"name":"_mm_sha256msg2_epu32","qualname":"::core_arch::x86::sha::_mm_sha256msg2_epu32","value":"fn (a: __m128i, b: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs the final calculation for the next four SHA256 message values\n (unsigned 32-bit integers) using previous message values from `a` and `b`,\n and return the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3478891,"byte_end":3478900,"line_start":108,"line_end":108,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3478901,"byte_end":3478934,"line_start":109,"line_end":109,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3478979,"byte_end":3479028,"line_start":111,"line_end":111,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12228},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3479771,"byte_end":3479792,"line_start":127,"line_end":127,"column_start":15,"column_end":36},"name":"_mm_sha256rnds2_epu32","qualname":"::core_arch::x86::sha::_mm_sha256rnds2_epu32","value":"fn (a: __m128i, b: __m128i, k: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Performs 2 rounds of SHA256 operation using an initial SHA256 state\n (C,D,G,H) from `a`, an initial SHA256 state (A,B,E,F) from `b`, and a\n pre-computed sum of the next 2 round message values (unsigned 32-bit\n integers) and the corresponding round constants from `k`, and store the\n updated SHA256 state (A,B,E,F) in dst.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3479618,"byte_end":3479627,"line_start":123,"line_end":123,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sha\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3479628,"byte_end":3479661,"line_start":124,"line_end":124,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/sha.rs","byte_start":3479707,"byte_end":3479756,"line_start":126,"line_end":126,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12236},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3484439,"byte_end":3484452,"line_start":20,"line_end":20,"column_start":15,"column_end":28},"name":"_addcarry_u32","qualname":"::core_arch::x86::adx::_addcarry_u32","value":"fn (c_in: u8, a: u32, b: u32, out: &mut u32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry flag), and store the unsigned 32-bit result in `out`, and the carry-out\n is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3484324,"byte_end":3484333,"line_start":17,"line_end":17,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3484371,"byte_end":3484424,"line_start":19,"line_end":19,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":12238},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3484941,"byte_end":3484955,"line_start":33,"line_end":33,"column_start":15,"column_end":29},"name":"_addcarryx_u32","qualname":"::core_arch::x86::adx::_addcarryx_u32","value":"fn (c_in: u8, a: u32, b: u32, out: &mut u32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry or overflow flag), and store the unsigned 32-bit result in `out`, and\n the carry-out is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3484792,"byte_end":3484801,"line_start":29,"line_end":29,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"adx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3484802,"byte_end":3484835,"line_start":30,"line_end":30,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3484873,"byte_end":3484926,"line_start":32,"line_end":32,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":12240},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3485403,"byte_end":3485417,"line_start":43,"line_end":43,"column_start":15,"column_end":29},"name":"_subborrow_u32","qualname":"::core_arch::x86::adx::_subborrow_u32","value":"fn (c_in: u8, a: u32, b: u32, out: &mut u32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 32-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry or overflow flag), and store the unsigned 32-bit result in `out`, and\n the carry-out is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3485288,"byte_end":3485297,"line_start":40,"line_end":40,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/adx.rs","byte_start":3485335,"byte_end":3485388,"line_start":42,"line_end":42,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":12244},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469913,"byte_end":2469916,"line_start":556,"line_end":556,"column_start":15,"column_end":18},"name":"ud2","qualname":"::core_arch::x86::ud2","value":"fn () -> !","parent":null,"children":[],"decl_id":null,"docs":" Generates the trap instruction `UD2`\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2469889,"byte_end":2469898,"line_start":555,"line_end":555,"column_start":1,"column_end":10}}]},{"kind":"Function","id":{"krate":0,"index":12264},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3488566,"byte_end":3488582,"line_start":15,"line_end":15,"column_start":15,"column_end":31},"name":"_mm512_abs_epi32","qualname":"::core_arch::x86::avx512f::_mm512_abs_epi32","value":"fn (a: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute values of packed 32-bit integers in `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3488464,"byte_end":3488473,"line_start":12,"line_end":12,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3488474,"byte_end":3488511,"line_start":13,"line_end":13,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":12266},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3489306,"byte_end":3489327,"line_start":32,"line_end":32,"column_start":15,"column_end":36},"name":"_mm512_mask_abs_epi32","qualname":"::core_arch::x86::avx512f::_mm512_mask_abs_epi32","value":"fn (src: __m512i, k: __mmask16, a: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 32-bit integers in `a`, and store the\n unsigned results in `dst` using writemask `k` (elements are copied from\n `src` when the corresponding mask bit is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3489204,"byte_end":3489213,"line_start":29,"line_end":29,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3489214,"byte_end":3489251,"line_start":30,"line_end":30,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":12268},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3489969,"byte_end":3489991,"line_start":45,"line_end":45,"column_start":15,"column_end":37},"name":"_mm512_maskz_abs_epi32","qualname":"::core_arch::x86::avx512f::_mm512_maskz_abs_epi32","value":"fn (k: __mmask16, a: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value of packed 32-bit integers in `a`, and store the\n unsigned results in `dst` using zeromask `k` (elements are zeroed out when\n the corresponding mask bit is not set).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3489867,"byte_end":3489876,"line_start":42,"line_end":42,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3489877,"byte_end":3489914,"line_start":43,"line_end":43,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":12270},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3490510,"byte_end":3490530,"line_start":57,"line_end":57,"column_start":15,"column_end":35},"name":"_mm512_setzero_si512","qualname":"::core_arch::x86::avx512f::_mm512_setzero_si512","value":"fn () -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Returns vector of type `__m512i` with all elements set to zero.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3490408,"byte_end":3490417,"line_start":54,"line_end":54,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3490418,"byte_end":3490455,"line_start":55,"line_end":55,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":12272},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3490764,"byte_end":3490781,"line_start":66,"line_end":66,"column_start":15,"column_end":32},"name":"_mm512_setr_epi32","qualname":"::core_arch::x86::avx512f::_mm512_setr_epi32","value":"fn (e15: i32, e14: i32, e13: i32, e12: i32, e11: i32, e10: i32, e9: i32, e8: i32, e7: i32, e6: i32, e5: i32, e4: i32, e3: i32, e2: i32, e1: i32, e0: i32) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Sets packed 32-bit integers in `dst` with the supplied values in reverse\n order.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3490702,"byte_end":3490711,"line_start":64,"line_end":64,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3490712,"byte_end":3490749,"line_start":65,"line_end":65,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":12274},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3491258,"byte_end":3491275,"line_start":93,"line_end":93,"column_start":15,"column_end":32},"name":"_mm512_set1_epi64","qualname":"::core_arch::x86::avx512f::_mm512_set1_epi64","value":"fn (a: i64) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Broadcast 64-bit integer `a` to all elements of `dst`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3491196,"byte_end":3491205,"line_start":91,"line_end":91,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512f\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512f.rs","byte_start":3491206,"byte_end":3491243,"line_start":92,"line_end":92,"column_start":1,"column_end":38}}]},{"kind":"Function","id":{"krate":0,"index":12282},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3494492,"byte_end":3494513,"line_start":16,"line_end":16,"column_start":15,"column_end":36},"name":"_mm512_madd52hi_epu64","qualname":"::core_arch::x86::avx512ifma::_mm512_madd52hi_epu64","value":"fn (a: __m512i, b: __m512i, c: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3494382,"byte_end":3494391,"line_start":13,"line_end":13,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3494392,"byte_end":3494432,"line_start":14,"line_end":14,"column_start":1,"column_end":41}}]},{"kind":"Function","id":{"krate":0,"index":12284},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3495127,"byte_end":3495148,"line_start":30,"line_end":30,"column_start":15,"column_end":36},"name":"_mm512_madd52lo_epu64","qualname":"::core_arch::x86::avx512ifma::_mm512_madd52lo_epu64","value":"fn (a: __m512i, b: __m512i, c: __m512i) -> __m512i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3495017,"byte_end":3495026,"line_start":27,"line_end":27,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3495027,"byte_end":3495067,"line_start":28,"line_end":28,"column_start":1,"column_end":41}}]},{"kind":"Function","id":{"krate":0,"index":12286},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3495795,"byte_end":3495816,"line_start":44,"line_end":44,"column_start":15,"column_end":36},"name":"_mm256_madd52hi_epu64","qualname":"::core_arch::x86::avx512ifma::_mm256_madd52hi_epu64","value":"fn (a: __m256i, b: __m256i, c: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3495676,"byte_end":3495685,"line_start":41,"line_end":41,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma,avx512vl\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3495686,"byte_end":3495735,"line_start":42,"line_end":42,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12288},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3496462,"byte_end":3496483,"line_start":58,"line_end":58,"column_start":15,"column_end":36},"name":"_mm256_madd52lo_epu64","qualname":"::core_arch::x86::avx512ifma::_mm256_madd52lo_epu64","value":"fn (a: __m256i, b: __m256i, c: __m256i) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3496343,"byte_end":3496352,"line_start":55,"line_end":55,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma,avx512vl\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3496353,"byte_end":3496402,"line_start":56,"line_end":56,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12290},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3497135,"byte_end":3497153,"line_start":72,"line_end":72,"column_start":15,"column_end":33},"name":"_mm_madd52hi_epu64","qualname":"::core_arch::x86::avx512ifma::_mm_madd52hi_epu64","value":"fn (a: __m128i, b: __m128i, c: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the high 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3497016,"byte_end":3497025,"line_start":69,"line_end":69,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma,avx512vl\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3497026,"byte_end":3497075,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12292},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3497804,"byte_end":3497822,"line_start":86,"line_end":86,"column_start":15,"column_end":33},"name":"_mm_madd52lo_epu64","qualname":"::core_arch::x86::avx512ifma::_mm_madd52lo_epu64","value":"fn (a: __m128i, b: __m128i, c: __m128i) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Multiply packed unsigned 52-bit integers in each 64-bit element of\n `b` and `c` to form a 104-bit intermediate result. Add the low 52-bit\n unsigned integer from the intermediate result with the\n corresponding unsigned 64-bit integer in `a`, and store the\n results in `dst`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3497685,"byte_end":3497694,"line_start":83,"line_end":83,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx512ifma,avx512vl\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/avx512ifma.rs","byte_start":3497695,"byte_end":3497744,"line_start":84,"line_end":84,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12300},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3501798,"byte_end":3501806,"line_start":8,"line_end":8,"column_start":15,"column_end":23},"name":"_bittest","qualname":"::core_arch::x86::bt::_bittest","value":"fn (p: *const i32, b: i32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3501679,"byte_end":3501688,"line_start":5,"line_end":5,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3501725,"byte_end":3501783,"line_start":7,"line_end":7,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":12302},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502187,"byte_end":3502201,"line_start":21,"line_end":21,"column_start":15,"column_end":29},"name":"_bittestandset","qualname":"::core_arch::x86::bt::_bittestandset","value":"fn (p: *mut i32, b: i32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then sets the bit to `1`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502067,"byte_end":3502076,"line_start":18,"line_end":18,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502114,"byte_end":3502172,"line_start":20,"line_end":20,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":12304},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502585,"byte_end":3502601,"line_start":34,"line_end":34,"column_start":15,"column_end":31},"name":"_bittestandreset","qualname":"::core_arch::x86::bt::_bittestandreset","value":"fn (p: *mut i32, b: i32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then resets that bit to `0`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502465,"byte_end":3502474,"line_start":31,"line_end":31,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502512,"byte_end":3502570,"line_start":33,"line_end":33,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":12306},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502979,"byte_end":3503000,"line_start":47,"line_end":47,"column_start":15,"column_end":36},"name":"_bittestandcomplement","qualname":"::core_arch::x86::bt::_bittestandcomplement","value":"fn (p: *mut i32, b: i32) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then inverts that bit.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502859,"byte_end":3502868,"line_start":44,"line_end":44,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/bt.rs","byte_start":3502906,"byte_end":3502964,"line_start":46,"line_end":46,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":12316},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3506173,"byte_end":3506182,"line_start":30,"line_end":30,"column_start":15,"column_end":24},"name":"_fxsave64","qualname":"::core_arch::x86_64::fxsr::_fxsave64","value":"fn (mem_addr: *mut u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3506022,"byte_end":3506031,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fxsr\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3506032,"byte_end":3506066,"line_start":27,"line_end":27,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3506109,"byte_end":3506158,"line_start":29,"line_end":29,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12318},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3507054,"byte_end":3507064,"line_start":54,"line_end":54,"column_start":15,"column_end":25},"name":"_fxrstor64","qualname":"::core_arch::x86_64::fxsr::_fxrstor64","value":"fn (mem_addr: *const u8) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Restores the `XMM`, `MMX`, `MXCSR`, and `x87` FPU registers from the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3506902,"byte_end":3506911,"line_start":50,"line_end":50,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"fxsr\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3506912,"byte_end":3506946,"line_start":51,"line_end":51,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/fxsr.rs","byte_start":3506990,"byte_end":3507039,"line_start":53,"line_end":53,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12328},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3509660,"byte_end":3509674,"line_start":33,"line_end":33,"column_start":15,"column_end":29},"name":"_mm_cvtss_si64","qualname":"::core_arch::x86_64::sse::_mm_cvtss_si64","value":"fn (a: __m128) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Converts the lowest 32 bit float in the input vector to a 64 bit integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3509510,"byte_end":3509519,"line_start":29,"line_end":29,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3509520,"byte_end":3509553,"line_start":30,"line_end":30,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3509596,"byte_end":3509645,"line_start":32,"line_end":32,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12330},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3510467,"byte_end":3510482,"line_start":52,"line_end":52,"column_start":15,"column_end":30},"name":"_mm_cvttss_si64","qualname":"::core_arch::x86_64::sse::_mm_cvttss_si64","value":"fn (a: __m128) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Converts the lowest 32 bit float in the input vector to a 64 bit integer\n with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3510316,"byte_end":3510325,"line_start":48,"line_end":48,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3510326,"byte_end":3510359,"line_start":49,"line_end":49,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3510403,"byte_end":3510452,"line_start":51,"line_end":51,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12332},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3511039,"byte_end":3511053,"line_start":67,"line_end":67,"column_start":15,"column_end":29},"name":"_mm_cvtsi64_ss","qualname":"::core_arch::x86_64::sse::_mm_cvtsi64_ss","value":"fn (a: __m128, b: i64) -> __m128","parent":null,"children":[],"decl_id":null,"docs":" Converts a 64 bit integer to a 32 bit float. The result vector is the input\n vector `a` with the lowest 32 bit float replaced by the converted integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3510889,"byte_end":3510898,"line_start":63,"line_end":63,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3510899,"byte_end":3510932,"line_start":64,"line_end":64,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse.rs","byte_start":3510975,"byte_end":3511024,"line_start":66,"line_end":66,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12350},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514157,"byte_end":3514171,"line_start":27,"line_end":27,"column_start":15,"column_end":29},"name":"_mm_cvtsd_si64","qualname":"::core_arch::x86_64::sse2::_mm_cvtsd_si64","value":"fn (a: __m128d) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in a to\n a 64-bit integer.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514006,"byte_end":3514015,"line_start":23,"line_end":23,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514016,"byte_end":3514050,"line_start":24,"line_end":24,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514093,"byte_end":3514142,"line_start":26,"line_end":26,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12352},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514512,"byte_end":3514527,"line_start":38,"line_end":38,"column_start":15,"column_end":30},"name":"_mm_cvtsd_si64x","qualname":"::core_arch::x86_64::sse2::_mm_cvtsd_si64x","value":"fn (a: __m128d) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Alias for `_mm_cvtsd_si64`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514361,"byte_end":3514370,"line_start":34,"line_end":34,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514371,"byte_end":3514405,"line_start":35,"line_end":35,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514448,"byte_end":3514497,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12354},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514962,"byte_end":3514977,"line_start":50,"line_end":50,"column_start":15,"column_end":30},"name":"_mm_cvttsd_si64","qualname":"::core_arch::x86_64::sse2::_mm_cvttsd_si64","value":"fn (a: __m128d) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Converts the lower double-precision (64-bit) floating-point element in `a`\n to a 64-bit integer with truncation.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514810,"byte_end":3514819,"line_start":46,"line_end":46,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514820,"byte_end":3514854,"line_start":47,"line_end":47,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3514898,"byte_end":3514947,"line_start":49,"line_end":49,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12356},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3515322,"byte_end":3515338,"line_start":61,"line_end":61,"column_start":15,"column_end":31},"name":"_mm_cvttsd_si64x","qualname":"::core_arch::x86_64::sse2::_mm_cvttsd_si64x","value":"fn (a: __m128d) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Alias for `_mm_cvttsd_si64`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3515170,"byte_end":3515179,"line_start":57,"line_end":57,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3515180,"byte_end":3515214,"line_start":58,"line_end":58,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3515258,"byte_end":3515307,"line_start":60,"line_end":60,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12358},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3515818,"byte_end":3515833,"line_start":74,"line_end":74,"column_start":15,"column_end":30},"name":"_mm_stream_si64","qualname":"::core_arch::x86_64::sse2::_mm_stream_si64","value":"fn (mem_addr: *mut i64, a: i64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Stores a 64-bit integer value in the specified memory location.\n To minimize caching, the data is flagged as non-temporal (unlikely to be\n used again soon).","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3515669,"byte_end":3515678,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3515679,"byte_end":3515713,"line_start":71,"line_end":71,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3515754,"byte_end":3515803,"line_start":73,"line_end":73,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12360},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516285,"byte_end":3516302,"line_start":86,"line_end":86,"column_start":15,"column_end":32},"name":"_mm_cvtsi64_si128","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi64_si128","value":"fn (a: i64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector whose lowest element is `a` and all higher elements are\n `0`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516119,"byte_end":3516128,"line_start":82,"line_end":82,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516129,"byte_end":3516163,"line_start":83,"line_end":83,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516221,"byte_end":3516270,"line_start":85,"line_end":85,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12362},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516723,"byte_end":3516741,"line_start":98,"line_end":98,"column_start":15,"column_end":33},"name":"_mm_cvtsi64x_si128","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi64x_si128","value":"fn (a: i64) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a vector whose lowest element is `a` and all higher elements are\n `0`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516557,"byte_end":3516566,"line_start":94,"line_end":94,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516567,"byte_end":3516601,"line_start":95,"line_end":95,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516659,"byte_end":3516708,"line_start":97,"line_end":97,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12364},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517114,"byte_end":3517131,"line_start":109,"line_end":109,"column_start":15,"column_end":32},"name":"_mm_cvtsi128_si64","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi128_si64","value":"fn (a: __m128i) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Returns the lowest element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516948,"byte_end":3516957,"line_start":105,"line_end":105,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3516958,"byte_end":3516992,"line_start":106,"line_end":106,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517050,"byte_end":3517099,"line_start":108,"line_end":108,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12366},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517514,"byte_end":3517532,"line_start":120,"line_end":120,"column_start":15,"column_end":33},"name":"_mm_cvtsi128_si64x","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi128_si64x","value":"fn (a: __m128i) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Returns the lowest element of `a`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517348,"byte_end":3517357,"line_start":116,"line_end":116,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517358,"byte_end":3517392,"line_start":117,"line_end":117,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517450,"byte_end":3517499,"line_start":119,"line_end":119,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12368},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517940,"byte_end":3517954,"line_start":132,"line_end":132,"column_start":15,"column_end":29},"name":"_mm_cvtsi64_sd","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi64_sd","value":"fn (a: __m128d, b: i64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns `a` with its lower element replaced by `b` after converting it to\n an `f64`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517789,"byte_end":3517798,"line_start":128,"line_end":128,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517799,"byte_end":3517833,"line_start":129,"line_end":129,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3517876,"byte_end":3517925,"line_start":131,"line_end":131,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12370},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3518382,"byte_end":3518397,"line_start":144,"line_end":144,"column_start":15,"column_end":30},"name":"_mm_cvtsi64x_sd","qualname":"::core_arch::x86_64::sse2::_mm_cvtsi64x_sd","value":"fn (a: __m128d, b: i64) -> __m128d","parent":null,"children":[],"decl_id":null,"docs":" Returns `a` with its lower element replaced by `b` after converting it to\n an `f64`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3518231,"byte_end":3518240,"line_start":140,"line_end":140,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3518241,"byte_end":3518275,"line_start":141,"line_end":141,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse2.rs","byte_start":3518318,"byte_end":3518367,"line_start":143,"line_end":143,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12386},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3520793,"byte_end":3520810,"line_start":19,"line_end":19,"column_start":15,"column_end":32},"name":"_mm_extract_epi64","qualname":"::core_arch::x86_64::sse41::_mm_extract_epi64","value":"fn (a: __m128i, imm8: i32) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Extracts an 64-bit integer from `a` selected with `imm8`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3520567,"byte_end":3520576,"line_start":14,"line_end":14,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3520577,"byte_end":3520613,"line_start":15,"line_end":15,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3520697,"byte_end":3520728,"line_start":17,"line_end":17,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3520729,"byte_end":3520778,"line_start":18,"line_end":18,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12388},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3521334,"byte_end":3521350,"line_start":33,"line_end":33,"column_start":15,"column_end":31},"name":"_mm_insert_epi64","qualname":"::core_arch::x86_64::sse41::_mm_insert_epi64","value":"fn (a: __m128i, i: i64, imm8: i32) -> __m128i","parent":null,"children":[],"decl_id":null,"docs":" Returns a copy of `a` with the 64-bit integer from `i` inserted at a\n location specified by `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3521141,"byte_end":3521150,"line_start":28,"line_end":28,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3521151,"byte_end":3521187,"line_start":29,"line_end":29,"column_start":1,"column_end":37}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3521238,"byte_end":3521269,"line_start":31,"line_end":31,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse41.rs","byte_start":3521270,"byte_end":3521319,"line_start":32,"line_end":32,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12396},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse42.rs","byte_start":3522747,"byte_end":3522760,"line_start":20,"line_end":20,"column_start":15,"column_end":28},"name":"_mm_crc32_u64","qualname":"::core_arch::x86_64::sse42::_mm_crc32_u64","value":"fn (crc: u64, v: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Starting with the initial value in `crc`, return the accumulated\n CRC32 value for unsigned 64-bit integer `v`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse42.rs","byte_start":3522597,"byte_end":3522606,"line_start":16,"line_end":16,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"sse4.2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse42.rs","byte_start":3522607,"byte_end":3522643,"line_start":17,"line_end":17,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/sse42.rs","byte_start":3522683,"byte_end":3522732,"line_start":19,"line_end":19,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12404},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3524545,"byte_end":3524553,"line_start":38,"line_end":38,"column_start":15,"column_end":23},"name":"_xsave64","qualname":"::core_arch::x86_64::xsave::_xsave64","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3524394,"byte_end":3524403,"line_start":34,"line_end":34,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3524404,"byte_end":3524439,"line_start":35,"line_end":35,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3524481,"byte_end":3524530,"line_start":37,"line_end":37,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12406},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3525220,"byte_end":3525229,"line_start":54,"line_end":54,"column_start":15,"column_end":24},"name":"_xrstor64","qualname":"::core_arch::x86_64::xsave::_xrstor64","value":"fn (mem_addr: *const u8, rs_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial restore of the enabled processor states using\n the state information stored in memory at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3525068,"byte_end":3525077,"line_start":50,"line_end":50,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3525078,"byte_end":3525113,"line_start":51,"line_end":51,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3525156,"byte_end":3525205,"line_start":53,"line_end":53,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12408},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3526003,"byte_end":3526014,"line_start":71,"line_end":71,"column_start":15,"column_end":26},"name":"_xsaveopt64","qualname":"::core_arch::x86_64::xsave::_xsaveopt64","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3525840,"byte_end":3525849,"line_start":67,"line_end":67,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaveopt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3525850,"byte_end":3525894,"line_start":68,"line_end":68,"column_start":1,"column_end":45}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3525939,"byte_end":3525988,"line_start":70,"line_end":70,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12410},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3526718,"byte_end":3526727,"line_start":87,"line_end":87,"column_start":15,"column_end":24},"name":"_xsavec64","qualname":"::core_arch::x86_64::xsave::_xsavec64","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory\n at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3526559,"byte_end":3526568,"line_start":83,"line_end":83,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsavec\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3526569,"byte_end":3526611,"line_start":84,"line_end":84,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3526654,"byte_end":3526703,"line_start":86,"line_end":86,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12412},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3527494,"byte_end":3527503,"line_start":104,"line_end":104,"column_start":15,"column_end":24},"name":"_xsaves64","qualname":"::core_arch::x86_64::xsave::_xsaves64","value":"fn (mem_addr: *mut u8, save_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3527335,"byte_end":3527344,"line_start":100,"line_end":100,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaves\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3527345,"byte_end":3527387,"line_start":101,"line_end":101,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3527430,"byte_end":3527479,"line_start":103,"line_end":103,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12414},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3528415,"byte_end":3528425,"line_start":123,"line_end":123,"column_start":15,"column_end":25},"name":"_xrstors64","qualname":"::core_arch::x86_64::xsave::_xrstors64","value":"fn (mem_addr: *const u8, rs_mask: u64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Performs a full or partial restore of the enabled processor states using the\n state information stored in memory at `mem_addr`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3528255,"byte_end":3528264,"line_start":119,"line_end":119,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"xsave,xsaves\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3528265,"byte_end":3528307,"line_start":120,"line_end":120,"column_start":1,"column_end":43}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/xsave.rs","byte_start":3528351,"byte_end":3528400,"line_start":122,"line_end":122,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12420},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3532677,"byte_end":3532687,"line_start":32,"line_end":32,"column_start":15,"column_end":25},"name":"_lzcnt_u64","qualname":"::core_arch::x86_64::abm::_lzcnt_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Counts the leading most significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3532528,"byte_end":3532537,"line_start":28,"line_end":28,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"lzcnt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3532538,"byte_end":3532573,"line_start":29,"line_end":29,"column_start":1,"column_end":36}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3532613,"byte_end":3532662,"line_start":31,"line_end":31,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12422},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3533032,"byte_end":3533041,"line_start":43,"line_end":43,"column_start":15,"column_end":24},"name":"_popcnt64","qualname":"::core_arch::x86_64::abm::_popcnt64","value":"fn (x: i64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Counts the bits that are set.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3532881,"byte_end":3532890,"line_start":39,"line_end":39,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"popcnt\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3532891,"byte_end":3532927,"line_start":40,"line_end":40,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/abm.rs","byte_start":3532968,"byte_end":3533017,"line_start":42,"line_end":42,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12438},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3534640,"byte_end":3534659,"line_start":30,"line_end":30,"column_start":15,"column_end":34},"name":"_mm256_insert_epi64","qualname":"::core_arch::x86_64::avx::_mm256_insert_epi64","value":"fn (a: __m256i, i: i64, index: i32) -> __m256i","parent":null,"children":[],"decl_id":null,"docs":" Copies `a` to result, and insert the 64-bit integer `i` into result\n at the location specified by `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3534448,"byte_end":3534457,"line_start":25,"line_end":25,"column_start":1,"column_end":10}},{"value":"rustc_args_required_const(2)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3534458,"byte_end":3534489,"line_start":26,"line_end":26,"column_start":1,"column_end":32}},{"value":"target_feature(enable = \"avx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3534490,"byte_end":3534523,"line_start":27,"line_end":27,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx.rs","byte_start":3534576,"byte_end":3534625,"line_start":29,"line_end":29,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12444},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3536167,"byte_end":3536177,"line_start":24,"line_end":24,"column_start":15,"column_end":25},"name":"_bextr_u64","qualname":"::core_arch::x86_64::bmi::_bextr_u64","value":"fn (a: u64, start: u32, len: u32) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Extracts bits in range [`start`, `start` + `length`) from `a` into\n the least significant bits of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3535986,"byte_end":3535995,"line_start":19,"line_end":19,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3535996,"byte_end":3536030,"line_start":20,"line_end":20,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3536070,"byte_end":3536102,"line_start":22,"line_end":22,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3536103,"byte_end":3536152,"line_start":23,"line_end":23,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12446},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3536832,"byte_end":3536843,"line_start":40,"line_end":40,"column_start":15,"column_end":26},"name":"_bextr2_u64","qualname":"::core_arch::x86_64::bmi::_bextr2_u64","value":"fn (a: u64, control: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Extracts bits of `a` specified by `control` into\n the least significant bits of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3536651,"byte_end":3536660,"line_start":35,"line_end":35,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3536661,"byte_end":3536695,"line_start":36,"line_end":36,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3536735,"byte_end":3536767,"line_start":38,"line_end":38,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3536768,"byte_end":3536817,"line_start":39,"line_end":39,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12448},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537220,"byte_end":3537229,"line_start":51,"line_end":51,"column_start":15,"column_end":24},"name":"_andn_u64","qualname":"::core_arch::x86_64::bmi::_andn_u64","value":"fn (a: u64, b: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Bitwise logical `AND` of inverted `a` with `b`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537073,"byte_end":3537082,"line_start":47,"line_end":47,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537083,"byte_end":3537117,"line_start":48,"line_end":48,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537156,"byte_end":3537205,"line_start":50,"line_end":50,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12450},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537631,"byte_end":3537640,"line_start":63,"line_end":63,"column_start":15,"column_end":24},"name":"_blsi_u64","qualname":"::core_arch::x86_64::bmi::_blsi_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Extracts lowest set isolated bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537417,"byte_end":3537426,"line_start":58,"line_end":58,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537427,"byte_end":3537461,"line_start":59,"line_end":59,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537500,"byte_end":3537532,"line_start":61,"line_end":61,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537567,"byte_end":3537616,"line_start":62,"line_end":62,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12452},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538050,"byte_end":3538061,"line_start":75,"line_end":75,"column_start":15,"column_end":26},"name":"_blsmsk_u64","qualname":"::core_arch::x86_64::bmi::_blsmsk_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Gets mask up to lowest set bit.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537834,"byte_end":3537843,"line_start":70,"line_end":70,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537844,"byte_end":3537878,"line_start":71,"line_end":71,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537919,"byte_end":3537951,"line_start":73,"line_end":73,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3537986,"byte_end":3538035,"line_start":74,"line_end":74,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12454},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538503,"byte_end":3538512,"line_start":89,"line_end":89,"column_start":15,"column_end":24},"name":"_blsr_u64","qualname":"::core_arch::x86_64::bmi::_blsr_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Resets the lowest set bit of `x`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538289,"byte_end":3538298,"line_start":84,"line_end":84,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538299,"byte_end":3538333,"line_start":85,"line_end":85,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538372,"byte_end":3538404,"line_start":87,"line_end":87,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538439,"byte_end":3538488,"line_start":88,"line_end":88,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12456},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538952,"byte_end":3538962,"line_start":102,"line_end":102,"column_start":15,"column_end":25},"name":"_tzcnt_u64","qualname":"::core_arch::x86_64::bmi::_tzcnt_u64","value":"fn (x: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Counts the number of trailing least significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538804,"byte_end":3538813,"line_start":98,"line_end":98,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538814,"byte_end":3538848,"line_start":99,"line_end":99,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3538888,"byte_end":3538937,"line_start":101,"line_end":101,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12458},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3539406,"byte_end":3539418,"line_start":115,"line_end":115,"column_start":15,"column_end":27},"name":"_mm_tzcnt_64","qualname":"::core_arch::x86_64::bmi::_mm_tzcnt_64","value":"fn (x: u64) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Counts the number of trailing least significant zero bits.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3539258,"byte_end":3539267,"line_start":111,"line_end":111,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi1\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3539268,"byte_end":3539302,"line_start":112,"line_end":112,"column_start":1,"column_end":35}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi.rs","byte_start":3539342,"byte_end":3539391,"line_start":114,"line_end":114,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12466},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542449,"byte_end":3542458,"line_start":27,"line_end":27,"column_start":15,"column_end":24},"name":"_mulx_u64","qualname":"::core_arch::x86_64::bmi2::_mulx_u64","value":"fn (a: u64, b: u64, hi: &mut u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Unsigned multiply without affecting flags.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542248,"byte_end":3542257,"line_start":22,"line_end":22,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542295,"byte_end":3542329,"line_start":24,"line_end":24,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542330,"byte_end":3542362,"line_start":25,"line_end":25,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542385,"byte_end":3542434,"line_start":26,"line_end":26,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12468},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542934,"byte_end":3542943,"line_start":41,"line_end":41,"column_start":15,"column_end":24},"name":"_bzhi_u64","qualname":"::core_arch::x86_64::bmi2::_bzhi_u64","value":"fn (a: u64, index: u32) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Zeroes higher bits of `a` >= `index`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542754,"byte_end":3542763,"line_start":36,"line_end":36,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542764,"byte_end":3542798,"line_start":37,"line_end":37,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542837,"byte_end":3542869,"line_start":39,"line_end":39,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3542870,"byte_end":3542919,"line_start":40,"line_end":40,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12470},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543409,"byte_end":3543418,"line_start":54,"line_end":54,"column_start":15,"column_end":24},"name":"_pdep_u64","qualname":"::core_arch::x86_64::bmi2::_pdep_u64","value":"fn (a: u64, mask: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Scatter contiguous low order bits of `a` to the result at the positions\n specified by the `mask`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543229,"byte_end":3543238,"line_start":49,"line_end":49,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543239,"byte_end":3543273,"line_start":50,"line_end":50,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543312,"byte_end":3543344,"line_start":52,"line_end":52,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543345,"byte_end":3543394,"line_start":53,"line_end":53,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12472},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543885,"byte_end":3543894,"line_start":67,"line_end":67,"column_start":15,"column_end":24},"name":"_pext_u64","qualname":"::core_arch::x86_64::bmi2::_pext_u64","value":"fn (a: u64, mask: u64) -> u64","parent":null,"children":[],"decl_id":null,"docs":" Gathers the bits of `x` specified by the `mask` into the contiguous low\n order bit positions of the result.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543705,"byte_end":3543714,"line_start":62,"line_end":62,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"bmi2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543715,"byte_end":3543749,"line_start":63,"line_end":63,"column_start":1,"column_end":35}},{"value":"cfg(not(target_arch = \"x86\"))","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543788,"byte_end":3543820,"line_start":65,"line_end":65,"column_start":1,"column_end":33}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bmi2.rs","byte_start":3543821,"byte_end":3543870,"line_start":66,"line_end":66,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12486},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3547281,"byte_end":3547301,"line_start":31,"line_end":31,"column_start":15,"column_end":35},"name":"_mm256_extract_epi64","qualname":"::core_arch::x86_64::avx2::_mm256_extract_epi64","value":"fn (a: __m256i, imm8: i32) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Extracts a 64-bit integer from `a`, selected with `imm8`.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3547088,"byte_end":3547097,"line_start":26,"line_end":26,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"avx2\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3547098,"byte_end":3547132,"line_start":27,"line_end":27,"column_start":1,"column_end":35}},{"value":"rustc_args_required_const(1)","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3547133,"byte_end":3547164,"line_start":28,"line_end":28,"column_start":1,"column_end":32}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/avx2.rs","byte_start":3547217,"byte_end":3547266,"line_start":30,"line_end":30,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12492},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bswap.rs","byte_start":3548110,"byte_end":3548118,"line_start":14,"line_end":14,"column_start":15,"column_end":23},"name":"_bswap64","qualname":"::core_arch::x86_64::bswap::_bswap64","value":"fn (x: i64) -> i64","parent":null,"children":[],"decl_id":null,"docs":" Returns an integer with the reversed byte order of x","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bswap.rs","byte_start":3547997,"byte_end":3548006,"line_start":11,"line_end":11,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bswap.rs","byte_start":3548046,"byte_end":3548095,"line_start":13,"line_end":13,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12502},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3549425,"byte_end":3549439,"line_start":26,"line_end":26,"column_start":15,"column_end":29},"name":"_rdrand64_step","qualname":"::core_arch::x86_64::rdrand::_rdrand64_step","value":"fn (val: &mut u64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a hardware generated 64-bit random value and store the result in val.\n Returns 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3549274,"byte_end":3549283,"line_start":22,"line_end":22,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdrand\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3549284,"byte_end":3549320,"line_start":23,"line_end":23,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3549361,"byte_end":3549410,"line_start":25,"line_end":25,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12504},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3549948,"byte_end":3549962,"line_start":40,"line_end":40,"column_start":15,"column_end":29},"name":"_rdseed64_step","qualname":"::core_arch::x86_64::rdrand::_rdseed64_step","value":"fn (val: &mut u64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" Read a 64-bit NIST SP800-90B and SP800-90C compliant random value and store\n in val. Return 1 if a random value was generated, and 0 otherwise.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3549797,"byte_end":3549806,"line_start":36,"line_end":36,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"rdseed\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3549807,"byte_end":3549843,"line_start":37,"line_end":37,"column_start":1,"column_end":37}},{"value":"stable(feature = \"simd_x86\", since = \"1.27.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/rdrand.rs","byte_start":3549884,"byte_end":3549933,"line_start":39,"line_end":39,"column_start":1,"column_end":50}}]},{"kind":"Function","id":{"krate":0,"index":12512},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/cmpxchg16b.rs","byte_start":3551982,"byte_end":3551992,"line_start":45,"line_end":45,"column_start":15,"column_end":25},"name":"cmpxchg16b","qualname":"::core_arch::x86_64::cmpxchg16b::cmpxchg16b","value":"fn (dst: *mut u128, old: u128, new: u128, success: Ordering, failure: Ordering) -> u128","parent":null,"children":[],"decl_id":null,"docs":" Compares and exchange 16 bytes (128 bits) of data atomically.","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/cmpxchg16b.rs","byte_start":3551817,"byte_end":3551826,"line_start":42,"line_end":42,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"cmpxchg16b\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/cmpxchg16b.rs","byte_start":3551927,"byte_end":3551967,"line_start":44,"line_end":44,"column_start":1,"column_end":41}}]},{"kind":"Function","id":{"krate":0,"index":12524},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3553997,"byte_end":3554010,"line_start":20,"line_end":20,"column_start":15,"column_end":28},"name":"_addcarry_u64","qualname":"::core_arch::x86_64::adx::_addcarry_u64","value":"fn (c_in: u8, a: u64, b: u64, out: &mut u64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry flag), and store the unsigned 64-bit result in `out`, and the carry-out\n is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3553882,"byte_end":3553891,"line_start":17,"line_end":17,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3553929,"byte_end":3553982,"line_start":19,"line_end":19,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":12526},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3554499,"byte_end":3554513,"line_start":33,"line_end":33,"column_start":15,"column_end":29},"name":"_addcarryx_u64","qualname":"::core_arch::x86_64::adx::_addcarryx_u64","value":"fn (c_in: u8, a: u64, b: u64, out: &mut u64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`\n (carry or overflow flag), and store the unsigned 64-bit result in `out`, and\n the carry-out is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3554350,"byte_end":3554359,"line_start":29,"line_end":29,"column_start":1,"column_end":10}},{"value":"target_feature(enable = \"adx\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3554360,"byte_end":3554393,"line_start":30,"line_end":30,"column_start":1,"column_end":34}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3554431,"byte_end":3554484,"line_start":32,"line_end":32,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":12528},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3554962,"byte_end":3554976,"line_start":43,"line_end":43,"column_start":15,"column_end":29},"name":"_subborrow_u64","qualname":"::core_arch::x86_64::adx::_subborrow_u64","value":"fn (c_in: u8, a: u64, b: u64, out: &mut u64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Adds unsigned 64-bit integers `a` and `b` with unsigned 8-bit carry-in `c_in`.\n (carry or overflow flag), and store the unsigned 64-bit result in `out`, and\n the carry-out is returned (carry or overflow flag).\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3554847,"byte_end":3554856,"line_start":40,"line_end":40,"column_start":1,"column_end":10}},{"value":"stable(feature = \"simd_x86_adx\", since = \"1.33.0\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/adx.rs","byte_start":3554894,"byte_end":3554947,"line_start":42,"line_end":42,"column_start":1,"column_end":54}}]},{"kind":"Function","id":{"krate":0,"index":12534},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3557895,"byte_end":3557905,"line_start":8,"line_end":8,"column_start":15,"column_end":25},"name":"_bittest64","qualname":"::core_arch::x86_64::bt::_bittest64","value":"fn (p: *const i64, b: i64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3557776,"byte_end":3557785,"line_start":5,"line_end":5,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3557822,"byte_end":3557880,"line_start":7,"line_end":7,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":12536},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3558286,"byte_end":3558302,"line_start":21,"line_end":21,"column_start":15,"column_end":31},"name":"_bittestandset64","qualname":"::core_arch::x86_64::bt::_bittestandset64","value":"fn (p: *mut i64, b: i64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then sets the bit to `1`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3558166,"byte_end":3558175,"line_start":18,"line_end":18,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3558213,"byte_end":3558271,"line_start":20,"line_end":20,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":12538},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3558686,"byte_end":3558704,"line_start":34,"line_end":34,"column_start":15,"column_end":33},"name":"_bittestandreset64","qualname":"::core_arch::x86_64::bt::_bittestandreset64","value":"fn (p: *mut i64, b: i64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then resets that bit to `0`.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3558566,"byte_end":3558575,"line_start":31,"line_end":31,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3558613,"byte_end":3558671,"line_start":33,"line_end":33,"column_start":1,"column_end":59}}]},{"kind":"Function","id":{"krate":0,"index":12540},"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3559082,"byte_end":3559105,"line_start":47,"line_end":47,"column_start":15,"column_end":38},"name":"_bittestandcomplement64","qualname":"::core_arch::x86_64::bt::_bittestandcomplement64","value":"fn (p: *mut i64, b: i64) -> u8","parent":null,"children":[],"decl_id":null,"docs":" Returns the bit in position `b` of the memory addressed by `p`, then inverts that bit.\n","sig":null,"attributes":[{"value":"inline","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3558962,"byte_end":3558971,"line_start":44,"line_end":44,"column_start":1,"column_end":10}},{"value":"unstable(feature = \"simd_x86_bittest\", issue = \"59414\")","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86_64/bt.rs","byte_start":3559009,"byte_end":3559067,"line_start":46,"line_end":46,"column_start":1,"column_end":59}}]}],"impls":[{"id":26,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":82556,"byte_end":82564,"line_start":166,"line_end":166,"column_start":36,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":326}],"docs":"","sig":null,"attributes":[]},{"id":27,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":82761,"byte_end":82769,"line_start":173,"line_end":173,"column_start":40,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":330}],"docs":"","sig":null,"attributes":[]},{"id":28,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":82960,"byte_end":82968,"line_start":180,"line_end":180,"column_start":38,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":334}],"docs":"","sig":null,"attributes":[]},{"id":29,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":83157,"byte_end":83165,"line_start":187,"line_end":187,"column_start":36,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":338}],"docs":"","sig":null,"attributes":[]},{"id":30,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":83360,"byte_end":83368,"line_start":194,"line_end":194,"column_start":42,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":342}],"docs":"","sig":null,"attributes":[]},{"id":31,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":83563,"byte_end":83571,"line_start":201,"line_end":201,"column_start":42,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":346}],"docs":"","sig":null,"attributes":[]},{"id":34,"kind":"Inherent","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239863,"byte_end":239867,"line_start":174,"line_end":174,"column_start":10,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":502},{"krate":0,"index":504}],"docs":"","sig":null,"attributes":[]},{"id":35,"kind":"Inherent","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":241600,"byte_end":241609,"line_start":223,"line_end":223,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":508},{"krate":0,"index":510}],"docs":"","sig":null,"attributes":[]},{"id":36,"kind":"Inherent","span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":368654,"byte_end":368662,"line_start":36,"line_end":36,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":702}],"docs":"","sig":null,"attributes":[]},{"id":39,"kind":"Inherent","span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381784,"byte_end":381791,"line_start":31,"line_end":31,"column_start":10,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":848}],"docs":"","sig":null,"attributes":[]},{"id":42,"kind":"Inherent","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":318585,"byte_end":318600,"line_start":183,"line_end":183,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":860}],"docs":"","sig":null,"attributes":[]},{"id":43,"kind":"Direct","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":319126,"byte_end":319141,"line_start":198,"line_end":198,"column_start":23,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":864}],"docs":"","sig":null,"attributes":[]},{"id":47,"kind":"Inherent","span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":405156,"byte_end":405158,"line_start":20,"line_end":20,"column_start":6,"column_end":8},"value":"","parent":null,"children":[{"krate":0,"index":912},{"krate":0,"index":916},{"krate":0,"index":918}],"docs":"","sig":null,"attributes":[]},{"id":72,"kind":"Inherent","span":{"file_name":"src/libcore/num/mod.rs","byte_start":211529,"byte_end":211544,"line_start":4413,"line_end":4413,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":1036}],"docs":"","sig":null,"attributes":[]},{"id":73,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":211955,"byte_end":211970,"line_start":4425,"line_end":4425,"column_start":23,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":1040}],"docs":"","sig":null,"attributes":[]},{"id":74,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":212161,"byte_end":212176,"line_start":4432,"line_end":4432,"column_start":27,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":1044}],"docs":"","sig":null,"attributes":[]},{"id":75,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":212325,"byte_end":212340,"line_start":4439,"line_end":4439,"column_start":18,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":1048}],"docs":"","sig":null,"attributes":[]},{"id":185,"kind":"Inherent","span":{"file_name":"src/libcore/num/mod.rs","byte_start":224523,"byte_end":224536,"line_start":4796,"line_end":4796,"column_start":6,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":1090},{"krate":0,"index":1092}],"docs":"","sig":null,"attributes":[]},{"id":186,"kind":"Direct","span":{"file_name":"src/libcore/num/mod.rs","byte_start":225657,"byte_end":225670,"line_start":4822,"line_end":4822,"column_start":23,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1096}],"docs":"","sig":null,"attributes":[]},{"id":245,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":536622,"byte_end":536634,"line_start":837,"line_end":837,"column_start":18,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":246,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":536727,"byte_end":536739,"line_start":840,"line_end":840,"column_start":26,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":1266}],"docs":"","sig":null,"attributes":[]},{"id":247,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":536885,"byte_end":536897,"line_start":847,"line_end":847,"column_start":28,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":1270}],"docs":"","sig":null,"attributes":[]},{"id":248,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":537055,"byte_end":537067,"line_start":854,"line_end":854,"column_start":21,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":249,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":537158,"byte_end":537170,"line_start":857,"line_end":857,"column_start":24,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1276}],"docs":"","sig":null,"attributes":[]},{"id":250,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":537349,"byte_end":537361,"line_start":864,"line_end":864,"column_start":24,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1280}],"docs":"","sig":null,"attributes":[]},{"id":251,"kind":"Inherent","span":{"file_name":"src/libcore/mem.rs","byte_start":540570,"byte_end":540582,"line_start":954,"line_end":954,"column_start":9,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":1286},{"krate":0,"index":1288},{"krate":0,"index":1290}],"docs":"","sig":null,"attributes":[]},{"id":252,"kind":"Inherent","span":{"file_name":"src/libcore/mem.rs","byte_start":542564,"byte_end":542576,"line_start":1010,"line_end":1010,"column_start":17,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":1294}],"docs":"","sig":null,"attributes":[]},{"id":253,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":543320,"byte_end":543332,"line_start":1030,"line_end":1030,"column_start":27,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":1298},{"krate":0,"index":1300}],"docs":"","sig":null,"attributes":[]},{"id":254,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":543522,"byte_end":543534,"line_start":1039,"line_end":1039,"column_start":30,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":1304}],"docs":"","sig":null,"attributes":[]},{"id":255,"kind":"Direct","span":{"file_name":"src/libcore/mem.rs","byte_start":547032,"byte_end":547043,"line_start":1126,"line_end":1126,"column_start":25,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1308}],"docs":"","sig":null,"attributes":[]},{"id":256,"kind":"Inherent","span":{"file_name":"src/libcore/mem.rs","byte_start":547223,"byte_end":547234,"line_start":1134,"line_end":1134,"column_start":9,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":1312},{"krate":0,"index":1314},{"krate":0,"index":1316},{"krate":0,"index":1318},{"krate":0,"index":1320},{"krate":0,"index":1322},{"krate":0,"index":1324},{"krate":0,"index":1326},{"krate":0,"index":1328},{"krate":0,"index":1330},{"krate":0,"index":1332},{"krate":0,"index":1334}],"docs":"","sig":null,"attributes":[]},{"id":257,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":656108,"byte_end":656114,"line_start":2778,"line_end":2778,"column_start":32,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":1566}],"docs":"","sig":null,"attributes":[]},{"id":258,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":656556,"byte_end":656562,"line_start":2789,"line_end":2789,"column_start":40,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":259,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":656890,"byte_end":656896,"line_start":2796,"line_end":2796,"column_start":40,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":260,"kind":"Inherent","span":{"file_name":"src/libcore/ptr.rs","byte_start":656972,"byte_end":656978,"line_start":2799,"line_end":2799,"column_start":16,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":1574}],"docs":"","sig":null,"attributes":[]},{"id":261,"kind":"Inherent","span":{"file_name":"src/libcore/ptr.rs","byte_start":657687,"byte_end":657693,"line_start":2818,"line_end":2818,"column_start":17,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":1578},{"krate":0,"index":1580},{"krate":0,"index":1582},{"krate":0,"index":1584},{"krate":0,"index":1586}],"docs":"","sig":null,"attributes":[]},{"id":262,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":659069,"byte_end":659075,"line_start":2862,"line_end":2862,"column_start":27,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":1590}],"docs":"","sig":null,"attributes":[]},{"id":263,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":659211,"byte_end":659217,"line_start":2869,"line_end":2869,"column_start":26,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":264,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":659334,"byte_end":659340,"line_start":2872,"line_end":2872,"column_start":57,"column_end":63},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":265,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":659478,"byte_end":659484,"line_start":2875,"line_end":2875,"column_start":59,"column_end":65},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":266,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":659597,"byte_end":659603,"line_start":2878,"line_end":2878,"column_start":34,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":1600}],"docs":"","sig":null,"attributes":[]},{"id":267,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":659811,"byte_end":659817,"line_start":2885,"line_end":2885,"column_start":34,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":1604}],"docs":"","sig":null,"attributes":[]},{"id":268,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":660035,"byte_end":660041,"line_start":2892,"line_end":2892,"column_start":30,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":1608}],"docs":"","sig":null,"attributes":[]},{"id":269,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":660269,"byte_end":660275,"line_start":2899,"line_end":2899,"column_start":42,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":1612}],"docs":"","sig":null,"attributes":[]},{"id":270,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":662534,"byte_end":662541,"line_start":2943,"line_end":2943,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":271,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":662788,"byte_end":662795,"line_start":2948,"line_end":2948,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":272,"kind":"Inherent","span":{"file_name":"src/libcore/ptr.rs","byte_start":662819,"byte_end":662826,"line_start":2950,"line_end":2950,"column_start":16,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":1622}],"docs":"","sig":null,"attributes":[]},{"id":273,"kind":"Inherent","span":{"file_name":"src/libcore/ptr.rs","byte_start":663588,"byte_end":663595,"line_start":2971,"line_end":2971,"column_start":17,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":1626},{"krate":0,"index":1628},{"krate":0,"index":1630},{"krate":0,"index":1632},{"krate":0,"index":1634},{"krate":0,"index":1636}],"docs":"","sig":null,"attributes":[]},{"id":274,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":665572,"byte_end":665579,"line_start":3035,"line_end":3035,"column_start":27,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":1640}],"docs":"","sig":null,"attributes":[]},{"id":275,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":665712,"byte_end":665719,"line_start":3042,"line_end":3042,"column_start":26,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":276,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":665842,"byte_end":665849,"line_start":3045,"line_end":3045,"column_start":58,"column_end":65},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":277,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":665992,"byte_end":665999,"line_start":3048,"line_end":3048,"column_start":60,"column_end":67},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":278,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":666107,"byte_end":666114,"line_start":3051,"line_end":3051,"column_start":32,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":1650}],"docs":"","sig":null,"attributes":[]},{"id":279,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":666319,"byte_end":666326,"line_start":3058,"line_end":3058,"column_start":34,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":1654}],"docs":"","sig":null,"attributes":[]},{"id":280,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":666521,"byte_end":666528,"line_start":3065,"line_end":3065,"column_start":24,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":281,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":666615,"byte_end":666622,"line_start":3068,"line_end":3068,"column_start":31,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":1660}],"docs":"","sig":null,"attributes":[]},{"id":282,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":666805,"byte_end":666812,"line_start":3076,"line_end":3076,"column_start":25,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":1664}],"docs":"","sig":null,"attributes":[]},{"id":283,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":667010,"byte_end":667017,"line_start":3084,"line_end":3084,"column_start":32,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":1668}],"docs":"","sig":null,"attributes":[]},{"id":284,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":667239,"byte_end":667246,"line_start":3092,"line_end":3092,"column_start":32,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":1672}],"docs":"","sig":null,"attributes":[]},{"id":285,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":667450,"byte_end":667457,"line_start":3100,"line_end":3100,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":1676}],"docs":"","sig":null,"attributes":[]},{"id":286,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":667664,"byte_end":667671,"line_start":3108,"line_end":3108,"column_start":34,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":1680}],"docs":"","sig":null,"attributes":[]},{"id":287,"kind":"Direct","span":{"file_name":"src/libcore/ptr.rs","byte_start":667879,"byte_end":667886,"line_start":3116,"line_end":3116,"column_start":30,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":1684}],"docs":"","sig":null,"attributes":[]},{"id":288,"kind":"Direct","span":{"file_name":"src/libcore/marker.rs","byte_start":694494,"byte_end":694504,"line_start":591,"line_end":591,"column_start":29,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":289,"kind":"Direct","span":{"file_name":"src/libcore/marker.rs","byte_start":694545,"byte_end":694556,"line_start":592,"line_end":592,"column_start":35,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":290,"kind":"Direct","span":{"file_name":"src/libcore/marker.rs","byte_start":696984,"byte_end":696997,"line_start":650,"line_end":650,"column_start":17,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":1916,"kind":"Direct","span":{"file_name":"src/libcore/ops/generator.rs","byte_start":778373,"byte_end":778376,"line_start":117,"line_end":117,"column_start":43,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":2046},{"krate":0,"index":2048},{"krate":0,"index":2050}],"docs":"","sig":null,"attributes":[]},{"id":1917,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":785604,"byte_end":785613,"line_start":47,"line_end":47,"column_start":21,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2084}],"docs":"","sig":null,"attributes":[]},{"id":1918,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":786844,"byte_end":786849,"line_start":86,"line_end":86,"column_start":38,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2088}],"docs":"","sig":null,"attributes":[]},{"id":1919,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":787059,"byte_end":787064,"line_start":95,"line_end":95,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2092},{"krate":0,"index":2094}],"docs":"","sig":null,"attributes":[]},{"id":1920,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":789922,"byte_end":789931,"line_start":188,"line_end":188,"column_start":38,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":2098}],"docs":"","sig":null,"attributes":[]},{"id":1921,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":790113,"byte_end":790122,"line_start":196,"line_end":196,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2102}],"docs":"","sig":null,"attributes":[]},{"id":1922,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":792398,"byte_end":792405,"line_start":272,"line_end":272,"column_start":38,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":2106}],"docs":"","sig":null,"attributes":[]},{"id":1923,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":792585,"byte_end":792592,"line_start":280,"line_end":280,"column_start":28,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2110}],"docs":"","sig":null,"attributes":[]},{"id":1924,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":794962,"byte_end":794963,"line_start":351,"line_end":351,"column_start":36,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2118}],"docs":"","sig":null,"attributes":[]},{"id":1925,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":795157,"byte_end":795158,"line_start":358,"line_end":358,"column_start":48,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":2122}],"docs":"","sig":null,"attributes":[]},{"id":1926,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":795371,"byte_end":795385,"line_start":366,"line_end":366,"column_start":36,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":2126}],"docs":"","sig":null,"attributes":[]},{"id":1927,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":795747,"byte_end":795761,"line_start":377,"line_end":377,"column_start":22,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":1928,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":795853,"byte_end":795867,"line_start":380,"line_end":380,"column_start":26,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":2132}],"docs":"","sig":null,"attributes":[]},{"id":1929,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":796077,"byte_end":796091,"line_start":388,"line_end":388,"column_start":11,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":47090},{"krate":0,"index":2136},{"krate":0,"index":2138},{"krate":0,"index":2140}],"docs":"","sig":null,"attributes":[]},{"id":1930,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":798779,"byte_end":798793,"line_start":475,"line_end":475,"column_start":38,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":2144}],"docs":"","sig":null,"attributes":[]},{"id":1931,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":799004,"byte_end":799018,"line_start":484,"line_end":484,"column_start":28,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":2148},{"krate":0,"index":2150},{"krate":0,"index":2152}],"docs":"","sig":null,"attributes":[]},{"id":1932,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":802980,"byte_end":802996,"line_start":613,"line_end":613,"column_start":38,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":2156}],"docs":"","sig":null,"attributes":[]},{"id":1933,"kind":"Inherent","span":{"file_name":"src/libcore/ops/range.rs","byte_start":803177,"byte_end":803193,"line_start":621,"line_end":621,"column_start":28,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":2160}],"docs":"","sig":null,"attributes":[]},{"id":1934,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":807875,"byte_end":807884,"line_start":774,"line_end":774,"column_start":36,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":2180},{"krate":0,"index":2182}],"docs":"","sig":null,"attributes":[]},{"id":1935,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":808104,"byte_end":808113,"line_start":784,"line_end":784,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2186},{"krate":0,"index":2188}],"docs":"","sig":null,"attributes":[]},{"id":1936,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":808348,"byte_end":808355,"line_start":794,"line_end":794,"column_start":28,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2192},{"krate":0,"index":2194}],"docs":"","sig":null,"attributes":[]},{"id":1937,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":808588,"byte_end":808593,"line_start":804,"line_end":804,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2198},{"krate":0,"index":2200}],"docs":"","sig":null,"attributes":[]},{"id":1938,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":808838,"byte_end":808852,"line_start":814,"line_end":814,"column_start":28,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":2204},{"krate":0,"index":2206}],"docs":"","sig":null,"attributes":[]},{"id":1939,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":809097,"byte_end":809113,"line_start":824,"line_end":824,"column_start":28,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":2210},{"krate":0,"index":2212}],"docs":"","sig":null,"attributes":[]},{"id":1940,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":810177,"byte_end":810186,"line_start":864,"line_end":864,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2228},{"krate":0,"index":2230}],"docs":"","sig":null,"attributes":[]},{"id":1941,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":810421,"byte_end":810428,"line_start":874,"line_end":874,"column_start":28,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2234},{"krate":0,"index":2236}],"docs":"","sig":null,"attributes":[]},{"id":1942,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":810661,"byte_end":810666,"line_start":884,"line_end":884,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2240},{"krate":0,"index":2242}],"docs":"","sig":null,"attributes":[]},{"id":1943,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":810910,"byte_end":810924,"line_start":894,"line_end":894,"column_start":28,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":2246},{"krate":0,"index":2248}],"docs":"","sig":null,"attributes":[]},{"id":1944,"kind":"Direct","span":{"file_name":"src/libcore/ops/range.rs","byte_start":811168,"byte_end":811184,"line_start":904,"line_end":904,"column_start":28,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":2252},{"krate":0,"index":2254}],"docs":"","sig":null,"attributes":[]},{"id":1945,"kind":"Inherent","span":{"file_name":"src/libcore/cmp.rs","byte_start":827741,"byte_end":827749,"line_start":300,"line_end":300,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":2430},{"krate":0,"index":2432},{"krate":0,"index":2434}],"docs":"","sig":null,"attributes":[]},{"id":1946,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":831770,"byte_end":831777,"line_start":432,"line_end":432,"column_start":36,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2438},{"krate":0,"index":2440},{"krate":0,"index":2442},{"krate":0,"index":2444},{"krate":0,"index":2446}],"docs":"","sig":null,"attributes":[]},{"id":1947,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":832288,"byte_end":832295,"line_start":449,"line_end":449,"column_start":22,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":2450}],"docs":"","sig":null,"attributes":[]},{"id":1948,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":836825,"byte_end":836833,"line_start":604,"line_end":604,"column_start":13,"column_end":21},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":1949,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":836897,"byte_end":836905,"line_start":607,"line_end":607,"column_start":14,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":2466}],"docs":"","sig":null,"attributes":[]},{"id":1950,"kind":"Direct","span":{"file_name":"src/libcore/cmp.rs","byte_start":837092,"byte_end":837100,"line_start":615,"line_end":615,"column_start":21,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":2470}],"docs":"","sig":null,"attributes":[]},{"id":2043,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":882800,"byte_end":882801,"line_start":537,"line_end":537,"column_start":24,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":2694}],"docs":"","sig":null,"attributes":[]},{"id":2044,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":882980,"byte_end":882981,"line_start":546,"line_end":546,"column_start":21,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":2698}],"docs":"","sig":null,"attributes":[]},{"id":2045,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":883120,"byte_end":883121,"line_start":553,"line_end":553,"column_start":27,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2702},{"krate":0,"index":2704}],"docs":"","sig":null,"attributes":[]},{"id":2046,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":883443,"byte_end":883444,"line_start":565,"line_end":565,"column_start":27,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2708},{"krate":0,"index":2710}],"docs":"","sig":null,"attributes":[]},{"id":2048,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":886530,"byte_end":886540,"line_start":660,"line_end":660,"column_start":16,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":2726}],"docs":"","sig":null,"attributes":[]},{"id":2049,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":886691,"byte_end":886701,"line_start":667,"line_end":667,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":2730}],"docs":"","sig":null,"attributes":[]},{"id":2050,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":886881,"byte_end":886891,"line_start":674,"line_end":674,"column_start":23,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2734}],"docs":"","sig":null,"attributes":[]},{"id":2051,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":887068,"byte_end":887078,"line_start":681,"line_end":681,"column_start":20,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2738}],"docs":"","sig":null,"attributes":[]},{"id":2052,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":887228,"byte_end":887238,"line_start":688,"line_end":688,"column_start":13,"column_end":23},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2053,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":887323,"byte_end":887333,"line_start":691,"line_end":691,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":2744}],"docs":"","sig":null,"attributes":[]},{"id":2054,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":887516,"byte_end":887526,"line_start":698,"line_end":698,"column_start":14,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":2748}],"docs":"","sig":null,"attributes":[]},{"id":2055,"kind":"Direct","span":{"file_name":"src/libcore/convert.rs","byte_start":887697,"byte_end":887707,"line_start":705,"line_end":705,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2752}],"docs":"","sig":null,"attributes":[]},{"id":2056,"kind":"Direct","span":{"file_name":"src/libcore/borrow.rs","byte_start":895949,"byte_end":895950,"line_start":213,"line_end":213,"column_start":31,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2766}],"docs":"","sig":null,"attributes":[]},{"id":2057,"kind":"Direct","span":{"file_name":"src/libcore/borrow.rs","byte_start":896071,"byte_end":896072,"line_start":218,"line_end":218,"column_start":34,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2770}],"docs":"","sig":null,"attributes":[]},{"id":2058,"kind":"Direct","span":{"file_name":"src/libcore/any.rs","byte_start":900048,"byte_end":900049,"line_start":100,"line_end":100,"column_start":36,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2796}],"docs":"","sig":null,"attributes":[]},{"id":2059,"kind":"Inherent","span":{"file_name":"src/libcore/any.rs","byte_start":908988,"byte_end":908994,"line_start":427,"line_end":427,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":2836}],"docs":"","sig":null,"attributes":[]},{"id":2060,"kind":"Direct","span":{"file_name":"src/libcore/array.rs","byte_start":911211,"byte_end":911212,"line_start":40,"line_end":40,"column_start":54,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":2874},{"krate":0,"index":2876}],"docs":"","sig":null,"attributes":[]},{"id":2061,"kind":"Direct","span":{"file_name":"src/libcore/array.rs","byte_start":911577,"byte_end":911594,"line_start":56,"line_end":56,"column_start":23,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":2880}],"docs":"","sig":null,"attributes":[]},{"id":2062,"kind":"Inherent","span":{"file_name":"src/libcore/array.rs","byte_start":911739,"byte_end":911756,"line_start":63,"line_end":63,"column_start":6,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":2884}],"docs":"","sig":null,"attributes":[]},{"id":2063,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":923106,"byte_end":923119,"line_start":116,"line_end":116,"column_start":19,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":2910},{"krate":0,"index":2912},{"krate":0,"index":2914}],"docs":"","sig":null,"attributes":[]},{"id":2064,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":923377,"byte_end":923390,"line_start":122,"line_end":122,"column_start":30,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2918}],"docs":"","sig":null,"attributes":[]},{"id":2065,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":923571,"byte_end":923584,"line_start":128,"line_end":128,"column_start":28,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2066,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":923658,"byte_end":923671,"line_start":130,"line_end":130,"column_start":24,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2067,"kind":"Direct","span":{"file_name":"src/libcore/ascii.rs","byte_start":923747,"byte_end":923760,"line_start":133,"line_end":133,"column_start":21,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":2926}],"docs":"","sig":null,"attributes":[]},{"id":2068,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930814,"byte_end":930824,"line_start":169,"line_end":169,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":2948}],"docs":"","sig":null,"attributes":[]},{"id":2069,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931093,"byte_end":931103,"line_start":179,"line_end":179,"column_start":22,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2070,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931662,"byte_end":931671,"line_start":195,"line_end":195,"column_start":21,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":2956}],"docs":"","sig":null,"attributes":[]},{"id":2071,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931911,"byte_end":931920,"line_start":204,"line_end":204,"column_start":25,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2072,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":932031,"byte_end":932040,"line_start":207,"line_end":207,"column_start":25,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2073,"kind":"Inherent","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":936918,"byte_end":936928,"line_start":314,"line_end":314,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":2966},{"krate":0,"index":2968},{"krate":0,"index":2970},{"krate":0,"index":2972},{"krate":0,"index":2974},{"krate":0,"index":2976},{"krate":0,"index":2978},{"krate":0,"index":2980},{"krate":0,"index":2982},{"krate":0,"index":2984},{"krate":0,"index":2986},{"krate":0,"index":2988},{"krate":0,"index":2990}],"docs":"","sig":null,"attributes":[]},{"id":2074,"kind":"Inherent","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955959,"byte_end":955968,"line_start":801,"line_end":801,"column_start":9,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":2994},{"krate":0,"index":2996},{"krate":0,"index":2998},{"krate":0,"index":3000},{"krate":0,"index":3002},{"krate":0,"index":3004},{"krate":0,"index":3006},{"krate":0,"index":3008},{"krate":0,"index":3010}],"docs":"","sig":null,"attributes":[]},{"id":2075,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":967929,"byte_end":967939,"line_start":1114,"line_end":1114,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":3014}],"docs":"","sig":null,"attributes":[]},{"id":2076,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":968374,"byte_end":968383,"line_start":1130,"line_end":1130,"column_start":26,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3018}],"docs":"","sig":null,"attributes":[]},{"id":2077,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1021015,"byte_end":1021025,"line_start":2508,"line_end":2508,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":3062}],"docs":"","sig":null,"attributes":[]},{"id":2078,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1021267,"byte_end":1021276,"line_start":2516,"line_end":2516,"column_start":24,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":3066}],"docs":"","sig":null,"attributes":[]},{"id":2079,"kind":"Direct","span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1021526,"byte_end":1021535,"line_start":2524,"line_end":2524,"column_start":26,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3070}],"docs":"","sig":null,"attributes":[]},{"id":2080,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1030841,"byte_end":1030845,"line_start":234,"line_end":234,"column_start":14,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":3102},{"krate":0,"index":3104}],"docs":"","sig":null,"attributes":[]},{"id":2081,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1031882,"byte_end":1031886,"line_start":281,"line_end":281,"column_start":33,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2082,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1031980,"byte_end":1031984,"line_start":284,"line_end":284,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2083,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1032061,"byte_end":1032065,"line_start":287,"line_end":287,"column_start":24,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3112}],"docs":"","sig":null,"attributes":[]},{"id":2084,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1032231,"byte_end":1032235,"line_start":295,"line_end":295,"column_start":29,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":3116}],"docs":"","sig":null,"attributes":[]},{"id":2085,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1032478,"byte_end":1032482,"line_start":304,"line_end":304,"column_start":40,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":3120}],"docs":"","sig":null,"attributes":[]},{"id":2086,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1032662,"byte_end":1032666,"line_start":312,"line_end":312,"column_start":26,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2087,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1032765,"byte_end":1032769,"line_start":315,"line_end":315,"column_start":42,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":3126},{"krate":0,"index":3128},{"krate":0,"index":3130},{"krate":0,"index":3132},{"krate":0,"index":3134}],"docs":"","sig":null,"attributes":[]},{"id":2088,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1033379,"byte_end":1033383,"line_start":343,"line_end":343,"column_start":28,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":3138}],"docs":"","sig":null,"attributes":[]},{"id":2089,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1033569,"byte_end":1033573,"line_start":351,"line_end":351,"column_start":21,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":3142}],"docs":"","sig":null,"attributes":[]},{"id":2090,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1033648,"byte_end":1033652,"line_start":357,"line_end":357,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":3146},{"krate":0,"index":3148},{"krate":0,"index":3150},{"krate":0,"index":3152},{"krate":0,"index":3154}],"docs":"","sig":null,"attributes":[]},{"id":2091,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1035857,"byte_end":1035861,"line_start":453,"line_end":453,"column_start":17,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":3158},{"krate":0,"index":3160},{"krate":0,"index":3162}],"docs":"","sig":null,"attributes":[]},{"id":2092,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1037422,"byte_end":1037426,"line_start":517,"line_end":517,"column_start":18,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":3166}],"docs":"","sig":null,"attributes":[]},{"id":2093,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1037991,"byte_end":1037995,"line_start":538,"line_end":538,"column_start":57,"column_end":61},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2094,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1038011,"byte_end":1038015,"line_start":540,"line_end":540,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":3172}],"docs":"","sig":null,"attributes":[]},{"id":2095,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1039156,"byte_end":1039167,"line_start":579,"line_end":579,"column_start":16,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3180}],"docs":"","sig":null,"attributes":[]},{"id":2096,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1039358,"byte_end":1039369,"line_start":586,"line_end":586,"column_start":18,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3184}],"docs":"","sig":null,"attributes":[]},{"id":2097,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1039761,"byte_end":1039775,"line_start":599,"line_end":599,"column_start":16,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3190}],"docs":"","sig":null,"attributes":[]},{"id":2098,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1039969,"byte_end":1039983,"line_start":606,"line_end":606,"column_start":18,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":3194}],"docs":"","sig":null,"attributes":[]},{"id":2099,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1041166,"byte_end":1041173,"line_start":638,"line_end":638,"column_start":9,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":3206},{"krate":0,"index":3208},{"krate":0,"index":3210},{"krate":0,"index":3212},{"krate":0,"index":3214}],"docs":"","sig":null,"attributes":[]},{"id":2100,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1044494,"byte_end":1044501,"line_start":752,"line_end":752,"column_start":17,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":3218},{"krate":0,"index":3220},{"krate":0,"index":3222},{"krate":0,"index":3224},{"krate":0,"index":3226},{"krate":0,"index":3228},{"krate":0,"index":3230}],"docs":"","sig":null,"attributes":[]},{"id":2101,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1051543,"byte_end":1051550,"line_start":999,"line_end":999,"column_start":33,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2102,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1051644,"byte_end":1051651,"line_start":1002,"line_end":1002,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2103,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1051730,"byte_end":1051737,"line_start":1005,"line_end":1005,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":3238}],"docs":"","sig":null,"attributes":[]},{"id":2104,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1052004,"byte_end":1052011,"line_start":1016,"line_end":1016,"column_start":29,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3242}],"docs":"","sig":null,"attributes":[]},{"id":2105,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1052266,"byte_end":1052273,"line_start":1025,"line_end":1025,"column_start":43,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":3246}],"docs":"","sig":null,"attributes":[]},{"id":2106,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1052563,"byte_end":1052570,"line_start":1036,"line_end":1036,"column_start":29,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2107,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1052672,"byte_end":1052679,"line_start":1039,"line_end":1039,"column_start":45,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":3252},{"krate":0,"index":3254},{"krate":0,"index":3256},{"krate":0,"index":3258},{"krate":0,"index":3260}],"docs":"","sig":null,"attributes":[]},{"id":2108,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1053826,"byte_end":1053833,"line_start":1082,"line_end":1082,"column_start":31,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":3264}],"docs":"","sig":null,"attributes":[]},{"id":2109,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1054125,"byte_end":1054132,"line_start":1093,"line_end":1093,"column_start":21,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3268}],"docs":"","sig":null,"attributes":[]},{"id":2110,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1054321,"byte_end":1054328,"line_start":1100,"line_end":1100,"column_start":60,"column_end":67},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2111,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1054405,"byte_end":1054414,"line_start":1106,"line_end":1106,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":3276}],"docs":"","sig":null,"attributes":[]},{"id":2112,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1054863,"byte_end":1054872,"line_start":1121,"line_end":1121,"column_start":15,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":3280}],"docs":"","sig":null,"attributes":[]},{"id":2113,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1055062,"byte_end":1055071,"line_start":1130,"line_end":1130,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":3284}],"docs":"","sig":null,"attributes":[]},{"id":2114,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1055923,"byte_end":1055926,"line_start":1156,"line_end":1156,"column_start":27,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3290},{"krate":0,"index":3292}],"docs":"","sig":null,"attributes":[]},{"id":2115,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1056048,"byte_end":1056051,"line_start":1165,"line_end":1165,"column_start":21,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":3296},{"krate":0,"index":3298},{"krate":0,"index":3300}],"docs":"","sig":null,"attributes":[]},{"id":2116,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1058798,"byte_end":1058801,"line_start":1244,"line_end":1244,"column_start":74,"column_end":77},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2117,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1058918,"byte_end":1058921,"line_start":1247,"line_end":1247,"column_start":49,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":3306}],"docs":"","sig":null,"attributes":[]},{"id":2118,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1059049,"byte_end":1059055,"line_start":1253,"line_end":1253,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3310},{"krate":0,"index":3312}],"docs":"","sig":null,"attributes":[]},{"id":2119,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1061685,"byte_end":1061697,"line_start":1332,"line_end":1332,"column_start":15,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3318}],"docs":"","sig":null,"attributes":[]},{"id":2120,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1061881,"byte_end":1061893,"line_start":1341,"line_end":1341,"column_start":10,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":3322},{"krate":0,"index":3324}],"docs":"","sig":null,"attributes":[]},{"id":2121,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1063432,"byte_end":1063438,"line_start":1383,"line_end":1383,"column_start":27,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":3330},{"krate":0,"index":3332}],"docs":"","sig":null,"attributes":[]},{"id":2122,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1063615,"byte_end":1063621,"line_start":1393,"line_end":1393,"column_start":30,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3336}],"docs":"","sig":null,"attributes":[]},{"id":2123,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1063846,"byte_end":1063852,"line_start":1401,"line_end":1401,"column_start":77,"column_end":83},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2124,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1063969,"byte_end":1063975,"line_start":1404,"line_end":1404,"column_start":49,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":3342}],"docs":"","sig":null,"attributes":[]},{"id":2125,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1067330,"byte_end":1067340,"line_start":1475,"line_end":1475,"column_start":27,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2126,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1067356,"byte_end":1067366,"line_start":1477,"line_end":1477,"column_start":9,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":3350},{"krate":0,"index":3352}],"docs":"","sig":null,"attributes":[]},{"id":2127,"kind":"Inherent","span":{"file_name":"src/libcore/cell.rs","byte_start":1068184,"byte_end":1068194,"line_start":1514,"line_end":1514,"column_start":17,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3356}],"docs":"","sig":null,"attributes":[]},{"id":2128,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1069071,"byte_end":1069081,"line_start":1541,"line_end":1541,"column_start":30,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":3360}],"docs":"","sig":null,"attributes":[]},{"id":2129,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1069312,"byte_end":1069322,"line_start":1549,"line_end":1549,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":3364}],"docs":"","sig":null,"attributes":[]},{"id":2130,"kind":"Direct","span":{"file_name":"src/libcore/cell.rs","byte_start":1069520,"byte_end":1069530,"line_start":1556,"line_end":1556,"column_start":63,"column_end":73},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2133,"kind":"Inherent","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091156,"byte_end":1091170,"line_start":173,"line_end":173,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":3398}],"docs":"","sig":null,"attributes":[]},{"id":2134,"kind":"Direct","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091798,"byte_end":1091812,"line_start":195,"line_end":195,"column_start":23,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":3402}],"docs":"","sig":null,"attributes":[]},{"id":2137,"kind":"Direct","span":{"file_name":"src/libcore/char/convert.rs","byte_start":1093103,"byte_end":1093119,"line_start":242,"line_end":242,"column_start":23,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3418}],"docs":"","sig":null,"attributes":[]},{"id":2138,"kind":"Direct","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1097070,"byte_end":1097081,"line_start":78,"line_end":78,"column_start":44,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":3432},{"krate":0,"index":3434},{"krate":0,"index":3436}],"docs":"","sig":null,"attributes":[]},{"id":2139,"kind":"Inherent","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1098558,"byte_end":1098574,"line_start":121,"line_end":121,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":3440}],"docs":"","sig":null,"attributes":[]},{"id":2140,"kind":"Direct","span":{"file_name":"src/libcore/char/decode.rs","byte_start":1098846,"byte_end":1098862,"line_start":130,"line_end":130,"column_start":23,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3444}],"docs":"","sig":null,"attributes":[]},{"id":2142,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1075749,"byte_end":1075762,"line_start":143,"line_end":143,"column_start":19,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":3596},{"krate":0,"index":3598},{"krate":0,"index":3600},{"krate":0,"index":3602},{"krate":0,"index":3604}],"docs":"","sig":null,"attributes":[]},{"id":2143,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1077545,"byte_end":1077558,"line_start":203,"line_end":203,"column_start":28,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":3608}],"docs":"","sig":null,"attributes":[]},{"id":2144,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1078081,"byte_end":1078094,"line_start":219,"line_end":219,"column_start":24,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2145,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1078182,"byte_end":1078195,"line_start":222,"line_end":222,"column_start":23,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3614}],"docs":"","sig":null,"attributes":[]},{"id":2146,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1078983,"byte_end":1078996,"line_start":253,"line_end":253,"column_start":19,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":3618},{"krate":0,"index":3620},{"krate":0,"index":3622},{"krate":0,"index":3624},{"krate":0,"index":3626},{"krate":0,"index":3628}],"docs":"","sig":null,"attributes":[]},{"id":2147,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1080964,"byte_end":1080977,"line_start":320,"line_end":320,"column_start":28,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":3632}],"docs":"","sig":null,"attributes":[]},{"id":2148,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1081330,"byte_end":1081343,"line_start":332,"line_end":332,"column_start":24,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2149,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1081431,"byte_end":1081444,"line_start":335,"line_end":335,"column_start":23,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3638}],"docs":"","sig":null,"attributes":[]},{"id":2150,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082104,"byte_end":1082115,"line_start":356,"line_end":356,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3642},{"krate":0,"index":3644},{"krate":0,"index":3646}],"docs":"","sig":null,"attributes":[]},{"id":2151,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082359,"byte_end":1082370,"line_start":363,"line_end":363,"column_start":28,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2152,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082446,"byte_end":1082457,"line_start":366,"line_end":366,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2153,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082543,"byte_end":1082554,"line_start":369,"line_end":369,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":3654}],"docs":"","sig":null,"attributes":[]},{"id":2154,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083150,"byte_end":1083161,"line_start":387,"line_end":387,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3658},{"krate":0,"index":3660},{"krate":0,"index":3662}],"docs":"","sig":null,"attributes":[]},{"id":2155,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083413,"byte_end":1083424,"line_start":398,"line_end":398,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2156,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083526,"byte_end":1083537,"line_start":401,"line_end":401,"column_start":28,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2157,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084025,"byte_end":1084036,"line_start":415,"line_end":415,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3670},{"krate":0,"index":3672},{"krate":0,"index":3674}],"docs":"","sig":null,"attributes":[]},{"id":2158,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084288,"byte_end":1084299,"line_start":426,"line_end":426,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2159,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084401,"byte_end":1084412,"line_start":429,"line_end":429,"column_start":28,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2160,"kind":"Inherent","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084547,"byte_end":1084562,"line_start":439,"line_end":439,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":3682}],"docs":"","sig":null,"attributes":[]},{"id":2161,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084971,"byte_end":1084986,"line_start":453,"line_end":453,"column_start":19,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":3686},{"krate":0,"index":3688},{"krate":0,"index":3690}],"docs":"","sig":null,"attributes":[]},{"id":2162,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1085853,"byte_end":1085868,"line_start":484,"line_end":484,"column_start":23,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":3694}],"docs":"","sig":null,"attributes":[]},{"id":2163,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1086477,"byte_end":1086488,"line_start":505,"line_end":505,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":3698}],"docs":"","sig":null,"attributes":[]},{"id":2164,"kind":"Direct","span":{"file_name":"src/libcore/char/mod.rs","byte_start":1086684,"byte_end":1086695,"line_start":512,"line_end":512,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":3702}],"docs":"","sig":null,"attributes":[]},{"id":2165,"kind":"Inherent","span":{"file_name":"src/libcore/panic.rs","byte_start":1143357,"byte_end":1143366,"line_start":41,"line_end":41,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":3712},{"krate":0,"index":3716},{"krate":0,"index":3718},{"krate":0,"index":3720},{"krate":0,"index":3722}],"docs":"","sig":null,"attributes":[]},{"id":2166,"kind":"Direct","span":{"file_name":"src/libcore/panic.rs","byte_start":1146264,"byte_end":1146273,"line_start":126,"line_end":126,"column_start":23,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":3726}],"docs":"","sig":null,"attributes":[]},{"id":2167,"kind":"Inherent","span":{"file_name":"src/libcore/panic.rs","byte_start":1147800,"byte_end":1147808,"line_start":173,"line_end":173,"column_start":10,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":3730},{"krate":0,"index":3732},{"krate":0,"index":3734},{"krate":0,"index":3736}],"docs":"","sig":null,"attributes":[]},{"id":2168,"kind":"Direct","span":{"file_name":"src/libcore/panic.rs","byte_start":1150154,"byte_end":1150162,"line_start":251,"line_end":251,"column_start":23,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":3740}],"docs":"","sig":null,"attributes":[]},{"id":2169,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1170023,"byte_end":1170026,"line_start":295,"line_end":295,"column_start":34,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":3798},{"krate":0,"index":3800}],"docs":"","sig":null,"attributes":[]},{"id":2170,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1170356,"byte_end":1170359,"line_start":309,"line_end":309,"column_start":35,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":3804},{"krate":0,"index":3806},{"krate":0,"index":3808},{"krate":0,"index":3810},{"krate":0,"index":3812}],"docs":"","sig":null,"attributes":[]},{"id":2171,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1170885,"byte_end":1170888,"line_start":334,"line_end":334,"column_start":16,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":3816}],"docs":"","sig":null,"attributes":[]},{"id":2172,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1171548,"byte_end":1171551,"line_start":354,"line_end":354,"column_start":16,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":3820},{"krate":0,"index":3822}],"docs":"","sig":null,"attributes":[]},{"id":2173,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1175518,"byte_end":1175521,"line_start":439,"line_end":439,"column_start":19,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":3826},{"krate":0,"index":3828}],"docs":"","sig":null,"attributes":[]},{"id":2174,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1176617,"byte_end":1176620,"line_start":467,"line_end":467,"column_start":21,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":3832},{"krate":0,"index":3834}],"docs":"","sig":null,"attributes":[]},{"id":2175,"kind":"Inherent","span":{"file_name":"src/libcore/pin.rs","byte_start":1178948,"byte_end":1178951,"line_start":516,"line_end":516,"column_start":21,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":3838},{"krate":0,"index":3840},{"krate":0,"index":3842},{"krate":0,"index":3844}],"docs":"","sig":null,"attributes":[]},{"id":2176,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1181729,"byte_end":1181732,"line_start":583,"line_end":583,"column_start":26,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3848},{"krate":0,"index":3850}],"docs":"","sig":null,"attributes":[]},{"id":2177,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1181928,"byte_end":1181931,"line_start":591,"line_end":591,"column_start":32,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3854}],"docs":"","sig":null,"attributes":[]},{"id":2178,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1182145,"byte_end":1182148,"line_start":601,"line_end":601,"column_start":32,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2179,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1182236,"byte_end":1182239,"line_start":604,"line_end":604,"column_start":36,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3860}],"docs":"","sig":null,"attributes":[]},{"id":2180,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1182443,"byte_end":1182446,"line_start":611,"line_end":611,"column_start":40,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":3864}],"docs":"","sig":null,"attributes":[]},{"id":2181,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1182652,"byte_end":1182655,"line_start":618,"line_end":618,"column_start":40,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":3868}],"docs":"","sig":null,"attributes":[]},{"id":2182,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1183187,"byte_end":1183190,"line_start":630,"line_end":630,"column_start":38,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2183,"kind":"Direct","span":{"file_name":"src/libcore/pin.rs","byte_start":1183317,"byte_end":1183320,"line_start":636,"line_end":636,"column_start":44,"column_end":47},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2196,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1202049,"byte_end":1202054,"line_start":166,"line_end":166,"column_start":33,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":4050},{"krate":0,"index":4052},{"krate":0,"index":4054},{"krate":0,"index":4056},{"krate":0,"index":4058},{"krate":0,"index":4060},{"krate":0,"index":4062}],"docs":"","sig":null,"attributes":[]},{"id":2197,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1204297,"byte_end":1204302,"line_start":239,"line_end":239,"column_start":44,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":4066}],"docs":"","sig":null,"attributes":[]},{"id":2198,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1204615,"byte_end":1204620,"line_start":252,"line_end":252,"column_start":38,"column_end":43},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2199,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1204706,"byte_end":1204715,"line_start":255,"line_end":255,"column_start":33,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":4072},{"krate":0,"index":4074},{"krate":0,"index":4076},{"krate":0,"index":4078}],"docs":"","sig":null,"attributes":[]},{"id":2200,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1205299,"byte_end":1205308,"line_start":279,"line_end":279,"column_start":38,"column_end":47},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2201,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1205411,"byte_end":1205420,"line_start":282,"line_end":282,"column_start":42,"column_end":51},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2202,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1205517,"byte_end":1205531,"line_start":285,"line_end":285,"column_start":33,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":4086},{"krate":0,"index":4088},{"krate":0,"index":4090},{"krate":0,"index":4092},{"krate":0,"index":4096},{"krate":0,"index":4098},{"krate":0,"index":4100},{"krate":0,"index":4102}],"docs":"","sig":null,"attributes":[]},{"id":2203,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1208084,"byte_end":1208098,"line_start":389,"line_end":389,"column_start":44,"column_end":58},"value":"","parent":null,"children":[{"krate":0,"index":4106},{"krate":0,"index":4108}],"docs":"","sig":null,"attributes":[]},{"id":2204,"kind":"Direct","span":{"file_name":"src/libcore/iter/range.rs","byte_start":1209275,"byte_end":1209289,"line_start":435,"line_end":435,"column_start":38,"column_end":52},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2205,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1209756,"byte_end":1209762,"line_start":19,"line_end":19,"column_start":29,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":4128},{"krate":0,"index":4130},{"krate":0,"index":4132}],"docs":"","sig":null,"attributes":[]},{"id":2206,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1210044,"byte_end":1210050,"line_start":29,"line_end":29,"column_start":40,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":4136}],"docs":"","sig":null,"attributes":[]},{"id":2207,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1210225,"byte_end":1210231,"line_start":35,"line_end":35,"column_start":34,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2208,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1210330,"byte_end":1210336,"line_start":38,"line_end":38,"column_start":38,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2209,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212409,"byte_end":1212419,"line_start":111,"line_end":111,"column_start":39,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":4146},{"krate":0,"index":4148},{"krate":0,"index":4150}],"docs":"","sig":null,"attributes":[]},{"id":2210,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212719,"byte_end":1212729,"line_start":122,"line_end":122,"column_start":44,"column_end":54},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2211,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212838,"byte_end":1212848,"line_start":125,"line_end":125,"column_start":48,"column_end":58},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2212,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215299,"byte_end":1215304,"line_start":202,"line_end":202,"column_start":24,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":4162}],"docs":"","sig":null,"attributes":[]},{"id":2213,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215477,"byte_end":1215482,"line_start":209,"line_end":209,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4166},{"krate":0,"index":4168},{"krate":0,"index":4170}],"docs":"","sig":null,"attributes":[]},{"id":2214,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215730,"byte_end":1215735,"line_start":222,"line_end":222,"column_start":33,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":4174}],"docs":"","sig":null,"attributes":[]},{"id":2215,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215887,"byte_end":1215892,"line_start":229,"line_end":229,"column_start":31,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":4178}],"docs":"","sig":null,"attributes":[]},{"id":2216,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216030,"byte_end":1216035,"line_start":236,"line_end":236,"column_start":31,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2217,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216116,"byte_end":1216121,"line_start":239,"line_end":239,"column_start":27,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2218,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216279,"byte_end":1216284,"line_start":244,"line_end":244,"column_start":19,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":4186}],"docs":"","sig":null,"attributes":[]},{"id":2219,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216522,"byte_end":1216527,"line_start":253,"line_end":253,"column_start":21,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4190}],"docs":"","sig":null,"attributes":[]},{"id":2220,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1217396,"byte_end":1217400,"line_start":290,"line_end":290,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4196},{"krate":0,"index":4198},{"krate":0,"index":4200}],"docs":"","sig":null,"attributes":[]},{"id":2221,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1217671,"byte_end":1217675,"line_start":303,"line_end":303,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":4204}],"docs":"","sig":null,"attributes":[]},{"id":2222,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1217844,"byte_end":1217848,"line_start":310,"line_end":310,"column_start":31,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":4208}],"docs":"","sig":null,"attributes":[]},{"id":2223,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1218001,"byte_end":1218005,"line_start":317,"line_end":317,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2224,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1218086,"byte_end":1218090,"line_start":320,"line_end":320,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2225,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220209,"byte_end":1220217,"line_start":392,"line_end":392,"column_start":40,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":4218},{"krate":0,"index":4220},{"krate":0,"index":4222}],"docs":"","sig":null,"attributes":[]},{"id":2226,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220557,"byte_end":1220565,"line_start":407,"line_end":407,"column_start":51,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":4226}],"docs":"","sig":null,"attributes":[]},{"id":2227,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220748,"byte_end":1220756,"line_start":414,"line_end":414,"column_start":49,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":4230}],"docs":"","sig":null,"attributes":[]},{"id":2228,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220931,"byte_end":1220939,"line_start":421,"line_end":421,"column_start":45,"column_end":53},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2229,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1221052,"byte_end":1221060,"line_start":424,"line_end":424,"column_start":49,"column_end":57},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2230,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1224946,"byte_end":1224952,"line_start":548,"line_end":548,"column_start":25,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":4242},{"krate":0,"index":4244}],"docs":"","sig":null,"attributes":[]},{"id":2231,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1225178,"byte_end":1225184,"line_start":560,"line_end":560,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4248}],"docs":"","sig":null,"attributes":[]},{"id":2232,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1226665,"byte_end":1226675,"line_start":604,"line_end":604,"column_start":25,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":4254},{"krate":0,"index":4256},{"krate":0,"index":4258}],"docs":"","sig":null,"attributes":[]},{"id":2233,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1227186,"byte_end":1227196,"line_start":628,"line_end":628,"column_start":30,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2234,"kind":"Direct","span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1227338,"byte_end":1227348,"line_start":633,"line_end":633,"column_start":39,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":4264}],"docs":"","sig":null,"attributes":[]},{"id":2235,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1335359,"byte_end":1335360,"line_start":241,"line_end":241,"column_start":36,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":4522},{"krate":0,"index":4524},{"krate":0,"index":4526}],"docs":"","sig":null,"attributes":[]},{"id":2284,"kind":"Inherent","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1343039,"byte_end":1343050,"line_start":127,"line_end":127,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4562},{"krate":0,"index":4564},{"krate":0,"index":4566}],"docs":"","sig":null,"attributes":[]},{"id":2285,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1343968,"byte_end":1343979,"line_start":159,"line_end":159,"column_start":28,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":4570},{"krate":0,"index":4572},{"krate":0,"index":4574}],"docs":"","sig":null,"attributes":[]},{"id":2286,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1344635,"byte_end":1344641,"line_start":186,"line_end":186,"column_start":37,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":4578}],"docs":"","sig":null,"attributes":[]},{"id":2287,"kind":"Direct","span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1345531,"byte_end":1345537,"line_start":214,"line_end":214,"column_start":41,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":4582}],"docs":"","sig":null,"attributes":[]},{"id":2288,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1406779,"byte_end":1406784,"line_start":21,"line_end":21,"column_start":12,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":4664}],"docs":"","sig":null,"attributes":[]},{"id":2289,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1407686,"byte_end":1407691,"line_start":51,"line_end":51,"column_start":25,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4668},{"krate":0,"index":4670},{"krate":0,"index":4672},{"krate":0,"index":4674},{"krate":0,"index":4676},{"krate":0,"index":4678},{"krate":0,"index":4680},{"krate":0,"index":4682},{"krate":0,"index":4684}],"docs":"","sig":null,"attributes":[]},{"id":2290,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1411694,"byte_end":1411699,"line_start":191,"line_end":191,"column_start":36,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":4688},{"krate":0,"index":4690},{"krate":0,"index":4692}],"docs":"","sig":null,"attributes":[]},{"id":2291,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1413534,"byte_end":1413539,"line_start":252,"line_end":252,"column_start":30,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2292,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1413707,"byte_end":1413712,"line_start":258,"line_end":258,"column_start":34,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2293,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1414502,"byte_end":1414509,"line_start":20,"line_end":20,"column_start":60,"column_end":67},"value":"","parent":null,"children":[{"krate":0,"index":4718}],"docs":"","sig":null,"attributes":[]},{"id":2294,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1414764,"byte_end":1414771,"line_start":27,"line_end":27,"column_start":61,"column_end":68},"value":"","parent":null,"children":[{"krate":0,"index":4722}],"docs":"","sig":null,"attributes":[]},{"id":2295,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1415014,"byte_end":1415021,"line_start":34,"line_end":34,"column_start":56,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":4726}],"docs":"","sig":null,"attributes":[]},{"id":2296,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1415307,"byte_end":1415314,"line_start":43,"line_end":43,"column_start":52,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":4730},{"krate":0,"index":4732},{"krate":0,"index":4734},{"krate":0,"index":4736},{"krate":0,"index":4738}],"docs":"","sig":null,"attributes":[]},{"id":2297,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1416050,"byte_end":1416057,"line_start":70,"line_end":70,"column_start":60,"column_end":67},"value":"","parent":null,"children":[{"krate":0,"index":4742},{"krate":0,"index":4744},{"krate":0,"index":4746}],"docs":"","sig":null,"attributes":[]},{"id":2298,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1416733,"byte_end":1416740,"line_start":94,"line_end":94,"column_start":33,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2299,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1417415,"byte_end":1417422,"line_start":111,"line_end":111,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4754}],"docs":"","sig":null,"attributes":[]},{"id":2300,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1417658,"byte_end":1417665,"line_start":119,"line_end":119,"column_start":27,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":4758}],"docs":"","sig":null,"attributes":[]},{"id":2301,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1418018,"byte_end":1418025,"line_start":129,"line_end":129,"column_start":22,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":4762}],"docs":"","sig":null,"attributes":[]},{"id":2302,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1418301,"byte_end":1418308,"line_start":137,"line_end":137,"column_start":25,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":4766},{"krate":0,"index":4768},{"krate":0,"index":4770},{"krate":0,"index":4772},{"krate":0,"index":4774}],"docs":"","sig":null,"attributes":[]},{"id":2303,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1419090,"byte_end":1419097,"line_start":165,"line_end":165,"column_start":36,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":4778},{"krate":0,"index":4780},{"krate":0,"index":4782}],"docs":"","sig":null,"attributes":[]},{"id":2304,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1419791,"byte_end":1419798,"line_start":188,"line_end":188,"column_start":30,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2305,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1420126,"byte_end":1420139,"line_start":200,"line_end":200,"column_start":12,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4788}],"docs":"","sig":null,"attributes":[]},{"id":2306,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1420376,"byte_end":1420389,"line_start":207,"line_end":207,"column_start":25,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":4792},{"krate":0,"index":4794},{"krate":0,"index":4796},{"krate":0,"index":4798},{"krate":0,"index":4800}],"docs":"","sig":null,"attributes":[]},{"id":2307,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1422612,"byte_end":1422625,"line_start":276,"line_end":276,"column_start":36,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":4804},{"krate":0,"index":4806},{"krate":0,"index":4808}],"docs":"","sig":null,"attributes":[]},{"id":2308,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1425067,"byte_end":1425070,"line_start":22,"line_end":22,"column_start":32,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":4828},{"krate":0,"index":4830}],"docs":"","sig":null,"attributes":[]},{"id":2309,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1425459,"byte_end":1425462,"line_start":36,"line_end":36,"column_start":25,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":4834},{"krate":0,"index":4836},{"krate":0,"index":4838},{"krate":0,"index":4840}],"docs":"","sig":null,"attributes":[]},{"id":2310,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1425931,"byte_end":1425934,"line_start":57,"line_end":57,"column_start":36,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":4844}],"docs":"","sig":null,"attributes":[]},{"id":2311,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1426658,"byte_end":1426661,"line_start":82,"line_end":82,"column_start":30,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":4862},{"krate":0,"index":4864},{"krate":0,"index":4866},{"krate":0,"index":4868},{"krate":0,"index":4870},{"krate":0,"index":4872}],"docs":"","sig":null,"attributes":[]},{"id":2312,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1428493,"byte_end":1428496,"line_start":150,"line_end":150,"column_start":30,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":4876},{"krate":0,"index":4878},{"krate":0,"index":4880},{"krate":0,"index":4882},{"krate":0,"index":4884}],"docs":"","sig":null,"attributes":[]},{"id":2313,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1431056,"byte_end":1431059,"line_start":242,"line_end":242,"column_start":34,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2314,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1431180,"byte_end":1431183,"line_start":246,"line_end":246,"column_start":43,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":4890},{"krate":0,"index":4892}],"docs":"","sig":null,"attributes":[]},{"id":2315,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1431587,"byte_end":1431590,"line_start":260,"line_end":260,"column_start":30,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2316,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1431734,"byte_end":1431737,"line_start":264,"line_end":264,"column_start":34,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2317,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348884,"byte_end":1348887,"line_start":33,"line_end":33,"column_start":9,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":4918}],"docs":"","sig":null,"attributes":[]},{"id":2318,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1349033,"byte_end":1349036,"line_start":40,"line_end":40,"column_start":22,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4922},{"krate":0,"index":4924},{"krate":0,"index":4926},{"krate":0,"index":4928},{"krate":0,"index":4930},{"krate":0,"index":4932},{"krate":0,"index":4934},{"krate":0,"index":4936}],"docs":"","sig":null,"attributes":[]},{"id":2319,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1350142,"byte_end":1350145,"line_start":79,"line_end":79,"column_start":33,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":4940},{"krate":0,"index":4942},{"krate":0,"index":4944},{"krate":0,"index":4946},{"krate":0,"index":4948}],"docs":"","sig":null,"attributes":[]},{"id":2320,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1350935,"byte_end":1350938,"line_start":106,"line_end":106,"column_start":31,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":4952},{"krate":0,"index":4954}],"docs":"","sig":null,"attributes":[]},{"id":2321,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351201,"byte_end":1351204,"line_start":119,"line_end":119,"column_start":27,"column_end":30},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2322,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351345,"byte_end":1351348,"line_start":123,"line_end":123,"column_start":31,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2323,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351861,"byte_end":1351867,"line_start":139,"line_end":139,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":4962}],"docs":"","sig":null,"attributes":[]},{"id":2324,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1352034,"byte_end":1352040,"line_start":146,"line_end":146,"column_start":33,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":4966},{"krate":0,"index":4968},{"krate":0,"index":4970},{"krate":0,"index":4972},{"krate":0,"index":4974}],"docs":"","sig":null,"attributes":[]},{"id":2325,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1352748,"byte_end":1352754,"line_start":173,"line_end":173,"column_start":44,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":4978},{"krate":0,"index":4980},{"krate":0,"index":4982}],"docs":"","sig":null,"attributes":[]},{"id":2326,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1353378,"byte_end":1353384,"line_start":194,"line_end":194,"column_start":42,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":4986},{"krate":0,"index":4988}],"docs":"","sig":null,"attributes":[]},{"id":2327,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1353660,"byte_end":1353666,"line_start":207,"line_end":207,"column_start":38,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2328,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1353787,"byte_end":1353793,"line_start":212,"line_end":212,"column_start":51,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":4994},{"krate":0,"index":4996}],"docs":"","sig":null,"attributes":[]},{"id":2329,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354151,"byte_end":1354157,"line_start":226,"line_end":226,"column_start":42,"column_end":48},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2330,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354677,"byte_end":1354683,"line_start":244,"line_end":244,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":5002}],"docs":"","sig":null,"attributes":[]},{"id":2331,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354848,"byte_end":1354854,"line_start":251,"line_end":251,"column_start":33,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":5006},{"krate":0,"index":5008},{"krate":0,"index":5010},{"krate":0,"index":5012},{"krate":0,"index":5014}],"docs":"","sig":null,"attributes":[]},{"id":2332,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1355575,"byte_end":1355581,"line_start":278,"line_end":278,"column_start":44,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":5018},{"krate":0,"index":5020},{"krate":0,"index":5022}],"docs":"","sig":null,"attributes":[]},{"id":2333,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1356218,"byte_end":1356224,"line_start":299,"line_end":299,"column_start":42,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5026},{"krate":0,"index":5028}],"docs":"","sig":null,"attributes":[]},{"id":2334,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1356494,"byte_end":1356500,"line_start":312,"line_end":312,"column_start":38,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2335,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1356622,"byte_end":1356628,"line_start":317,"line_end":317,"column_start":51,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":5034},{"krate":0,"index":5036}],"docs":"","sig":null,"attributes":[]},{"id":2336,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1356947,"byte_end":1356953,"line_start":329,"line_end":329,"column_start":51,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":5040},{"krate":0,"index":5042}],"docs":"","sig":null,"attributes":[]},{"id":2337,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357311,"byte_end":1357317,"line_start":343,"line_end":343,"column_start":42,"column_end":48},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2338,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357822,"byte_end":1357827,"line_start":362,"line_end":362,"column_start":16,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":5048}],"docs":"","sig":null,"attributes":[]},{"id":2339,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357997,"byte_end":1358002,"line_start":369,"line_end":369,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5052},{"krate":0,"index":5054},{"krate":0,"index":5056}],"docs":"","sig":null,"attributes":[]},{"id":2340,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1358647,"byte_end":1358652,"line_start":392,"line_end":392,"column_start":27,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2341,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1359184,"byte_end":1359190,"line_start":409,"line_end":409,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":5062}],"docs":"","sig":null,"attributes":[]},{"id":2342,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1359429,"byte_end":1359435,"line_start":417,"line_end":417,"column_start":22,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":5066},{"krate":0,"index":5068},{"krate":0,"index":5070},{"krate":0,"index":5072}],"docs":"","sig":null,"attributes":[]},{"id":2343,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1361701,"byte_end":1361707,"line_start":489,"line_end":489,"column_start":31,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2344,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1363593,"byte_end":1363596,"line_start":548,"line_end":548,"column_start":12,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":5078}],"docs":"","sig":null,"attributes":[]},{"id":2345,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1363784,"byte_end":1363787,"line_start":555,"line_end":555,"column_start":39,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":5082}],"docs":"","sig":null,"attributes":[]},{"id":2346,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1364042,"byte_end":1364045,"line_start":564,"line_end":564,"column_start":38,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":5086},{"krate":0,"index":5088},{"krate":0,"index":5090},{"krate":0,"index":5092},{"krate":0,"index":5094}],"docs":"","sig":null,"attributes":[]},{"id":2347,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1364863,"byte_end":1364866,"line_start":593,"line_end":593,"column_start":60,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":5098},{"krate":0,"index":5100},{"krate":0,"index":5102}],"docs":"","sig":null,"attributes":[]},{"id":2348,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1365576,"byte_end":1365579,"line_start":617,"line_end":617,"column_start":56,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":5106},{"krate":0,"index":5108}],"docs":"","sig":null,"attributes":[]},{"id":2349,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1365846,"byte_end":1365849,"line_start":630,"line_end":630,"column_start":48,"column_end":51},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2350,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1365983,"byte_end":1365986,"line_start":634,"line_end":634,"column_start":37,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2351,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1366115,"byte_end":1366118,"line_start":639,"line_end":639,"column_start":46,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":5116},{"krate":0,"index":5118}],"docs":"","sig":null,"attributes":[]},{"id":2352,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1366847,"byte_end":1366853,"line_start":664,"line_end":664,"column_start":12,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":5122}],"docs":"","sig":null,"attributes":[]},{"id":2353,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1367063,"byte_end":1367069,"line_start":671,"line_end":671,"column_start":39,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":5126}],"docs":"","sig":null,"attributes":[]},{"id":2354,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1367324,"byte_end":1367330,"line_start":680,"line_end":680,"column_start":35,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":5130},{"krate":0,"index":5132},{"krate":0,"index":5134},{"krate":0,"index":5136},{"krate":0,"index":5138},{"krate":0,"index":5140}],"docs":"","sig":null,"attributes":[]},{"id":2355,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1369341,"byte_end":1369347,"line_start":737,"line_end":737,"column_start":57,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":5144},{"krate":0,"index":5146},{"krate":0,"index":5148}],"docs":"","sig":null,"attributes":[]},{"id":2356,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1370314,"byte_end":1370320,"line_start":771,"line_end":771,"column_start":45,"column_end":51},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2357,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1370852,"byte_end":1370861,"line_start":788,"line_end":788,"column_start":12,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":5154}],"docs":"","sig":null,"attributes":[]},{"id":2358,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1371061,"byte_end":1371070,"line_start":795,"line_end":795,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5158}],"docs":"","sig":null,"attributes":[]},{"id":2359,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1371331,"byte_end":1371340,"line_start":804,"line_end":804,"column_start":38,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":5162},{"krate":0,"index":5164},{"krate":0,"index":5166},{"krate":0,"index":5168},{"krate":0,"index":5170}],"docs":"","sig":null,"attributes":[]},{"id":2360,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1372467,"byte_end":1372476,"line_start":844,"line_end":844,"column_start":60,"column_end":69},"value":"","parent":null,"children":[{"krate":0,"index":5174},{"krate":0,"index":5176},{"krate":0,"index":5178}],"docs":"","sig":null,"attributes":[]},{"id":2361,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1373402,"byte_end":1373411,"line_start":876,"line_end":876,"column_start":48,"column_end":57},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2362,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1373958,"byte_end":1373967,"line_start":893,"line_end":893,"column_start":9,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":5184}],"docs":"","sig":null,"attributes":[]},{"id":2363,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1374135,"byte_end":1374144,"line_start":900,"line_end":900,"column_start":22,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":5188},{"krate":0,"index":5190},{"krate":0,"index":5192},{"krate":0,"index":5194},{"krate":0,"index":5196},{"krate":0,"index":5198},{"krate":0,"index":5200}],"docs":"","sig":null,"attributes":[]},{"id":2364,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1376150,"byte_end":1376159,"line_start":971,"line_end":971,"column_start":33,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":5204},{"krate":0,"index":5206},{"krate":0,"index":5208},{"krate":0,"index":5210}],"docs":"","sig":null,"attributes":[]},{"id":2365,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377945,"byte_end":1377954,"line_start":1022,"line_end":1022,"column_start":31,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":5214},{"krate":0,"index":5216}],"docs":"","sig":null,"attributes":[]},{"id":2366,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378172,"byte_end":1378181,"line_start":1033,"line_end":1033,"column_start":40,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":5220},{"krate":0,"index":5222}],"docs":"","sig":null,"attributes":[]},{"id":2367,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378507,"byte_end":1378516,"line_start":1046,"line_end":1046,"column_start":27,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2368,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378631,"byte_end":1378640,"line_start":1049,"line_end":1049,"column_start":31,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2369,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1379270,"byte_end":1379278,"line_start":1070,"line_end":1070,"column_start":19,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5230}],"docs":"","sig":null,"attributes":[]},{"id":2370,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1379702,"byte_end":1379710,"line_start":1081,"line_end":1081,"column_start":32,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":5234},{"krate":0,"index":5236},{"krate":0,"index":5238},{"krate":0,"index":5240},{"krate":0,"index":5242},{"krate":0,"index":5244},{"krate":0,"index":5246},{"krate":0,"index":5248}],"docs":"","sig":null,"attributes":[]},{"id":2371,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1381909,"byte_end":1381917,"line_start":1161,"line_end":1161,"column_start":50,"column_end":58},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2372,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382013,"byte_end":1382021,"line_start":1164,"line_end":1164,"column_start":42,"column_end":50},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2373,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382047,"byte_end":1382055,"line_start":1166,"line_end":1166,"column_start":19,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5256}],"docs":"","sig":null,"attributes":[]},{"id":2374,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1384052,"byte_end":1384061,"line_start":1227,"line_end":1227,"column_start":12,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":5260}],"docs":"","sig":null,"attributes":[]},{"id":2375,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1384290,"byte_end":1384299,"line_start":1234,"line_end":1234,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5264}],"docs":"","sig":null,"attributes":[]},{"id":2376,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1384596,"byte_end":1384605,"line_start":1244,"line_end":1244,"column_start":35,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5268},{"krate":0,"index":5270},{"krate":0,"index":5272},{"krate":0,"index":5274},{"krate":0,"index":5276}],"docs":"","sig":null,"attributes":[]},{"id":2377,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386024,"byte_end":1386033,"line_start":1297,"line_end":1297,"column_start":30,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2378,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386609,"byte_end":1386618,"line_start":1315,"line_end":1315,"column_start":12,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":5282}],"docs":"","sig":null,"attributes":[]},{"id":2379,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386847,"byte_end":1386856,"line_start":1322,"line_end":1322,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":5286}],"docs":"","sig":null,"attributes":[]},{"id":2380,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1387153,"byte_end":1387162,"line_start":1332,"line_end":1332,"column_start":35,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5290},{"krate":0,"index":5292},{"krate":0,"index":5294},{"krate":0,"index":5296}],"docs":"","sig":null,"attributes":[]},{"id":2381,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388582,"byte_end":1388591,"line_start":1385,"line_end":1385,"column_start":30,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2382,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1389103,"byte_end":1389107,"line_start":1402,"line_end":1402,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":5302}],"docs":"","sig":null,"attributes":[]},{"id":2383,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1389268,"byte_end":1389272,"line_start":1409,"line_end":1409,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":5306},{"krate":0,"index":5308},{"krate":0,"index":5310},{"krate":0,"index":5312},{"krate":0,"index":5314},{"krate":0,"index":5316},{"krate":0,"index":5318},{"krate":0,"index":5320}],"docs":"","sig":null,"attributes":[]},{"id":2384,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1391542,"byte_end":1391546,"line_start":1499,"line_end":1499,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2385,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1391680,"byte_end":1391684,"line_start":1502,"line_end":1502,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":5326},{"krate":0,"index":5328}],"docs":"","sig":null,"attributes":[]},{"id":2386,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392493,"byte_end":1392497,"line_start":1529,"line_end":1529,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2387,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1393016,"byte_end":1393020,"line_start":1545,"line_end":1545,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":5334}],"docs":"","sig":null,"attributes":[]},{"id":2388,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1393181,"byte_end":1393185,"line_start":1552,"line_end":1552,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":5338},{"krate":0,"index":5340},{"krate":0,"index":5342},{"krate":0,"index":5344},{"krate":0,"index":5346}],"docs":"","sig":null,"attributes":[]},{"id":2389,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1394761,"byte_end":1394765,"line_start":1616,"line_end":1616,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2390,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1394873,"byte_end":1394877,"line_start":1619,"line_end":1619,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2391,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395004,"byte_end":1395008,"line_start":1622,"line_end":1622,"column_start":43,"column_end":47},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2392,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395493,"byte_end":1395497,"line_start":1639,"line_end":1639,"column_start":16,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":5356}],"docs":"","sig":null,"attributes":[]},{"id":2393,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395729,"byte_end":1395733,"line_start":1646,"line_end":1646,"column_start":55,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":5360}],"docs":"","sig":null,"attributes":[]},{"id":2394,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1396028,"byte_end":1396032,"line_start":1656,"line_end":1656,"column_start":32,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":5364},{"krate":0,"index":5366},{"krate":0,"index":5368},{"krate":0,"index":5370}],"docs":"","sig":null,"attributes":[]},{"id":2395,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397428,"byte_end":1397432,"line_start":1703,"line_end":1703,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":5374}],"docs":"","sig":null,"attributes":[]},{"id":2396,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397599,"byte_end":1397603,"line_start":1710,"line_end":1710,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2397,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397696,"byte_end":1397700,"line_start":1713,"line_end":1713,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":5380},{"krate":0,"index":5382},{"krate":0,"index":5384},{"krate":0,"index":5386},{"krate":0,"index":5388},{"krate":0,"index":5390},{"krate":0,"index":5392},{"krate":0,"index":5394}],"docs":"","sig":null,"attributes":[]},{"id":2398,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399475,"byte_end":1399479,"line_start":1791,"line_end":1791,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":5398},{"krate":0,"index":5400},{"krate":0,"index":5402},{"krate":0,"index":5404}],"docs":"","sig":null,"attributes":[]},{"id":2399,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1400717,"byte_end":1400721,"line_start":1839,"line_end":1839,"column_start":40,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5408},{"krate":0,"index":5410}],"docs":"","sig":null,"attributes":[]},{"id":2400,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1401016,"byte_end":1401020,"line_start":1852,"line_end":1852,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":5414},{"krate":0,"index":5416},{"krate":0,"index":5418},{"krate":0,"index":5420},{"krate":0,"index":5422},{"krate":0,"index":5424},{"krate":0,"index":5426}],"docs":"","sig":null,"attributes":[]},{"id":2401,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1401982,"byte_end":1401986,"line_start":1894,"line_end":1894,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":5430},{"krate":0,"index":5432},{"krate":0,"index":5434},{"krate":0,"index":5436}],"docs":"","sig":null,"attributes":[]},{"id":2402,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1402745,"byte_end":1402749,"line_start":1924,"line_end":1924,"column_start":31,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":5440},{"krate":0,"index":5442}],"docs":"","sig":null,"attributes":[]},{"id":2403,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403406,"byte_end":1403413,"line_start":1949,"line_end":1949,"column_start":12,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":5446}],"docs":"","sig":null,"attributes":[]},{"id":2404,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403609,"byte_end":1403616,"line_start":1956,"line_end":1956,"column_start":39,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":5450}],"docs":"","sig":null,"attributes":[]},{"id":2405,"kind":"Inherent","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403813,"byte_end":1403820,"line_start":1964,"line_end":1964,"column_start":22,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":5454}],"docs":"","sig":null,"attributes":[]},{"id":2406,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1404112,"byte_end":1404119,"line_start":1976,"line_end":1976,"column_start":35,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":5458},{"krate":0,"index":5460},{"krate":0,"index":5462},{"krate":0,"index":5464},{"krate":0,"index":5466}],"docs":"","sig":null,"attributes":[]},{"id":2407,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1405051,"byte_end":1405058,"line_start":2008,"line_end":2008,"column_start":57,"column_end":64},"value":"","parent":null,"children":[{"krate":0,"index":5470},{"krate":0,"index":5472},{"krate":0,"index":5474}],"docs":"","sig":null,"attributes":[]},{"id":2408,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1405876,"byte_end":1405883,"line_start":2035,"line_end":2035,"column_start":53,"column_end":60},"value":"","parent":null,"children":[{"krate":0,"index":5478},{"krate":0,"index":5480}],"docs":"","sig":null,"attributes":[]},{"id":2409,"kind":"Direct","span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1406143,"byte_end":1406150,"line_start":2048,"line_end":2048,"column_start":45,"column_end":52},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2410,"kind":"Direct","span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195740,"byte_end":1195749,"line_start":372,"line_end":372,"column_start":20,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":5486},{"krate":0,"index":5488},{"krate":0,"index":5490},{"krate":0,"index":5492},{"krate":0,"index":5494}],"docs":"","sig":null,"attributes":[]},{"id":2411,"kind":"Inherent","span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1196165,"byte_end":1196174,"line_start":388,"line_end":388,"column_start":12,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":5498}],"docs":"","sig":null,"attributes":[]},{"id":2412,"kind":"Inherent","span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1196379,"byte_end":1196388,"line_start":398,"line_end":398,"column_start":14,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":5502},{"krate":0,"index":5504}],"docs":"","sig":null,"attributes":[]},{"id":2413,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1437985,"byte_end":1437991,"line_start":163,"line_end":163,"column_start":9,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":5532},{"krate":0,"index":5534},{"krate":0,"index":5536},{"krate":0,"index":5538},{"krate":0,"index":5540},{"krate":0,"index":5542},{"krate":0,"index":5544},{"krate":0,"index":5546},{"krate":0,"index":5548},{"krate":0,"index":5550},{"krate":0,"index":5552},{"krate":0,"index":5554},{"krate":0,"index":5556},{"krate":0,"index":5558},{"krate":0,"index":5560},{"krate":0,"index":5562},{"krate":0,"index":5564},{"krate":0,"index":5566},{"krate":0,"index":5568},{"krate":0,"index":5570},{"krate":0,"index":5572},{"krate":0,"index":5574},{"krate":0,"index":5576},{"krate":0,"index":5578},{"krate":0,"index":5580},{"krate":0,"index":5582},{"krate":0,"index":5584}],"docs":"","sig":null,"attributes":[]},{"id":2414,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1459008,"byte_end":1459014,"line_start":879,"line_end":879,"column_start":15,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":5588}],"docs":"","sig":null,"attributes":[]},{"id":2415,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1459476,"byte_end":1459482,"line_start":898,"line_end":898,"column_start":15,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":5592}],"docs":"","sig":null,"attributes":[]},{"id":2416,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1459969,"byte_end":1459975,"line_start":917,"line_end":917,"column_start":16,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":5596}],"docs":"","sig":null,"attributes":[]},{"id":2417,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1460443,"byte_end":1460449,"line_start":936,"line_end":936,"column_start":16,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":5600}],"docs":"","sig":null,"attributes":[]},{"id":2418,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1460956,"byte_end":1460962,"line_start":955,"line_end":955,"column_start":18,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":5604}],"docs":"","sig":null,"attributes":[]},{"id":2419,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1462386,"byte_end":1462392,"line_start":995,"line_end":995,"column_start":16,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":5608}],"docs":"","sig":null,"attributes":[]},{"id":2420,"kind":"Inherent","span":{"file_name":"src/libcore/option.rs","byte_start":1462733,"byte_end":1462739,"line_start":1005,"line_end":1005,"column_start":12,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":5612}],"docs":"","sig":null,"attributes":[]},{"id":2421,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1463944,"byte_end":1463950,"line_start":1044,"line_end":1044,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5618}],"docs":"","sig":null,"attributes":[]},{"id":2422,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1464123,"byte_end":1464129,"line_start":1051,"line_end":1051,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":5622},{"krate":0,"index":5624},{"krate":0,"index":5626}],"docs":"","sig":null,"attributes":[]},{"id":2423,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1465198,"byte_end":1465204,"line_start":1095,"line_end":1095,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5646}],"docs":"","sig":null,"attributes":[]},{"id":2424,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1465376,"byte_end":1465382,"line_start":1102,"line_end":1102,"column_start":37,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":5650}],"docs":"","sig":null,"attributes":[]},{"id":2425,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1465577,"byte_end":1465583,"line_start":1109,"line_end":1109,"column_start":41,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":5654}],"docs":"","sig":null,"attributes":[]},{"id":2426,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1465947,"byte_end":1465951,"line_start":1124,"line_end":1124,"column_start":22,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":5658},{"krate":0,"index":5660},{"krate":0,"index":5662}],"docs":"","sig":null,"attributes":[]},{"id":2427,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1466273,"byte_end":1466277,"line_start":1141,"line_end":1141,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":5666}],"docs":"","sig":null,"attributes":[]},{"id":2428,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1466403,"byte_end":1466407,"line_start":1148,"line_end":1148,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2429,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1466440,"byte_end":1466444,"line_start":1149,"line_end":1149,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2430,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1466481,"byte_end":1466485,"line_start":1150,"line_end":1150,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2431,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1467039,"byte_end":1467043,"line_start":1166,"line_end":1166,"column_start":26,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":5676},{"krate":0,"index":5678},{"krate":0,"index":5680}],"docs":"","sig":null,"attributes":[]},{"id":2432,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1467329,"byte_end":1467333,"line_start":1176,"line_end":1176,"column_start":37,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":5684}],"docs":"","sig":null,"attributes":[]},{"id":2433,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1467508,"byte_end":1467512,"line_start":1182,"line_end":1182,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2434,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1467597,"byte_end":1467601,"line_start":1185,"line_end":1185,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2435,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1467697,"byte_end":1467701,"line_start":1188,"line_end":1188,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2436,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1467777,"byte_end":1467781,"line_start":1191,"line_end":1191,"column_start":19,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":5694}],"docs":"","sig":null,"attributes":[]},{"id":2437,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1468460,"byte_end":1468467,"line_start":1212,"line_end":1212,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":5698},{"krate":0,"index":5700},{"krate":0,"index":5702}],"docs":"","sig":null,"attributes":[]},{"id":2438,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1468761,"byte_end":1468768,"line_start":1222,"line_end":1222,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5706}],"docs":"","sig":null,"attributes":[]},{"id":2439,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1468947,"byte_end":1468954,"line_start":1228,"line_end":1228,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2440,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1469039,"byte_end":1469046,"line_start":1231,"line_end":1231,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2441,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1469141,"byte_end":1469148,"line_start":1233,"line_end":1233,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2442,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1469710,"byte_end":1469718,"line_start":1249,"line_end":1249,"column_start":22,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":5716},{"krate":0,"index":5718},{"krate":0,"index":5720}],"docs":"","sig":null,"attributes":[]},{"id":2443,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1469988,"byte_end":1469996,"line_start":1259,"line_end":1259,"column_start":33,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":5724}],"docs":"","sig":null,"attributes":[]},{"id":2444,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1470163,"byte_end":1470171,"line_start":1265,"line_end":1265,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2445,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1470252,"byte_end":1470260,"line_start":1268,"line_end":1268,"column_start":27,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2446,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1470352,"byte_end":1470360,"line_start":1271,"line_end":1271,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2447,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1470643,"byte_end":1470649,"line_start":1278,"line_end":1278,"column_start":57,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":5734}],"docs":"","sig":null,"attributes":[]},{"id":2448,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1473055,"byte_end":1473062,"line_start":1351,"line_end":1351,"column_start":62,"column_end":69},"value":"","parent":null,"children":[{"krate":0,"index":5740},{"krate":0,"index":5742},{"krate":0,"index":5744}],"docs":"","sig":null,"attributes":[]},{"id":2449,"kind":"Direct","span":{"file_name":"src/libcore/option.rs","byte_start":1474625,"byte_end":1474631,"line_start":1397,"line_end":1397,"column_start":22,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":5748},{"krate":0,"index":5750},{"krate":0,"index":5752},{"krate":0,"index":5754},{"krate":0,"index":5756}],"docs":"","sig":null,"attributes":[]},{"id":2450,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1486145,"byte_end":1486151,"line_start":260,"line_end":260,"column_start":12,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":5780},{"krate":0,"index":5782},{"krate":0,"index":5784},{"krate":0,"index":5786},{"krate":0,"index":5788},{"krate":0,"index":5790},{"krate":0,"index":5792},{"krate":0,"index":5794},{"krate":0,"index":5796},{"krate":0,"index":5798},{"krate":0,"index":5800},{"krate":0,"index":5802},{"krate":0,"index":5804},{"krate":0,"index":5806},{"krate":0,"index":5808},{"krate":0,"index":5810},{"krate":0,"index":5812}],"docs":"","sig":null,"attributes":[]},{"id":2451,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1501522,"byte_end":1501528,"line_start":771,"line_end":771,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":5816},{"krate":0,"index":5818}],"docs":"","sig":null,"attributes":[]},{"id":2452,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1503229,"byte_end":1503235,"line_start":832,"line_end":832,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":5822},{"krate":0,"index":5824}],"docs":"","sig":null,"attributes":[]},{"id":2453,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1504922,"byte_end":1504928,"line_start":892,"line_end":892,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5828}],"docs":"","sig":null,"attributes":[]},{"id":2454,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1506319,"byte_end":1506325,"line_start":931,"line_end":931,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":5832}],"docs":"","sig":null,"attributes":[]},{"id":2455,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1506790,"byte_end":1506796,"line_start":943,"line_end":943,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":5836}],"docs":"","sig":null,"attributes":[]},{"id":2456,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1507278,"byte_end":1507284,"line_start":956,"line_end":956,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":5840}],"docs":"","sig":null,"attributes":[]},{"id":2457,"kind":"Inherent","span":{"file_name":"src/libcore/result.rs","byte_start":1507720,"byte_end":1507726,"line_start":968,"line_end":968,"column_start":12,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":5844}],"docs":"","sig":null,"attributes":[]},{"id":2458,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1508971,"byte_end":1508977,"line_start":1007,"line_end":1007,"column_start":29,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":5850},{"krate":0,"index":5852},{"krate":0,"index":5854}],"docs":"","sig":null,"attributes":[]},{"id":2459,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1510814,"byte_end":1510818,"line_start":1072,"line_end":1072,"column_start":26,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":5874},{"krate":0,"index":5876},{"krate":0,"index":5878}],"docs":"","sig":null,"attributes":[]},{"id":2460,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1511160,"byte_end":1511164,"line_start":1085,"line_end":1085,"column_start":37,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":5882}],"docs":"","sig":null,"attributes":[]},{"id":2461,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1511334,"byte_end":1511338,"line_start":1091,"line_end":1091,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2462,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1511423,"byte_end":1511427,"line_start":1094,"line_end":1094,"column_start":27,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2463,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1511523,"byte_end":1511527,"line_start":1097,"line_end":1097,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2464,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1511603,"byte_end":1511607,"line_start":1100,"line_end":1100,"column_start":19,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":5892}],"docs":"","sig":null,"attributes":[]},{"id":2465,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1512144,"byte_end":1512151,"line_start":1117,"line_end":1117,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":5896},{"krate":0,"index":5898},{"krate":0,"index":5900}],"docs":"","sig":null,"attributes":[]},{"id":2466,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1512501,"byte_end":1512508,"line_start":1130,"line_end":1130,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5904}],"docs":"","sig":null,"attributes":[]},{"id":2467,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1512682,"byte_end":1512689,"line_start":1136,"line_end":1136,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2468,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1512774,"byte_end":1512781,"line_start":1139,"line_end":1139,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2469,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1512877,"byte_end":1512884,"line_start":1142,"line_end":1142,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2470,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1513555,"byte_end":1513563,"line_start":1160,"line_end":1160,"column_start":22,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":5914},{"krate":0,"index":5916},{"krate":0,"index":5918}],"docs":"","sig":null,"attributes":[]},{"id":2471,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1513889,"byte_end":1513897,"line_start":1173,"line_end":1173,"column_start":33,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":5922}],"docs":"","sig":null,"attributes":[]},{"id":2472,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1514059,"byte_end":1514067,"line_start":1179,"line_end":1179,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2473,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1514148,"byte_end":1514156,"line_start":1182,"line_end":1182,"column_start":27,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2474,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1514248,"byte_end":1514256,"line_start":1185,"line_end":1185,"column_start":31,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2475,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1514545,"byte_end":1514551,"line_start":1192,"line_end":1192,"column_start":63,"column_end":69},"value":"","parent":null,"children":[{"krate":0,"index":5932}],"docs":"","sig":null,"attributes":[]},{"id":2476,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1516549,"byte_end":1516556,"line_start":1245,"line_end":1245,"column_start":68,"column_end":75},"value":"","parent":null,"children":[{"krate":0,"index":5938},{"krate":0,"index":5940},{"krate":0,"index":5942}],"docs":"","sig":null,"attributes":[]},{"id":2477,"kind":"Direct","span":{"file_name":"src/libcore/result.rs","byte_start":1517448,"byte_end":1517454,"line_start":1277,"line_end":1277,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":5946},{"krate":0,"index":5948},{"krate":0,"index":5950},{"krate":0,"index":5952},{"krate":0,"index":5954}],"docs":"","sig":null,"attributes":[]},{"id":2478,"kind":"Direct","span":{"file_name":"src/libcore/ffi.rs","byte_start":1519415,"byte_end":1519421,"line_start":41,"line_end":41,"column_start":21,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":5964}],"docs":"","sig":null,"attributes":[]},{"id":2490,"kind":"Inherent","span":{"file_name":"src/libcore/ffi.rs","byte_start":1524144,"byte_end":1524150,"line_start":178,"line_end":178,"column_start":10,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":5978},{"krate":0,"index":5980}],"docs":"","sig":null,"attributes":[]},{"id":2491,"kind":"Inherent","span":{"file_name":"src/libcore/slice/rotate.rs","byte_start":1706148,"byte_end":1706156,"line_start":18,"line_end":18,"column_start":9,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":6086}],"docs":"","sig":null,"attributes":[]},{"id":2492,"kind":"Direct","span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1708976,"byte_end":1708986,"line_start":19,"line_end":19,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":6106}],"docs":"","sig":null,"attributes":[]},{"id":2494,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615551,"byte_end":1615556,"line_start":2584,"line_end":2584,"column_start":26,"column_end":31},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2495,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615653,"byte_end":1615660,"line_start":2586,"line_end":2586,"column_start":26,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2496,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615757,"byte_end":1615766,"line_start":2588,"line_end":2588,"column_start":26,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2497,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615863,"byte_end":1615872,"line_start":2590,"line_end":2590,"column_start":26,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2498,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615962,"byte_end":1615976,"line_start":2592,"line_end":2592,"column_start":26,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2499,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616073,"byte_end":1616089,"line_start":2594,"line_end":2594,"column_start":26,"column_end":42},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2501,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1619480,"byte_end":1619485,"line_start":2698,"line_end":2698,"column_start":35,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":6382},{"krate":0,"index":6384},{"krate":0,"index":6386},{"krate":0,"index":6388},{"krate":0,"index":6390},{"krate":0,"index":6392},{"krate":0,"index":6394}],"docs":"","sig":null,"attributes":[]},{"id":2502,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1621157,"byte_end":1621164,"line_start":2759,"line_end":2759,"column_start":34,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":6398},{"krate":0,"index":6400},{"krate":0,"index":6402},{"krate":0,"index":6404},{"krate":0,"index":6406},{"krate":0,"index":6408},{"krate":0,"index":6410}],"docs":"","sig":null,"attributes":[]},{"id":2503,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1621986,"byte_end":1621995,"line_start":2794,"line_end":2794,"column_start":34,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":6414},{"krate":0,"index":6416},{"krate":0,"index":6418},{"krate":0,"index":6420},{"krate":0,"index":6422},{"krate":0,"index":6424},{"krate":0,"index":6426}],"docs":"","sig":null,"attributes":[]},{"id":2504,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1622889,"byte_end":1622898,"line_start":2829,"line_end":2829,"column_start":34,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":6430},{"krate":0,"index":6432},{"krate":0,"index":6434},{"krate":0,"index":6436},{"krate":0,"index":6438},{"krate":0,"index":6440},{"krate":0,"index":6442}],"docs":"","sig":null,"attributes":[]},{"id":2505,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1623570,"byte_end":1623584,"line_start":2865,"line_end":2865,"column_start":34,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":6446},{"krate":0,"index":6448},{"krate":0,"index":6450},{"krate":0,"index":6452},{"krate":0,"index":6454},{"krate":0,"index":6456},{"krate":0,"index":6458}],"docs":"","sig":null,"attributes":[]},{"id":2506,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1624790,"byte_end":1624806,"line_start":2904,"line_end":2904,"column_start":34,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":6462},{"krate":0,"index":6464},{"krate":0,"index":6466},{"krate":0,"index":6468},{"krate":0,"index":6470},{"krate":0,"index":6472},{"krate":0,"index":6474}],"docs":"","sig":null,"attributes":[]},{"id":2507,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1637801,"byte_end":1637805,"line_start":3286,"line_end":3286,"column_start":36,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":6512}],"docs":"","sig":null,"attributes":[]},{"id":2508,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1638052,"byte_end":1638056,"line_start":3295,"line_end":3295,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2509,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1638143,"byte_end":1638147,"line_start":3297,"line_end":3297,"column_start":31,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2510,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1638171,"byte_end":1638175,"line_start":3299,"line_end":3299,"column_start":13,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":6520}],"docs":"","sig":null,"attributes":[]},{"id":2511,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1639585,"byte_end":1639589,"line_start":3343,"line_end":3343,"column_start":19,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":6524}],"docs":"","sig":null,"attributes":[]},{"id":2512,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1639777,"byte_end":1639781,"line_start":3348,"line_end":3348,"column_start":24,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":6528}],"docs":"","sig":null,"attributes":[]},{"id":2513,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1640940,"byte_end":1640947,"line_start":3388,"line_end":3388,"column_start":36,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":6534}],"docs":"","sig":null,"attributes":[]},{"id":2514,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1641199,"byte_end":1641206,"line_start":3397,"line_end":3397,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2515,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1641293,"byte_end":1641300,"line_start":3399,"line_end":3399,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2516,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1641324,"byte_end":1641331,"line_start":3401,"line_end":3401,"column_start":13,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":6542},{"krate":0,"index":6544}],"docs":"","sig":null,"attributes":[]},{"id":2517,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1644539,"byte_end":1644544,"line_start":3495,"line_end":3495,"column_start":39,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":6554}],"docs":"","sig":null,"attributes":[]},{"id":2518,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1644912,"byte_end":1644917,"line_start":3506,"line_end":3506,"column_start":22,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":6558}],"docs":"","sig":null,"attributes":[]},{"id":2519,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1645201,"byte_end":1645206,"line_start":3517,"line_end":3517,"column_start":29,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":6562},{"krate":0,"index":6564},{"krate":0,"index":6566}],"docs":"","sig":null,"attributes":[]},{"id":2520,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1645917,"byte_end":1645922,"line_start":3545,"line_end":3545,"column_start":40,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":6570}],"docs":"","sig":null,"attributes":[]},{"id":2521,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1646365,"byte_end":1646370,"line_start":3561,"line_end":3561,"column_start":30,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":6574}],"docs":"","sig":null,"attributes":[]},{"id":2522,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1646633,"byte_end":1646638,"line_start":3569,"line_end":3569,"column_start":30,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2523,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647229,"byte_end":1647237,"line_start":3586,"line_end":3586,"column_start":39,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":6582}],"docs":"","sig":null,"attributes":[]},{"id":2524,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647515,"byte_end":1647523,"line_start":3595,"line_end":3595,"column_start":30,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":6586}],"docs":"","sig":null,"attributes":[]},{"id":2525,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647868,"byte_end":1647876,"line_start":3608,"line_end":3608,"column_start":29,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":6590},{"krate":0,"index":6592},{"krate":0,"index":6594}],"docs":"","sig":null,"attributes":[]},{"id":2526,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1648944,"byte_end":1648952,"line_start":3643,"line_end":3643,"column_start":40,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":6598}],"docs":"","sig":null,"attributes":[]},{"id":2527,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1649652,"byte_end":1649660,"line_start":3667,"line_end":3667,"column_start":30,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2528,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650323,"byte_end":1650329,"line_start":3683,"line_end":3683,"column_start":39,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":6604}],"docs":"","sig":null,"attributes":[]},{"id":2529,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650670,"byte_end":1650676,"line_start":3693,"line_end":3693,"column_start":29,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":6608},{"krate":0,"index":6610},{"krate":0,"index":6612}],"docs":"","sig":null,"attributes":[]},{"id":2530,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651037,"byte_end":1651043,"line_start":3708,"line_end":3708,"column_start":40,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":6616}],"docs":"","sig":null,"attributes":[]},{"id":2531,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651264,"byte_end":1651270,"line_start":3716,"line_end":3716,"column_start":30,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":6620}],"docs":"","sig":null,"attributes":[]},{"id":2532,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651490,"byte_end":1651496,"line_start":3724,"line_end":3724,"column_start":30,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2533,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652111,"byte_end":1652120,"line_start":3739,"line_end":3739,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":6628}],"docs":"","sig":null,"attributes":[]},{"id":2534,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652465,"byte_end":1652474,"line_start":3749,"line_end":3749,"column_start":30,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":6632}],"docs":"","sig":null,"attributes":[]},{"id":2535,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652697,"byte_end":1652706,"line_start":3757,"line_end":3757,"column_start":29,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":6636},{"krate":0,"index":6638},{"krate":0,"index":6640}],"docs":"","sig":null,"attributes":[]},{"id":2536,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653075,"byte_end":1653084,"line_start":3772,"line_end":3772,"column_start":40,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":6644}],"docs":"","sig":null,"attributes":[]},{"id":2537,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653314,"byte_end":1653323,"line_start":3782,"line_end":3782,"column_start":30,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2538,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653630,"byte_end":1653643,"line_start":3793,"line_end":3793,"column_start":44,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":6650},{"krate":0,"index":6652},{"krate":0,"index":6654}],"docs":"","sig":null,"attributes":[]},{"id":2539,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654651,"byte_end":1654657,"line_start":3825,"line_end":3825,"column_start":39,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":6660}],"docs":"","sig":null,"attributes":[]},{"id":2540,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1655462,"byte_end":1655469,"line_start":3847,"line_end":3847,"column_start":39,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":6666}],"docs":"","sig":null,"attributes":[]},{"id":2541,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1656248,"byte_end":1656257,"line_start":3868,"line_end":3868,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":6672}],"docs":"","sig":null,"attributes":[]},{"id":2542,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1657083,"byte_end":1657093,"line_start":3890,"line_end":3890,"column_start":39,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":6678}],"docs":"","sig":null,"attributes":[]},{"id":2543,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1658697,"byte_end":1658704,"line_start":3943,"line_end":3943,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":6684}],"docs":"","sig":null,"attributes":[]},{"id":2544,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1658904,"byte_end":1658911,"line_start":3953,"line_end":3953,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":6688},{"krate":0,"index":6690},{"krate":0,"index":6692},{"krate":0,"index":6694},{"krate":0,"index":6696},{"krate":0,"index":6698}],"docs":"","sig":null,"attributes":[]},{"id":2545,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1660175,"byte_end":1660182,"line_start":4007,"line_end":4007,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":6702},{"krate":0,"index":6704}],"docs":"","sig":null,"attributes":[]},{"id":2546,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1660917,"byte_end":1660924,"line_start":4034,"line_end":4034,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2547,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661020,"byte_end":1661027,"line_start":4037,"line_end":4037,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2548,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661112,"byte_end":1661119,"line_start":4040,"line_end":4040,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2549,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661189,"byte_end":1661196,"line_start":4043,"line_end":4043,"column_start":44,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":6714},{"krate":0,"index":6716}],"docs":"","sig":null,"attributes":[]},{"id":2550,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1662078,"byte_end":1662084,"line_start":4069,"line_end":4069,"column_start":19,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":6720}],"docs":"","sig":null,"attributes":[]},{"id":2551,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1662295,"byte_end":1662301,"line_start":4079,"line_end":4079,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":6724},{"krate":0,"index":6726},{"krate":0,"index":6728},{"krate":0,"index":6730},{"krate":0,"index":6732},{"krate":0,"index":6734}],"docs":"","sig":null,"attributes":[]},{"id":2552,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1663932,"byte_end":1663938,"line_start":4140,"line_end":4140,"column_start":37,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":6738}],"docs":"","sig":null,"attributes":[]},{"id":2553,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1664433,"byte_end":1664439,"line_start":4156,"line_end":4156,"column_start":31,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2554,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1664535,"byte_end":1664541,"line_start":4159,"line_end":4159,"column_start":31,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2555,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1664626,"byte_end":1664632,"line_start":4162,"line_end":4162,"column_start":27,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2556,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1664702,"byte_end":1664708,"line_start":4165,"line_end":4165,"column_start":44,"column_end":50},"value":"","parent":null,"children":[{"krate":0,"index":6748},{"krate":0,"index":6750}],"docs":"","sig":null,"attributes":[]},{"id":2557,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1665776,"byte_end":1665785,"line_start":4195,"line_end":4195,"column_start":26,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":6754},{"krate":0,"index":6756},{"krate":0,"index":6758},{"krate":0,"index":6760},{"krate":0,"index":6762},{"krate":0,"index":6764}],"docs":"","sig":null,"attributes":[]},{"id":2558,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1667601,"byte_end":1667610,"line_start":4259,"line_end":4259,"column_start":37,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":6768}],"docs":"","sig":null,"attributes":[]},{"id":2559,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1668194,"byte_end":1668203,"line_start":4277,"line_end":4277,"column_start":31,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2560,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1668299,"byte_end":1668308,"line_start":4280,"line_end":4280,"column_start":31,"column_end":40},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2561,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1668393,"byte_end":1668402,"line_start":4283,"line_end":4283,"column_start":27,"column_end":36},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2562,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1668472,"byte_end":1668481,"line_start":4286,"line_end":4286,"column_start":44,"column_end":53},"value":"","parent":null,"children":[{"krate":0,"index":6778},{"krate":0,"index":6780}],"docs":"","sig":null,"attributes":[]},{"id":2563,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1669676,"byte_end":1669687,"line_start":4318,"line_end":4318,"column_start":13,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":6784}],"docs":"","sig":null,"attributes":[]},{"id":2564,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1670123,"byte_end":1670134,"line_start":4330,"line_end":4330,"column_start":19,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":6788}],"docs":"","sig":null,"attributes":[]},{"id":2565,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1670385,"byte_end":1670396,"line_start":4341,"line_end":4341,"column_start":26,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":6792},{"krate":0,"index":6794},{"krate":0,"index":6796},{"krate":0,"index":6798},{"krate":0,"index":6800},{"krate":0,"index":6802}],"docs":"","sig":null,"attributes":[]},{"id":2566,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1671455,"byte_end":1671466,"line_start":4386,"line_end":4386,"column_start":37,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":6806}],"docs":"","sig":null,"attributes":[]},{"id":2567,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1671846,"byte_end":1671857,"line_start":4400,"line_end":4400,"column_start":31,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":6810}],"docs":"","sig":null,"attributes":[]},{"id":2568,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1672019,"byte_end":1672030,"line_start":4407,"line_end":4407,"column_start":31,"column_end":42},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2569,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1672122,"byte_end":1672133,"line_start":4410,"line_end":4410,"column_start":27,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2570,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1672257,"byte_end":1672268,"line_start":4414,"line_end":4414,"column_start":44,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":6818},{"krate":0,"index":6820}],"docs":"","sig":null,"attributes":[]},{"id":2571,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1673344,"byte_end":1673358,"line_start":4442,"line_end":4442,"column_start":13,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":6824}],"docs":"","sig":null,"attributes":[]},{"id":2572,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1673754,"byte_end":1673768,"line_start":4453,"line_end":4453,"column_start":26,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":6828},{"krate":0,"index":6830},{"krate":0,"index":6832},{"krate":0,"index":6834},{"krate":0,"index":6836},{"krate":0,"index":6838}],"docs":"","sig":null,"attributes":[]},{"id":2573,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1674962,"byte_end":1674976,"line_start":4500,"line_end":4500,"column_start":37,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":6842}],"docs":"","sig":null,"attributes":[]},{"id":2574,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675455,"byte_end":1675469,"line_start":4516,"line_end":4516,"column_start":31,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":6846}],"docs":"","sig":null,"attributes":[]},{"id":2575,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675631,"byte_end":1675645,"line_start":4523,"line_end":4523,"column_start":31,"column_end":45},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2576,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675737,"byte_end":1675751,"line_start":4526,"line_end":4526,"column_start":27,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2577,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675875,"byte_end":1675889,"line_start":4530,"line_end":4530,"column_start":44,"column_end":58},"value":"","parent":null,"children":[{"krate":0,"index":6854},{"krate":0,"index":6856}],"docs":"","sig":null,"attributes":[]},{"id":2578,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676838,"byte_end":1676845,"line_start":4557,"line_end":4557,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":6860}],"docs":"","sig":null,"attributes":[]},{"id":2579,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1677060,"byte_end":1677067,"line_start":4567,"line_end":4567,"column_start":26,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":6864},{"krate":0,"index":6866},{"krate":0,"index":6868},{"krate":0,"index":6870},{"krate":0,"index":6872},{"krate":0,"index":6874}],"docs":"","sig":null,"attributes":[]},{"id":2580,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1678821,"byte_end":1678828,"line_start":4631,"line_end":4631,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":6878}],"docs":"","sig":null,"attributes":[]},{"id":2581,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679311,"byte_end":1679318,"line_start":4647,"line_end":4647,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2582,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679414,"byte_end":1679421,"line_start":4650,"line_end":4650,"column_start":31,"column_end":38},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2583,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679508,"byte_end":1679515,"line_start":4653,"line_end":4653,"column_start":27,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2584,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679634,"byte_end":1679641,"line_start":4657,"line_end":4657,"column_start":44,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":6888},{"krate":0,"index":6890}],"docs":"","sig":null,"attributes":[]},{"id":2585,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1680695,"byte_end":1680705,"line_start":4687,"line_end":4687,"column_start":26,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":6894},{"krate":0,"index":6896},{"krate":0,"index":6898},{"krate":0,"index":6900},{"krate":0,"index":6902},{"krate":0,"index":6904}],"docs":"","sig":null,"attributes":[]},{"id":2586,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1682680,"byte_end":1682690,"line_start":4755,"line_end":4755,"column_start":37,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":6908}],"docs":"","sig":null,"attributes":[]},{"id":2587,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683230,"byte_end":1683240,"line_start":4772,"line_end":4772,"column_start":31,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2588,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683336,"byte_end":1683346,"line_start":4775,"line_end":4775,"column_start":31,"column_end":41},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2589,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683433,"byte_end":1683443,"line_start":4778,"line_end":4778,"column_start":27,"column_end":37},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2590,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683562,"byte_end":1683572,"line_start":4782,"line_end":4782,"column_start":44,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":6918},{"krate":0,"index":6920}],"docs":"","sig":null,"attributes":[]},{"id":2591,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684742,"byte_end":1684754,"line_start":4814,"line_end":4814,"column_start":13,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":6924}],"docs":"","sig":null,"attributes":[]},{"id":2592,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685184,"byte_end":1685196,"line_start":4826,"line_end":4826,"column_start":23,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":6928}],"docs":"","sig":null,"attributes":[]},{"id":2593,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685458,"byte_end":1685470,"line_start":4837,"line_end":4837,"column_start":26,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":6932},{"krate":0,"index":6934},{"krate":0,"index":6936},{"krate":0,"index":6938},{"krate":0,"index":6940},{"krate":0,"index":6942}],"docs":"","sig":null,"attributes":[]},{"id":2594,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1686548,"byte_end":1686560,"line_start":4882,"line_end":4882,"column_start":37,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":6946}],"docs":"","sig":null,"attributes":[]},{"id":2595,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1686924,"byte_end":1686936,"line_start":4896,"line_end":4896,"column_start":35,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":6950}],"docs":"","sig":null,"attributes":[]},{"id":2596,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1687098,"byte_end":1687110,"line_start":4903,"line_end":4903,"column_start":31,"column_end":43},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2597,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1687197,"byte_end":1687209,"line_start":4906,"line_end":4906,"column_start":27,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2598,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1687328,"byte_end":1687340,"line_start":4910,"line_end":4910,"column_start":44,"column_end":56},"value":"","parent":null,"children":[{"krate":0,"index":6958},{"krate":0,"index":6960}],"docs":"","sig":null,"attributes":[]},{"id":2599,"kind":"Inherent","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688465,"byte_end":1688480,"line_start":4939,"line_end":4939,"column_start":13,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":6964}],"docs":"","sig":null,"attributes":[]},{"id":2600,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688866,"byte_end":1688881,"line_start":4950,"line_end":4950,"column_start":26,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":6968},{"krate":0,"index":6970},{"krate":0,"index":6972},{"krate":0,"index":6974},{"krate":0,"index":6976},{"krate":0,"index":6978}],"docs":"","sig":null,"attributes":[]},{"id":2601,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690158,"byte_end":1690173,"line_start":4999,"line_end":4999,"column_start":37,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":6982}],"docs":"","sig":null,"attributes":[]},{"id":2602,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690600,"byte_end":1690615,"line_start":5014,"line_end":5014,"column_start":31,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":6986}],"docs":"","sig":null,"attributes":[]},{"id":2603,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690777,"byte_end":1690792,"line_start":5021,"line_end":5021,"column_start":31,"column_end":46},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2604,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690879,"byte_end":1690894,"line_start":5024,"line_end":5024,"column_start":27,"column_end":42},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2605,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1691013,"byte_end":1691028,"line_start":5028,"line_end":5028,"column_start":44,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":6994},{"krate":0,"index":6996}],"docs":"","sig":null,"attributes":[]},{"id":2618,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700121,"byte_end":1700125,"line_start":5328,"line_end":5328,"column_start":44,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":7070},{"krate":0,"index":7072}],"docs":"","sig":null,"attributes":[]},{"id":2619,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700336,"byte_end":1700343,"line_start":5336,"line_end":5336,"column_start":44,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":7076},{"krate":0,"index":7078}],"docs":"","sig":null,"attributes":[]},{"id":2620,"kind":"Direct","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700612,"byte_end":1700613,"line_start":5347,"line_end":5347,"column_start":27,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":7086}],"docs":"","sig":null,"attributes":[]},{"id":2623,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1887432,"byte_end":1887444,"line_start":269,"line_end":269,"column_start":34,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":7196},{"krate":0,"index":7198},{"krate":0,"index":7200}],"docs":"","sig":null,"attributes":[]},{"id":2624,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1890751,"byte_end":1890763,"line_start":343,"line_end":343,"column_start":41,"column_end":53},"value":"","parent":null,"children":[{"krate":0,"index":7204},{"krate":0,"index":7206}],"docs":"","sig":null,"attributes":[]},{"id":2625,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1894470,"byte_end":1894482,"line_start":419,"line_end":419,"column_start":38,"column_end":50},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2627,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1896046,"byte_end":1896047,"line_start":478,"line_end":478,"column_start":25,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":7228}],"docs":"","sig":null,"attributes":[]},{"id":2628,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1896539,"byte_end":1896557,"line_start":499,"line_end":499,"column_start":42,"column_end":60},"value":"","parent":null,"children":[{"krate":0,"index":7238},{"krate":0,"index":7240}],"docs":"","sig":null,"attributes":[]},{"id":2629,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1896904,"byte_end":1896923,"line_start":512,"line_end":512,"column_start":50,"column_end":69},"value":"","parent":null,"children":[{"krate":0,"index":7244},{"krate":0,"index":7246}],"docs":"","sig":null,"attributes":[]},{"id":2630,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1897670,"byte_end":1897689,"line_start":537,"line_end":537,"column_start":57,"column_end":76},"value":"","parent":null,"children":[{"krate":0,"index":7250}],"docs":"","sig":null,"attributes":[]},{"id":2631,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1898364,"byte_end":1898383,"line_start":557,"line_end":557,"column_start":54,"column_end":73},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2632,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1900545,"byte_end":1900562,"line_start":634,"line_end":634,"column_start":38,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":42980},{"krate":0,"index":42982},{"krate":0,"index":42984},{"krate":0,"index":42986}],"docs":"","sig":null,"attributes":[]},{"id":2633,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1900652,"byte_end":1900669,"line_start":638,"line_end":638,"column_start":45,"column_end":62},"value":"","parent":null,"children":[{"krate":0,"index":42988},{"krate":0,"index":42990},{"krate":0,"index":42992}],"docs":"","sig":null,"attributes":[]},{"id":2634,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1900756,"byte_end":1900773,"line_start":642,"line_end":642,"column_start":42,"column_end":59},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2635,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1901403,"byte_end":1901424,"line_start":658,"line_end":658,"column_start":24,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":7268}],"docs":"","sig":null,"attributes":[]},{"id":2636,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1901750,"byte_end":1901771,"line_start":668,"line_end":668,"column_start":37,"column_end":58},"value":"","parent":null,"children":[{"krate":0,"index":43010},{"krate":0,"index":43012},{"krate":0,"index":43014},{"krate":0,"index":43016}],"docs":"","sig":null,"attributes":[]},{"id":2637,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1901892,"byte_end":1901913,"line_start":674,"line_end":674,"column_start":44,"column_end":65},"value":"","parent":null,"children":[{"krate":0,"index":43018},{"krate":0,"index":43020},{"krate":0,"index":43022}],"docs":"","sig":null,"attributes":[]},{"id":2638,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1902031,"byte_end":1902052,"line_start":680,"line_end":680,"column_start":41,"column_end":62},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2639,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1902179,"byte_end":1902180,"line_start":684,"line_end":684,"column_start":29,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":43024},{"krate":0,"index":43026},{"krate":0,"index":43028},{"krate":0,"index":43030},{"krate":0,"index":43032}],"docs":"","sig":null,"attributes":[]},{"id":2640,"kind":"Inherent","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1904338,"byte_end":1904349,"line_start":757,"line_end":757,"column_start":14,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":7292}],"docs":"","sig":null,"attributes":[]},{"id":2641,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1905096,"byte_end":1905107,"line_start":782,"line_end":782,"column_start":38,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":7296},{"krate":0,"index":7298},{"krate":0,"index":7300}],"docs":"","sig":null,"attributes":[]},{"id":2642,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1908587,"byte_end":1908598,"line_start":863,"line_end":863,"column_start":45,"column_end":56},"value":"","parent":null,"children":[{"krate":0,"index":7304},{"krate":0,"index":7306}],"docs":"","sig":null,"attributes":[]},{"id":2643,"kind":"Inherent","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1915506,"byte_end":1915520,"line_start":1028,"line_end":1028,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":7310},{"krate":0,"index":7312},{"krate":0,"index":7314},{"krate":0,"index":7316},{"krate":0,"index":7318},{"krate":0,"index":7320},{"krate":0,"index":7322}],"docs":"","sig":null,"attributes":[]},{"id":2644,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929632,"byte_end":1929641,"line_start":1379,"line_end":1379,"column_start":25,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":7338},{"krate":0,"index":7340},{"krate":0,"index":7342},{"krate":0,"index":7344}],"docs":"","sig":null,"attributes":[]},{"id":2645,"kind":"Direct","span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929985,"byte_end":1929999,"line_start":1393,"line_end":1393,"column_start":25,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":7350},{"krate":0,"index":7352},{"krate":0,"index":7354},{"krate":0,"index":7356}],"docs":"","sig":null,"attributes":[]},{"id":2646,"kind":"Inherent","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930499,"byte_end":1930508,"line_start":12,"line_end":12,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":7376},{"krate":0,"index":7378},{"krate":0,"index":7380}],"docs":"","sig":null,"attributes":[]},{"id":2647,"kind":"Direct","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1931371,"byte_end":1931390,"line_start":45,"line_end":45,"column_start":23,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":7386},{"krate":0,"index":7388}],"docs":"","sig":null,"attributes":[]},{"id":2648,"kind":"Direct","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1934497,"byte_end":1934506,"line_start":140,"line_end":140,"column_start":23,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":7398}],"docs":"","sig":null,"attributes":[]},{"id":2649,"kind":"Direct","span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1935405,"byte_end":1935414,"line_start":166,"line_end":166,"column_start":21,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":7402}],"docs":"","sig":null,"attributes":[]},{"id":2651,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1741519,"byte_end":1741533,"line_start":148,"line_end":148,"column_start":23,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":7418}],"docs":"","sig":null,"attributes":[]},{"id":2652,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1743266,"byte_end":1743275,"line_start":206,"line_end":206,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":7422},{"krate":0,"index":7424}],"docs":"","sig":null,"attributes":[]},{"id":2653,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1750399,"byte_end":1750408,"line_start":441,"line_end":441,"column_start":23,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":7436}],"docs":"","sig":null,"attributes":[]},{"id":2654,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1754150,"byte_end":1754155,"line_start":561,"line_end":561,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":7452},{"krate":0,"index":7454},{"krate":0,"index":7456},{"krate":0,"index":7458},{"krate":0,"index":7460}],"docs":"","sig":null,"attributes":[]},{"id":2655,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1755363,"byte_end":1755368,"line_start":602,"line_end":602,"column_start":34,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":7464}],"docs":"","sig":null,"attributes":[]},{"id":2656,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1755735,"byte_end":1755740,"line_start":615,"line_end":615,"column_start":24,"column_end":29},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2657,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1755758,"byte_end":1755763,"line_start":617,"line_end":617,"column_start":10,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":7470}],"docs":"","sig":null,"attributes":[]},{"id":2658,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1757020,"byte_end":1757031,"line_start":659,"line_end":659,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":7474},{"krate":0,"index":7476},{"krate":0,"index":7478},{"krate":0,"index":7480},{"krate":0,"index":7482}],"docs":"","sig":null,"attributes":[]},{"id":2659,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1757883,"byte_end":1757894,"line_start":694,"line_end":694,"column_start":34,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":7486}],"docs":"","sig":null,"attributes":[]},{"id":2660,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758191,"byte_end":1758202,"line_start":705,"line_end":705,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2661,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758220,"byte_end":1758231,"line_start":707,"line_end":707,"column_start":10,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":7492}],"docs":"","sig":null,"attributes":[]},{"id":2662,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1759033,"byte_end":1759038,"line_start":731,"line_end":731,"column_start":19,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":7496},{"krate":0,"index":7498},{"krate":0,"index":7500},{"krate":0,"index":7502},{"krate":0,"index":7504},{"krate":0,"index":7506},{"krate":0,"index":7508},{"krate":0,"index":7510},{"krate":0,"index":7512},{"krate":0,"index":7514},{"krate":0,"index":7516}],"docs":"","sig":null,"attributes":[]},{"id":2663,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1760319,"byte_end":1760324,"line_start":792,"line_end":792,"column_start":30,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":7520},{"krate":0,"index":7522},{"krate":0,"index":7524}],"docs":"","sig":null,"attributes":[]},{"id":2664,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1760773,"byte_end":1760778,"line_start":812,"line_end":812,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":7528},{"krate":0,"index":7530}],"docs":"","sig":null,"attributes":[]},{"id":2665,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1761008,"byte_end":1761013,"line_start":825,"line_end":825,"column_start":24,"column_end":29},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2666,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1761103,"byte_end":1761108,"line_start":828,"line_end":828,"column_start":28,"column_end":33},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2667,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1761168,"byte_end":1761173,"line_start":831,"line_end":831,"column_start":37,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":7538},{"krate":0,"index":7540}],"docs":"","sig":null,"attributes":[]},{"id":2668,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1768399,"byte_end":1768412,"line_start":1040,"line_end":1040,"column_start":41,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":7550}],"docs":"","sig":null,"attributes":[]},{"id":2669,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1768852,"byte_end":1768865,"line_start":1052,"line_end":1052,"column_start":26,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":7554},{"krate":0,"index":7556},{"krate":0,"index":7558}],"docs":"","sig":null,"attributes":[]},{"id":2670,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1771925,"byte_end":1771939,"line_start":1157,"line_end":1157,"column_start":41,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":7564}],"docs":"","sig":null,"attributes":[]},{"id":2671,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1772219,"byte_end":1772233,"line_start":1166,"line_end":1166,"column_start":26,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":7568},{"krate":0,"index":7570}],"docs":"","sig":null,"attributes":[]},{"id":2672,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1773503,"byte_end":1773523,"line_start":1213,"line_end":1213,"column_start":41,"column_end":61},"value":"","parent":null,"children":[{"krate":0,"index":7576}],"docs":"","sig":null,"attributes":[]},{"id":2673,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1773756,"byte_end":1773776,"line_start":1221,"line_end":1221,"column_start":26,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":7580},{"krate":0,"index":7582}],"docs":"","sig":null,"attributes":[]},{"id":2674,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1775050,"byte_end":1775065,"line_start":1264,"line_end":1264,"column_start":41,"column_end":56},"value":"","parent":null,"children":[{"krate":0,"index":7588}],"docs":"","sig":null,"attributes":[]},{"id":2675,"kind":"Inherent","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1775293,"byte_end":1775308,"line_start":1272,"line_end":1272,"column_start":26,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":7592},{"krate":0,"index":7594}],"docs":"","sig":null,"attributes":[]},{"id":2676,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1776856,"byte_end":1776861,"line_start":1322,"line_end":1322,"column_start":23,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":7598},{"krate":0,"index":7600},{"krate":0,"index":7602}],"docs":"","sig":null,"attributes":[]},{"id":2677,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1777162,"byte_end":1777167,"line_start":1337,"line_end":1337,"column_start":34,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":7606}],"docs":"","sig":null,"attributes":[]},{"id":2678,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1777343,"byte_end":1777348,"line_start":1345,"line_end":1345,"column_start":24,"column_end":29},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2679,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1778043,"byte_end":1778051,"line_start":1368,"line_end":1368,"column_start":23,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":7612},{"krate":0,"index":7614},{"krate":0,"index":7616}],"docs":"","sig":null,"attributes":[]},{"id":2680,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1778373,"byte_end":1778381,"line_start":1384,"line_end":1384,"column_start":34,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":7620}],"docs":"","sig":null,"attributes":[]},{"id":2681,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1778578,"byte_end":1778586,"line_start":1393,"line_end":1393,"column_start":24,"column_end":32},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2688,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1787794,"byte_end":1787803,"line_start":1655,"line_end":1655,"column_start":35,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":7684},{"krate":0,"index":7686},{"krate":0,"index":7688},{"krate":0,"index":7690},{"krate":0,"index":7692},{"krate":0,"index":7694},{"krate":0,"index":7696}],"docs":"","sig":null,"attributes":[]},{"id":2689,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1789665,"byte_end":1789670,"line_start":1719,"line_end":1719,"column_start":35,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":7700},{"krate":0,"index":7702},{"krate":0,"index":7704},{"krate":0,"index":7706},{"krate":0,"index":7708},{"krate":0,"index":7710},{"krate":0,"index":7712}],"docs":"","sig":null,"attributes":[]},{"id":2690,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1792463,"byte_end":1792470,"line_start":1788,"line_end":1788,"column_start":35,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":7716},{"krate":0,"index":7718},{"krate":0,"index":7720},{"krate":0,"index":7722},{"krate":0,"index":7724},{"krate":0,"index":7726},{"krate":0,"index":7728}],"docs":"","sig":null,"attributes":[]},{"id":2691,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1794795,"byte_end":1794804,"line_start":1849,"line_end":1849,"column_start":35,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":7732},{"krate":0,"index":7734},{"krate":0,"index":7736},{"krate":0,"index":7738},{"krate":0,"index":7740},{"krate":0,"index":7742},{"krate":0,"index":7744}],"docs":"","sig":null,"attributes":[]},{"id":2692,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797390,"byte_end":1797404,"line_start":1912,"line_end":1912,"column_start":35,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":7748},{"krate":0,"index":7750},{"krate":0,"index":7752},{"krate":0,"index":7754},{"krate":0,"index":7756},{"krate":0,"index":7758},{"krate":0,"index":7760}],"docs":"","sig":null,"attributes":[]},{"id":2693,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799344,"byte_end":1799360,"line_start":1959,"line_end":1959,"column_start":35,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":7764},{"krate":0,"index":7766},{"krate":0,"index":7768},{"krate":0,"index":7770},{"krate":0,"index":7772},{"krate":0,"index":7774},{"krate":0,"index":7776}],"docs":"","sig":null,"attributes":[]},{"id":2696,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872152,"byte_end":1872167,"line_start":4206,"line_end":4206,"column_start":23,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":7914},{"krate":0,"index":7916},{"krate":0,"index":7918}],"docs":"","sig":null,"attributes":[]},{"id":2697,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872487,"byte_end":1872502,"line_start":4221,"line_end":4221,"column_start":34,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":7922}],"docs":"","sig":null,"attributes":[]},{"id":2698,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872682,"byte_end":1872697,"line_start":4229,"line_end":4229,"column_start":24,"column_end":39},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2699,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872792,"byte_end":1872812,"line_start":4232,"line_end":4232,"column_start":23,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":7928},{"krate":0,"index":7930},{"krate":0,"index":7932}],"docs":"","sig":null,"attributes":[]},{"id":2700,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1873139,"byte_end":1873159,"line_start":4247,"line_end":4247,"column_start":34,"column_end":54},"value":"","parent":null,"children":[{"krate":0,"index":7936}],"docs":"","sig":null,"attributes":[]},{"id":2701,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1873356,"byte_end":1873376,"line_start":4255,"line_end":4255,"column_start":24,"column_end":44},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2702,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1873938,"byte_end":1873949,"line_start":4274,"line_end":4274,"column_start":21,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":7942}],"docs":"","sig":null,"attributes":[]},{"id":2703,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1874139,"byte_end":1874150,"line_start":4281,"line_end":4281,"column_start":23,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":7946},{"krate":0,"index":7948},{"krate":0,"index":7950}],"docs":"","sig":null,"attributes":[]},{"id":2704,"kind":"Direct","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1874996,"byte_end":1875007,"line_start":4313,"line_end":4313,"column_start":24,"column_end":35},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2705,"kind":"Inherent","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961086,"byte_end":1961095,"line_start":134,"line_end":134,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":7984},{"krate":0,"index":7986}],"docs":"","sig":null,"attributes":[]},{"id":2706,"kind":"Inherent","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961880,"byte_end":1961891,"line_start":156,"line_end":156,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":7990},{"krate":0,"index":7992}],"docs":"","sig":null,"attributes":[]},{"id":2707,"kind":"Inherent","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1962703,"byte_end":1962709,"line_start":178,"line_end":178,"column_start":14,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":7996},{"krate":0,"index":7998},{"krate":0,"index":8000}],"docs":"","sig":null,"attributes":[]},{"id":2708,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1964799,"byte_end":1964808,"line_start":242,"line_end":242,"column_start":24,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":8004},{"krate":0,"index":8006}],"docs":"","sig":null,"attributes":[]},{"id":2709,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1965066,"byte_end":1965077,"line_start":255,"line_end":255,"column_start":24,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":8010},{"krate":0,"index":8012}],"docs":"","sig":null,"attributes":[]},{"id":2710,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1965283,"byte_end":1965289,"line_start":267,"line_end":267,"column_start":32,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":8016},{"krate":0,"index":8018},{"krate":0,"index":8020},{"krate":0,"index":8022}],"docs":"","sig":null,"attributes":[]},{"id":2711,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1967178,"byte_end":1967184,"line_start":340,"line_end":340,"column_start":24,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":8026}],"docs":"","sig":null,"attributes":[]},{"id":2712,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1967509,"byte_end":1967515,"line_start":355,"line_end":355,"column_start":26,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":8030}],"docs":"","sig":null,"attributes":[]},{"id":2713,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1967839,"byte_end":1967850,"line_start":372,"line_end":372,"column_start":14,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":8040},{"krate":0,"index":8042}],"docs":"","sig":null,"attributes":[]},{"id":2714,"kind":"Direct","span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1968142,"byte_end":1968153,"line_start":389,"line_end":389,"column_start":14,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":8046},{"krate":0,"index":8048}],"docs":"","sig":null,"attributes":[]},{"id":2715,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1950713,"byte_end":1950731,"line_start":502,"line_end":502,"column_start":24,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":8126}],"docs":"","sig":null,"attributes":[]},{"id":2716,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1950940,"byte_end":1950958,"line_start":509,"line_end":509,"column_start":43,"column_end":61},"value":"","parent":null,"children":[{"krate":0,"index":8130},{"krate":0,"index":8132}],"docs":"","sig":null,"attributes":[]},{"id":2717,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1951121,"byte_end":1951139,"line_start":518,"line_end":518,"column_start":19,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":8136}],"docs":"","sig":null,"attributes":[]},{"id":2718,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1951322,"byte_end":1951340,"line_start":525,"line_end":525,"column_start":21,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":8140}],"docs":"","sig":null,"attributes":[]},{"id":2719,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1951526,"byte_end":1951544,"line_start":532,"line_end":532,"column_start":23,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":8144}],"docs":"","sig":null,"attributes":[]},{"id":2720,"kind":"Direct","span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1951703,"byte_end":1951721,"line_start":539,"line_end":539,"column_start":16,"column_end":34},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2724,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2052534,"byte_end":2052544,"line_start":8,"line_end":8,"column_start":10,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":8332}],"docs":"","sig":null,"attributes":[]},{"id":2725,"kind":"Direct","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2052905,"byte_end":2052915,"line_start":21,"line_end":21,"column_start":21,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":8336}],"docs":"","sig":null,"attributes":[]},{"id":2726,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2054981,"byte_end":2054992,"line_start":99,"line_end":99,"column_start":18,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":8344},{"krate":0,"index":8346},{"krate":0,"index":8348}],"docs":"","sig":null,"attributes":[]},{"id":2727,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2059532,"byte_end":2059542,"line_start":250,"line_end":250,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":8356},{"krate":0,"index":8358},{"krate":0,"index":8360}],"docs":"","sig":null,"attributes":[]},{"id":2728,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2062325,"byte_end":2062335,"line_start":344,"line_end":344,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":8366},{"krate":0,"index":8368}],"docs":"","sig":null,"attributes":[]},{"id":2729,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2064276,"byte_end":2064284,"line_start":416,"line_end":416,"column_start":18,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":8376},{"krate":0,"index":8378},{"krate":0,"index":8380}],"docs":"","sig":null,"attributes":[]},{"id":2730,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2068053,"byte_end":2068062,"line_start":553,"line_end":553,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":8388},{"krate":0,"index":8390},{"krate":0,"index":8392}],"docs":"","sig":null,"attributes":[]},{"id":2731,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2071864,"byte_end":2071872,"line_start":690,"line_end":690,"column_start":18,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":8400},{"krate":0,"index":8402},{"krate":0,"index":8404},{"krate":0,"index":8406}],"docs":"","sig":null,"attributes":[]},{"id":2732,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1977137,"byte_end":1977147,"line_start":269,"line_end":269,"column_start":10,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":8448},{"krate":0,"index":8450},{"krate":0,"index":8452},{"krate":0,"index":8454}],"docs":"","sig":null,"attributes":[]},{"id":2733,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1978330,"byte_end":1978339,"line_start":308,"line_end":308,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":8458},{"krate":0,"index":8460},{"krate":0,"index":8462}],"docs":"","sig":null,"attributes":[]},{"id":2734,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1982325,"byte_end":1982334,"line_start":408,"line_end":408,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":8466}],"docs":"","sig":null,"attributes":[]},{"id":2735,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1982500,"byte_end":1982509,"line_start":415,"line_end":415,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":8470}],"docs":"","sig":null,"attributes":[]},{"id":2736,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1999293,"byte_end":1999304,"line_start":1046,"line_end":1046,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":8514},{"krate":0,"index":8516}],"docs":"","sig":null,"attributes":[]},{"id":2737,"kind":"Inherent","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1999611,"byte_end":1999620,"line_start":1060,"line_end":1060,"column_start":10,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":8520},{"krate":0,"index":8522},{"krate":0,"index":8524},{"krate":0,"index":8526},{"krate":0,"index":8530},{"krate":0,"index":8532},{"krate":0,"index":8534},{"krate":0,"index":8536},{"krate":0,"index":8542},{"krate":0,"index":8544},{"krate":0,"index":8546},{"krate":0,"index":8548},{"krate":0,"index":8550},{"krate":0,"index":8552},{"krate":0,"index":8554},{"krate":0,"index":8556},{"krate":0,"index":8558},{"krate":0,"index":8560},{"krate":0,"index":8562},{"krate":0,"index":8564},{"krate":0,"index":8566},{"krate":0,"index":8568},{"krate":0,"index":8570},{"krate":0,"index":8572},{"krate":0,"index":8574},{"krate":0,"index":8576}],"docs":"","sig":null,"attributes":[]},{"id":2738,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2028056,"byte_end":2028065,"line_start":1886,"line_end":1886,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":8580},{"krate":0,"index":8582},{"krate":0,"index":8584}],"docs":"","sig":null,"attributes":[]},{"id":2739,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2028409,"byte_end":2028414,"line_start":1901,"line_end":1901,"column_start":18,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":8588}],"docs":"","sig":null,"attributes":[]},{"id":2746,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034314,"byte_end":2034325,"line_start":2111,"line_end":2111,"column_start":27,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":8664}],"docs":"","sig":null,"attributes":[]},{"id":2747,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034500,"byte_end":2034504,"line_start":2118,"line_end":2118,"column_start":33,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":8668}],"docs":"","sig":null,"attributes":[]},{"id":2748,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034746,"byte_end":2034753,"line_start":2127,"line_end":2127,"column_start":35,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":8672}],"docs":"","sig":null,"attributes":[]},{"id":2749,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035239,"byte_end":2035258,"line_start":2140,"line_end":2140,"column_start":32,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":8678}],"docs":"","sig":null,"attributes":[]},{"id":2750,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035664,"byte_end":2035667,"line_start":2155,"line_end":2155,"column_start":35,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":8682}],"docs":"","sig":null,"attributes":[]},{"id":2751,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035850,"byte_end":2035856,"line_start":2162,"line_end":2162,"column_start":35,"column_end":41},"value":"","parent":null,"children":[{"krate":0,"index":8686}],"docs":"","sig":null,"attributes":[]},{"id":2752,"kind":"Direct","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2036058,"byte_end":2036068,"line_start":2169,"line_end":2169,"column_start":35,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":8690}],"docs":"","sig":null,"attributes":[]},{"id":2753,"kind":"Inherent","span":{"file_name":"src/libcore/time.rs","byte_start":2078440,"byte_end":2078448,"line_start":60,"line_end":60,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":8732},{"krate":0,"index":8734},{"krate":0,"index":8736},{"krate":0,"index":8738},{"krate":0,"index":8740},{"krate":0,"index":47088},{"krate":0,"index":47086},{"krate":0,"index":47084},{"krate":0,"index":47082},{"krate":0,"index":8742},{"krate":0,"index":8744},{"krate":0,"index":8746},{"krate":0,"index":8748},{"krate":0,"index":8750},{"krate":0,"index":8752},{"krate":0,"index":8754},{"krate":0,"index":8756},{"krate":0,"index":8758},{"krate":0,"index":8760},{"krate":0,"index":8762},{"krate":0,"index":8764},{"krate":0,"index":8766},{"krate":0,"index":8768},{"krate":0,"index":8772},{"krate":0,"index":8776},{"krate":0,"index":8778},{"krate":0,"index":8780},{"krate":0,"index":8782},{"krate":0,"index":8784},{"krate":0,"index":8786}],"docs":"","sig":null,"attributes":[]},{"id":2754,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2100475,"byte_end":2100483,"line_start":732,"line_end":732,"column_start":14,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":8790},{"krate":0,"index":8792}],"docs":"","sig":null,"attributes":[]},{"id":2755,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2100726,"byte_end":2100734,"line_start":741,"line_end":741,"column_start":20,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":8796}],"docs":"","sig":null,"attributes":[]},{"id":2756,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2100883,"byte_end":2100891,"line_start":748,"line_end":748,"column_start":14,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":8800},{"krate":0,"index":8802}],"docs":"","sig":null,"attributes":[]},{"id":2757,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2101139,"byte_end":2101147,"line_start":757,"line_end":757,"column_start":20,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":8806}],"docs":"","sig":null,"attributes":[]},{"id":2758,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2101301,"byte_end":2101309,"line_start":764,"line_end":764,"column_start":19,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":8810},{"krate":0,"index":8812}],"docs":"","sig":null,"attributes":[]},{"id":2760,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2101766,"byte_end":2101774,"line_start":782,"line_end":782,"column_start":25,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":8822}],"docs":"","sig":null,"attributes":[]},{"id":2761,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2101923,"byte_end":2101931,"line_start":789,"line_end":789,"column_start":19,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":8826},{"krate":0,"index":8828}],"docs":"","sig":null,"attributes":[]},{"id":2762,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2102197,"byte_end":2102205,"line_start":798,"line_end":798,"column_start":25,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":8832}],"docs":"","sig":null,"attributes":[]},{"id":2763,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2103419,"byte_end":2103427,"line_start":835,"line_end":835,"column_start":14,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":8838}],"docs":"","sig":null,"attributes":[]},{"id":2764,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2103615,"byte_end":2103623,"line_start":842,"line_end":842,"column_start":32,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":8842}],"docs":"","sig":null,"attributes":[]},{"id":2765,"kind":"Direct","span":{"file_name":"src/libcore/time.rs","byte_start":2103811,"byte_end":2103819,"line_start":849,"line_end":849,"column_start":21,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":8846}],"docs":"","sig":null,"attributes":[]},{"id":2766,"kind":"Inherent","span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2111013,"byte_end":2111021,"line_start":33,"line_end":33,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":8858}],"docs":"","sig":null,"attributes":[]},{"id":2767,"kind":"Inherent","span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2111691,"byte_end":2111704,"line_start":54,"line_end":54,"column_start":6,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":8864}],"docs":"","sig":null,"attributes":[]},{"id":2768,"kind":"Direct","span":{"file_name":"src/libcore/future/future.rs","byte_start":2357511,"byte_end":2357514,"line_start":106,"line_end":106,"column_start":20,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":9016},{"krate":0,"index":9018}],"docs":"","sig":null,"attributes":[]},{"id":2769,"kind":"Inherent","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358849,"byte_end":2358853,"line_start":24,"line_end":24,"column_start":9,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":9032},{"krate":0,"index":9034},{"krate":0,"index":9036}],"docs":"","sig":null,"attributes":[]},{"id":2770,"kind":"Inherent","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2359504,"byte_end":2359508,"line_start":51,"line_end":51,"column_start":12,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":9040},{"krate":0,"index":9042}],"docs":"","sig":null,"attributes":[]},{"id":2771,"kind":"Direct","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2360280,"byte_end":2360284,"line_start":75,"line_end":75,"column_start":21,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":9046}],"docs":"","sig":null,"attributes":[]},{"id":2772,"kind":"Direct","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2360372,"byte_end":2360376,"line_start":81,"line_end":81,"column_start":20,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":9050},{"krate":0,"index":9052},{"krate":0,"index":9054},{"krate":0,"index":9056},{"krate":0,"index":9058}],"docs":"","sig":null,"attributes":[]},{"id":2773,"kind":"Direct","span":{"file_name":"src/libcore/task/poll.rs","byte_start":2360885,"byte_end":2360889,"line_start":105,"line_end":105,"column_start":20,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":9062},{"krate":0,"index":9064},{"krate":0,"index":9066},{"krate":0,"index":9068},{"krate":0,"index":9070}],"docs":"","sig":null,"attributes":[]},{"id":2774,"kind":"Inherent","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2362529,"byte_end":2362537,"line_start":27,"line_end":27,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":47080}],"docs":"","sig":null,"attributes":[]},{"id":2775,"kind":"Inherent","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2365582,"byte_end":2365596,"line_start":95,"line_end":95,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":47078}],"docs":"","sig":null,"attributes":[]},{"id":2776,"kind":"Inherent","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368138,"byte_end":2368145,"line_start":165,"line_end":165,"column_start":10,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":9092},{"krate":0,"index":9094}],"docs":"","sig":null,"attributes":[]},{"id":2777,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368519,"byte_end":2368526,"line_start":182,"line_end":182,"column_start":21,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":9098}],"docs":"","sig":null,"attributes":[]},{"id":2778,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369055,"byte_end":2369060,"line_start":202,"line_end":202,"column_start":16,"column_end":21},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2779,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369085,"byte_end":2369090,"line_start":203,"line_end":203,"column_start":22,"column_end":27},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2780,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369115,"byte_end":2369120,"line_start":204,"line_end":204,"column_start":22,"column_end":27},"value":"","parent":null,"children":[],"docs":"","sig":null,"attributes":[]},{"id":2781,"kind":"Inherent","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369130,"byte_end":2369135,"line_start":206,"line_end":206,"column_start":6,"column_end":11},"value":"","parent":null,"children":[{"krate":0,"index":9110},{"krate":0,"index":9112},{"krate":0,"index":9114},{"krate":0,"index":9116}],"docs":"","sig":null,"attributes":[]},{"id":2782,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2371319,"byte_end":2371324,"line_start":263,"line_end":263,"column_start":16,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":9120}],"docs":"","sig":null,"attributes":[]},{"id":2783,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2371714,"byte_end":2371719,"line_start":275,"line_end":275,"column_start":15,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":9124}],"docs":"","sig":null,"attributes":[]},{"id":2784,"kind":"Direct","span":{"file_name":"src/libcore/task/wake.rs","byte_start":2372056,"byte_end":2372061,"line_start":285,"line_end":285,"column_start":21,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":9128}],"docs":"","sig":null,"attributes":[]},{"id":2785,"kind":"Inherent","span":{"file_name":"src/libcore/alloc.rs","byte_start":2374119,"byte_end":2374125,"line_start":52,"line_end":52,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":9162},{"krate":0,"index":9164},{"krate":0,"index":9166},{"krate":0,"index":9168},{"krate":0,"index":9170},{"krate":0,"index":9172},{"krate":0,"index":9174},{"krate":0,"index":9176},{"krate":0,"index":9178},{"krate":0,"index":9180},{"krate":0,"index":9182},{"krate":0,"index":9184},{"krate":0,"index":9186},{"krate":0,"index":9188}],"docs":"","sig":null,"attributes":[]},{"id":2786,"kind":"Direct","span":{"file_name":"src/libcore/alloc.rs","byte_start":2386286,"byte_end":2386295,"line_start":340,"line_end":340,"column_start":23,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":9192}],"docs":"","sig":null,"attributes":[]},{"id":2787,"kind":"Direct","span":{"file_name":"src/libcore/alloc.rs","byte_start":2386879,"byte_end":2386887,"line_start":356,"line_end":356,"column_start":23,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":9196}],"docs":"","sig":null,"attributes":[]},{"id":2788,"kind":"Inherent","span":{"file_name":"src/libcore/alloc.rs","byte_start":2387363,"byte_end":2387383,"line_start":370,"line_end":370,"column_start":6,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":9200}],"docs":"","sig":null,"attributes":[]},{"id":2789,"kind":"Direct","span":{"file_name":"src/libcore/alloc.rs","byte_start":2387622,"byte_end":2387642,"line_start":378,"line_end":378,"column_start":23,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":9204}],"docs":"","sig":null,"attributes":[]},{"id":2790,"kind":"Direct","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467045,"byte_end":2467052,"line_start":400,"line_end":400,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":9334}],"docs":"","sig":null,"attributes":[]},{"id":2791,"kind":"Direct","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468294,"byte_end":2468301,"line_start":453,"line_end":453,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":9358}],"docs":"","sig":null,"attributes":[]},{"id":2792,"kind":"Direct","span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468673,"byte_end":2468680,"line_start":471,"line_end":471,"column_start":19,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":9368}],"docs":"","sig":null,"attributes":[]}],"refs":[{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5386,"byte_end":5391,"line_start":149,"line_end":149,"column_start":34,"column_end":39},"ref_id":{"krate":0,"index":52}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5426,"byte_end":5428,"line_start":150,"line_end":150,"column_start":34,"column_end":36},"ref_id":{"krate":0,"index":54}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5463,"byte_end":5466,"line_start":151,"line_end":151,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":56}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5501,"byte_end":5504,"line_start":152,"line_end":152,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":58}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5539,"byte_end":5542,"line_start":153,"line_end":153,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":60}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5577,"byte_end":5581,"line_start":154,"line_end":154,"column_start":34,"column_end":38},"ref_id":{"krate":0,"index":62}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5617,"byte_end":5622,"line_start":156,"line_end":156,"column_start":34,"column_end":39},"ref_id":{"krate":0,"index":64}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5657,"byte_end":5659,"line_start":157,"line_end":157,"column_start":34,"column_end":36},"ref_id":{"krate":0,"index":66}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5694,"byte_end":5697,"line_start":158,"line_end":158,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":68}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5732,"byte_end":5735,"line_start":159,"line_end":159,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":70}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5770,"byte_end":5773,"line_start":160,"line_end":160,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":72}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5808,"byte_end":5812,"line_start":161,"line_end":161,"column_start":34,"column_end":38},"ref_id":{"krate":0,"index":74}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5848,"byte_end":5851,"line_start":163,"line_end":163,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":76}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5886,"byte_end":5889,"line_start":164,"line_end":164,"column_start":34,"column_end":37},"ref_id":{"krate":0,"index":186}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":5913,"byte_end":5916,"line_start":167,"line_end":167,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":298}},{"kind":"Mod","span":{"file_name":"src/libcore/num/mod.rs","byte_start":83756,"byte_end":83763,"line_start":208,"line_end":208,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":348}},{"kind":"Mod","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238413,"byte_end":238422,"line_start":126,"line_end":126,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":362}},{"kind":"Mod","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238432,"byte_end":238439,"line_start":127,"line_end":127,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":366}},{"kind":"Mod","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238506,"byte_end":238512,"line_start":131,"line_end":131,"column_start":13,"column_end":19},"ref_id":{"krate":0,"index":394}},{"kind":"Mod","span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":238526,"byte_end":238531,"line_start":132,"line_end":132,"column_start":13,"column_end":18},"ref_id":{"krate":0,"index":436}},{"kind":"Mod","span":{"file_name":"src/libcore/num/mod.rs","byte_start":83773,"byte_end":83780,"line_start":209,"line_end":209,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":528}},{"kind":"Mod","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":315814,"byte_end":315819,"line_start":96,"line_end":96,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":644}},{"kind":"Mod","span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":315829,"byte_end":315834,"line_start":97,"line_end":97,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":832}},{"kind":"Mod","span":{"file_name":"src/libcore/num/mod.rs","byte_start":83790,"byte_end":83796,"line_start":210,"line_end":210,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":882}},{"kind":"Mod","span":{"file_name":"src/libcore/num/mod.rs","byte_start":83806,"byte_end":83815,"line_start":211,"line_end":211,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":908}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6001,"byte_end":6008,"line_start":171,"line_end":171,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":1104}},{"kind":"Mod","span":{"file_name":"src/libcore/prelude/mod.rs","byte_start":435004,"byte_end":435006,"line_start":5,"line_end":5,"column_start":9,"column_end":11},"ref_id":{"krate":0,"index":1106}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6064,"byte_end":6074,"line_start":175,"line_end":175,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":1186}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6084,"byte_end":6087,"line_start":176,"line_end":176,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":1204}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6097,"byte_end":6100,"line_start":177,"line_end":177,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":1336}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6110,"byte_end":6114,"line_start":178,"line_end":178,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":1686}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6153,"byte_end":6159,"line_start":182,"line_end":182,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":1696}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6169,"byte_end":6172,"line_start":183,"line_end":183,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":1770}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6182,"byte_end":6185,"line_start":184,"line_end":184,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":2412}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6195,"byte_end":6200,"line_start":185,"line_end":185,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2604}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6210,"byte_end":6217,"line_start":186,"line_end":186,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":2638}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6227,"byte_end":6234,"line_start":187,"line_end":187,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":2646}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6244,"byte_end":6250,"line_start":188,"line_end":188,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2754}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6305,"byte_end":6308,"line_start":192,"line_end":192,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":2784}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6318,"byte_end":6323,"line_start":193,"line_end":193,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2838}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6333,"byte_end":6338,"line_start":194,"line_end":194,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2894}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6348,"byte_end":6352,"line_start":195,"line_end":195,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":2928}},{"kind":"Mod","span":{"file_name":"src/libcore/sync/mod.rs","byte_start":923961,"byte_end":923967,"line_start":5,"line_end":5,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2930}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6362,"byte_end":6366,"line_start":196,"line_end":196,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":3072}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6376,"byte_end":6380,"line_start":197,"line_end":197,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":3370}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6390,"byte_end":6395,"line_start":198,"line_end":198,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":3704}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6405,"byte_end":6414,"line_start":199,"line_end":199,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":3748}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6424,"byte_end":6427,"line_start":200,"line_end":200,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":3766}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6437,"byte_end":6441,"line_start":201,"line_end":201,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":3874}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6451,"byte_end":6457,"line_start":202,"line_end":202,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":5506}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6467,"byte_end":6470,"line_start":203,"line_end":203,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":5758}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6480,"byte_end":6486,"line_start":204,"line_end":204,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":5760}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6496,"byte_end":6499,"line_start":205,"line_end":205,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":5956}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6510,"byte_end":6515,"line_start":207,"line_end":207,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":5984}},{"kind":"Mod","span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1527855,"byte_end":1527861,"line_start":41,"line_end":41,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":6046}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6525,"byte_end":6528,"line_start":208,"line_end":208,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":7096}},{"kind":"Mod","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1737480,"byte_end":1737487,"line_start":19,"line_end":19,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":7152}},{"kind":"Mod","span":{"file_name":"src/libcore/str/mod.rs","byte_start":1737573,"byte_end":1737578,"line_start":23,"line_end":23,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":7358}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6538,"byte_end":6542,"line_start":209,"line_end":209,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":7956}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6552,"byte_end":6555,"line_start":210,"line_end":210,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":8198}},{"kind":"Mod","span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1969595,"byte_end":1969597,"line_start":40,"line_end":40,"column_start":13,"column_end":15},"ref_id":{"krate":0,"index":8422}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6565,"byte_end":6569,"line_start":211,"line_end":211,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":8692}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6580,"byte_end":6587,"line_start":213,"line_end":213,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":8850}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6610,"byte_end":6616,"line_start":216,"line_end":216,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":8986}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6626,"byte_end":6630,"line_start":217,"line_end":217,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":9022}},{"kind":"Mod","span":{"file_name":"src/libcore/lib.rs","byte_start":6698,"byte_end":6703,"line_start":221,"line_end":221,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":9140}}],"macro_refs":[],"relations":[{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":82556,"byte_end":82564,"line_start":166,"line_end":166,"column_start":36,"column_end":44},"kind":{"Impl":{"id":26}},"from":{"krate":0,"index":13554},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":82761,"byte_end":82769,"line_start":173,"line_end":173,"column_start":40,"column_end":48},"kind":{"Impl":{"id":27}},"from":{"krate":0,"index":13554},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":82960,"byte_end":82968,"line_start":180,"line_end":180,"column_start":38,"column_end":46},"kind":{"Impl":{"id":28}},"from":{"krate":0,"index":13554},"to":{"krate":0,"index":8484}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":83157,"byte_end":83165,"line_start":187,"line_end":187,"column_start":36,"column_end":44},"kind":{"Impl":{"id":29}},"from":{"krate":0,"index":13554},"to":{"krate":0,"index":8480}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":83360,"byte_end":83368,"line_start":194,"line_end":194,"column_start":42,"column_end":50},"kind":{"Impl":{"id":30}},"from":{"krate":0,"index":13554},"to":{"krate":0,"index":8488}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":83563,"byte_end":83571,"line_start":201,"line_end":201,"column_start":42,"column_end":50},"kind":{"Impl":{"id":31}},"from":{"krate":0,"index":13554},"to":{"krate":0,"index":8492}},{"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262852,"byte_end":262860,"line_start":44,"line_end":44,"column_start":27,"column_end":35},"kind":"SuperTrait","from":{"krate":0,"index":704},"to":{"krate":0,"index":378}},{"span":{"file_name":"src/libcore/num/flt2dec/decoder.rs","byte_start":262863,"byte_end":262867,"line_start":44,"line_end":44,"column_start":38,"column_end":42},"kind":"SuperTrait","from":{"krate":0,"index":1716},"to":{"krate":0,"index":378}},{"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":239863,"byte_end":239867,"line_start":174,"line_end":174,"column_start":10,"column_end":14},"kind":{"Impl":{"id":34}},"from":{"krate":0,"index":13640},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/flt2dec/mod.rs","byte_start":241600,"byte_end":241609,"line_start":223,"line_end":223,"column_start":10,"column_end":19},"kind":{"Impl":{"id":35}},"from":{"krate":0,"index":13662},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":368654,"byte_end":368662,"line_start":36,"line_end":36,"column_start":6,"column_end":14},"kind":{"Impl":{"id":36}},"from":{"krate":0,"index":13688},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369036,"byte_end":369040,"line_start":48,"line_end":48,"column_start":7,"column_end":11},"kind":"SuperTrait","from":{"krate":0,"index":1716},"to":{"krate":0,"index":704}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369047,"byte_end":369052,"line_start":49,"line_end":49,"column_start":7,"column_end":12},"kind":"SuperTrait","from":{"krate":0,"index":8472},"to":{"krate":0,"index":704}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369059,"byte_end":369067,"line_start":50,"line_end":50,"column_start":7,"column_end":15},"kind":"SuperTrait","from":{"krate":0,"index":8500},"to":{"krate":0,"index":704}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369074,"byte_end":369077,"line_start":51,"line_end":51,"column_start":7,"column_end":10},"kind":"SuperTrait","from":{"krate":0,"index":1790},"to":{"krate":0,"index":704}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369097,"byte_end":369100,"line_start":52,"line_end":52,"column_start":7,"column_end":10},"kind":"SuperTrait","from":{"krate":0,"index":1798},"to":{"krate":0,"index":704}},{"span":{"file_name":"src/libcore/num/dec2flt/rawfp.rs","byte_start":369120,"byte_end":369123,"line_start":53,"line_end":53,"column_start":7,"column_end":10},"kind":"SuperTrait","from":{"krate":0,"index":1818},"to":{"krate":0,"index":704}},{"span":{"file_name":"src/libcore/num/dec2flt/parse.rs","byte_start":381784,"byte_end":381791,"line_start":31,"line_end":31,"column_start":10,"column_end":17},"kind":{"Impl":{"id":39}},"from":{"krate":0,"index":13746},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":318585,"byte_end":318600,"line_start":183,"line_end":183,"column_start":6,"column_end":21},"kind":{"Impl":{"id":42}},"from":{"krate":0,"index":13790},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/dec2flt/mod.rs","byte_start":319126,"byte_end":319141,"line_start":198,"line_end":198,"column_start":23,"column_end":38},"kind":{"Impl":{"id":43}},"from":{"krate":0,"index":13790},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/num/bignum.rs","byte_start":385996,"byte_end":386001,"line_start":24,"line_end":24,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":888}},{"span":{"file_name":"src/libcore/num/diy_float.rs","byte_start":405156,"byte_end":405158,"line_start":20,"line_end":20,"column_start":6,"column_end":8},"kind":{"Impl":{"id":47}},"from":{"krate":0,"index":14042},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":211529,"byte_end":211544,"line_start":4413,"line_end":4413,"column_start":6,"column_end":21},"kind":{"Impl":{"id":72}},"from":{"krate":0,"index":19882},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":211955,"byte_end":211970,"line_start":4425,"line_end":4425,"column_start":23,"column_end":38},"kind":{"Impl":{"id":73}},"from":{"krate":0,"index":19882},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":212161,"byte_end":212176,"line_start":4432,"line_end":4432,"column_start":27,"column_end":42},"kind":{"Impl":{"id":74}},"from":{"krate":0,"index":19882},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":212325,"byte_end":212340,"line_start":4439,"line_end":4439,"column_start":18,"column_end":33},"kind":{"Impl":{"id":75}},"from":{"krate":0,"index":19882},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219450,"byte_end":219460,"line_start":4649,"line_end":4649,"column_start":27,"column_end":37},"kind":"SuperTrait","from":{"krate":0,"index":2472},"to":{"krate":0,"index":1066}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":219463,"byte_end":219467,"line_start":4649,"line_end":4649,"column_start":40,"column_end":44},"kind":"SuperTrait","from":{"krate":0,"index":1716},"to":{"krate":0,"index":1066}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":224523,"byte_end":224536,"line_start":4796,"line_end":4796,"column_start":6,"column_end":19},"kind":{"Impl":{"id":185}},"from":{"krate":0,"index":20654},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/num/mod.rs","byte_start":225657,"byte_end":225670,"line_start":4822,"line_end":4822,"column_start":23,"column_end":36},"kind":{"Impl":{"id":186}},"from":{"krate":0,"index":20654},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":536622,"byte_end":536634,"line_start":837,"line_end":837,"column_start":18,"column_end":30},"kind":{"Impl":{"id":245}},"from":{"krate":0,"index":1260},"to":{"krate":0,"index":1716}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":536727,"byte_end":536739,"line_start":840,"line_end":840,"column_start":26,"column_end":38},"kind":{"Impl":{"id":246}},"from":{"krate":0,"index":1260},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":536885,"byte_end":536897,"line_start":847,"line_end":847,"column_start":28,"column_end":40},"kind":{"Impl":{"id":247}},"from":{"krate":0,"index":1260},"to":{"krate":0,"index":2416}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":537055,"byte_end":537067,"line_start":854,"line_end":854,"column_start":21,"column_end":33},"kind":{"Impl":{"id":248}},"from":{"krate":0,"index":1260},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":537158,"byte_end":537170,"line_start":857,"line_end":857,"column_start":24,"column_end":36},"kind":{"Impl":{"id":249}},"from":{"krate":0,"index":1260},"to":{"krate":0,"index":8050}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":537349,"byte_end":537361,"line_start":864,"line_end":864,"column_start":24,"column_end":36},"kind":{"Impl":{"id":250}},"from":{"krate":0,"index":1260},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":540570,"byte_end":540582,"line_start":954,"line_end":954,"column_start":9,"column_end":21},"kind":{"Impl":{"id":251}},"from":{"krate":0,"index":20924},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":542564,"byte_end":542576,"line_start":1010,"line_end":1010,"column_start":17,"column_end":29},"kind":{"Impl":{"id":252}},"from":{"krate":0,"index":20924},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":543320,"byte_end":543332,"line_start":1030,"line_end":1030,"column_start":27,"column_end":39},"kind":{"Impl":{"id":253}},"from":{"krate":0,"index":20924},"to":{"krate":0,"index":1950}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":543522,"byte_end":543534,"line_start":1039,"line_end":1039,"column_start":30,"column_end":42},"kind":{"Impl":{"id":254}},"from":{"krate":0,"index":20924},"to":{"krate":0,"index":1968}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":547032,"byte_end":547043,"line_start":1126,"line_end":1126,"column_start":25,"column_end":36},"kind":{"Impl":{"id":255}},"from":{"krate":0,"index":20968},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/mem.rs","byte_start":547223,"byte_end":547234,"line_start":1134,"line_end":1134,"column_start":9,"column_end":20},"kind":{"Impl":{"id":256}},"from":{"krate":0,"index":20968},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":656108,"byte_end":656114,"line_start":2778,"line_end":2778,"column_start":32,"column_end":38},"kind":{"Impl":{"id":257}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":656556,"byte_end":656562,"line_start":2789,"line_end":2789,"column_start":40,"column_end":46},"kind":{"Impl":{"id":258}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":1706}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":656890,"byte_end":656896,"line_start":2796,"line_end":2796,"column_start":40,"column_end":46},"kind":{"Impl":{"id":259}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":656972,"byte_end":656978,"line_start":2799,"line_end":2799,"column_start":16,"column_end":22},"kind":{"Impl":{"id":260}},"from":{"krate":0,"index":1562},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":657687,"byte_end":657693,"line_start":2818,"line_end":2818,"column_start":17,"column_end":23},"kind":{"Impl":{"id":261}},"from":{"krate":0,"index":1562},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":659069,"byte_end":659075,"line_start":2862,"line_end":2862,"column_start":27,"column_end":33},"kind":{"Impl":{"id":262}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":659211,"byte_end":659217,"line_start":2869,"line_end":2869,"column_start":26,"column_end":32},"kind":{"Impl":{"id":263}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":1716}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":659334,"byte_end":659340,"line_start":2872,"line_end":2872,"column_start":57,"column_end":63},"kind":{"Impl":{"id":264}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":2274}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":659478,"byte_end":659484,"line_start":2875,"line_end":2875,"column_start":59,"column_end":65},"kind":{"Impl":{"id":265}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":2294}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":659597,"byte_end":659603,"line_start":2878,"line_end":2878,"column_start":34,"column_end":40},"kind":{"Impl":{"id":266}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":8496}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":659811,"byte_end":659817,"line_start":2885,"line_end":2885,"column_start":34,"column_end":40},"kind":{"Impl":{"id":267}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":660035,"byte_end":660041,"line_start":2892,"line_end":2892,"column_start":30,"column_end":36},"kind":{"Impl":{"id":268}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":660269,"byte_end":660275,"line_start":2899,"line_end":2899,"column_start":42,"column_end":48},"kind":{"Impl":{"id":269}},"from":{"krate":0,"index":1562},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":662534,"byte_end":662541,"line_start":2943,"line_end":2943,"column_start":27,"column_end":34},"kind":{"Impl":{"id":270}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":1706}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":662788,"byte_end":662795,"line_start":2948,"line_end":2948,"column_start":27,"column_end":34},"kind":{"Impl":{"id":271}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":662819,"byte_end":662826,"line_start":2950,"line_end":2950,"column_start":16,"column_end":23},"kind":{"Impl":{"id":272}},"from":{"krate":0,"index":1614},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":663588,"byte_end":663595,"line_start":2971,"line_end":2971,"column_start":17,"column_end":24},"kind":{"Impl":{"id":273}},"from":{"krate":0,"index":1614},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":665572,"byte_end":665579,"line_start":3035,"line_end":3035,"column_start":27,"column_end":34},"kind":{"Impl":{"id":274}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":665712,"byte_end":665719,"line_start":3042,"line_end":3042,"column_start":26,"column_end":33},"kind":{"Impl":{"id":275}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":1716}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":665842,"byte_end":665849,"line_start":3045,"line_end":3045,"column_start":58,"column_end":65},"kind":{"Impl":{"id":276}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2274}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":665992,"byte_end":665999,"line_start":3048,"line_end":3048,"column_start":60,"column_end":67},"kind":{"Impl":{"id":277}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2294}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":666107,"byte_end":666114,"line_start":3051,"line_end":3051,"column_start":32,"column_end":39},"kind":{"Impl":{"id":278}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":666319,"byte_end":666326,"line_start":3058,"line_end":3058,"column_start":34,"column_end":41},"kind":{"Impl":{"id":279}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":8496}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":666521,"byte_end":666528,"line_start":3065,"line_end":3065,"column_start":24,"column_end":31},"kind":{"Impl":{"id":280}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":666615,"byte_end":666622,"line_start":3068,"line_end":3068,"column_start":31,"column_end":38},"kind":{"Impl":{"id":281}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2416}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":666805,"byte_end":666812,"line_start":3076,"line_end":3076,"column_start":25,"column_end":32},"kind":{"Impl":{"id":282}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2452}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":667010,"byte_end":667017,"line_start":3084,"line_end":3084,"column_start":32,"column_end":39},"kind":{"Impl":{"id":283}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2472}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":667239,"byte_end":667246,"line_start":3092,"line_end":3092,"column_start":32,"column_end":39},"kind":{"Impl":{"id":284}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":8050}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":667450,"byte_end":667457,"line_start":3100,"line_end":3100,"column_start":37,"column_end":44},"kind":{"Impl":{"id":285}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":667664,"byte_end":667671,"line_start":3108,"line_end":3108,"column_start":34,"column_end":41},"kind":{"Impl":{"id":286}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/ptr.rs","byte_start":667879,"byte_end":667886,"line_start":3116,"line_end":3116,"column_start":30,"column_end":37},"kind":{"Impl":{"id":287}},"from":{"krate":0,"index":1614},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/marker.rs","byte_start":683350,"byte_end":683355,"line_start":287,"line_end":287,"column_start":18,"column_end":23},"kind":"SuperTrait","from":{"krate":0,"index":2606},"to":{"krate":0,"index":1716}},{"span":{"file_name":"src/libcore/marker.rs","byte_start":694494,"byte_end":694504,"line_start":591,"line_end":591,"column_start":29,"column_end":39},"kind":{"Impl":{"id":288}},"from":{"krate":0,"index":3344},"to":{"krate":0,"index":1734}},{"span":{"file_name":"src/libcore/marker.rs","byte_start":694545,"byte_end":694556,"line_start":592,"line_end":592,"column_start":35,"column_end":46},"kind":{"Impl":{"id":289}},"from":{"krate":0,"index":1726},"to":{"krate":0,"index":1734}},{"span":{"file_name":"src/libcore/marker.rs","byte_start":696984,"byte_end":696997,"line_start":650,"line_end":650,"column_start":17,"column_end":30},"kind":{"Impl":{"id":290}},"from":{"krate":0,"index":22976},"to":{"krate":0,"index":1748}},{"span":{"file_name":"src/libcore/ops/deref.rs","byte_start":760074,"byte_end":760079,"line_start":160,"line_end":160,"column_start":21,"column_end":26},"kind":"SuperTrait","from":{"krate":0,"index":1950},"to":{"krate":0,"index":1968}},{"span":{"file_name":"src/libcore/ops/function.rs","byte_start":766350,"byte_end":766355,"line_start":66,"line_end":66,"column_start":22,"column_end":27},"kind":"SuperTrait","from":{"krate":0,"index":1994},"to":{"krate":0,"index":1990}},{"span":{"file_name":"src/libcore/ops/function.rs","byte_start":769073,"byte_end":769079,"line_start":145,"line_end":145,"column_start":25,"column_end":31},"kind":"SuperTrait","from":{"krate":0,"index":1998},"to":{"krate":0,"index":1994}},{"span":{"file_name":"src/libcore/ops/generator.rs","byte_start":778373,"byte_end":778376,"line_start":117,"line_end":117,"column_start":43,"column_end":46},"kind":{"Impl":{"id":1916}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":2036}},{"span":{"file_name":"src/libcore/ops/index.rs","byte_start":784080,"byte_end":784085,"line_start":166,"line_end":166,"column_start":34,"column_end":39},"kind":"SuperTrait","from":{"krate":0,"index":2062},"to":{"krate":0,"index":2068}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":785604,"byte_end":785613,"line_start":47,"line_end":47,"column_start":21,"column_end":30},"kind":{"Impl":{"id":1917}},"from":{"krate":0,"index":36038},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":786844,"byte_end":786849,"line_start":86,"line_end":86,"column_start":38,"column_end":43},"kind":{"Impl":{"id":1918}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":787059,"byte_end":787064,"line_start":95,"line_end":95,"column_start":28,"column_end":33},"kind":{"Impl":{"id":1919}},"from":{"krate":0,"index":36058},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":789922,"byte_end":789931,"line_start":188,"line_end":188,"column_start":38,"column_end":47},"kind":{"Impl":{"id":1920}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":790113,"byte_end":790122,"line_start":196,"line_end":196,"column_start":28,"column_end":37},"kind":{"Impl":{"id":1921}},"from":{"krate":0,"index":36078},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":792398,"byte_end":792405,"line_start":272,"line_end":272,"column_start":38,"column_end":45},"kind":{"Impl":{"id":1922}},"from":{"krate":0,"index":36098},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":792585,"byte_end":792592,"line_start":280,"line_end":280,"column_start":28,"column_end":35},"kind":{"Impl":{"id":1923}},"from":{"krate":0,"index":36098},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":794847,"byte_end":794852,"line_start":347,"line_end":347,"column_start":31,"column_end":36},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":2112}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":794962,"byte_end":794963,"line_start":351,"line_end":351,"column_start":36,"column_end":37},"kind":{"Impl":{"id":1924}},"from":{"krate":0,"index":1201},"to":{"krate":0,"index":2112}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":795157,"byte_end":795158,"line_start":358,"line_end":358,"column_start":48,"column_end":49},"kind":{"Impl":{"id":1925}},"from":{"krate":0,"index":1203},"to":{"krate":0,"index":2112}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":795371,"byte_end":795385,"line_start":366,"line_end":366,"column_start":36,"column_end":50},"kind":{"Impl":{"id":1926}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":2416}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":795747,"byte_end":795761,"line_start":377,"line_end":377,"column_start":22,"column_end":36},"kind":{"Impl":{"id":1927}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":795853,"byte_end":795867,"line_start":380,"line_end":380,"column_start":26,"column_end":40},"kind":{"Impl":{"id":1928}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":8050}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":796077,"byte_end":796091,"line_start":388,"line_end":388,"column_start":11,"column_end":25},"kind":{"Impl":{"id":1929}},"from":{"krate":0,"index":36120},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":798779,"byte_end":798793,"line_start":475,"line_end":475,"column_start":38,"column_end":52},"kind":{"Impl":{"id":1930}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":799004,"byte_end":799018,"line_start":484,"line_end":484,"column_start":28,"column_end":42},"kind":{"Impl":{"id":1931}},"from":{"krate":0,"index":36120},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":802980,"byte_end":802996,"line_start":613,"line_end":613,"column_start":38,"column_end":54},"kind":{"Impl":{"id":1932}},"from":{"krate":0,"index":36126},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":803177,"byte_end":803193,"line_start":621,"line_end":621,"column_start":28,"column_end":44},"kind":{"Impl":{"id":1933}},"from":{"krate":0,"index":36126},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":807875,"byte_end":807884,"line_start":774,"line_end":774,"column_start":36,"column_end":45},"kind":{"Impl":{"id":1934}},"from":{"krate":0,"index":36038},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":808104,"byte_end":808113,"line_start":784,"line_end":784,"column_start":28,"column_end":37},"kind":{"Impl":{"id":1935}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":808348,"byte_end":808355,"line_start":794,"line_end":794,"column_start":28,"column_end":35},"kind":{"Impl":{"id":1936}},"from":{"krate":0,"index":36098},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":808588,"byte_end":808593,"line_start":804,"line_end":804,"column_start":28,"column_end":33},"kind":{"Impl":{"id":1937}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":808838,"byte_end":808852,"line_start":814,"line_end":814,"column_start":28,"column_end":42},"kind":{"Impl":{"id":1938}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":809097,"byte_end":809113,"line_start":824,"line_end":824,"column_start":28,"column_end":44},"kind":{"Impl":{"id":1939}},"from":{"krate":0,"index":36126},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":810177,"byte_end":810186,"line_start":864,"line_end":864,"column_start":28,"column_end":37},"kind":{"Impl":{"id":1940}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":810421,"byte_end":810428,"line_start":874,"line_end":874,"column_start":28,"column_end":35},"kind":{"Impl":{"id":1941}},"from":{"krate":0,"index":36098},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":810661,"byte_end":810666,"line_start":884,"line_end":884,"column_start":28,"column_end":33},"kind":{"Impl":{"id":1942}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":810910,"byte_end":810924,"line_start":894,"line_end":894,"column_start":28,"column_end":42},"kind":{"Impl":{"id":1943}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/ops/range.rs","byte_start":811168,"byte_end":811184,"line_start":904,"line_end":904,"column_start":28,"column_end":44},"kind":{"Impl":{"id":1944}},"from":{"krate":0,"index":36126},"to":{"krate":0,"index":2162}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":825975,"byte_end":825984,"line_start":245,"line_end":245,"column_start":15,"column_end":24},"kind":"SuperTrait","from":{"krate":0,"index":2416},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":827741,"byte_end":827749,"line_start":300,"line_end":300,"column_start":6,"column_end":14},"kind":{"Impl":{"id":1945}},"from":{"krate":0,"index":36174},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":831770,"byte_end":831777,"line_start":432,"line_end":432,"column_start":36,"column_end":43},"kind":{"Impl":{"id":1946}},"from":{"krate":0,"index":36194},"to":{"krate":0,"index":2472}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":832288,"byte_end":832295,"line_start":449,"line_end":449,"column_start":22,"column_end":29},"kind":{"Impl":{"id":1947}},"from":{"krate":0,"index":36194},"to":{"krate":0,"index":2452}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":834514,"byte_end":834516,"line_start":519,"line_end":519,"column_start":16,"column_end":18},"kind":"SuperTrait","from":{"krate":0,"index":2422},"to":{"krate":0,"index":2452}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":834519,"byte_end":834529,"line_start":519,"line_end":519,"column_start":21,"column_end":31},"kind":"SuperTrait","from":{"krate":0,"index":2472},"to":{"krate":0,"index":2452}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":836825,"byte_end":836833,"line_start":604,"line_end":604,"column_start":13,"column_end":21},"kind":{"Impl":{"id":1948}},"from":{"krate":0,"index":36174},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":836897,"byte_end":836905,"line_start":607,"line_end":607,"column_start":14,"column_end":22},"kind":{"Impl":{"id":1949}},"from":{"krate":0,"index":36174},"to":{"krate":0,"index":2452}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":837092,"byte_end":837100,"line_start":615,"line_end":615,"column_start":21,"column_end":29},"kind":{"Impl":{"id":1950}},"from":{"krate":0,"index":36174},"to":{"krate":0,"index":2472}},{"span":{"file_name":"src/libcore/cmp.rs","byte_start":840606,"byte_end":840615,"line_start":730,"line_end":730,"column_start":43,"column_end":52},"kind":"SuperTrait","from":{"krate":0,"index":2416},"to":{"krate":0,"index":2472}},{"span":{"file_name":"src/libcore/clone.rs","byte_start":856414,"byte_end":856419,"line_start":110,"line_end":110,"column_start":19,"column_end":24},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/default.rs","byte_start":861332,"byte_end":861337,"line_start":84,"line_end":84,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":873689,"byte_end":873694,"line_start":279,"line_end":279,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":2660}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":877318,"byte_end":877323,"line_start":374,"line_end":374,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":878182,"byte_end":878187,"line_start":398,"line_end":398,"column_start":23,"column_end":28},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":2668}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":881046,"byte_end":881051,"line_start":478,"line_end":478,"column_start":23,"column_end":28},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":2674}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":882800,"byte_end":882801,"line_start":537,"line_end":537,"column_start":24,"column_end":25},"kind":{"Impl":{"id":2043}},"from":{"krate":0,"index":1427},"to":{"krate":0,"index":2660}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":882980,"byte_end":882981,"line_start":546,"line_end":546,"column_start":21,"column_end":22},"kind":{"Impl":{"id":2044}},"from":{"krate":0,"index":1431},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":883120,"byte_end":883121,"line_start":553,"line_end":553,"column_start":27,"column_end":28},"kind":{"Impl":{"id":2045}},"from":{"krate":0,"index":1433},"to":{"krate":0,"index":2668}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":883443,"byte_end":883444,"line_start":565,"line_end":565,"column_start":27,"column_end":28},"kind":{"Impl":{"id":2046}},"from":{"krate":0,"index":1437},"to":{"krate":0,"index":2674}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":886530,"byte_end":886540,"line_start":660,"line_end":660,"column_start":16,"column_end":26},"kind":{"Impl":{"id":2048}},"from":{"krate":0,"index":36714},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":886691,"byte_end":886701,"line_start":667,"line_end":667,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2049}},"from":{"krate":0,"index":36714},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":886881,"byte_end":886891,"line_start":674,"line_end":674,"column_start":23,"column_end":33},"kind":{"Impl":{"id":2050}},"from":{"krate":0,"index":36714},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":887068,"byte_end":887078,"line_start":681,"line_end":681,"column_start":20,"column_end":30},"kind":{"Impl":{"id":2051}},"from":{"krate":0,"index":36714},"to":{"krate":0,"index":2416}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":887228,"byte_end":887238,"line_start":688,"line_end":688,"column_start":13,"column_end":23},"kind":{"Impl":{"id":2052}},"from":{"krate":0,"index":36714},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":887323,"byte_end":887333,"line_start":691,"line_end":691,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2053}},"from":{"krate":0,"index":36714},"to":{"krate":0,"index":2472}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":887516,"byte_end":887526,"line_start":698,"line_end":698,"column_start":14,"column_end":24},"kind":{"Impl":{"id":2054}},"from":{"krate":0,"index":36714},"to":{"krate":0,"index":2452}},{"span":{"file_name":"src/libcore/convert.rs","byte_start":887697,"byte_end":887707,"line_start":705,"line_end":705,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2055}},"from":{"krate":0,"index":36714},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/borrow.rs","byte_start":895425,"byte_end":895431,"line_start":192,"line_end":192,"column_start":41,"column_end":47},"kind":"SuperTrait","from":{"krate":0,"index":2756},"to":{"krate":0,"index":2760}},{"span":{"file_name":"src/libcore/borrow.rs","byte_start":895949,"byte_end":895950,"line_start":213,"line_end":213,"column_start":31,"column_end":32},"kind":{"Impl":{"id":2056}},"from":{"krate":0,"index":1449},"to":{"krate":0,"index":2756}},{"span":{"file_name":"src/libcore/borrow.rs","byte_start":896071,"byte_end":896072,"line_start":218,"line_end":218,"column_start":34,"column_end":35},"kind":{"Impl":{"id":2057}},"from":{"krate":0,"index":1451},"to":{"krate":0,"index":2760}},{"span":{"file_name":"src/libcore/any.rs","byte_start":900048,"byte_end":900049,"line_start":100,"line_end":100,"column_start":36,"column_end":37},"kind":{"Impl":{"id":2058}},"from":{"krate":0,"index":1459},"to":{"krate":0,"index":2790}},{"span":{"file_name":"src/libcore/any.rs","byte_start":908988,"byte_end":908994,"line_start":427,"line_end":427,"column_start":6,"column_end":12},"kind":{"Impl":{"id":2059}},"from":{"krate":0,"index":36718},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/array.rs","byte_start":911211,"byte_end":911212,"line_start":40,"line_end":40,"column_start":54,"column_end":55},"kind":{"Impl":{"id":2060}},"from":{"krate":0,"index":1485},"to":{"krate":0,"index":2866}},{"span":{"file_name":"src/libcore/array.rs","byte_start":911577,"byte_end":911594,"line_start":56,"line_end":56,"column_start":23,"column_end":40},"kind":{"Impl":{"id":2061}},"from":{"krate":0,"index":36760},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/array.rs","byte_start":911739,"byte_end":911756,"line_start":63,"line_end":63,"column_start":6,"column_end":23},"kind":{"Impl":{"id":2062}},"from":{"krate":0,"index":36760},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":923106,"byte_end":923119,"line_start":116,"line_end":116,"column_start":19,"column_end":32},"kind":{"Impl":{"id":2063}},"from":{"krate":0,"index":2902},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":923377,"byte_end":923390,"line_start":122,"line_end":122,"column_start":30,"column_end":43},"kind":{"Impl":{"id":2064}},"from":{"krate":0,"index":2902},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":923571,"byte_end":923584,"line_start":128,"line_end":128,"column_start":28,"column_end":41},"kind":{"Impl":{"id":2065}},"from":{"krate":0,"index":2902},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":923658,"byte_end":923671,"line_start":130,"line_end":130,"column_start":24,"column_end":37},"kind":{"Impl":{"id":2066}},"from":{"krate":0,"index":2902},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/ascii.rs","byte_start":923747,"byte_end":923760,"line_start":133,"line_end":133,"column_start":21,"column_end":34},"kind":{"Impl":{"id":2067}},"from":{"krate":0,"index":2902},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":930814,"byte_end":930824,"line_start":169,"line_end":169,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2068}},"from":{"krate":0,"index":2944},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931093,"byte_end":931103,"line_start":179,"line_end":179,"column_start":22,"column_end":32},"kind":{"Impl":{"id":2069}},"from":{"krate":0,"index":2944},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931662,"byte_end":931671,"line_start":195,"line_end":195,"column_start":21,"column_end":30},"kind":{"Impl":{"id":2070}},"from":{"krate":0,"index":2952},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":931911,"byte_end":931920,"line_start":204,"line_end":204,"column_start":25,"column_end":34},"kind":{"Impl":{"id":2071}},"from":{"krate":0,"index":2952},"to":{"krate":0,"index":1706}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":932031,"byte_end":932040,"line_start":207,"line_end":207,"column_start":25,"column_end":34},"kind":{"Impl":{"id":2072}},"from":{"krate":0,"index":2952},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":936918,"byte_end":936928,"line_start":314,"line_end":314,"column_start":6,"column_end":16},"kind":{"Impl":{"id":2073}},"from":{"krate":0,"index":2944},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":955959,"byte_end":955968,"line_start":801,"line_end":801,"column_start":9,"column_end":18},"kind":{"Impl":{"id":2074}},"from":{"krate":0,"index":2952},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":967929,"byte_end":967939,"line_start":1114,"line_end":1114,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2075}},"from":{"krate":0,"index":2944},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":968374,"byte_end":968383,"line_start":1130,"line_end":1130,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2076}},"from":{"krate":0,"index":2952},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1021015,"byte_end":1021025,"line_start":2508,"line_end":2508,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2077}},"from":{"krate":0,"index":2944},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1021267,"byte_end":1021276,"line_start":2516,"line_end":2516,"column_start":24,"column_end":33},"kind":{"Impl":{"id":2078}},"from":{"krate":0,"index":2952},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/sync/atomic.rs","byte_start":1021526,"byte_end":1021535,"line_start":2524,"line_end":2524,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2079}},"from":{"krate":0,"index":2952},"to":{"krate":0,"index":8496}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1030841,"byte_end":1030845,"line_start":234,"line_end":234,"column_start":14,"column_end":18},"kind":{"Impl":{"id":2080}},"from":{"krate":0,"index":3098},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1031882,"byte_end":1031886,"line_start":281,"line_end":281,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2081}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":1706}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1031980,"byte_end":1031984,"line_start":284,"line_end":284,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2082}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1032061,"byte_end":1032065,"line_start":287,"line_end":287,"column_start":24,"column_end":28},"kind":{"Impl":{"id":2083}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1032231,"byte_end":1032235,"line_start":295,"line_end":295,"column_start":29,"column_end":33},"kind":{"Impl":{"id":2084}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1032478,"byte_end":1032482,"line_start":304,"line_end":304,"column_start":40,"column_end":44},"kind":{"Impl":{"id":2085}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":2416}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1032662,"byte_end":1032666,"line_start":312,"line_end":312,"column_start":26,"column_end":30},"kind":{"Impl":{"id":2086}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1032765,"byte_end":1032769,"line_start":315,"line_end":315,"column_start":42,"column_end":46},"kind":{"Impl":{"id":2087}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":2472}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1033379,"byte_end":1033383,"line_start":343,"line_end":343,"column_start":28,"column_end":32},"kind":{"Impl":{"id":2088}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":2452}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1033569,"byte_end":1033573,"line_start":351,"line_end":351,"column_start":21,"column_end":25},"kind":{"Impl":{"id":2089}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1033648,"byte_end":1033652,"line_start":357,"line_end":357,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2090}},"from":{"krate":0,"index":3098},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1035857,"byte_end":1035861,"line_start":453,"line_end":453,"column_start":17,"column_end":21},"kind":{"Impl":{"id":2091}},"from":{"krate":0,"index":3098},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1037422,"byte_end":1037426,"line_start":517,"line_end":517,"column_start":18,"column_end":22},"kind":{"Impl":{"id":2092}},"from":{"krate":0,"index":3098},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1037991,"byte_end":1037995,"line_start":538,"line_end":538,"column_start":57,"column_end":61},"kind":{"Impl":{"id":2093}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":2274}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1038011,"byte_end":1038015,"line_start":540,"line_end":540,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2094}},"from":{"krate":0,"index":3098},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1039156,"byte_end":1039167,"line_start":579,"line_end":579,"column_start":16,"column_end":27},"kind":{"Impl":{"id":2095}},"from":{"krate":0,"index":3176},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1039358,"byte_end":1039369,"line_start":586,"line_end":586,"column_start":18,"column_end":29},"kind":{"Impl":{"id":2096}},"from":{"krate":0,"index":3176},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1039761,"byte_end":1039775,"line_start":599,"line_end":599,"column_start":16,"column_end":30},"kind":{"Impl":{"id":2097}},"from":{"krate":0,"index":3186},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1039969,"byte_end":1039983,"line_start":606,"line_end":606,"column_start":18,"column_end":32},"kind":{"Impl":{"id":2098}},"from":{"krate":0,"index":3186},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1041166,"byte_end":1041173,"line_start":638,"line_end":638,"column_start":9,"column_end":16},"kind":{"Impl":{"id":2099}},"from":{"krate":0,"index":3174},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1044494,"byte_end":1044501,"line_start":752,"line_end":752,"column_start":17,"column_end":24},"kind":{"Impl":{"id":2100}},"from":{"krate":0,"index":3174},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1051543,"byte_end":1051550,"line_start":999,"line_end":999,"column_start":33,"column_end":40},"kind":{"Impl":{"id":2101}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":1706}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1051644,"byte_end":1051651,"line_start":1002,"line_end":1002,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2102}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1051730,"byte_end":1051737,"line_start":1005,"line_end":1005,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2103}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1052004,"byte_end":1052011,"line_start":1016,"line_end":1016,"column_start":29,"column_end":36},"kind":{"Impl":{"id":2104}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1052266,"byte_end":1052273,"line_start":1025,"line_end":1025,"column_start":43,"column_end":50},"kind":{"Impl":{"id":2105}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":2416}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1052563,"byte_end":1052570,"line_start":1036,"line_end":1036,"column_start":29,"column_end":36},"kind":{"Impl":{"id":2106}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1052672,"byte_end":1052679,"line_start":1039,"line_end":1039,"column_start":45,"column_end":52},"kind":{"Impl":{"id":2107}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":2472}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1053826,"byte_end":1053833,"line_start":1082,"line_end":1082,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2108}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":2452}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1054125,"byte_end":1054132,"line_start":1093,"line_end":1093,"column_start":21,"column_end":28},"kind":{"Impl":{"id":2109}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1054321,"byte_end":1054328,"line_start":1100,"line_end":1100,"column_start":60,"column_end":67},"kind":{"Impl":{"id":2110}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":2274}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1054405,"byte_end":1054414,"line_start":1106,"line_end":1106,"column_start":10,"column_end":19},"kind":{"Impl":{"id":2111}},"from":{"krate":0,"index":3272},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1054863,"byte_end":1054872,"line_start":1121,"line_end":1121,"column_start":15,"column_end":24},"kind":{"Impl":{"id":2112}},"from":{"krate":0,"index":3272},"to":{"krate":0,"index":1984}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1055062,"byte_end":1055071,"line_start":1130,"line_end":1130,"column_start":16,"column_end":25},"kind":{"Impl":{"id":2113}},"from":{"krate":0,"index":3272},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1055923,"byte_end":1055926,"line_start":1156,"line_end":1156,"column_start":27,"column_end":30},"kind":{"Impl":{"id":2114}},"from":{"krate":0,"index":3286},"to":{"krate":0,"index":1950}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1056048,"byte_end":1056051,"line_start":1165,"line_end":1165,"column_start":21,"column_end":24},"kind":{"Impl":{"id":2115}},"from":{"krate":0,"index":3286},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1058798,"byte_end":1058801,"line_start":1244,"line_end":1244,"column_start":74,"column_end":77},"kind":{"Impl":{"id":2116}},"from":{"krate":0,"index":3286},"to":{"krate":0,"index":2274}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1058918,"byte_end":1058921,"line_start":1247,"line_end":1247,"column_start":49,"column_end":52},"kind":{"Impl":{"id":2117}},"from":{"krate":0,"index":3286},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1059049,"byte_end":1059055,"line_start":1253,"line_end":1253,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2118}},"from":{"krate":0,"index":3326},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1061685,"byte_end":1061697,"line_start":1332,"line_end":1332,"column_start":15,"column_end":27},"kind":{"Impl":{"id":2119}},"from":{"krate":0,"index":3314},"to":{"krate":0,"index":1984}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1061881,"byte_end":1061893,"line_start":1341,"line_end":1341,"column_start":10,"column_end":22},"kind":{"Impl":{"id":2120}},"from":{"krate":0,"index":3314},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1063432,"byte_end":1063438,"line_start":1383,"line_end":1383,"column_start":27,"column_end":33},"kind":{"Impl":{"id":2121}},"from":{"krate":0,"index":3326},"to":{"krate":0,"index":1950}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1063615,"byte_end":1063621,"line_start":1393,"line_end":1393,"column_start":30,"column_end":36},"kind":{"Impl":{"id":2122}},"from":{"krate":0,"index":3326},"to":{"krate":0,"index":1968}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1063846,"byte_end":1063852,"line_start":1401,"line_end":1401,"column_start":77,"column_end":83},"kind":{"Impl":{"id":2123}},"from":{"krate":0,"index":3326},"to":{"krate":0,"index":2274}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1063969,"byte_end":1063975,"line_start":1404,"line_end":1404,"column_start":49,"column_end":55},"kind":{"Impl":{"id":2124}},"from":{"krate":0,"index":3326},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1067330,"byte_end":1067340,"line_start":1475,"line_end":1475,"column_start":27,"column_end":37},"kind":{"Impl":{"id":2125}},"from":{"krate":0,"index":3344},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1067356,"byte_end":1067366,"line_start":1477,"line_end":1477,"column_start":9,"column_end":19},"kind":{"Impl":{"id":2126}},"from":{"krate":0,"index":3344},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1068184,"byte_end":1068194,"line_start":1514,"line_end":1514,"column_start":17,"column_end":27},"kind":{"Impl":{"id":2127}},"from":{"krate":0,"index":3344},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1069071,"byte_end":1069081,"line_start":1541,"line_end":1541,"column_start":30,"column_end":40},"kind":{"Impl":{"id":2128}},"from":{"krate":0,"index":3344},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1069312,"byte_end":1069322,"line_start":1549,"line_end":1549,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2129}},"from":{"krate":0,"index":3344},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/cell.rs","byte_start":1069520,"byte_end":1069530,"line_start":1556,"line_end":1556,"column_start":63,"column_end":73},"kind":{"Impl":{"id":2130}},"from":{"krate":0,"index":3344},"to":{"krate":0,"index":2274}},{"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091156,"byte_end":1091170,"line_start":173,"line_end":173,"column_start":6,"column_end":20},"kind":{"Impl":{"id":2133}},"from":{"krate":0,"index":41382},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1091798,"byte_end":1091812,"line_start":195,"line_end":195,"column_start":23,"column_end":37},"kind":{"Impl":{"id":2134}},"from":{"krate":0,"index":41382},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/char/convert.rs","byte_start":1093103,"byte_end":1093119,"line_start":242,"line_end":242,"column_start":23,"column_end":39},"kind":{"Impl":{"id":2137}},"from":{"krate":0,"index":41422},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1097070,"byte_end":1097081,"line_start":78,"line_end":78,"column_start":44,"column_end":55},"kind":{"Impl":{"id":2138}},"from":{"krate":0,"index":41444},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1098558,"byte_end":1098574,"line_start":121,"line_end":121,"column_start":6,"column_end":22},"kind":{"Impl":{"id":2139}},"from":{"krate":0,"index":41454},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/char/decode.rs","byte_start":1098846,"byte_end":1098862,"line_start":130,"line_end":130,"column_start":23,"column_end":39},"kind":{"Impl":{"id":2140}},"from":{"krate":0,"index":41454},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1075749,"byte_end":1075762,"line_start":143,"line_end":143,"column_start":19,"column_end":32},"kind":{"Impl":{"id":2142}},"from":{"krate":0,"index":41474},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1077545,"byte_end":1077558,"line_start":203,"line_end":203,"column_start":28,"column_end":41},"kind":{"Impl":{"id":2143}},"from":{"krate":0,"index":41474},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1078081,"byte_end":1078094,"line_start":219,"line_end":219,"column_start":24,"column_end":37},"kind":{"Impl":{"id":2144}},"from":{"krate":0,"index":41474},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1078182,"byte_end":1078195,"line_start":222,"line_end":222,"column_start":23,"column_end":36},"kind":{"Impl":{"id":2145}},"from":{"krate":0,"index":41474},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1078983,"byte_end":1078996,"line_start":253,"line_end":253,"column_start":19,"column_end":32},"kind":{"Impl":{"id":2146}},"from":{"krate":0,"index":41494},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1080964,"byte_end":1080977,"line_start":320,"line_end":320,"column_start":28,"column_end":41},"kind":{"Impl":{"id":2147}},"from":{"krate":0,"index":41494},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1081330,"byte_end":1081343,"line_start":332,"line_end":332,"column_start":24,"column_end":37},"kind":{"Impl":{"id":2148}},"from":{"krate":0,"index":41494},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1081431,"byte_end":1081444,"line_start":335,"line_end":335,"column_start":23,"column_end":36},"kind":{"Impl":{"id":2149}},"from":{"krate":0,"index":41494},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082104,"byte_end":1082115,"line_start":356,"line_end":356,"column_start":19,"column_end":30},"kind":{"Impl":{"id":2150}},"from":{"krate":0,"index":41514},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082359,"byte_end":1082370,"line_start":363,"line_end":363,"column_start":28,"column_end":39},"kind":{"Impl":{"id":2151}},"from":{"krate":0,"index":41514},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082446,"byte_end":1082457,"line_start":366,"line_end":366,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2152}},"from":{"krate":0,"index":41514},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1082543,"byte_end":1082554,"line_start":369,"line_end":369,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2153}},"from":{"krate":0,"index":41514},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083150,"byte_end":1083161,"line_start":387,"line_end":387,"column_start":19,"column_end":30},"kind":{"Impl":{"id":2154}},"from":{"krate":0,"index":41524},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083413,"byte_end":1083424,"line_start":398,"line_end":398,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2155}},"from":{"krate":0,"index":41524},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1083526,"byte_end":1083537,"line_start":401,"line_end":401,"column_start":28,"column_end":39},"kind":{"Impl":{"id":2156}},"from":{"krate":0,"index":41524},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084025,"byte_end":1084036,"line_start":415,"line_end":415,"column_start":19,"column_end":30},"kind":{"Impl":{"id":2157}},"from":{"krate":0,"index":41534},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084288,"byte_end":1084299,"line_start":426,"line_end":426,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2158}},"from":{"krate":0,"index":41534},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084401,"byte_end":1084412,"line_start":429,"line_end":429,"column_start":28,"column_end":39},"kind":{"Impl":{"id":2159}},"from":{"krate":0,"index":41534},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084547,"byte_end":1084562,"line_start":439,"line_end":439,"column_start":6,"column_end":21},"kind":{"Impl":{"id":2160}},"from":{"krate":0,"index":41544},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1084971,"byte_end":1084986,"line_start":453,"line_end":453,"column_start":19,"column_end":34},"kind":{"Impl":{"id":2161}},"from":{"krate":0,"index":41544},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1085853,"byte_end":1085868,"line_start":484,"line_end":484,"column_start":23,"column_end":38},"kind":{"Impl":{"id":2162}},"from":{"krate":0,"index":41544},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1086477,"byte_end":1086488,"line_start":505,"line_end":505,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2163}},"from":{"krate":0,"index":41524},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/char/mod.rs","byte_start":1086684,"byte_end":1086695,"line_start":512,"line_end":512,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2164}},"from":{"krate":0,"index":41534},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/panic.rs","byte_start":1143357,"byte_end":1143366,"line_start":41,"line_end":41,"column_start":10,"column_end":19},"kind":{"Impl":{"id":2165}},"from":{"krate":0,"index":41554},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/panic.rs","byte_start":1146264,"byte_end":1146273,"line_start":126,"line_end":126,"column_start":23,"column_end":32},"kind":{"Impl":{"id":2166}},"from":{"krate":0,"index":41554},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/panic.rs","byte_start":1147800,"byte_end":1147808,"line_start":173,"line_end":173,"column_start":10,"column_end":18},"kind":{"Impl":{"id":2167}},"from":{"krate":0,"index":41560},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/panic.rs","byte_start":1150154,"byte_end":1150162,"line_start":251,"line_end":251,"column_start":23,"column_end":31},"kind":{"Impl":{"id":2168}},"from":{"krate":0,"index":41560},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1170023,"byte_end":1170026,"line_start":295,"line_end":295,"column_start":34,"column_end":37},"kind":{"Impl":{"id":2169}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":2416}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1170356,"byte_end":1170359,"line_start":309,"line_end":309,"column_start":35,"column_end":38},"kind":{"Impl":{"id":2170}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":2472}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1170885,"byte_end":1170888,"line_start":334,"line_end":334,"column_start":16,"column_end":19},"kind":{"Impl":{"id":2171}},"from":{"krate":0,"index":41566},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1171548,"byte_end":1171551,"line_start":354,"line_end":354,"column_start":16,"column_end":19},"kind":{"Impl":{"id":2172}},"from":{"krate":0,"index":41566},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1175518,"byte_end":1175521,"line_start":439,"line_end":439,"column_start":19,"column_end":22},"kind":{"Impl":{"id":2173}},"from":{"krate":0,"index":41566},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1176617,"byte_end":1176620,"line_start":467,"line_end":467,"column_start":21,"column_end":24},"kind":{"Impl":{"id":2174}},"from":{"krate":0,"index":41566},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1178948,"byte_end":1178951,"line_start":516,"line_end":516,"column_start":21,"column_end":24},"kind":{"Impl":{"id":2175}},"from":{"krate":0,"index":41566},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1181729,"byte_end":1181732,"line_start":583,"line_end":583,"column_start":26,"column_end":29},"kind":{"Impl":{"id":2176}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":1950}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1181928,"byte_end":1181931,"line_start":591,"line_end":591,"column_start":32,"column_end":35},"kind":{"Impl":{"id":2177}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":1968}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1182145,"byte_end":1182148,"line_start":601,"line_end":601,"column_start":32,"column_end":35},"kind":{"Impl":{"id":2178}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":1976}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1182236,"byte_end":1182239,"line_start":604,"line_end":604,"column_start":36,"column_end":39},"kind":{"Impl":{"id":2179}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1182443,"byte_end":1182446,"line_start":611,"line_end":611,"column_start":40,"column_end":43},"kind":{"Impl":{"id":2180}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1182652,"byte_end":1182655,"line_start":618,"line_end":618,"column_start":40,"column_end":43},"kind":{"Impl":{"id":2181}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":8496}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1183187,"byte_end":1183190,"line_start":630,"line_end":630,"column_start":38,"column_end":41},"kind":{"Impl":{"id":2182}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":2274}},{"span":{"file_name":"src/libcore/pin.rs","byte_start":1183317,"byte_end":1183320,"line_start":636,"line_end":636,"column_start":44,"column_end":47},"kind":{"Impl":{"id":2183}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":2294}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197229,"byte_end":1197234,"line_start":15,"line_end":15,"column_start":17,"column_end":22},"kind":"SuperTrait","from":{"krate":0,"index":2606},"to":{"krate":0,"index":4020}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197237,"byte_end":1197247,"line_start":15,"line_end":15,"column_start":25,"column_end":35},"kind":"SuperTrait","from":{"krate":0,"index":2472},"to":{"krate":0,"index":4020}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1197250,"byte_end":1197255,"line_start":15,"line_end":15,"column_start":38,"column_end":43},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":4020}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1202049,"byte_end":1202054,"line_start":166,"line_end":166,"column_start":33,"column_end":38},"kind":{"Impl":{"id":2196}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1204297,"byte_end":1204302,"line_start":239,"line_end":239,"column_start":44,"column_end":49},"kind":{"Impl":{"id":2197}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1204615,"byte_end":1204620,"line_start":252,"line_end":252,"column_start":38,"column_end":43},"kind":{"Impl":{"id":2198}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1204706,"byte_end":1204715,"line_start":255,"line_end":255,"column_start":33,"column_end":42},"kind":{"Impl":{"id":2199}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1205299,"byte_end":1205308,"line_start":279,"line_end":279,"column_start":38,"column_end":47},"kind":{"Impl":{"id":2200}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1205411,"byte_end":1205420,"line_start":282,"line_end":282,"column_start":42,"column_end":51},"kind":{"Impl":{"id":2201}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1205517,"byte_end":1205531,"line_start":285,"line_end":285,"column_start":33,"column_end":47},"kind":{"Impl":{"id":2202}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1208084,"byte_end":1208098,"line_start":389,"line_end":389,"column_start":44,"column_end":58},"kind":{"Impl":{"id":2203}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/range.rs","byte_start":1209275,"byte_end":1209289,"line_start":435,"line_end":435,"column_start":38,"column_end":52},"kind":{"Impl":{"id":2204}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1209756,"byte_end":1209762,"line_start":19,"line_end":19,"column_start":29,"column_end":35},"kind":{"Impl":{"id":2205}},"from":{"krate":0,"index":41826},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1210044,"byte_end":1210050,"line_start":29,"line_end":29,"column_start":40,"column_end":46},"kind":{"Impl":{"id":2206}},"from":{"krate":0,"index":41826},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1210225,"byte_end":1210231,"line_start":35,"line_end":35,"column_start":34,"column_end":40},"kind":{"Impl":{"id":2207}},"from":{"krate":0,"index":41826},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1210330,"byte_end":1210336,"line_start":38,"line_end":38,"column_start":38,"column_end":44},"kind":{"Impl":{"id":2208}},"from":{"krate":0,"index":41826},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212409,"byte_end":1212419,"line_start":111,"line_end":111,"column_start":39,"column_end":49},"kind":{"Impl":{"id":2209}},"from":{"krate":0,"index":41836},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212719,"byte_end":1212729,"line_start":122,"line_end":122,"column_start":44,"column_end":54},"kind":{"Impl":{"id":2210}},"from":{"krate":0,"index":41836},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1212838,"byte_end":1212848,"line_start":125,"line_end":125,"column_start":48,"column_end":58},"kind":{"Impl":{"id":2211}},"from":{"krate":0,"index":41836},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215299,"byte_end":1215304,"line_start":202,"line_end":202,"column_start":24,"column_end":29},"kind":{"Impl":{"id":2212}},"from":{"krate":0,"index":4158},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215477,"byte_end":1215482,"line_start":209,"line_end":209,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2213}},"from":{"krate":0,"index":4158},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215730,"byte_end":1215735,"line_start":222,"line_end":222,"column_start":33,"column_end":38},"kind":{"Impl":{"id":2214}},"from":{"krate":0,"index":4158},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1215887,"byte_end":1215892,"line_start":229,"line_end":229,"column_start":31,"column_end":36},"kind":{"Impl":{"id":2215}},"from":{"krate":0,"index":4158},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216030,"byte_end":1216035,"line_start":236,"line_end":236,"column_start":31,"column_end":36},"kind":{"Impl":{"id":2216}},"from":{"krate":0,"index":4158},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216116,"byte_end":1216121,"line_start":239,"line_end":239,"column_start":27,"column_end":32},"kind":{"Impl":{"id":2217}},"from":{"krate":0,"index":4158},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216279,"byte_end":1216284,"line_start":244,"line_end":244,"column_start":19,"column_end":24},"kind":{"Impl":{"id":2218}},"from":{"krate":0,"index":4158},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1216522,"byte_end":1216527,"line_start":253,"line_end":253,"column_start":21,"column_end":26},"kind":{"Impl":{"id":2219}},"from":{"krate":0,"index":4158},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1217396,"byte_end":1217400,"line_start":290,"line_end":290,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2220}},"from":{"krate":0,"index":41848},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1217671,"byte_end":1217675,"line_start":303,"line_end":303,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2221}},"from":{"krate":0,"index":41848},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1217844,"byte_end":1217848,"line_start":310,"line_end":310,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2222}},"from":{"krate":0,"index":41848},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1218001,"byte_end":1218005,"line_start":317,"line_end":317,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2223}},"from":{"krate":0,"index":41848},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1218086,"byte_end":1218090,"line_start":320,"line_end":320,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2224}},"from":{"krate":0,"index":41848},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220209,"byte_end":1220217,"line_start":392,"line_end":392,"column_start":40,"column_end":48},"kind":{"Impl":{"id":2225}},"from":{"krate":0,"index":41858},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220557,"byte_end":1220565,"line_start":407,"line_end":407,"column_start":51,"column_end":59},"kind":{"Impl":{"id":2226}},"from":{"krate":0,"index":41858},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220748,"byte_end":1220756,"line_start":414,"line_end":414,"column_start":49,"column_end":57},"kind":{"Impl":{"id":2227}},"from":{"krate":0,"index":41858},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1220931,"byte_end":1220939,"line_start":421,"line_end":421,"column_start":45,"column_end":53},"kind":{"Impl":{"id":2228}},"from":{"krate":0,"index":41858},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1221052,"byte_end":1221060,"line_start":424,"line_end":424,"column_start":49,"column_end":57},"kind":{"Impl":{"id":2229}},"from":{"krate":0,"index":41858},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1224946,"byte_end":1224952,"line_start":548,"line_end":548,"column_start":25,"column_end":31},"kind":{"Impl":{"id":2230}},"from":{"krate":0,"index":41870},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1225178,"byte_end":1225184,"line_start":560,"line_end":560,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2231}},"from":{"krate":0,"index":41870},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1226665,"byte_end":1226675,"line_start":604,"line_end":604,"column_start":25,"column_end":35},"kind":{"Impl":{"id":2232}},"from":{"krate":0,"index":41876},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1227186,"byte_end":1227196,"line_start":628,"line_end":628,"column_start":30,"column_end":40},"kind":{"Impl":{"id":2233}},"from":{"krate":0,"index":41876},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/sources.rs","byte_start":1227338,"byte_end":1227348,"line_start":633,"line_end":633,"column_start":39,"column_end":49},"kind":{"Impl":{"id":2234}},"from":{"krate":0,"index":41876},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/traits/double_ended.rs","byte_start":1316357,"byte_end":1316365,"line_start":39,"line_end":39,"column_start":32,"column_end":40},"kind":"SuperTrait","from":{"krate":0,"index":4334},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/traits/exact_size.rs","byte_start":1326731,"byte_end":1326739,"line_start":71,"line_end":71,"column_start":30,"column_end":38},"kind":"SuperTrait","from":{"krate":0,"index":4334},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1331507,"byte_end":1331512,"line_start":98,"line_end":98,"column_start":28,"column_end":33},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":4508}},{"span":{"file_name":"src/libcore/iter/traits/collect.rs","byte_start":1335359,"byte_end":1335360,"line_start":241,"line_end":241,"column_start":36,"column_end":37},"kind":{"Impl":{"id":2235}},"from":{"krate":0,"index":2131},"to":{"krate":0,"index":4512}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1339190,"byte_end":1339195,"line_start":15,"line_end":15,"column_start":26,"column_end":31},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":4546}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1340108,"byte_end":1340113,"line_start":34,"line_end":34,"column_start":30,"column_end":35},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":4550}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1343039,"byte_end":1343050,"line_start":127,"line_end":127,"column_start":15,"column_end":26},"kind":{"Impl":{"id":2284}},"from":{"krate":0,"index":4558},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1343968,"byte_end":1343979,"line_start":159,"line_end":159,"column_start":28,"column_end":39},"kind":{"Impl":{"id":2285}},"from":{"krate":0,"index":4558},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1344635,"byte_end":1344641,"line_start":186,"line_end":186,"column_start":37,"column_end":43},"kind":{"Impl":{"id":2286}},"from":{"krate":0,"index":42602},"to":{"krate":0,"index":4546}},{"span":{"file_name":"src/libcore/iter/traits/accum.rs","byte_start":1345531,"byte_end":1345537,"line_start":214,"line_end":214,"column_start":41,"column_end":47},"kind":{"Impl":{"id":2287}},"from":{"krate":0,"index":42602},"to":{"krate":0,"index":4550}},{"span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1346793,"byte_end":1346801,"line_start":16,"line_end":16,"column_start":26,"column_end":34},"kind":"SuperTrait","from":{"krate":0,"index":4334},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/traits/marker.rs","byte_start":1347895,"byte_end":1347903,"line_start":41,"line_end":41,"column_start":31,"column_end":39},"kind":"SuperTrait","from":{"krate":0,"index":4334},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1406779,"byte_end":1406784,"line_start":21,"line_end":21,"column_start":12,"column_end":17},"kind":{"Impl":{"id":2288}},"from":{"krate":0,"index":42298},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1407686,"byte_end":1407691,"line_start":51,"line_end":51,"column_start":25,"column_end":30},"kind":{"Impl":{"id":2289}},"from":{"krate":0,"index":42298},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1411694,"byte_end":1411699,"line_start":191,"line_end":191,"column_start":36,"column_end":41},"kind":{"Impl":{"id":2290}},"from":{"krate":0,"index":42298},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1413534,"byte_end":1413539,"line_start":252,"line_end":252,"column_start":30,"column_end":35},"kind":{"Impl":{"id":2291}},"from":{"krate":0,"index":42298},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/chain.rs","byte_start":1413707,"byte_end":1413712,"line_start":258,"line_end":258,"column_start":34,"column_end":39},"kind":{"Impl":{"id":2292}},"from":{"krate":0,"index":42298},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1414502,"byte_end":1414509,"line_start":20,"line_end":20,"column_start":60,"column_end":67},"kind":{"Impl":{"id":2293}},"from":{"krate":0,"index":4714},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1414764,"byte_end":1414771,"line_start":27,"line_end":27,"column_start":61,"column_end":68},"kind":{"Impl":{"id":2294}},"from":{"krate":0,"index":4714},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1415014,"byte_end":1415021,"line_start":34,"line_end":34,"column_start":56,"column_end":63},"kind":{"Impl":{"id":2295}},"from":{"krate":0,"index":4714},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1415307,"byte_end":1415314,"line_start":43,"line_end":43,"column_start":52,"column_end":59},"kind":{"Impl":{"id":2296}},"from":{"krate":0,"index":4714},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1416050,"byte_end":1416057,"line_start":70,"line_end":70,"column_start":60,"column_end":67},"kind":{"Impl":{"id":2297}},"from":{"krate":0,"index":4714},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1416733,"byte_end":1416740,"line_start":94,"line_end":94,"column_start":33,"column_end":40},"kind":{"Impl":{"id":2298}},"from":{"krate":0,"index":4714},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1417415,"byte_end":1417422,"line_start":111,"line_end":111,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2299}},"from":{"krate":0,"index":4750},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1417658,"byte_end":1417665,"line_start":119,"line_end":119,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2300}},"from":{"krate":0,"index":4750},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1418018,"byte_end":1418025,"line_start":129,"line_end":129,"column_start":22,"column_end":29},"kind":{"Impl":{"id":2301}},"from":{"krate":0,"index":4750},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1418301,"byte_end":1418308,"line_start":137,"line_end":137,"column_start":25,"column_end":32},"kind":{"Impl":{"id":2302}},"from":{"krate":0,"index":4750},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1419090,"byte_end":1419097,"line_start":165,"line_end":165,"column_start":36,"column_end":43},"kind":{"Impl":{"id":2303}},"from":{"krate":0,"index":4750},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1419791,"byte_end":1419798,"line_start":188,"line_end":188,"column_start":30,"column_end":37},"kind":{"Impl":{"id":2304}},"from":{"krate":0,"index":4750},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1420126,"byte_end":1420139,"line_start":200,"line_end":200,"column_start":12,"column_end":25},"kind":{"Impl":{"id":2305}},"from":{"krate":0,"index":42318},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1420376,"byte_end":1420389,"line_start":207,"line_end":207,"column_start":25,"column_end":38},"kind":{"Impl":{"id":2306}},"from":{"krate":0,"index":42318},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/flatten.rs","byte_start":1422612,"byte_end":1422625,"line_start":276,"line_end":276,"column_start":36,"column_end":49},"kind":{"Impl":{"id":2307}},"from":{"krate":0,"index":42318},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1425067,"byte_end":1425070,"line_start":22,"line_end":22,"column_start":32,"column_end":35},"kind":{"Impl":{"id":2308}},"from":{"krate":0,"index":42328},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1425459,"byte_end":1425462,"line_start":36,"line_end":36,"column_start":25,"column_end":28},"kind":{"Impl":{"id":2309}},"from":{"krate":0,"index":42328},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1425931,"byte_end":1425934,"line_start":57,"line_end":57,"column_start":36,"column_end":39},"kind":{"Impl":{"id":2310}},"from":{"krate":0,"index":42328},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1426658,"byte_end":1426661,"line_start":82,"line_end":82,"column_start":30,"column_end":33},"kind":{"Impl":{"id":2311}},"from":{"krate":0,"index":42328},"to":{"krate":0,"index":4846}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1428493,"byte_end":1428496,"line_start":150,"line_end":150,"column_start":30,"column_end":33},"kind":{"Impl":{"id":2312}},"from":{"krate":0,"index":42328},"to":{"krate":0,"index":4846}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1431056,"byte_end":1431059,"line_start":242,"line_end":242,"column_start":34,"column_end":37},"kind":{"Impl":{"id":2313}},"from":{"krate":0,"index":42328},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1431180,"byte_end":1431183,"line_start":246,"line_end":246,"column_start":43,"column_end":46},"kind":{"Impl":{"id":2314}},"from":{"krate":0,"index":42328},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1431587,"byte_end":1431590,"line_start":260,"line_end":260,"column_start":30,"column_end":33},"kind":{"Impl":{"id":2315}},"from":{"krate":0,"index":42328},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1431734,"byte_end":1431737,"line_start":264,"line_end":264,"column_start":34,"column_end":37},"kind":{"Impl":{"id":2316}},"from":{"krate":0,"index":42328},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/zip.rs","byte_start":1432185,"byte_end":1432202,"line_start":278,"line_end":278,"column_start":47,"column_end":64},"kind":"SuperTrait","from":{"krate":0,"index":4494},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1348884,"byte_end":1348887,"line_start":33,"line_end":33,"column_start":9,"column_end":12},"kind":{"Impl":{"id":2317}},"from":{"krate":0,"index":42338},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1349033,"byte_end":1349036,"line_start":40,"line_end":40,"column_start":22,"column_end":25},"kind":{"Impl":{"id":2318}},"from":{"krate":0,"index":42338},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1350142,"byte_end":1350145,"line_start":79,"line_end":79,"column_start":33,"column_end":36},"kind":{"Impl":{"id":2319}},"from":{"krate":0,"index":42338},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1350935,"byte_end":1350938,"line_start":106,"line_end":106,"column_start":31,"column_end":34},"kind":{"Impl":{"id":2320}},"from":{"krate":0,"index":42338},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351201,"byte_end":1351204,"line_start":119,"line_end":119,"column_start":27,"column_end":30},"kind":{"Impl":{"id":2321}},"from":{"krate":0,"index":42338},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351345,"byte_end":1351348,"line_start":123,"line_end":123,"column_start":31,"column_end":34},"kind":{"Impl":{"id":2322}},"from":{"krate":0,"index":42338},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1351861,"byte_end":1351867,"line_start":139,"line_end":139,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2323}},"from":{"krate":0,"index":42348},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1352034,"byte_end":1352040,"line_start":146,"line_end":146,"column_start":33,"column_end":39},"kind":{"Impl":{"id":2324}},"from":{"krate":0,"index":42348},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1352748,"byte_end":1352754,"line_start":173,"line_end":173,"column_start":44,"column_end":50},"kind":{"Impl":{"id":2325}},"from":{"krate":0,"index":42348},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1353378,"byte_end":1353384,"line_start":194,"line_end":194,"column_start":42,"column_end":48},"kind":{"Impl":{"id":2326}},"from":{"krate":0,"index":42348},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1353660,"byte_end":1353666,"line_start":207,"line_end":207,"column_start":38,"column_end":44},"kind":{"Impl":{"id":2327}},"from":{"krate":0,"index":42348},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1353787,"byte_end":1353793,"line_start":212,"line_end":212,"column_start":51,"column_end":57},"kind":{"Impl":{"id":2328}},"from":{"krate":0,"index":42348},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354151,"byte_end":1354157,"line_start":226,"line_end":226,"column_start":42,"column_end":48},"kind":{"Impl":{"id":2329}},"from":{"krate":0,"index":42348},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354677,"byte_end":1354683,"line_start":244,"line_end":244,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2330}},"from":{"krate":0,"index":42358},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1354848,"byte_end":1354854,"line_start":251,"line_end":251,"column_start":33,"column_end":39},"kind":{"Impl":{"id":2331}},"from":{"krate":0,"index":42358},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1355575,"byte_end":1355581,"line_start":278,"line_end":278,"column_start":44,"column_end":50},"kind":{"Impl":{"id":2332}},"from":{"krate":0,"index":42358},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1356218,"byte_end":1356224,"line_start":299,"line_end":299,"column_start":42,"column_end":48},"kind":{"Impl":{"id":2333}},"from":{"krate":0,"index":42358},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1356494,"byte_end":1356500,"line_start":312,"line_end":312,"column_start":38,"column_end":44},"kind":{"Impl":{"id":2334}},"from":{"krate":0,"index":42358},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1356622,"byte_end":1356628,"line_start":317,"line_end":317,"column_start":51,"column_end":57},"kind":{"Impl":{"id":2335}},"from":{"krate":0,"index":42358},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1356947,"byte_end":1356953,"line_start":329,"line_end":329,"column_start":51,"column_end":57},"kind":{"Impl":{"id":2336}},"from":{"krate":0,"index":42358},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357311,"byte_end":1357317,"line_start":343,"line_end":343,"column_start":42,"column_end":48},"kind":{"Impl":{"id":2337}},"from":{"krate":0,"index":42358},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357822,"byte_end":1357827,"line_start":362,"line_end":362,"column_start":16,"column_end":21},"kind":{"Impl":{"id":2338}},"from":{"krate":0,"index":42368},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1357997,"byte_end":1358002,"line_start":369,"line_end":369,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2339}},"from":{"krate":0,"index":42368},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1358647,"byte_end":1358652,"line_start":392,"line_end":392,"column_start":27,"column_end":32},"kind":{"Impl":{"id":2340}},"from":{"krate":0,"index":42368},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1359184,"byte_end":1359190,"line_start":409,"line_end":409,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2341}},"from":{"krate":0,"index":42378},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1359429,"byte_end":1359435,"line_start":417,"line_end":417,"column_start":22,"column_end":28},"kind":{"Impl":{"id":2342}},"from":{"krate":0,"index":42378},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1361701,"byte_end":1361707,"line_start":489,"line_end":489,"column_start":31,"column_end":37},"kind":{"Impl":{"id":2343}},"from":{"krate":0,"index":42378},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1363593,"byte_end":1363596,"line_start":548,"line_end":548,"column_start":12,"column_end":15},"kind":{"Impl":{"id":2344}},"from":{"krate":0,"index":42388},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1363784,"byte_end":1363787,"line_start":555,"line_end":555,"column_start":39,"column_end":42},"kind":{"Impl":{"id":2345}},"from":{"krate":0,"index":42388},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1364042,"byte_end":1364045,"line_start":564,"line_end":564,"column_start":38,"column_end":41},"kind":{"Impl":{"id":2346}},"from":{"krate":0,"index":42388},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1364863,"byte_end":1364866,"line_start":593,"line_end":593,"column_start":60,"column_end":63},"kind":{"Impl":{"id":2347}},"from":{"krate":0,"index":42388},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1365576,"byte_end":1365579,"line_start":617,"line_end":617,"column_start":56,"column_end":59},"kind":{"Impl":{"id":2348}},"from":{"krate":0,"index":42388},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1365846,"byte_end":1365849,"line_start":630,"line_end":630,"column_start":48,"column_end":51},"kind":{"Impl":{"id":2349}},"from":{"krate":0,"index":42388},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1365983,"byte_end":1365986,"line_start":634,"line_end":634,"column_start":37,"column_end":40},"kind":{"Impl":{"id":2350}},"from":{"krate":0,"index":42388},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1366115,"byte_end":1366118,"line_start":639,"line_end":639,"column_start":46,"column_end":49},"kind":{"Impl":{"id":2351}},"from":{"krate":0,"index":42388},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1366847,"byte_end":1366853,"line_start":664,"line_end":664,"column_start":12,"column_end":18},"kind":{"Impl":{"id":2352}},"from":{"krate":0,"index":42394},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1367063,"byte_end":1367069,"line_start":671,"line_end":671,"column_start":39,"column_end":45},"kind":{"Impl":{"id":2353}},"from":{"krate":0,"index":42394},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1367324,"byte_end":1367330,"line_start":680,"line_end":680,"column_start":35,"column_end":41},"kind":{"Impl":{"id":2354}},"from":{"krate":0,"index":42394},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1369341,"byte_end":1369347,"line_start":737,"line_end":737,"column_start":57,"column_end":63},"kind":{"Impl":{"id":2355}},"from":{"krate":0,"index":42394},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1370314,"byte_end":1370320,"line_start":771,"line_end":771,"column_start":45,"column_end":51},"kind":{"Impl":{"id":2356}},"from":{"krate":0,"index":42394},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1370852,"byte_end":1370861,"line_start":788,"line_end":788,"column_start":12,"column_end":21},"kind":{"Impl":{"id":2357}},"from":{"krate":0,"index":42400},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1371061,"byte_end":1371070,"line_start":795,"line_end":795,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2358}},"from":{"krate":0,"index":42400},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1371331,"byte_end":1371340,"line_start":804,"line_end":804,"column_start":38,"column_end":47},"kind":{"Impl":{"id":2359}},"from":{"krate":0,"index":42400},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1372467,"byte_end":1372476,"line_start":844,"line_end":844,"column_start":60,"column_end":69},"kind":{"Impl":{"id":2360}},"from":{"krate":0,"index":42400},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1373402,"byte_end":1373411,"line_start":876,"line_end":876,"column_start":48,"column_end":57},"kind":{"Impl":{"id":2361}},"from":{"krate":0,"index":42400},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1373958,"byte_end":1373967,"line_start":893,"line_end":893,"column_start":9,"column_end":18},"kind":{"Impl":{"id":2362}},"from":{"krate":0,"index":42406},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1374135,"byte_end":1374144,"line_start":900,"line_end":900,"column_start":22,"column_end":31},"kind":{"Impl":{"id":2363}},"from":{"krate":0,"index":42406},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1376150,"byte_end":1376159,"line_start":971,"line_end":971,"column_start":33,"column_end":42},"kind":{"Impl":{"id":2364}},"from":{"krate":0,"index":42406},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1377945,"byte_end":1377954,"line_start":1022,"line_end":1022,"column_start":31,"column_end":40},"kind":{"Impl":{"id":2365}},"from":{"krate":0,"index":42406},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378172,"byte_end":1378181,"line_start":1033,"line_end":1033,"column_start":40,"column_end":49},"kind":{"Impl":{"id":2366}},"from":{"krate":0,"index":42406},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378507,"byte_end":1378516,"line_start":1046,"line_end":1046,"column_start":27,"column_end":36},"kind":{"Impl":{"id":2367}},"from":{"krate":0,"index":42406},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1378631,"byte_end":1378640,"line_start":1049,"line_end":1049,"column_start":31,"column_end":40},"kind":{"Impl":{"id":2368}},"from":{"krate":0,"index":42406},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1379270,"byte_end":1379278,"line_start":1070,"line_end":1070,"column_start":19,"column_end":27},"kind":{"Impl":{"id":2369}},"from":{"krate":0,"index":42416},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1379702,"byte_end":1379710,"line_start":1081,"line_end":1081,"column_start":32,"column_end":40},"kind":{"Impl":{"id":2370}},"from":{"krate":0,"index":42416},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1381909,"byte_end":1381917,"line_start":1161,"line_end":1161,"column_start":50,"column_end":58},"kind":{"Impl":{"id":2371}},"from":{"krate":0,"index":42416},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382013,"byte_end":1382021,"line_start":1164,"line_end":1164,"column_start":42,"column_end":50},"kind":{"Impl":{"id":2372}},"from":{"krate":0,"index":42416},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1382047,"byte_end":1382055,"line_start":1166,"line_end":1166,"column_start":19,"column_end":27},"kind":{"Impl":{"id":2373}},"from":{"krate":0,"index":42416},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1384052,"byte_end":1384061,"line_start":1227,"line_end":1227,"column_start":12,"column_end":21},"kind":{"Impl":{"id":2374}},"from":{"krate":0,"index":42426},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1384290,"byte_end":1384299,"line_start":1234,"line_end":1234,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2375}},"from":{"krate":0,"index":42426},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1384596,"byte_end":1384605,"line_start":1244,"line_end":1244,"column_start":35,"column_end":44},"kind":{"Impl":{"id":2376}},"from":{"krate":0,"index":42426},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386024,"byte_end":1386033,"line_start":1297,"line_end":1297,"column_start":30,"column_end":39},"kind":{"Impl":{"id":2377}},"from":{"krate":0,"index":42426},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386609,"byte_end":1386618,"line_start":1315,"line_end":1315,"column_start":12,"column_end":21},"kind":{"Impl":{"id":2378}},"from":{"krate":0,"index":42432},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1386847,"byte_end":1386856,"line_start":1322,"line_end":1322,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2379}},"from":{"krate":0,"index":42432},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1387153,"byte_end":1387162,"line_start":1332,"line_end":1332,"column_start":35,"column_end":44},"kind":{"Impl":{"id":2380}},"from":{"krate":0,"index":42432},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1388582,"byte_end":1388591,"line_start":1385,"line_end":1385,"column_start":30,"column_end":39},"kind":{"Impl":{"id":2381}},"from":{"krate":0,"index":42432},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1389103,"byte_end":1389107,"line_start":1402,"line_end":1402,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2382}},"from":{"krate":0,"index":42438},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1389268,"byte_end":1389272,"line_start":1409,"line_end":1409,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2383}},"from":{"krate":0,"index":42438},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1391542,"byte_end":1391546,"line_start":1499,"line_end":1499,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2384}},"from":{"krate":0,"index":42438},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1391680,"byte_end":1391684,"line_start":1502,"line_end":1502,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2385}},"from":{"krate":0,"index":42438},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1392493,"byte_end":1392497,"line_start":1529,"line_end":1529,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2386}},"from":{"krate":0,"index":42438},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1393016,"byte_end":1393020,"line_start":1545,"line_end":1545,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2387}},"from":{"krate":0,"index":42448},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1393181,"byte_end":1393185,"line_start":1552,"line_end":1552,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2388}},"from":{"krate":0,"index":42448},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1394761,"byte_end":1394765,"line_start":1616,"line_end":1616,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2389}},"from":{"krate":0,"index":42448},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1394873,"byte_end":1394877,"line_start":1619,"line_end":1619,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2390}},"from":{"krate":0,"index":42448},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395004,"byte_end":1395008,"line_start":1622,"line_end":1622,"column_start":43,"column_end":47},"kind":{"Impl":{"id":2391}},"from":{"krate":0,"index":42448},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395493,"byte_end":1395497,"line_start":1639,"line_end":1639,"column_start":16,"column_end":20},"kind":{"Impl":{"id":2392}},"from":{"krate":0,"index":42458},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1395729,"byte_end":1395733,"line_start":1646,"line_end":1646,"column_start":55,"column_end":59},"kind":{"Impl":{"id":2393}},"from":{"krate":0,"index":42458},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1396028,"byte_end":1396032,"line_start":1656,"line_end":1656,"column_start":32,"column_end":36},"kind":{"Impl":{"id":2394}},"from":{"krate":0,"index":42458},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397428,"byte_end":1397432,"line_start":1703,"line_end":1703,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2395}},"from":{"krate":0,"index":42464},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397599,"byte_end":1397603,"line_start":1710,"line_end":1710,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2396}},"from":{"krate":0,"index":42464},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1397696,"byte_end":1397700,"line_start":1713,"line_end":1713,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2397}},"from":{"krate":0,"index":42464},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1399475,"byte_end":1399479,"line_start":1791,"line_end":1791,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2398}},"from":{"krate":0,"index":42464},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1400717,"byte_end":1400721,"line_start":1839,"line_end":1839,"column_start":40,"column_end":44},"kind":{"Impl":{"id":2399}},"from":{"krate":0,"index":42464},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1401016,"byte_end":1401020,"line_start":1852,"line_end":1852,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2400}},"from":{"krate":0,"index":42464},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1401982,"byte_end":1401986,"line_start":1894,"line_end":1894,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2401}},"from":{"krate":0,"index":42464},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1402745,"byte_end":1402749,"line_start":1924,"line_end":1924,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2402}},"from":{"krate":0,"index":42464},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403406,"byte_end":1403413,"line_start":1949,"line_end":1949,"column_start":12,"column_end":19},"kind":{"Impl":{"id":2403}},"from":{"krate":0,"index":42474},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403609,"byte_end":1403616,"line_start":1956,"line_end":1956,"column_start":39,"column_end":46},"kind":{"Impl":{"id":2404}},"from":{"krate":0,"index":42474},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1403813,"byte_end":1403820,"line_start":1964,"line_end":1964,"column_start":22,"column_end":29},"kind":{"Impl":{"id":2405}},"from":{"krate":0,"index":42474},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1404112,"byte_end":1404119,"line_start":1976,"line_end":1976,"column_start":35,"column_end":42},"kind":{"Impl":{"id":2406}},"from":{"krate":0,"index":42474},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1405051,"byte_end":1405058,"line_start":2008,"line_end":2008,"column_start":57,"column_end":64},"kind":{"Impl":{"id":2407}},"from":{"krate":0,"index":42474},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1405876,"byte_end":1405883,"line_start":2035,"line_end":2035,"column_start":53,"column_end":60},"kind":{"Impl":{"id":2408}},"from":{"krate":0,"index":42474},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/iter/adapters/mod.rs","byte_start":1406143,"byte_end":1406150,"line_start":2048,"line_end":2048,"column_start":45,"column_end":52},"kind":{"Impl":{"id":2409}},"from":{"krate":0,"index":42474},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1195740,"byte_end":1195749,"line_start":372,"line_end":372,"column_start":20,"column_end":29},"kind":{"Impl":{"id":2410}},"from":{"krate":0,"index":42480},"to":{"krate":0,"index":2258}},{"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1196165,"byte_end":1196174,"line_start":388,"line_end":388,"column_start":12,"column_end":21},"kind":{"Impl":{"id":2411}},"from":{"krate":0,"index":42480},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/iter/mod.rs","byte_start":1196379,"byte_end":1196388,"line_start":398,"line_end":398,"column_start":14,"column_end":23},"kind":{"Impl":{"id":2412}},"from":{"krate":0,"index":42480},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1437985,"byte_end":1437991,"line_start":163,"line_end":163,"column_start":9,"column_end":15},"kind":{"Impl":{"id":2413}},"from":{"krate":0,"index":42488},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1459008,"byte_end":1459014,"line_start":879,"line_end":879,"column_start":15,"column_end":21},"kind":{"Impl":{"id":2414}},"from":{"krate":0,"index":42488},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1459476,"byte_end":1459482,"line_start":898,"line_end":898,"column_start":15,"column_end":21},"kind":{"Impl":{"id":2415}},"from":{"krate":0,"index":42488},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1459969,"byte_end":1459975,"line_start":917,"line_end":917,"column_start":16,"column_end":22},"kind":{"Impl":{"id":2416}},"from":{"krate":0,"index":42488},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1460443,"byte_end":1460449,"line_start":936,"line_end":936,"column_start":16,"column_end":22},"kind":{"Impl":{"id":2417}},"from":{"krate":0,"index":42488},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1460956,"byte_end":1460962,"line_start":955,"line_end":955,"column_start":18,"column_end":24},"kind":{"Impl":{"id":2418}},"from":{"krate":0,"index":42488},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1462386,"byte_end":1462392,"line_start":995,"line_end":995,"column_start":16,"column_end":22},"kind":{"Impl":{"id":2419}},"from":{"krate":0,"index":42488},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1462733,"byte_end":1462739,"line_start":1005,"line_end":1005,"column_start":12,"column_end":18},"kind":{"Impl":{"id":2420}},"from":{"krate":0,"index":42488},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1463944,"byte_end":1463950,"line_start":1044,"line_end":1044,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2421}},"from":{"krate":0,"index":42488},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1464123,"byte_end":1464129,"line_start":1051,"line_end":1051,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2422}},"from":{"krate":0,"index":42488},"to":{"krate":0,"index":4512}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1465198,"byte_end":1465204,"line_start":1095,"line_end":1095,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2423}},"from":{"krate":0,"index":42488},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1465376,"byte_end":1465382,"line_start":1102,"line_end":1102,"column_start":37,"column_end":43},"kind":{"Impl":{"id":2424}},"from":{"krate":0,"index":42488},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1465577,"byte_end":1465583,"line_start":1109,"line_end":1109,"column_start":41,"column_end":47},"kind":{"Impl":{"id":2425}},"from":{"krate":0,"index":42488},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1465947,"byte_end":1465951,"line_start":1124,"line_end":1124,"column_start":22,"column_end":26},"kind":{"Impl":{"id":2426}},"from":{"krate":0,"index":42530},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1466273,"byte_end":1466277,"line_start":1141,"line_end":1141,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2427}},"from":{"krate":0,"index":42530},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1466403,"byte_end":1466407,"line_start":1148,"line_end":1148,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2428}},"from":{"krate":0,"index":42530},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1466440,"byte_end":1466444,"line_start":1149,"line_end":1149,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2429}},"from":{"krate":0,"index":42530},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1466481,"byte_end":1466485,"line_start":1150,"line_end":1150,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2430}},"from":{"krate":0,"index":42530},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1467039,"byte_end":1467043,"line_start":1166,"line_end":1166,"column_start":26,"column_end":30},"kind":{"Impl":{"id":2431}},"from":{"krate":0,"index":42540},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1467329,"byte_end":1467333,"line_start":1176,"line_end":1176,"column_start":37,"column_end":41},"kind":{"Impl":{"id":2432}},"from":{"krate":0,"index":42540},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1467508,"byte_end":1467512,"line_start":1182,"line_end":1182,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2433}},"from":{"krate":0,"index":42540},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1467597,"byte_end":1467601,"line_start":1185,"line_end":1185,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2434}},"from":{"krate":0,"index":42540},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1467697,"byte_end":1467701,"line_start":1188,"line_end":1188,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2435}},"from":{"krate":0,"index":42540},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1467777,"byte_end":1467781,"line_start":1191,"line_end":1191,"column_start":19,"column_end":23},"kind":{"Impl":{"id":2436}},"from":{"krate":0,"index":42540},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1468460,"byte_end":1468467,"line_start":1212,"line_end":1212,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2437}},"from":{"krate":0,"index":42546},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1468761,"byte_end":1468768,"line_start":1222,"line_end":1222,"column_start":37,"column_end":44},"kind":{"Impl":{"id":2438}},"from":{"krate":0,"index":42546},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1468947,"byte_end":1468954,"line_start":1228,"line_end":1228,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2439}},"from":{"krate":0,"index":42546},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1469039,"byte_end":1469046,"line_start":1231,"line_end":1231,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2440}},"from":{"krate":0,"index":42546},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1469141,"byte_end":1469148,"line_start":1233,"line_end":1233,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2441}},"from":{"krate":0,"index":42546},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1469710,"byte_end":1469718,"line_start":1249,"line_end":1249,"column_start":22,"column_end":30},"kind":{"Impl":{"id":2442}},"from":{"krate":0,"index":42552},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1469988,"byte_end":1469996,"line_start":1259,"line_end":1259,"column_start":33,"column_end":41},"kind":{"Impl":{"id":2443}},"from":{"krate":0,"index":42552},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1470163,"byte_end":1470171,"line_start":1265,"line_end":1265,"column_start":31,"column_end":39},"kind":{"Impl":{"id":2444}},"from":{"krate":0,"index":42552},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1470252,"byte_end":1470260,"line_start":1268,"line_end":1268,"column_start":27,"column_end":35},"kind":{"Impl":{"id":2445}},"from":{"krate":0,"index":42552},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1470352,"byte_end":1470360,"line_start":1271,"line_end":1271,"column_start":31,"column_end":39},"kind":{"Impl":{"id":2446}},"from":{"krate":0,"index":42552},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1470643,"byte_end":1470649,"line_start":1278,"line_end":1278,"column_start":57,"column_end":63},"kind":{"Impl":{"id":2447}},"from":{"krate":0,"index":42488},"to":{"krate":0,"index":4508}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1473055,"byte_end":1473062,"line_start":1351,"line_end":1351,"column_start":62,"column_end":69},"kind":{"Impl":{"id":2448}},"from":{"krate":0,"index":5736},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/option.rs","byte_start":1474625,"byte_end":1474631,"line_start":1397,"line_end":1397,"column_start":22,"column_end":28},"kind":{"Impl":{"id":2449}},"from":{"krate":0,"index":42488},"to":{"krate":0,"index":2258}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1486145,"byte_end":1486151,"line_start":260,"line_end":260,"column_start":12,"column_end":18},"kind":{"Impl":{"id":2450}},"from":{"krate":0,"index":42602},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1501522,"byte_end":1501528,"line_start":771,"line_end":771,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2451}},"from":{"krate":0,"index":42602},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1503229,"byte_end":1503235,"line_start":832,"line_end":832,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2452}},"from":{"krate":0,"index":42602},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1504922,"byte_end":1504928,"line_start":892,"line_end":892,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2453}},"from":{"krate":0,"index":42602},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1506319,"byte_end":1506325,"line_start":931,"line_end":931,"column_start":19,"column_end":25},"kind":{"Impl":{"id":2454}},"from":{"krate":0,"index":42602},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1506790,"byte_end":1506796,"line_start":943,"line_end":943,"column_start":19,"column_end":25},"kind":{"Impl":{"id":2455}},"from":{"krate":0,"index":42602},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1507278,"byte_end":1507284,"line_start":956,"line_end":956,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2456}},"from":{"krate":0,"index":42602},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1507720,"byte_end":1507726,"line_start":968,"line_end":968,"column_start":12,"column_end":18},"kind":{"Impl":{"id":2457}},"from":{"krate":0,"index":42602},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1508971,"byte_end":1508977,"line_start":1007,"line_end":1007,"column_start":29,"column_end":35},"kind":{"Impl":{"id":2458}},"from":{"krate":0,"index":42602},"to":{"krate":0,"index":4512}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1510814,"byte_end":1510818,"line_start":1072,"line_end":1072,"column_start":26,"column_end":30},"kind":{"Impl":{"id":2459}},"from":{"krate":0,"index":42644},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1511160,"byte_end":1511164,"line_start":1085,"line_end":1085,"column_start":37,"column_end":41},"kind":{"Impl":{"id":2460}},"from":{"krate":0,"index":42644},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1511334,"byte_end":1511338,"line_start":1091,"line_end":1091,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2461}},"from":{"krate":0,"index":42644},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1511423,"byte_end":1511427,"line_start":1094,"line_end":1094,"column_start":27,"column_end":31},"kind":{"Impl":{"id":2462}},"from":{"krate":0,"index":42644},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1511523,"byte_end":1511527,"line_start":1097,"line_end":1097,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2463}},"from":{"krate":0,"index":42644},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1511603,"byte_end":1511607,"line_start":1100,"line_end":1100,"column_start":19,"column_end":23},"kind":{"Impl":{"id":2464}},"from":{"krate":0,"index":42644},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1512144,"byte_end":1512151,"line_start":1117,"line_end":1117,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2465}},"from":{"krate":0,"index":42650},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1512501,"byte_end":1512508,"line_start":1130,"line_end":1130,"column_start":37,"column_end":44},"kind":{"Impl":{"id":2466}},"from":{"krate":0,"index":42650},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1512682,"byte_end":1512689,"line_start":1136,"line_end":1136,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2467}},"from":{"krate":0,"index":42650},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1512774,"byte_end":1512781,"line_start":1139,"line_end":1139,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2468}},"from":{"krate":0,"index":42650},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1512877,"byte_end":1512884,"line_start":1142,"line_end":1142,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2469}},"from":{"krate":0,"index":42650},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1513555,"byte_end":1513563,"line_start":1160,"line_end":1160,"column_start":22,"column_end":30},"kind":{"Impl":{"id":2470}},"from":{"krate":0,"index":42656},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1513889,"byte_end":1513897,"line_start":1173,"line_end":1173,"column_start":33,"column_end":41},"kind":{"Impl":{"id":2471}},"from":{"krate":0,"index":42656},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1514059,"byte_end":1514067,"line_start":1179,"line_end":1179,"column_start":31,"column_end":39},"kind":{"Impl":{"id":2472}},"from":{"krate":0,"index":42656},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1514148,"byte_end":1514156,"line_start":1182,"line_end":1182,"column_start":27,"column_end":35},"kind":{"Impl":{"id":2473}},"from":{"krate":0,"index":42656},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1514248,"byte_end":1514256,"line_start":1185,"line_end":1185,"column_start":31,"column_end":39},"kind":{"Impl":{"id":2474}},"from":{"krate":0,"index":42656},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1514545,"byte_end":1514551,"line_start":1192,"line_end":1192,"column_start":63,"column_end":69},"kind":{"Impl":{"id":2475}},"from":{"krate":0,"index":42602},"to":{"krate":0,"index":4508}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1516549,"byte_end":1516556,"line_start":1245,"line_end":1245,"column_start":68,"column_end":75},"kind":{"Impl":{"id":2476}},"from":{"krate":0,"index":5934},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/result.rs","byte_start":1517448,"byte_end":1517454,"line_start":1277,"line_end":1277,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2477}},"from":{"krate":0,"index":42602},"to":{"krate":0,"index":2258}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1519415,"byte_end":1519421,"line_start":41,"line_end":41,"column_start":21,"column_end":27},"kind":{"Impl":{"id":2478}},"from":{"krate":0,"index":5960},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/ffi.rs","byte_start":1524144,"byte_end":1524150,"line_start":178,"line_end":178,"column_start":10,"column_end":16},"kind":{"Impl":{"id":2490}},"from":{"krate":0,"index":42672},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/rotate.rs","byte_start":1706148,"byte_end":1706156,"line_start":18,"line_end":18,"column_start":9,"column_end":17},"kind":{"Impl":{"id":2491}},"from":{"krate":0,"index":6082},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/sort.rs","byte_start":1708976,"byte_end":1708986,"line_start":19,"line_end":19,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2492}},"from":{"krate":0,"index":6102},"to":{"krate":0,"index":1984}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615551,"byte_end":1615556,"line_start":2584,"line_end":2584,"column_start":26,"column_end":31},"kind":{"Impl":{"id":2494}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":6332}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615653,"byte_end":1615660,"line_start":2586,"line_end":2586,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2495}},"from":{"krate":0,"index":36098},"to":{"krate":0,"index":6332}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615757,"byte_end":1615766,"line_start":2588,"line_end":2588,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2496}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":6332}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615863,"byte_end":1615872,"line_start":2590,"line_end":2590,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2497}},"from":{"krate":0,"index":36038},"to":{"krate":0,"index":6332}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1615962,"byte_end":1615976,"line_start":2592,"line_end":2592,"column_start":26,"column_end":40},"kind":{"Impl":{"id":2498}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":6332}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616073,"byte_end":1616089,"line_start":2594,"line_end":2594,"column_start":26,"column_end":42},"kind":{"Impl":{"id":2499}},"from":{"krate":0,"index":36126},"to":{"krate":0,"index":6332}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1616780,"byte_end":1616786,"line_start":2612,"line_end":2612,"column_start":55,"column_end":61},"kind":"SuperTrait","from":{"krate":0,"index":6332},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1619480,"byte_end":1619485,"line_start":2698,"line_end":2698,"column_start":35,"column_end":40},"kind":{"Impl":{"id":2501}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1621157,"byte_end":1621164,"line_start":2759,"line_end":2759,"column_start":34,"column_end":41},"kind":{"Impl":{"id":2502}},"from":{"krate":0,"index":36098},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1621986,"byte_end":1621995,"line_start":2794,"line_end":2794,"column_start":34,"column_end":43},"kind":{"Impl":{"id":2503}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1622889,"byte_end":1622898,"line_start":2829,"line_end":2829,"column_start":34,"column_end":43},"kind":{"Impl":{"id":2504}},"from":{"krate":0,"index":36038},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1623570,"byte_end":1623584,"line_start":2865,"line_end":2865,"column_start":34,"column_end":48},"kind":{"Impl":{"id":2505}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1624790,"byte_end":1624806,"line_start":2904,"line_end":2904,"column_start":34,"column_end":50},"kind":{"Impl":{"id":2506}},"from":{"krate":0,"index":36126},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1637801,"byte_end":1637805,"line_start":3286,"line_end":3286,"column_start":36,"column_end":40},"kind":{"Impl":{"id":2507}},"from":{"krate":0,"index":6508},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1638052,"byte_end":1638056,"line_start":3295,"line_end":3295,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2508}},"from":{"krate":0,"index":6508},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1638143,"byte_end":1638147,"line_start":3297,"line_end":3297,"column_start":31,"column_end":35},"kind":{"Impl":{"id":2509}},"from":{"krate":0,"index":6508},"to":{"krate":0,"index":1706}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1638171,"byte_end":1638175,"line_start":3299,"line_end":3299,"column_start":13,"column_end":17},"kind":{"Impl":{"id":2510}},"from":{"krate":0,"index":6508},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1639585,"byte_end":1639589,"line_start":3343,"line_end":3343,"column_start":19,"column_end":23},"kind":{"Impl":{"id":2511}},"from":{"krate":0,"index":6508},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1639777,"byte_end":1639781,"line_start":3348,"line_end":3348,"column_start":24,"column_end":28},"kind":{"Impl":{"id":2512}},"from":{"krate":0,"index":6508},"to":{"krate":0,"index":2652}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1640940,"byte_end":1640947,"line_start":3388,"line_end":3388,"column_start":36,"column_end":43},"kind":{"Impl":{"id":2513}},"from":{"krate":0,"index":6530},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1641199,"byte_end":1641206,"line_start":3397,"line_end":3397,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2514}},"from":{"krate":0,"index":6530},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1641293,"byte_end":1641300,"line_start":3399,"line_end":3399,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2515}},"from":{"krate":0,"index":6530},"to":{"krate":0,"index":1706}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1641324,"byte_end":1641331,"line_start":3401,"line_end":3401,"column_start":13,"column_end":20},"kind":{"Impl":{"id":2516}},"from":{"krate":0,"index":6530},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1643844,"byte_end":1643863,"line_start":3474,"line_end":3474,"column_start":18,"column_end":37},"kind":"SuperTrait","from":{"krate":0,"index":4474},"to":{"krate":0,"index":6546}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1644539,"byte_end":1644544,"line_start":3495,"line_end":3495,"column_start":39,"column_end":44},"kind":{"Impl":{"id":2517}},"from":{"krate":0,"index":6550},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1644912,"byte_end":1644917,"line_start":3506,"line_end":3506,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2518}},"from":{"krate":0,"index":6550},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1645201,"byte_end":1645206,"line_start":3517,"line_end":3517,"column_start":29,"column_end":34},"kind":{"Impl":{"id":2519}},"from":{"krate":0,"index":6550},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1645917,"byte_end":1645922,"line_start":3545,"line_end":3545,"column_start":40,"column_end":45},"kind":{"Impl":{"id":2520}},"from":{"krate":0,"index":6550},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1646365,"byte_end":1646370,"line_start":3561,"line_end":3561,"column_start":30,"column_end":35},"kind":{"Impl":{"id":2521}},"from":{"krate":0,"index":6550},"to":{"krate":0,"index":6546}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1646633,"byte_end":1646638,"line_start":3569,"line_end":3569,"column_start":30,"column_end":35},"kind":{"Impl":{"id":2522}},"from":{"krate":0,"index":6550},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647229,"byte_end":1647237,"line_start":3586,"line_end":3586,"column_start":39,"column_end":47},"kind":{"Impl":{"id":2523}},"from":{"krate":0,"index":6578},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647515,"byte_end":1647523,"line_start":3595,"line_end":3595,"column_start":30,"column_end":38},"kind":{"Impl":{"id":2524}},"from":{"krate":0,"index":6578},"to":{"krate":0,"index":6546}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1647868,"byte_end":1647876,"line_start":3608,"line_end":3608,"column_start":29,"column_end":37},"kind":{"Impl":{"id":2525}},"from":{"krate":0,"index":6578},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1648944,"byte_end":1648952,"line_start":3643,"line_end":3643,"column_start":40,"column_end":48},"kind":{"Impl":{"id":2526}},"from":{"krate":0,"index":6578},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1649652,"byte_end":1649660,"line_start":3667,"line_end":3667,"column_start":30,"column_end":38},"kind":{"Impl":{"id":2527}},"from":{"krate":0,"index":6578},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650323,"byte_end":1650329,"line_start":3683,"line_end":3683,"column_start":39,"column_end":45},"kind":{"Impl":{"id":2528}},"from":{"krate":0,"index":42798},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1650670,"byte_end":1650676,"line_start":3693,"line_end":3693,"column_start":29,"column_end":35},"kind":{"Impl":{"id":2529}},"from":{"krate":0,"index":42798},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651037,"byte_end":1651043,"line_start":3708,"line_end":3708,"column_start":40,"column_end":46},"kind":{"Impl":{"id":2530}},"from":{"krate":0,"index":42798},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651264,"byte_end":1651270,"line_start":3716,"line_end":3716,"column_start":30,"column_end":36},"kind":{"Impl":{"id":2531}},"from":{"krate":0,"index":42798},"to":{"krate":0,"index":6546}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1651490,"byte_end":1651496,"line_start":3724,"line_end":3724,"column_start":30,"column_end":36},"kind":{"Impl":{"id":2532}},"from":{"krate":0,"index":42798},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652111,"byte_end":1652120,"line_start":3739,"line_end":3739,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2533}},"from":{"krate":0,"index":6624},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652465,"byte_end":1652474,"line_start":3749,"line_end":3749,"column_start":30,"column_end":39},"kind":{"Impl":{"id":2534}},"from":{"krate":0,"index":6624},"to":{"krate":0,"index":6546}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1652697,"byte_end":1652706,"line_start":3757,"line_end":3757,"column_start":29,"column_end":38},"kind":{"Impl":{"id":2535}},"from":{"krate":0,"index":6624},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653075,"byte_end":1653084,"line_start":3772,"line_end":3772,"column_start":40,"column_end":49},"kind":{"Impl":{"id":2536}},"from":{"krate":0,"index":6624},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653314,"byte_end":1653323,"line_start":3782,"line_end":3782,"column_start":30,"column_end":39},"kind":{"Impl":{"id":2537}},"from":{"krate":0,"index":6624},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1653630,"byte_end":1653643,"line_start":3793,"line_end":3793,"column_start":44,"column_end":57},"kind":{"Impl":{"id":2538}},"from":{"krate":0,"index":42804},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1654651,"byte_end":1654657,"line_start":3825,"line_end":3825,"column_start":39,"column_end":45},"kind":{"Impl":{"id":2539}},"from":{"krate":0,"index":6656},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1655462,"byte_end":1655469,"line_start":3847,"line_end":3847,"column_start":39,"column_end":46},"kind":{"Impl":{"id":2540}},"from":{"krate":0,"index":6662},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1656248,"byte_end":1656257,"line_start":3868,"line_end":3868,"column_start":39,"column_end":48},"kind":{"Impl":{"id":2541}},"from":{"krate":0,"index":6668},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1657083,"byte_end":1657093,"line_start":3890,"line_end":3890,"column_start":39,"column_end":49},"kind":{"Impl":{"id":2542}},"from":{"krate":0,"index":6674},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1658697,"byte_end":1658704,"line_start":3943,"line_end":3943,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2543}},"from":{"krate":0,"index":42850},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1658904,"byte_end":1658911,"line_start":3953,"line_end":3953,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2544}},"from":{"krate":0,"index":42850},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1660175,"byte_end":1660182,"line_start":4007,"line_end":4007,"column_start":37,"column_end":44},"kind":{"Impl":{"id":2545}},"from":{"krate":0,"index":42850},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1660917,"byte_end":1660924,"line_start":4034,"line_end":4034,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2546}},"from":{"krate":0,"index":42850},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661020,"byte_end":1661027,"line_start":4037,"line_end":4037,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2547}},"from":{"krate":0,"index":42850},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661112,"byte_end":1661119,"line_start":4040,"line_end":4040,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2548}},"from":{"krate":0,"index":42850},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1661189,"byte_end":1661196,"line_start":4043,"line_end":4043,"column_start":44,"column_end":51},"kind":{"Impl":{"id":2549}},"from":{"krate":0,"index":42850},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1662078,"byte_end":1662084,"line_start":4069,"line_end":4069,"column_start":19,"column_end":25},"kind":{"Impl":{"id":2550}},"from":{"krate":0,"index":42856},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1662295,"byte_end":1662301,"line_start":4079,"line_end":4079,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2551}},"from":{"krate":0,"index":42856},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1663932,"byte_end":1663938,"line_start":4140,"line_end":4140,"column_start":37,"column_end":43},"kind":{"Impl":{"id":2552}},"from":{"krate":0,"index":42856},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1664433,"byte_end":1664439,"line_start":4156,"line_end":4156,"column_start":31,"column_end":37},"kind":{"Impl":{"id":2553}},"from":{"krate":0,"index":42856},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1664535,"byte_end":1664541,"line_start":4159,"line_end":4159,"column_start":31,"column_end":37},"kind":{"Impl":{"id":2554}},"from":{"krate":0,"index":42856},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1664626,"byte_end":1664632,"line_start":4162,"line_end":4162,"column_start":27,"column_end":33},"kind":{"Impl":{"id":2555}},"from":{"krate":0,"index":42856},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1664702,"byte_end":1664708,"line_start":4165,"line_end":4165,"column_start":44,"column_end":50},"kind":{"Impl":{"id":2556}},"from":{"krate":0,"index":42856},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1665776,"byte_end":1665785,"line_start":4195,"line_end":4195,"column_start":26,"column_end":35},"kind":{"Impl":{"id":2557}},"from":{"krate":0,"index":42862},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1667601,"byte_end":1667610,"line_start":4259,"line_end":4259,"column_start":37,"column_end":46},"kind":{"Impl":{"id":2558}},"from":{"krate":0,"index":42862},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1668194,"byte_end":1668203,"line_start":4277,"line_end":4277,"column_start":31,"column_end":40},"kind":{"Impl":{"id":2559}},"from":{"krate":0,"index":42862},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1668299,"byte_end":1668308,"line_start":4280,"line_end":4280,"column_start":31,"column_end":40},"kind":{"Impl":{"id":2560}},"from":{"krate":0,"index":42862},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1668393,"byte_end":1668402,"line_start":4283,"line_end":4283,"column_start":27,"column_end":36},"kind":{"Impl":{"id":2561}},"from":{"krate":0,"index":42862},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1668472,"byte_end":1668481,"line_start":4286,"line_end":4286,"column_start":44,"column_end":53},"kind":{"Impl":{"id":2562}},"from":{"krate":0,"index":42862},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1669676,"byte_end":1669687,"line_start":4318,"line_end":4318,"column_start":13,"column_end":24},"kind":{"Impl":{"id":2563}},"from":{"krate":0,"index":42868},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1670123,"byte_end":1670134,"line_start":4330,"line_end":4330,"column_start":19,"column_end":30},"kind":{"Impl":{"id":2564}},"from":{"krate":0,"index":42868},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1670385,"byte_end":1670396,"line_start":4341,"line_end":4341,"column_start":26,"column_end":37},"kind":{"Impl":{"id":2565}},"from":{"krate":0,"index":42868},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1671455,"byte_end":1671466,"line_start":4386,"line_end":4386,"column_start":37,"column_end":48},"kind":{"Impl":{"id":2566}},"from":{"krate":0,"index":42868},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1671846,"byte_end":1671857,"line_start":4400,"line_end":4400,"column_start":31,"column_end":42},"kind":{"Impl":{"id":2567}},"from":{"krate":0,"index":42868},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1672019,"byte_end":1672030,"line_start":4407,"line_end":4407,"column_start":31,"column_end":42},"kind":{"Impl":{"id":2568}},"from":{"krate":0,"index":42868},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1672122,"byte_end":1672133,"line_start":4410,"line_end":4410,"column_start":27,"column_end":38},"kind":{"Impl":{"id":2569}},"from":{"krate":0,"index":42868},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1672257,"byte_end":1672268,"line_start":4414,"line_end":4414,"column_start":44,"column_end":55},"kind":{"Impl":{"id":2570}},"from":{"krate":0,"index":42868},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1673344,"byte_end":1673358,"line_start":4442,"line_end":4442,"column_start":13,"column_end":27},"kind":{"Impl":{"id":2571}},"from":{"krate":0,"index":42874},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1673754,"byte_end":1673768,"line_start":4453,"line_end":4453,"column_start":26,"column_end":40},"kind":{"Impl":{"id":2572}},"from":{"krate":0,"index":42874},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1674962,"byte_end":1674976,"line_start":4500,"line_end":4500,"column_start":37,"column_end":51},"kind":{"Impl":{"id":2573}},"from":{"krate":0,"index":42874},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675455,"byte_end":1675469,"line_start":4516,"line_end":4516,"column_start":31,"column_end":45},"kind":{"Impl":{"id":2574}},"from":{"krate":0,"index":42874},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675631,"byte_end":1675645,"line_start":4523,"line_end":4523,"column_start":31,"column_end":45},"kind":{"Impl":{"id":2575}},"from":{"krate":0,"index":42874},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675737,"byte_end":1675751,"line_start":4526,"line_end":4526,"column_start":27,"column_end":41},"kind":{"Impl":{"id":2576}},"from":{"krate":0,"index":42874},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1675875,"byte_end":1675889,"line_start":4530,"line_end":4530,"column_start":44,"column_end":58},"kind":{"Impl":{"id":2577}},"from":{"krate":0,"index":42874},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1676838,"byte_end":1676845,"line_start":4557,"line_end":4557,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2578}},"from":{"krate":0,"index":42880},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1677060,"byte_end":1677067,"line_start":4567,"line_end":4567,"column_start":26,"column_end":33},"kind":{"Impl":{"id":2579}},"from":{"krate":0,"index":42880},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1678821,"byte_end":1678828,"line_start":4631,"line_end":4631,"column_start":37,"column_end":44},"kind":{"Impl":{"id":2580}},"from":{"krate":0,"index":42880},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679311,"byte_end":1679318,"line_start":4647,"line_end":4647,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2581}},"from":{"krate":0,"index":42880},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679414,"byte_end":1679421,"line_start":4650,"line_end":4650,"column_start":31,"column_end":38},"kind":{"Impl":{"id":2582}},"from":{"krate":0,"index":42880},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679508,"byte_end":1679515,"line_start":4653,"line_end":4653,"column_start":27,"column_end":34},"kind":{"Impl":{"id":2583}},"from":{"krate":0,"index":42880},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1679634,"byte_end":1679641,"line_start":4657,"line_end":4657,"column_start":44,"column_end":51},"kind":{"Impl":{"id":2584}},"from":{"krate":0,"index":42880},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1680695,"byte_end":1680705,"line_start":4687,"line_end":4687,"column_start":26,"column_end":36},"kind":{"Impl":{"id":2585}},"from":{"krate":0,"index":42886},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1682680,"byte_end":1682690,"line_start":4755,"line_end":4755,"column_start":37,"column_end":47},"kind":{"Impl":{"id":2586}},"from":{"krate":0,"index":42886},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683230,"byte_end":1683240,"line_start":4772,"line_end":4772,"column_start":31,"column_end":41},"kind":{"Impl":{"id":2587}},"from":{"krate":0,"index":42886},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683336,"byte_end":1683346,"line_start":4775,"line_end":4775,"column_start":31,"column_end":41},"kind":{"Impl":{"id":2588}},"from":{"krate":0,"index":42886},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683433,"byte_end":1683443,"line_start":4778,"line_end":4778,"column_start":27,"column_end":37},"kind":{"Impl":{"id":2589}},"from":{"krate":0,"index":42886},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1683562,"byte_end":1683572,"line_start":4782,"line_end":4782,"column_start":44,"column_end":54},"kind":{"Impl":{"id":2590}},"from":{"krate":0,"index":42886},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1684742,"byte_end":1684754,"line_start":4814,"line_end":4814,"column_start":13,"column_end":25},"kind":{"Impl":{"id":2591}},"from":{"krate":0,"index":42892},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685184,"byte_end":1685196,"line_start":4826,"line_end":4826,"column_start":23,"column_end":35},"kind":{"Impl":{"id":2592}},"from":{"krate":0,"index":42892},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1685458,"byte_end":1685470,"line_start":4837,"line_end":4837,"column_start":26,"column_end":38},"kind":{"Impl":{"id":2593}},"from":{"krate":0,"index":42892},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1686548,"byte_end":1686560,"line_start":4882,"line_end":4882,"column_start":37,"column_end":49},"kind":{"Impl":{"id":2594}},"from":{"krate":0,"index":42892},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1686924,"byte_end":1686936,"line_start":4896,"line_end":4896,"column_start":35,"column_end":47},"kind":{"Impl":{"id":2595}},"from":{"krate":0,"index":42892},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1687098,"byte_end":1687110,"line_start":4903,"line_end":4903,"column_start":31,"column_end":43},"kind":{"Impl":{"id":2596}},"from":{"krate":0,"index":42892},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1687197,"byte_end":1687209,"line_start":4906,"line_end":4906,"column_start":27,"column_end":39},"kind":{"Impl":{"id":2597}},"from":{"krate":0,"index":42892},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1687328,"byte_end":1687340,"line_start":4910,"line_end":4910,"column_start":44,"column_end":56},"kind":{"Impl":{"id":2598}},"from":{"krate":0,"index":42892},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688465,"byte_end":1688480,"line_start":4939,"line_end":4939,"column_start":13,"column_end":28},"kind":{"Impl":{"id":2599}},"from":{"krate":0,"index":42898},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1688866,"byte_end":1688881,"line_start":4950,"line_end":4950,"column_start":26,"column_end":41},"kind":{"Impl":{"id":2600}},"from":{"krate":0,"index":42898},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690158,"byte_end":1690173,"line_start":4999,"line_end":4999,"column_start":37,"column_end":52},"kind":{"Impl":{"id":2601}},"from":{"krate":0,"index":42898},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690600,"byte_end":1690615,"line_start":5014,"line_end":5014,"column_start":31,"column_end":46},"kind":{"Impl":{"id":2602}},"from":{"krate":0,"index":42898},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690777,"byte_end":1690792,"line_start":5021,"line_end":5021,"column_start":31,"column_end":46},"kind":{"Impl":{"id":2603}},"from":{"krate":0,"index":42898},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1690879,"byte_end":1690894,"line_start":5024,"line_end":5024,"column_start":27,"column_end":42},"kind":{"Impl":{"id":2604}},"from":{"krate":0,"index":42898},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1691013,"byte_end":1691028,"line_start":5028,"line_end":5028,"column_start":44,"column_end":59},"kind":{"Impl":{"id":2605}},"from":{"krate":0,"index":42898},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700121,"byte_end":1700125,"line_start":5328,"line_end":5328,"column_start":44,"column_end":48},"kind":{"Impl":{"id":2618}},"from":{"krate":0,"index":6508},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700336,"byte_end":1700343,"line_start":5336,"line_end":5336,"column_start":44,"column_end":51},"kind":{"Impl":{"id":2619}},"from":{"krate":0,"index":6530},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700525,"byte_end":1700530,"line_start":5343,"line_end":5343,"column_start":22,"column_end":27},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":7080}},{"span":{"file_name":"src/libcore/slice/mod.rs","byte_start":1700612,"byte_end":1700613,"line_start":5347,"line_end":5347,"column_start":27,"column_end":28},"kind":{"Impl":{"id":2620}},"from":{"krate":0,"index":4245},"to":{"krate":0,"index":7080}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1878200,"byte_end":1878205,"line_start":28,"line_end":28,"column_start":24,"column_end":29},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":7162}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1883343,"byte_end":1883351,"line_start":167,"line_end":167,"column_start":39,"column_end":47},"kind":"SuperTrait","from":{"krate":0,"index":7174},"to":{"krate":0,"index":7184}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1885939,"byte_end":1885954,"line_start":234,"line_end":234,"column_start":36,"column_end":51},"kind":"SuperTrait","from":{"krate":0,"index":7184},"to":{"krate":0,"index":7192}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1887432,"byte_end":1887444,"line_start":269,"line_end":269,"column_start":34,"column_end":46},"kind":{"Impl":{"id":2623}},"from":{"krate":0,"index":42950},"to":{"krate":0,"index":7174}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1890751,"byte_end":1890763,"line_start":343,"line_end":343,"column_start":41,"column_end":53},"kind":{"Impl":{"id":2624}},"from":{"krate":0,"index":42950},"to":{"krate":0,"index":7184}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1894470,"byte_end":1894482,"line_start":419,"line_end":419,"column_start":38,"column_end":50},"kind":{"Impl":{"id":2625}},"from":{"krate":0,"index":42950},"to":{"krate":0,"index":7192}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1896046,"byte_end":1896047,"line_start":478,"line_end":478,"column_start":25,"column_end":26},"kind":{"Impl":{"id":2627}},"from":{"krate":0,"index":4269},"to":{"krate":0,"index":7222}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1896539,"byte_end":1896557,"line_start":499,"line_end":499,"column_start":42,"column_end":60},"kind":{"Impl":{"id":2628}},"from":{"krate":0,"index":7234},"to":{"krate":0,"index":7162}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1896904,"byte_end":1896923,"line_start":512,"line_end":512,"column_start":50,"column_end":69},"kind":{"Impl":{"id":2629}},"from":{"krate":0,"index":42960},"to":{"krate":0,"index":7174}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1897670,"byte_end":1897689,"line_start":537,"line_end":537,"column_start":57,"column_end":76},"kind":{"Impl":{"id":2630}},"from":{"krate":0,"index":42960},"to":{"krate":0,"index":7184}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1898364,"byte_end":1898383,"line_start":557,"line_end":557,"column_start":54,"column_end":73},"kind":{"Impl":{"id":2631}},"from":{"krate":0,"index":42960},"to":{"krate":0,"index":7192}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1900545,"byte_end":1900562,"line_start":634,"line_end":634,"column_start":38,"column_end":55},"kind":{"Impl":{"id":2632}},"from":{"krate":0,"index":42970},"to":{"krate":0,"index":7174}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1900652,"byte_end":1900669,"line_start":638,"line_end":638,"column_start":45,"column_end":62},"kind":{"Impl":{"id":2633}},"from":{"krate":0,"index":42970},"to":{"krate":0,"index":7184}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1900756,"byte_end":1900773,"line_start":642,"line_end":642,"column_start":42,"column_end":59},"kind":{"Impl":{"id":2634}},"from":{"krate":0,"index":42970},"to":{"krate":0,"index":7192}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1901403,"byte_end":1901424,"line_start":658,"line_end":658,"column_start":24,"column_end":45},"kind":{"Impl":{"id":2635}},"from":{"krate":0,"index":43004},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1901750,"byte_end":1901771,"line_start":668,"line_end":668,"column_start":37,"column_end":58},"kind":{"Impl":{"id":2636}},"from":{"krate":0,"index":43004},"to":{"krate":0,"index":7174}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1901892,"byte_end":1901913,"line_start":674,"line_end":674,"column_start":44,"column_end":65},"kind":{"Impl":{"id":2637}},"from":{"krate":0,"index":43004},"to":{"krate":0,"index":7184}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1902031,"byte_end":1902052,"line_start":680,"line_end":680,"column_start":41,"column_end":62},"kind":{"Impl":{"id":2638}},"from":{"krate":0,"index":43004},"to":{"krate":0,"index":7192}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1902179,"byte_end":1902180,"line_start":684,"line_end":684,"column_start":29,"column_end":30},"kind":{"Impl":{"id":2639}},"from":{"krate":0,"index":4327},"to":{"krate":0,"index":7162}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1904338,"byte_end":1904349,"line_start":757,"line_end":757,"column_start":14,"column_end":25},"kind":{"Impl":{"id":2640}},"from":{"krate":0,"index":43044},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1905096,"byte_end":1905107,"line_start":782,"line_end":782,"column_start":38,"column_end":49},"kind":{"Impl":{"id":2641}},"from":{"krate":0,"index":43044},"to":{"krate":0,"index":7174}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1908587,"byte_end":1908598,"line_start":863,"line_end":863,"column_start":45,"column_end":56},"kind":{"Impl":{"id":2642}},"from":{"krate":0,"index":43044},"to":{"krate":0,"index":7184}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1915506,"byte_end":1915520,"line_start":1028,"line_end":1028,"column_start":6,"column_end":20},"kind":{"Impl":{"id":2643}},"from":{"krate":0,"index":43074},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929632,"byte_end":1929641,"line_start":1379,"line_end":1379,"column_start":25,"column_end":34},"kind":{"Impl":{"id":2644}},"from":{"krate":0,"index":7334},"to":{"krate":0,"index":7324}},{"span":{"file_name":"src/libcore/str/pattern.rs","byte_start":1929985,"byte_end":1929999,"line_start":1393,"line_end":1393,"column_start":25,"column_end":39},"kind":{"Impl":{"id":2645}},"from":{"krate":0,"index":7346},"to":{"krate":0,"index":7324}},{"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1930499,"byte_end":1930508,"line_start":12,"line_end":12,"column_start":6,"column_end":15},"kind":{"Impl":{"id":2646}},"from":{"krate":0,"index":7372},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1931371,"byte_end":1931390,"line_start":45,"line_end":45,"column_start":23,"column_end":42},"kind":{"Impl":{"id":2647}},"from":{"krate":0,"index":7382},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1934497,"byte_end":1934506,"line_start":140,"line_end":140,"column_start":23,"column_end":32},"kind":{"Impl":{"id":2648}},"from":{"krate":0,"index":7372},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/str/lossy.rs","byte_start":1935405,"byte_end":1935414,"line_start":166,"line_end":166,"column_start":21,"column_end":30},"kind":{"Impl":{"id":2649}},"from":{"krate":0,"index":7372},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1739119,"byte_end":1739124,"line_start":72,"line_end":72,"column_start":20,"column_end":25},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":7404}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1741519,"byte_end":1741533,"line_start":148,"line_end":148,"column_start":23,"column_end":37},"kind":{"Impl":{"id":2651}},"from":{"krate":0,"index":43100},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1743266,"byte_end":1743275,"line_start":206,"line_end":206,"column_start":6,"column_end":15},"kind":{"Impl":{"id":2652}},"from":{"krate":0,"index":43120},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1750399,"byte_end":1750408,"line_start":441,"line_end":441,"column_start":23,"column_end":32},"kind":{"Impl":{"id":2653}},"from":{"krate":0,"index":43120},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1754150,"byte_end":1754155,"line_start":561,"line_end":561,"column_start":23,"column_end":28},"kind":{"Impl":{"id":2654}},"from":{"krate":0,"index":43142},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1755363,"byte_end":1755368,"line_start":602,"line_end":602,"column_start":34,"column_end":39},"kind":{"Impl":{"id":2655}},"from":{"krate":0,"index":43142},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1755735,"byte_end":1755740,"line_start":615,"line_end":615,"column_start":24,"column_end":29},"kind":{"Impl":{"id":2656}},"from":{"krate":0,"index":43142},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1755758,"byte_end":1755763,"line_start":617,"line_end":617,"column_start":10,"column_end":15},"kind":{"Impl":{"id":2657}},"from":{"krate":0,"index":43142},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1757020,"byte_end":1757031,"line_start":659,"line_end":659,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2658}},"from":{"krate":0,"index":43152},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1757883,"byte_end":1757894,"line_start":694,"line_end":694,"column_start":34,"column_end":45},"kind":{"Impl":{"id":2659}},"from":{"krate":0,"index":43152},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758191,"byte_end":1758202,"line_start":705,"line_end":705,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2660}},"from":{"krate":0,"index":43152},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1758220,"byte_end":1758231,"line_start":707,"line_end":707,"column_start":10,"column_end":21},"kind":{"Impl":{"id":2661}},"from":{"krate":0,"index":43152},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1759033,"byte_end":1759038,"line_start":731,"line_end":731,"column_start":19,"column_end":24},"kind":{"Impl":{"id":2662}},"from":{"krate":0,"index":43162},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1760319,"byte_end":1760324,"line_start":792,"line_end":792,"column_start":30,"column_end":35},"kind":{"Impl":{"id":2663}},"from":{"krate":0,"index":43162},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1760773,"byte_end":1760778,"line_start":812,"line_end":812,"column_start":28,"column_end":33},"kind":{"Impl":{"id":2664}},"from":{"krate":0,"index":43162},"to":{"krate":0,"index":4494}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1761008,"byte_end":1761013,"line_start":825,"line_end":825,"column_start":24,"column_end":29},"kind":{"Impl":{"id":2665}},"from":{"krate":0,"index":43162},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1761103,"byte_end":1761108,"line_start":828,"line_end":828,"column_start":28,"column_end":33},"kind":{"Impl":{"id":2666}},"from":{"krate":0,"index":43162},"to":{"krate":0,"index":4590}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1761168,"byte_end":1761173,"line_start":831,"line_end":831,"column_start":37,"column_end":42},"kind":{"Impl":{"id":2667}},"from":{"krate":0,"index":43162},"to":{"krate":0,"index":4898}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1768399,"byte_end":1768412,"line_start":1040,"line_end":1040,"column_start":41,"column_end":54},"kind":{"Impl":{"id":2668}},"from":{"krate":0,"index":7546},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1768852,"byte_end":1768865,"line_start":1052,"line_end":1052,"column_start":26,"column_end":39},"kind":{"Impl":{"id":2669}},"from":{"krate":0,"index":7546},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1771925,"byte_end":1771939,"line_start":1157,"line_end":1157,"column_start":41,"column_end":55},"kind":{"Impl":{"id":2670}},"from":{"krate":0,"index":7560},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1772219,"byte_end":1772233,"line_start":1166,"line_end":1166,"column_start":26,"column_end":40},"kind":{"Impl":{"id":2671}},"from":{"krate":0,"index":7560},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1773503,"byte_end":1773523,"line_start":1213,"line_end":1213,"column_start":41,"column_end":61},"kind":{"Impl":{"id":2672}},"from":{"krate":0,"index":7572},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1773756,"byte_end":1773776,"line_start":1221,"line_end":1221,"column_start":26,"column_end":46},"kind":{"Impl":{"id":2673}},"from":{"krate":0,"index":7572},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1775050,"byte_end":1775065,"line_start":1264,"line_end":1264,"column_start":41,"column_end":56},"kind":{"Impl":{"id":2674}},"from":{"krate":0,"index":7584},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1775293,"byte_end":1775308,"line_start":1272,"line_end":1272,"column_start":26,"column_end":41},"kind":{"Impl":{"id":2675}},"from":{"krate":0,"index":7584},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1776856,"byte_end":1776861,"line_start":1322,"line_end":1322,"column_start":23,"column_end":28},"kind":{"Impl":{"id":2676}},"from":{"krate":0,"index":43400},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1777162,"byte_end":1777167,"line_start":1337,"line_end":1337,"column_start":34,"column_end":39},"kind":{"Impl":{"id":2677}},"from":{"krate":0,"index":43400},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1777343,"byte_end":1777348,"line_start":1345,"line_end":1345,"column_start":24,"column_end":29},"kind":{"Impl":{"id":2678}},"from":{"krate":0,"index":43400},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1778043,"byte_end":1778051,"line_start":1368,"line_end":1368,"column_start":23,"column_end":31},"kind":{"Impl":{"id":2679}},"from":{"krate":0,"index":43410},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1778373,"byte_end":1778381,"line_start":1384,"line_end":1384,"column_start":34,"column_end":42},"kind":{"Impl":{"id":2680}},"from":{"krate":0,"index":43410},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1778578,"byte_end":1778586,"line_start":1393,"line_end":1393,"column_start":24,"column_end":32},"kind":{"Impl":{"id":2681}},"from":{"krate":0,"index":43410},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1787794,"byte_end":1787803,"line_start":1655,"line_end":1655,"column_start":35,"column_end":44},"kind":{"Impl":{"id":2688}},"from":{"krate":0,"index":36038},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1789665,"byte_end":1789670,"line_start":1719,"line_end":1719,"column_start":35,"column_end":40},"kind":{"Impl":{"id":2689}},"from":{"krate":0,"index":36058},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1792463,"byte_end":1792470,"line_start":1788,"line_end":1788,"column_start":35,"column_end":42},"kind":{"Impl":{"id":2690}},"from":{"krate":0,"index":36098},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1794795,"byte_end":1794804,"line_start":1849,"line_end":1849,"column_start":35,"column_end":44},"kind":{"Impl":{"id":2691}},"from":{"krate":0,"index":36078},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1797390,"byte_end":1797404,"line_start":1912,"line_end":1912,"column_start":35,"column_end":49},"kind":{"Impl":{"id":2692}},"from":{"krate":0,"index":36120},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1799344,"byte_end":1799360,"line_start":1959,"line_end":1959,"column_start":35,"column_end":51},"kind":{"Impl":{"id":2693}},"from":{"krate":0,"index":36126},"to":{"krate":0,"index":6348}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872152,"byte_end":1872167,"line_start":4206,"line_end":4206,"column_start":23,"column_end":38},"kind":{"Impl":{"id":2696}},"from":{"krate":0,"index":43500},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872487,"byte_end":1872502,"line_start":4221,"line_end":4221,"column_start":34,"column_end":49},"kind":{"Impl":{"id":2697}},"from":{"krate":0,"index":43500},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872682,"byte_end":1872697,"line_start":4229,"line_end":4229,"column_start":24,"column_end":39},"kind":{"Impl":{"id":2698}},"from":{"krate":0,"index":43500},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1872792,"byte_end":1872812,"line_start":4232,"line_end":4232,"column_start":23,"column_end":43},"kind":{"Impl":{"id":2699}},"from":{"krate":0,"index":43510},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1873139,"byte_end":1873159,"line_start":4247,"line_end":4247,"column_start":34,"column_end":54},"kind":{"Impl":{"id":2700}},"from":{"krate":0,"index":43510},"to":{"krate":0,"index":4474}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1873356,"byte_end":1873376,"line_start":4255,"line_end":4255,"column_start":24,"column_end":44},"kind":{"Impl":{"id":2701}},"from":{"krate":0,"index":43510},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1873938,"byte_end":1873949,"line_start":4274,"line_end":4274,"column_start":21,"column_end":32},"kind":{"Impl":{"id":2702}},"from":{"krate":0,"index":43620},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1874139,"byte_end":1874150,"line_start":4281,"line_end":4281,"column_start":23,"column_end":34},"kind":{"Impl":{"id":2703}},"from":{"krate":0,"index":43620},"to":{"krate":0,"index":4334}},{"span":{"file_name":"src/libcore/str/mod.rs","byte_start":1874996,"byte_end":1875007,"line_start":4313,"line_end":4313,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2704}},"from":{"krate":0,"index":43620},"to":{"krate":0,"index":4586}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961086,"byte_end":1961095,"line_start":134,"line_end":134,"column_start":6,"column_end":15},"kind":{"Impl":{"id":2705}},"from":{"krate":0,"index":43738},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1961880,"byte_end":1961891,"line_start":156,"line_end":156,"column_start":6,"column_end":17},"kind":{"Impl":{"id":2706}},"from":{"krate":0,"index":43710},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1962703,"byte_end":1962709,"line_start":178,"line_end":178,"column_start":14,"column_end":20},"kind":{"Impl":{"id":2707}},"from":{"krate":0,"index":43752},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1964799,"byte_end":1964808,"line_start":242,"line_end":242,"column_start":24,"column_end":33},"kind":{"Impl":{"id":2708}},"from":{"krate":0,"index":43738},"to":{"krate":0,"index":8056}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1965066,"byte_end":1965077,"line_start":255,"line_end":255,"column_start":24,"column_end":35},"kind":{"Impl":{"id":2709}},"from":{"krate":0,"index":43710},"to":{"krate":0,"index":8056}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1965283,"byte_end":1965289,"line_start":267,"line_end":267,"column_start":32,"column_end":38},"kind":{"Impl":{"id":2710}},"from":{"krate":0,"index":43752},"to":{"krate":0,"index":8056}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1967178,"byte_end":1967184,"line_start":340,"line_end":340,"column_start":24,"column_end":30},"kind":{"Impl":{"id":2711}},"from":{"krate":0,"index":43752},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1967509,"byte_end":1967515,"line_start":355,"line_end":355,"column_start":26,"column_end":32},"kind":{"Impl":{"id":2712}},"from":{"krate":0,"index":43752},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1967839,"byte_end":1967850,"line_start":372,"line_end":372,"column_start":14,"column_end":25},"kind":{"Impl":{"id":2713}},"from":{"krate":0,"index":43770},"to":{"krate":0,"index":8032}},{"span":{"file_name":"src/libcore/hash/sip.rs","byte_start":1968142,"byte_end":1968153,"line_start":389,"line_end":389,"column_start":14,"column_end":25},"kind":{"Impl":{"id":2714}},"from":{"krate":0,"index":43784},"to":{"krate":0,"index":8032}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1950713,"byte_end":1950731,"line_start":502,"line_end":502,"column_start":24,"column_end":42},"kind":{"Impl":{"id":2715}},"from":{"krate":0,"index":8122},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1950940,"byte_end":1950958,"line_start":509,"line_end":509,"column_start":43,"column_end":61},"kind":{"Impl":{"id":2716}},"from":{"krate":0,"index":8122},"to":{"krate":0,"index":8116}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1951121,"byte_end":1951139,"line_start":518,"line_end":518,"column_start":19,"column_end":37},"kind":{"Impl":{"id":2717}},"from":{"krate":0,"index":8122},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1951322,"byte_end":1951340,"line_start":525,"line_end":525,"column_start":21,"column_end":39},"kind":{"Impl":{"id":2718}},"from":{"krate":0,"index":8122},"to":{"krate":0,"index":2640}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1951526,"byte_end":1951544,"line_start":532,"line_end":532,"column_start":23,"column_end":41},"kind":{"Impl":{"id":2719}},"from":{"krate":0,"index":8122},"to":{"krate":0,"index":2416}},{"span":{"file_name":"src/libcore/hash/mod.rs","byte_start":1951703,"byte_end":1951721,"line_start":539,"line_end":539,"column_start":16,"column_end":34},"kind":{"Impl":{"id":2720}},"from":{"krate":0,"index":8122},"to":{"krate":0,"index":2422}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2042883,"byte_end":2042892,"line_start":12,"line_end":12,"column_start":12,"column_end":21},"kind":"SuperTrait","from":{"krate":0,"index":2416},"to":{"krate":0,"index":8280}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2042895,"byte_end":2042905,"line_start":12,"line_end":12,"column_start":24,"column_end":34},"kind":"SuperTrait","from":{"krate":0,"index":2472},"to":{"krate":0,"index":8280}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2042908,"byte_end":2042911,"line_start":12,"line_end":12,"column_start":37,"column_end":40},"kind":"SuperTrait","from":{"krate":0,"index":1798},"to":{"krate":0,"index":8280}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2042927,"byte_end":2042930,"line_start":12,"line_end":12,"column_start":56,"column_end":59},"kind":"SuperTrait","from":{"krate":0,"index":1808},"to":{"krate":0,"index":8280}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2042957,"byte_end":2042960,"line_start":13,"line_end":13,"column_start":12,"column_end":15},"kind":"SuperTrait","from":{"krate":0,"index":1782},"to":{"krate":0,"index":8280}},{"span":{"file_name":"src/libcore/fmt/num.rs","byte_start":2042976,"byte_end":2042980,"line_start":13,"line_end":13,"column_start":31,"column_end":35},"kind":"SuperTrait","from":{"krate":0,"index":1716},"to":{"krate":0,"index":8280}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2052534,"byte_end":2052544,"line_start":8,"line_end":8,"column_start":10,"column_end":20},"kind":{"Impl":{"id":2724}},"from":{"krate":0,"index":8328},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2052905,"byte_end":2052915,"line_start":21,"line_end":21,"column_start":21,"column_end":31},"kind":{"Impl":{"id":2725}},"from":{"krate":0,"index":8328},"to":{"krate":0,"index":8426}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2054981,"byte_end":2054992,"line_start":99,"line_end":99,"column_start":18,"column_end":29},"kind":{"Impl":{"id":2726}},"from":{"krate":0,"index":8338},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2059532,"byte_end":2059542,"line_start":250,"line_end":250,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2727}},"from":{"krate":0,"index":8350},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2062325,"byte_end":2062335,"line_start":344,"line_end":344,"column_start":18,"column_end":28},"kind":{"Impl":{"id":2728}},"from":{"krate":0,"index":8362},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2064276,"byte_end":2064284,"line_start":416,"line_end":416,"column_start":18,"column_end":26},"kind":{"Impl":{"id":2729}},"from":{"krate":0,"index":8370},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2068053,"byte_end":2068062,"line_start":553,"line_end":553,"column_start":18,"column_end":27},"kind":{"Impl":{"id":2730}},"from":{"krate":0,"index":8382},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/builders.rs","byte_start":2071864,"byte_end":2071872,"line_start":690,"line_end":690,"column_start":18,"column_end":26},"kind":{"Impl":{"id":2731}},"from":{"krate":0,"index":8394},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1977137,"byte_end":1977147,"line_start":269,"line_end":269,"column_start":10,"column_end":20},"kind":{"Impl":{"id":2732}},"from":{"krate":0,"index":44600},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1978330,"byte_end":1978339,"line_start":308,"line_end":308,"column_start":10,"column_end":19},"kind":{"Impl":{"id":2733}},"from":{"krate":0,"index":44616},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1982325,"byte_end":1982334,"line_start":408,"line_end":408,"column_start":16,"column_end":25},"kind":{"Impl":{"id":2734}},"from":{"krate":0,"index":44616},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1982500,"byte_end":1982509,"line_start":415,"line_end":415,"column_start":18,"column_end":27},"kind":{"Impl":{"id":2735}},"from":{"krate":0,"index":44616},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1999293,"byte_end":1999304,"line_start":1046,"line_end":1046,"column_start":6,"column_end":17},"kind":{"Impl":{"id":2736}},"from":{"krate":0,"index":8510},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":1999611,"byte_end":1999620,"line_start":1060,"line_end":1060,"column_start":10,"column_end":19},"kind":{"Impl":{"id":2737}},"from":{"krate":0,"index":8442},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2028056,"byte_end":2028065,"line_start":1886,"line_end":1886,"column_start":16,"column_end":25},"kind":{"Impl":{"id":2738}},"from":{"krate":0,"index":8442},"to":{"krate":0,"index":8426}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2028409,"byte_end":2028414,"line_start":1901,"line_end":1901,"column_start":18,"column_end":23},"kind":{"Impl":{"id":2739}},"from":{"krate":0,"index":44564},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034314,"byte_end":2034325,"line_start":2111,"line_end":2111,"column_start":27,"column_end":38},"kind":{"Impl":{"id":2746}},"from":{"krate":0,"index":1726},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034500,"byte_end":2034504,"line_start":2118,"line_end":2118,"column_start":33,"column_end":37},"kind":{"Impl":{"id":2747}},"from":{"krate":0,"index":3098},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2034746,"byte_end":2034753,"line_start":2127,"line_end":2127,"column_start":35,"column_end":42},"kind":{"Impl":{"id":2748}},"from":{"krate":0,"index":3174},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035239,"byte_end":2035258,"line_start":2140,"line_end":2140,"column_start":32,"column_end":51},"kind":{"Impl":{"id":2749}},"from":{"krate":0,"index":8674},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035664,"byte_end":2035667,"line_start":2155,"line_end":2155,"column_start":35,"column_end":38},"kind":{"Impl":{"id":2750}},"from":{"krate":0,"index":3286},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2035850,"byte_end":2035856,"line_start":2162,"line_end":2162,"column_start":35,"column_end":41},"kind":{"Impl":{"id":2751}},"from":{"krate":0,"index":3326},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/fmt/mod.rs","byte_start":2036058,"byte_end":2036068,"line_start":2169,"line_end":2169,"column_start":35,"column_end":45},"kind":{"Impl":{"id":2752}},"from":{"krate":0,"index":3344},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2078440,"byte_end":2078448,"line_start":60,"line_end":60,"column_start":6,"column_end":14},"kind":{"Impl":{"id":2753}},"from":{"krate":0,"index":44736},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2100475,"byte_end":2100483,"line_start":732,"line_end":732,"column_start":14,"column_end":22},"kind":{"Impl":{"id":2754}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":1774}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2100726,"byte_end":2100734,"line_start":741,"line_end":741,"column_start":20,"column_end":28},"kind":{"Impl":{"id":2755}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":1830}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2100883,"byte_end":2100891,"line_start":748,"line_end":748,"column_start":14,"column_end":22},"kind":{"Impl":{"id":2756}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":1782}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2101139,"byte_end":2101147,"line_start":757,"line_end":757,"column_start":20,"column_end":28},"kind":{"Impl":{"id":2757}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":1836}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2101301,"byte_end":2101309,"line_start":764,"line_end":764,"column_start":19,"column_end":27},"kind":{"Impl":{"id":2758}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":1790}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2101766,"byte_end":2101774,"line_start":782,"line_end":782,"column_start":25,"column_end":33},"kind":{"Impl":{"id":2760}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":1842}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2101923,"byte_end":2101931,"line_start":789,"line_end":789,"column_start":19,"column_end":27},"kind":{"Impl":{"id":2761}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":1798}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2102197,"byte_end":2102205,"line_start":798,"line_end":798,"column_start":25,"column_end":33},"kind":{"Impl":{"id":2762}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":1848}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2103419,"byte_end":2103427,"line_start":835,"line_end":835,"column_start":14,"column_end":22},"kind":{"Impl":{"id":2763}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":4546}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2103615,"byte_end":2103623,"line_start":842,"line_end":842,"column_start":32,"column_end":40},"kind":{"Impl":{"id":2764}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":4546}},{"span":{"file_name":"src/libcore/time.rs","byte_start":2103811,"byte_end":2103819,"line_start":849,"line_end":849,"column_start":21,"column_end":29},"kind":{"Impl":{"id":2765}},"from":{"krate":0,"index":44736},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2111013,"byte_end":2111021,"line_start":33,"line_end":33,"column_start":6,"column_end":14},"kind":{"Impl":{"id":2766}},"from":{"krate":0,"index":8854},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/unicode/bool_trie.rs","byte_start":2111691,"byte_end":2111704,"line_start":54,"line_end":54,"column_start":6,"column_end":19},"kind":{"Impl":{"id":2767}},"from":{"krate":0,"index":8860},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/future/future.rs","byte_start":2357511,"byte_end":2357514,"line_start":106,"line_end":106,"column_start":20,"column_end":23},"kind":{"Impl":{"id":2768}},"from":{"krate":0,"index":41566},"to":{"krate":0,"index":9002}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2358849,"byte_end":2358853,"line_start":24,"line_end":24,"column_start":9,"column_end":13},"kind":{"Impl":{"id":2769}},"from":{"krate":0,"index":44816},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2359504,"byte_end":2359508,"line_start":51,"line_end":51,"column_start":12,"column_end":16},"kind":{"Impl":{"id":2770}},"from":{"krate":0,"index":44816},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2360280,"byte_end":2360284,"line_start":75,"line_end":75,"column_start":21,"column_end":25},"kind":{"Impl":{"id":2771}},"from":{"krate":0,"index":44816},"to":{"krate":0,"index":2664}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2360372,"byte_end":2360376,"line_start":81,"line_end":81,"column_start":20,"column_end":24},"kind":{"Impl":{"id":2772}},"from":{"krate":0,"index":44816},"to":{"krate":0,"index":2258}},{"span":{"file_name":"src/libcore/task/poll.rs","byte_start":2360885,"byte_end":2360889,"line_start":105,"line_end":105,"column_start":20,"column_end":24},"kind":{"Impl":{"id":2773}},"from":{"krate":0,"index":44816},"to":{"krate":0,"index":2258}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2362529,"byte_end":2362537,"line_start":27,"line_end":27,"column_start":6,"column_end":14},"kind":{"Impl":{"id":2774}},"from":{"krate":0,"index":44858},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2365582,"byte_end":2365596,"line_start":95,"line_end":95,"column_start":6,"column_end":20},"kind":{"Impl":{"id":2775}},"from":{"krate":0,"index":44870},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368138,"byte_end":2368145,"line_start":165,"line_end":165,"column_start":10,"column_end":17},"kind":{"Impl":{"id":2776}},"from":{"krate":0,"index":9088},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2368519,"byte_end":2368526,"line_start":182,"line_end":182,"column_start":21,"column_end":28},"kind":{"Impl":{"id":2777}},"from":{"krate":0,"index":9088},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369055,"byte_end":2369060,"line_start":202,"line_end":202,"column_start":16,"column_end":21},"kind":{"Impl":{"id":2778}},"from":{"krate":0,"index":9100},"to":{"krate":0,"index":1748}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369085,"byte_end":2369090,"line_start":203,"line_end":203,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2779}},"from":{"krate":0,"index":9100},"to":{"krate":0,"index":1706}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369115,"byte_end":2369120,"line_start":204,"line_end":204,"column_start":22,"column_end":27},"kind":{"Impl":{"id":2780}},"from":{"krate":0,"index":9100},"to":{"krate":0,"index":1718}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2369130,"byte_end":2369135,"line_start":206,"line_end":206,"column_start":6,"column_end":11},"kind":{"Impl":{"id":2781}},"from":{"krate":0,"index":9100},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2371319,"byte_end":2371324,"line_start":263,"line_end":263,"column_start":16,"column_end":21},"kind":{"Impl":{"id":2782}},"from":{"krate":0,"index":9100},"to":{"krate":0,"index":2606}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2371714,"byte_end":2371719,"line_start":275,"line_end":275,"column_start":15,"column_end":20},"kind":{"Impl":{"id":2783}},"from":{"krate":0,"index":9100},"to":{"krate":0,"index":1984}},{"span":{"file_name":"src/libcore/task/wake.rs","byte_start":2372056,"byte_end":2372061,"line_start":285,"line_end":285,"column_start":21,"column_end":26},"kind":{"Impl":{"id":2784}},"from":{"krate":0,"index":9100},"to":{"krate":0,"index":8472}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2374119,"byte_end":2374125,"line_start":52,"line_end":52,"column_start":6,"column_end":12},"kind":{"Impl":{"id":2785}},"from":{"krate":0,"index":44894},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2386286,"byte_end":2386295,"line_start":340,"line_end":340,"column_start":23,"column_end":32},"kind":{"Impl":{"id":2786}},"from":{"krate":0,"index":44916},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2386879,"byte_end":2386887,"line_start":356,"line_end":356,"column_start":23,"column_end":31},"kind":{"Impl":{"id":2787}},"from":{"krate":0,"index":44936},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2387363,"byte_end":2387383,"line_start":370,"line_end":370,"column_start":6,"column_end":26},"kind":{"Impl":{"id":2788}},"from":{"krate":0,"index":44954},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"src/libcore/alloc.rs","byte_start":2387622,"byte_end":2387642,"line_start":378,"line_end":378,"column_start":23,"column_end":43},"kind":{"Impl":{"id":2789}},"from":{"krate":0,"index":44954},"to":{"krate":0,"index":8476}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2465990,"byte_end":2465995,"line_start":356,"line_end":356,"column_start":28,"column_end":33},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":9312}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467045,"byte_end":2467052,"line_start":400,"line_end":400,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2790}},"from":{"krate":0,"index":46924},"to":{"krate":0,"index":9312}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2467235,"byte_end":2467240,"line_start":409,"line_end":409,"column_start":28,"column_end":33},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":9336}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468294,"byte_end":2468301,"line_start":453,"line_end":453,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2791}},"from":{"krate":0,"index":46960},"to":{"krate":0,"index":9336}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468484,"byte_end":2468489,"line_start":462,"line_end":462,"column_start":28,"column_end":33},"kind":"SuperTrait","from":{"krate":0,"index":1712},"to":{"krate":0,"index":9360}},{"span":{"file_name":"src/libcore/../stdsimd/crates/core_arch/src/x86/mod.rs","byte_start":2468673,"byte_end":2468680,"line_start":471,"line_end":471,"column_start":19,"column_end":26},"kind":{"Impl":{"id":2792}},"from":{"krate":0,"index":46996},"to":{"krate":0,"index":9360}}]}